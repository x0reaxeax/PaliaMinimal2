#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: HoudiniEngineRuntime

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "PhysicsCore_structs.hpp"


namespace SDK
{

// Enum HoudiniEngineRuntime.EHoudiniStaticMeshMethod
// NumValues: 0x0004
enum class EHoudiniStaticMeshMethod : uint8
{
	RawMesh_DEPRECATED                       = 0,
	FMeshDescription                         = 1,
	UHoudiniStaticMesh                       = 2,
	EHoudiniStaticMeshMethod_MAX             = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniBakeAfterNextCook
// NumValues: 0x0004
enum class EHoudiniBakeAfterNextCook : uint8
{
	Disabled                                 = 0,
	Always                                   = 1,
	Once                                     = 2,
	EHoudiniBakeAfterNextCook_MAX            = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniAssetState
// NumValues: 0x000F
enum class EHoudiniAssetState : uint8
{
	NeedInstantiation                        = 0,
	NewHDA                                   = 1,
	PreInstantiation                         = 2,
	Instantiating                            = 3,
	PreCook                                  = 4,
	Cooking                                  = 5,
	PostCook                                 = 6,
	PreProcess                               = 7,
	Processing                               = 8,
	None                                     = 9,
	NeedRebuild                              = 10,
	NeedDelete                               = 11,
	Deleting                                 = 12,
	ProcessTemplate                          = 13,
	EHoudiniAssetState_MAX                   = 14,
};

// Enum HoudiniEngineRuntime.EHoudiniAssetStateResult
// NumValues: 0x0007
enum class EHoudiniAssetStateResult : uint8
{
	None                                     = 0,
	Working                                  = 1,
	Success                                  = 2,
	FinishedWithError                        = 3,
	FinishedWithFatalError                   = 4,
	Aborted                                  = 5,
	EHoudiniAssetStateResult_MAX             = 6,
};

// Enum HoudiniEngineRuntime.EHoudiniEngineEditorSettingUseCustomLocation
// NumValues: 0x0004
enum class EHoudiniEngineEditorSettingUseCustomLocation : uint8
{
	Project                                  = 0,
	Disabled                                 = 1,
	Enabled                                  = 2,
	EHoudiniEngineEditorSettingUseCustomLocation_MAX = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniRampInterpolationType
// NumValues: 0x0009
enum class EHoudiniRampInterpolationType : uint8
{
	InValid                                  = 18446744073709551615,
	CONSTANT                                 = 0,
	LINEAR                                   = 1,
	CATMULL_ROM                              = 2,
	MONOTONE_CUBIC                           = 3,
	BEZIER                                   = 4,
	BSPLINE                                  = 5,
	HERMITE                                  = 6,
	EHoudiniRampInterpolationType_MAX        = 7,
};

// Enum HoudiniEngineRuntime.EHoudiniLandscapeOutputBakeType
// NumValues: 0x0005
enum class EHoudiniLandscapeOutputBakeType : uint8
{
	Detachment                               = 0,
	BakeToImage                              = 1,
	BakeToWorld                              = 2,
	InValid                                  = 3,
	EHoudiniLandscapeOutputBakeType_MAX      = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniInputType
// NumValues: 0x0009
enum class EHoudiniInputType : uint8
{
	Invalid                                  = 0,
	Geometry                                 = 1,
	Curve                                    = 2,
	Asset_DEPRECATED                         = 3,
	Landscape_DEPRECATED                     = 4,
	World                                    = 5,
	Skeletal_DEPRECATED                      = 6,
	GeometryCollection_DEPRECATED            = 7,
	EHoudiniInputType_MAX                    = 8,
};

// Enum HoudiniEngineRuntime.EHoudiniOutputType
// NumValues: 0x000B
enum class EHoudiniOutputType : uint8
{
	Invalid                                  = 0,
	Mesh                                     = 1,
	Instancer                                = 2,
	Landscape                                = 3,
	Curve                                    = 4,
	Skeletal                                 = 5,
	GeometryCollection                       = 6,
	DataTable                                = 7,
	LandscapeSpline                          = 8,
	AnimSequence                             = 9,
	EHoudiniOutputType_MAX                   = 10,
};

// Enum HoudiniEngineRuntime.EHoudiniCurveType
// NumValues: 0x0006
enum class EHoudiniCurveType : uint8
{
	Invalid                                  = 18446744073709551615,
	Polygon                                  = 0,
	Nurbs                                    = 1,
	Bezier                                   = 2,
	Points                                   = 3,
	EHoudiniCurveType_MAX                    = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniCurveMethod
// NumValues: 0x0005
enum class EHoudiniCurveMethod : uint8
{
	Invalid                                  = 18446744073709551615,
	CVs                                      = 0,
	Breakpoints                              = 1,
	Freehand                                 = 2,
	EHoudiniCurveMethod_MAX                  = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniCurveBreakpointParameterization
// NumValues: 0x0005
enum class EHoudiniCurveBreakpointParameterization : uint8
{
	Invalid                                  = 18446744073709551615,
	Uniform                                  = 0,
	Chord                                    = 1,
	Centripetal                              = 2,
	EHoudiniCurveBreakpointParameterization_MAX = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniLandscapeExportType
// NumValues: 0x0004
enum class EHoudiniLandscapeExportType : uint8
{
	Heightfield                              = 0,
	Mesh                                     = 1,
	Points                                   = 2,
	EHoudiniLandscapeExportType_MAX          = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniProxyRefineResult
// NumValues: 0x0005
enum class EHoudiniProxyRefineResult : uint8
{
	Invalid                                  = 0,
	Failed                                   = 1,
	Success                                  = 2,
	Skipped                                  = 3,
	EHoudiniProxyRefineResult_MAX            = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniProxyRefineRequestResult
// NumValues: 0x0005
enum class EHoudiniProxyRefineRequestResult : uint8
{
	Invalid                                  = 0,
	None                                     = 1,
	PendingCooks                             = 2,
	Refined                                  = 3,
	EHoudiniProxyRefineRequestResult_MAX     = 4,
};

// Enum HoudiniEngineRuntime.EAttribStorageType
// NumValues: 0x0007
enum class EAttribStorageType : uint8
{
	Invalid                                  = 18446744073709551615,
	INT                                      = 0,
	INT64                                    = 1,
	FLOAT                                    = 2,
	FLOAT64                                  = 3,
	STRING                                   = 4,
	EAttribStorageType_MAX                   = 5,
};

// Enum HoudiniEngineRuntime.EAttribOwner
// NumValues: 0x0006
enum class EAttribOwner : uint8
{
	Invalid                                  = 18446744073709551615,
	Vertex                                   = 0,
	Point                                    = 1,
	Prim                                     = 2,
	Detail                                   = 3,
	EAttribOwner_MAX                         = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniGeoType
// NumValues: 0x0006
enum class EHoudiniGeoType : uint8
{
	Invalid                                  = 0,
	Default                                  = 1,
	Intermediate                             = 2,
	Input                                    = 3,
	Curve                                    = 4,
	EHoudiniGeoType_MAX                      = 5,
};

// Enum HoudiniEngineRuntime.EHoudiniPartType
// NumValues: 0x000A
enum class EHoudiniPartType : uint8
{
	Invalid                                  = 0,
	Mesh                                     = 1,
	Instancer                                = 2,
	Curve                                    = 3,
	Volume                                   = 4,
	DataTable                                = 5,
	LandscapeSpline                          = 6,
	SkeletalMesh                             = 7,
	MotionClip                               = 8,
	EHoudiniPartType_MAX                     = 9,
};

// Enum HoudiniEngineRuntime.EHoudiniInstancerType
// NumValues: 0x0009
enum class EHoudiniInstancerType : uint8
{
	Invalid                                  = 0,
	ObjectInstancer                          = 1,
	PackedPrimitive                          = 2,
	AttributeInstancer                       = 3,
	OldSchoolAttributeInstancer              = 4,
	GeometryCollection                       = 5,
	SkeletalMesh                             = 6,
	MotionClip                               = 7,
	EHoudiniInstancerType_MAX                = 8,
};

// Enum HoudiniEngineRuntime.EXformParameter
// NumValues: 0x000B
enum class EXformParameter : uint8
{
	TX                                       = 0,
	TY                                       = 1,
	TZ                                       = 2,
	RX                                       = 3,
	RY                                       = 4,
	RZ                                       = 5,
	SX                                       = 6,
	SY                                       = 7,
	SZ                                       = 8,
	COUNT                                    = 9,
	EXformParameter_MAX                      = 10,
};

// Enum HoudiniEngineRuntime.EHoudiniHandleType
// NumValues: 0x0004
enum class EHoudiniHandleType : uint8
{
	Xform                                    = 0,
	Bounder                                  = 1,
	Unsupported                              = 2,
	EHoudiniHandleType_MAX                   = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniInputObjectType
// NumValues: 0x001D
enum class EHoudiniInputObjectType : uint8
{
	Invalid                                  = 0,
	Object                                   = 1,
	StaticMesh                               = 2,
	SkeletalMesh                             = 3,
	SceneComponent                           = 4,
	StaticMeshComponent                      = 5,
	InstancedStaticMeshComponent             = 6,
	SplineComponent                          = 7,
	HoudiniSplineComponent                   = 8,
	HoudiniAssetComponent                    = 9,
	Actor                                    = 10,
	Landscape                                = 11,
	Brush                                    = 12,
	CameraComponent                          = 13,
	DataTable                                = 14,
	HoudiniAssetActor                        = 15,
	FoliageType_InstancedStaticMesh          = 16,
	GeometryCollection                       = 17,
	GeometryCollectionComponent              = 18,
	GeometryCollectionActor_Deprecated       = 19,
	SkeletalMeshComponent                    = 20,
	LandscapeSplineActor                     = 21,
	LandscapeSplinesComponent                = 22,
	Blueprint                                = 23,
	Animation                                = 24,
	SplineMeshComponent                      = 25,
	LevelInstance                            = 26,
	PackedLevelActor                         = 27,
	EHoudiniInputObjectType_MAX              = 28,
};

// Enum HoudiniEngineRuntime.EHoudiniXformType
// NumValues: 0x0004
enum class EHoudiniXformType : uint8
{
	None                                     = 0,
	IntoThisObject                           = 1,
	Auto                                     = 2,
	EHoudiniXformType_MAX                    = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniCurveOutputType
// NumValues: 0x0003
enum class EHoudiniCurveOutputType : uint8
{
	UnrealSpline                             = 0,
	HoudiniSpline                            = 1,
	EHoudiniCurveOutputType_MAX              = 2,
};

// Enum HoudiniEngineRuntime.EHoudiniParameterType
// NumValues: 0x0018
enum class EHoudiniParameterType : uint8
{
	Invalid                                  = 0,
	Button                                   = 1,
	ButtonStrip                              = 2,
	Color                                    = 3,
	ColorRamp                                = 4,
	File                                     = 5,
	FileDir                                  = 6,
	FileGeo                                  = 7,
	FileImage                                = 8,
	Float                                    = 9,
	FloatRamp                                = 10,
	Folder                                   = 11,
	FolderList                               = 12,
	Input                                    = 13,
	Int                                      = 14,
	IntChoice                                = 15,
	Label                                    = 16,
	MultiParm                                = 17,
	Separator                                = 18,
	String                                   = 19,
	StringChoice                             = 20,
	StringAssetRef                           = 21,
	Toggle                                   = 22,
	EHoudiniParameterType_MAX                = 23,
};

// Enum HoudiniEngineRuntime.EHoudiniFolderParameterType
// NumValues: 0x0007
enum class EHoudiniFolderParameterType : uint8
{
	Invalid                                  = 0,
	Collapsible                              = 1,
	Simple                                   = 2,
	Tabs                                     = 3,
	Radio                                    = 4,
	Other                                    = 5,
	EHoudiniFolderParameterType_MAX          = 6,
};

// Enum HoudiniEngineRuntime.EHoudiniMultiParmModificationType
// NumValues: 0x0005
enum class EHoudiniMultiParmModificationType : uint8
{
	None                                     = 0,
	Inserted                                 = 1,
	Removed                                  = 2,
	Modified                                 = 3,
	EHoudiniMultiParmModificationType_MAX    = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniRampPointConstructStatus
// NumValues: 0x0006
enum class EHoudiniRampPointConstructStatus : uint8
{
	None                                     = 0,
	INITIALIZED                              = 1,
	POSITION_INSERTED                        = 2,
	VALUE_INSERTED                           = 3,
	INTERPTYPE_INSERTED                      = 4,
	EHoudiniRampPointConstructStatus_MAX     = 5,
};

// Enum HoudiniEngineRuntime.EPDGLinkState
// NumValues: 0x0005
enum class EPDGLinkState : uint8
{
	Inactive                                 = 0,
	Linking                                  = 1,
	Linked                                   = 2,
	Error_Not_Linked                         = 3,
	EPDGLinkState_MAX                        = 4,
};

// Enum HoudiniEngineRuntime.EPDGNodeState
// NumValues: 0x0007
enum class EPDGNodeState : uint8
{
	None                                     = 0,
	Dirtied                                  = 1,
	Dirtying                                 = 2,
	Cooking                                  = 3,
	Cook_Complete                            = 4,
	Cook_Failed                              = 5,
	EPDGNodeState_MAX                        = 6,
};

// Enum HoudiniEngineRuntime.EPDGWorkResultState
// NumValues: 0x0009
enum class EPDGWorkResultState : uint8
{
	None                                     = 0,
	ToLoad                                   = 1,
	Loading                                  = 2,
	Loaded                                   = 3,
	ToDelete                                 = 4,
	Deleting                                 = 5,
	Deleted                                  = 6,
	NotLoaded                                = 7,
	EPDGWorkResultState_MAX                  = 8,
};

// Enum HoudiniEngineRuntime.EHoudiniRuntimeSettingsSessionType
// NumValues: 0x0005
enum class EHoudiniRuntimeSettingsSessionType : uint8
{
	HRSST_InProcess                          = 0,
	HRSST_Socket                             = 1,
	HRSST_NamedPipe                          = 2,
	HRSST_None                               = 3,
	HRSST_MAX                                = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniRuntimeSettingsRecomputeFlag
// NumValues: 0x0004
enum class EHoudiniRuntimeSettingsRecomputeFlag : uint8
{
	HRSRF_Always                             = 0,
	HRSRF_OnlyIfMissing                      = 1,
	HRSRF_Never                              = 2,
	HRSRF_MAX                                = 3,
};

// Enum HoudiniEngineRuntime.EHoudiniExecutableType
// NumValues: 0x0005
enum class EHoudiniExecutableType : uint8
{
	HRSHE_Houdini                            = 0,
	HRSHE_HoudiniFX                          = 1,
	HRSHE_HoudiniCore                        = 2,
	HRSHE_HoudiniIndie                       = 3,
	HRSHE_MAX                                = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniToolType
// NumValues: 0x0005
enum class EHoudiniToolType : uint8
{
	HTOOLTYPE_GENERATOR                      = 0,
	HTOOLTYPE_OPERATOR_SINGLE                = 1,
	HTOOLTYPE_OPERATOR_MULTI                 = 2,
	HTOOLTYPE_OPERATOR_BATCH                 = 3,
	HTOOLTYPE_MAX                            = 4,
};

// Enum HoudiniEngineRuntime.EHoudiniToolSelectionType
// NumValues: 0x0004
enum class EHoudiniToolSelectionType : uint8
{
	HTOOL_SELECTION_ALL                      = 0,
	HTOOL_SELECTION_WORLD_ONLY               = 1,
	HTOOL_SELECTION_CB_ONLY                  = 2,
	HTOOL_SELECTION_MAX                      = 3,
};

// ScriptStruct HoudiniEngineRuntime.HoudiniCurveOutputProperties
// 0x000C (0x000C - 0x0000)
struct FHoudiniCurveOutputProperties final
{
public:
	EHoudiniCurveOutputType                       CurveOutputType;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E44[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPoints;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClosed;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniCurveType                             CurveType;                                         // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniCurveMethod                           CurveMethod;                                       // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E45[0x1];                                     // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniCurveOutputProperties) == 0x000004, "Wrong alignment on FHoudiniCurveOutputProperties");
static_assert(sizeof(FHoudiniCurveOutputProperties) == 0x00000C, "Wrong size on FHoudiniCurveOutputProperties");
static_assert(offsetof(FHoudiniCurveOutputProperties, CurveOutputType) == 0x000000, "Member 'FHoudiniCurveOutputProperties::CurveOutputType' has a wrong offset!");
static_assert(offsetof(FHoudiniCurveOutputProperties, NumPoints) == 0x000004, "Member 'FHoudiniCurveOutputProperties::NumPoints' has a wrong offset!");
static_assert(offsetof(FHoudiniCurveOutputProperties, bClosed) == 0x000008, "Member 'FHoudiniCurveOutputProperties::bClosed' has a wrong offset!");
static_assert(offsetof(FHoudiniCurveOutputProperties, CurveType) == 0x000009, "Member 'FHoudiniCurveOutputProperties::CurveType' has a wrong offset!");
static_assert(offsetof(FHoudiniCurveOutputProperties, CurveMethod) == 0x00000A, "Member 'FHoudiniCurveOutputProperties::CurveMethod' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniDataLayer
// 0x0018 (0x0018 - 0x0000)
struct FHoudiniDataLayer final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateIfNeeded;                                   // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E46[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniDataLayer) == 0x000008, "Wrong alignment on FHoudiniDataLayer");
static_assert(sizeof(FHoudiniDataLayer) == 0x000018, "Wrong size on FHoudiniDataLayer");
static_assert(offsetof(FHoudiniDataLayer, Name) == 0x000000, "Member 'FHoudiniDataLayer::Name' has a wrong offset!");
static_assert(offsetof(FHoudiniDataLayer, bCreateIfNeeded) == 0x000010, "Member 'FHoudiniDataLayer::bCreateIfNeeded' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniHLODLayer
// 0x0010 (0x0010 - 0x0000)
struct FHoudiniHLODLayer final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniHLODLayer) == 0x000008, "Wrong alignment on FHoudiniHLODLayer");
static_assert(sizeof(FHoudiniHLODLayer) == 0x000010, "Wrong size on FHoudiniHLODLayer");
static_assert(offsetof(FHoudiniHLODLayer, Name) == 0x000000, "Member 'FHoudiniHLODLayer::Name' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniLevelInstanceParams
// 0x0018 (0x0018 - 0x0000)
struct FHoudiniLevelInstanceParams final
{
public:
	ELevelInstanceCreationType                    Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E47[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutputName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniLevelInstanceParams) == 0x000008, "Wrong alignment on FHoudiniLevelInstanceParams");
static_assert(sizeof(FHoudiniLevelInstanceParams) == 0x000018, "Wrong size on FHoudiniLevelInstanceParams");
static_assert(offsetof(FHoudiniLevelInstanceParams, Type) == 0x000000, "Member 'FHoudiniLevelInstanceParams::Type' has a wrong offset!");
static_assert(offsetof(FHoudiniLevelInstanceParams, OutputName) == 0x000008, "Member 'FHoudiniLevelInstanceParams::OutputName' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniOutputObject
// 0x0168 (0x0168 - 0x0000)
struct FHoudiniOutputObject final
{
public:
	class UObject*                                OutputObject;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        OutputComponents;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          OutputActors;                                      // 0x0018(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UObject*                                OutputComponent;                                   // 0x0028(0x0008)(ZeroConstructor, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ProxyObject;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ProxyComponent;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProxyIsCurrent;                                   // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsImplicit;                                       // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInvisibleCollisionMesh;                         // 0x0042(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGeometryCollectionPiece;                        // 0x0043(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E48[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GeometryCollectionPieceName;                       // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BakeName;                                          // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHoudiniCurveOutputProperties          CurveOutputProperty;                               // 0x0068(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E49[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            CachedAttributes;                                  // 0x0078(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            CachedTokens;                                      // 0x00C8(0x0050)(NativeAccessSpecifierPublic)
	class UObject*                                UserFoliageType;                                   // 0x0118(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFoliageType*                           FoliageType;                                       // 0x0120(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0128(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHoudiniDataLayer>              DataLayers;                                        // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHoudiniHLODLayer>              HLODLayers;                                        // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHoudiniLevelInstanceParams            LevelInstanceParams;                               // 0x0150(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniOutputObject) == 0x000008, "Wrong alignment on FHoudiniOutputObject");
static_assert(sizeof(FHoudiniOutputObject) == 0x000168, "Wrong size on FHoudiniOutputObject");
static_assert(offsetof(FHoudiniOutputObject, OutputObject) == 0x000000, "Member 'FHoudiniOutputObject::OutputObject' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, OutputComponents) == 0x000008, "Member 'FHoudiniOutputObject::OutputComponents' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, OutputActors) == 0x000018, "Member 'FHoudiniOutputObject::OutputActors' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, OutputComponent) == 0x000028, "Member 'FHoudiniOutputObject::OutputComponent' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, ProxyObject) == 0x000030, "Member 'FHoudiniOutputObject::ProxyObject' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, ProxyComponent) == 0x000038, "Member 'FHoudiniOutputObject::ProxyComponent' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, bProxyIsCurrent) == 0x000040, "Member 'FHoudiniOutputObject::bProxyIsCurrent' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, bIsImplicit) == 0x000041, "Member 'FHoudiniOutputObject::bIsImplicit' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, bIsInvisibleCollisionMesh) == 0x000042, "Member 'FHoudiniOutputObject::bIsInvisibleCollisionMesh' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, bIsGeometryCollectionPiece) == 0x000043, "Member 'FHoudiniOutputObject::bIsGeometryCollectionPiece' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, GeometryCollectionPieceName) == 0x000048, "Member 'FHoudiniOutputObject::GeometryCollectionPieceName' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, BakeName) == 0x000058, "Member 'FHoudiniOutputObject::BakeName' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, CurveOutputProperty) == 0x000068, "Member 'FHoudiniOutputObject::CurveOutputProperty' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, CachedAttributes) == 0x000078, "Member 'FHoudiniOutputObject::CachedAttributes' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, CachedTokens) == 0x0000C8, "Member 'FHoudiniOutputObject::CachedTokens' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, UserFoliageType) == 0x000118, "Member 'FHoudiniOutputObject::UserFoliageType' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, FoliageType) == 0x000120, "Member 'FHoudiniOutputObject::FoliageType' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, World) == 0x000128, "Member 'FHoudiniOutputObject::World' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, DataLayers) == 0x000130, "Member 'FHoudiniOutputObject::DataLayers' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, HLODLayers) == 0x000140, "Member 'FHoudiniOutputObject::HLODLayers' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObject, LevelInstanceParams) == 0x000150, "Member 'FHoudiniOutputObject::LevelInstanceParams' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniAssetBlueprintOutput
// 0x0170 (0x0170 - 0x0000)
struct FHoudiniAssetBlueprintOutput final
{
public:
	int32                                         OutputIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4A[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHoudiniOutputObject                   OutputObject;                                      // 0x0008(0x0168)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniAssetBlueprintOutput) == 0x000008, "Wrong alignment on FHoudiniAssetBlueprintOutput");
static_assert(sizeof(FHoudiniAssetBlueprintOutput) == 0x000170, "Wrong size on FHoudiniAssetBlueprintOutput");
static_assert(offsetof(FHoudiniAssetBlueprintOutput, OutputIndex) == 0x000000, "Member 'FHoudiniAssetBlueprintOutput::OutputIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintOutput, OutputObject) == 0x000008, "Member 'FHoudiniAssetBlueprintOutput::OutputObject' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniOutputObjectIdentifier
// 0x0040 (0x0040 - 0x0000)
struct FHoudiniOutputObjectIdentifier final
{
public:
	int32                                         ObjectId;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GeoId;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartId;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4B[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SplitIdentifier;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartName;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimitiveIndex;                                    // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointIndex;                                        // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4C[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniOutputObjectIdentifier) == 0x000008, "Wrong alignment on FHoudiniOutputObjectIdentifier");
static_assert(sizeof(FHoudiniOutputObjectIdentifier) == 0x000040, "Wrong size on FHoudiniOutputObjectIdentifier");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, ObjectId) == 0x000000, "Member 'FHoudiniOutputObjectIdentifier::ObjectId' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, GeoId) == 0x000004, "Member 'FHoudiniOutputObjectIdentifier::GeoId' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, PartId) == 0x000008, "Member 'FHoudiniOutputObjectIdentifier::PartId' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, SplitIdentifier) == 0x000010, "Member 'FHoudiniOutputObjectIdentifier::SplitIdentifier' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, PartName) == 0x000020, "Member 'FHoudiniOutputObjectIdentifier::PartName' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, PrimitiveIndex) == 0x000030, "Member 'FHoudiniOutputObjectIdentifier::PrimitiveIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniOutputObjectIdentifier, PointIndex) == 0x000034, "Member 'FHoudiniOutputObjectIdentifier::PointIndex' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniAssetBlueprintInstanceData
// 0x00B8 (0x0120 - 0x0068)
struct FHoudiniAssetBlueprintInstanceData final : public FActorComponentInstanceData
{
public:
	class UHoudiniAsset*                          HoudiniAsset;                                      // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssetId;                                           // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniAssetState                            AssetState;                                        // 0x0074(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4D[0x3];                                     // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SubAssetIndex;                                     // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AssetCookCount;                                    // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenLoaded;                                    // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenDuplicated;                                // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPendingDelete;                                    // 0x0082(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecookRequested;                                  // 0x0083(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRebuildRequested;                                 // 0x0084(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCooking;                                    // 0x0085(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceNeedUpdate;                                  // 0x0086(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastCookSuccess;                                  // 0x0087(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ComponentGUID;                                     // 0x0088(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  HapiGUID;                                          // 0x0098(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegisteredComponentTemplate;                      // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4E[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SourceName;                                        // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FHoudiniOutputObjectIdentifier, struct FHoudiniAssetBlueprintOutput> Outputs;                                           // 0x00C0(0x0050)(NativeAccessSpecifierPublic)
	TArray<class UHoudiniInput*>                  Inputs;                                            // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniAssetBlueprintInstanceData) == 0x000008, "Wrong alignment on FHoudiniAssetBlueprintInstanceData");
static_assert(sizeof(FHoudiniAssetBlueprintInstanceData) == 0x000120, "Wrong size on FHoudiniAssetBlueprintInstanceData");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, HoudiniAsset) == 0x000068, "Member 'FHoudiniAssetBlueprintInstanceData::HoudiniAsset' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, AssetId) == 0x000070, "Member 'FHoudiniAssetBlueprintInstanceData::AssetId' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, AssetState) == 0x000074, "Member 'FHoudiniAssetBlueprintInstanceData::AssetState' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, SubAssetIndex) == 0x000078, "Member 'FHoudiniAssetBlueprintInstanceData::SubAssetIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, AssetCookCount) == 0x00007C, "Member 'FHoudiniAssetBlueprintInstanceData::AssetCookCount' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bHasBeenLoaded) == 0x000080, "Member 'FHoudiniAssetBlueprintInstanceData::bHasBeenLoaded' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bHasBeenDuplicated) == 0x000081, "Member 'FHoudiniAssetBlueprintInstanceData::bHasBeenDuplicated' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bPendingDelete) == 0x000082, "Member 'FHoudiniAssetBlueprintInstanceData::bPendingDelete' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bRecookRequested) == 0x000083, "Member 'FHoudiniAssetBlueprintInstanceData::bRecookRequested' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bRebuildRequested) == 0x000084, "Member 'FHoudiniAssetBlueprintInstanceData::bRebuildRequested' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bEnableCooking) == 0x000085, "Member 'FHoudiniAssetBlueprintInstanceData::bEnableCooking' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bForceNeedUpdate) == 0x000086, "Member 'FHoudiniAssetBlueprintInstanceData::bForceNeedUpdate' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bLastCookSuccess) == 0x000087, "Member 'FHoudiniAssetBlueprintInstanceData::bLastCookSuccess' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, ComponentGUID) == 0x000088, "Member 'FHoudiniAssetBlueprintInstanceData::ComponentGUID' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, HapiGUID) == 0x000098, "Member 'FHoudiniAssetBlueprintInstanceData::HapiGUID' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, bRegisteredComponentTemplate) == 0x0000A8, "Member 'FHoudiniAssetBlueprintInstanceData::bRegisteredComponentTemplate' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, SourceName) == 0x0000B0, "Member 'FHoudiniAssetBlueprintInstanceData::SourceName' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, Outputs) == 0x0000C0, "Member 'FHoudiniAssetBlueprintInstanceData::Outputs' has a wrong offset!");
static_assert(offsetof(FHoudiniAssetBlueprintInstanceData, Inputs) == 0x000110, "Member 'FHoudiniAssetBlueprintInstanceData::Inputs' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.UserPackageRules
// 0x0028 (0x0028 - 0x0000)
struct FUserPackageRules final
{
public:
	class UHoudiniToolsPackageAsset*              ToolsPackageAsset;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Include;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Exclude;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserPackageRules) == 0x000008, "Wrong alignment on FUserPackageRules");
static_assert(sizeof(FUserPackageRules) == 0x000028, "Wrong size on FUserPackageRules");
static_assert(offsetof(FUserPackageRules, ToolsPackageAsset) == 0x000000, "Member 'FUserPackageRules::ToolsPackageAsset' has a wrong offset!");
static_assert(offsetof(FUserPackageRules, Include) == 0x000008, "Member 'FUserPackageRules::Include' has a wrong offset!");
static_assert(offsetof(FUserPackageRules, Exclude) == 0x000018, "Member 'FUserPackageRules::Exclude' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.UserCategoryRules
// 0x0010 (0x0010 - 0x0000)
struct FUserCategoryRules final
{
public:
	TArray<struct FUserPackageRules>              Packages;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserCategoryRules) == 0x000008, "Wrong alignment on FUserCategoryRules");
static_assert(sizeof(FUserCategoryRules) == 0x000010, "Wrong size on FUserCategoryRules");
static_assert(offsetof(FUserCategoryRules, Packages) == 0x000000, "Member 'FUserCategoryRules::Packages' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniGenericAttributeChangedProperty
// 0x0098 (0x0098 - 0x0000)
struct FHoudiniGenericAttributeChangedProperty final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4F[0x90];                                    // 0x0008(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniGenericAttributeChangedProperty) == 0x000008, "Wrong alignment on FHoudiniGenericAttributeChangedProperty");
static_assert(sizeof(FHoudiniGenericAttributeChangedProperty) == 0x000098, "Wrong size on FHoudiniGenericAttributeChangedProperty");
static_assert(offsetof(FHoudiniGenericAttributeChangedProperty, Object) == 0x000000, "Member 'FHoudiniGenericAttributeChangedProperty::Object' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniGenericAttribute
// 0x0050 (0x0050 - 0x0000)
struct FHoudiniGenericAttribute final
{
public:
	class FString                                 AttributeName;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttribStorageType                            AttributeType;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttribOwner                                  AttributeOwner;                                    // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E50[0x2];                                     // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AttributeCount;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttributeTupleSize;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E51[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<double>                                DoubleValues;                                      // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 IntValues;                                         // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringValues;                                      // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniGenericAttribute) == 0x000008, "Wrong alignment on FHoudiniGenericAttribute");
static_assert(sizeof(FHoudiniGenericAttribute) == 0x000050, "Wrong size on FHoudiniGenericAttribute");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeName) == 0x000000, "Member 'FHoudiniGenericAttribute::AttributeName' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeType) == 0x000010, "Member 'FHoudiniGenericAttribute::AttributeType' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeOwner) == 0x000011, "Member 'FHoudiniGenericAttribute::AttributeOwner' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeCount) == 0x000014, "Member 'FHoudiniGenericAttribute::AttributeCount' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, AttributeTupleSize) == 0x000018, "Member 'FHoudiniGenericAttribute::AttributeTupleSize' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, DoubleValues) == 0x000020, "Member 'FHoudiniGenericAttribute::DoubleValues' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, IntValues) == 0x000030, "Member 'FHoudiniGenericAttribute::IntValues' has a wrong offset!");
static_assert(offsetof(FHoudiniGenericAttribute, StringValues) == 0x000040, "Member 'FHoudiniGenericAttribute::StringValues' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniObjectInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FHoudiniObjectInfo final
{
public:
	uint8                                         Pad_2E52[0x28];                                    // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniObjectInfo) == 0x000008, "Wrong alignment on FHoudiniObjectInfo");
static_assert(sizeof(FHoudiniObjectInfo) == 0x000028, "Wrong size on FHoudiniObjectInfo");

// ScriptStruct HoudiniEngineRuntime.HoudiniGeoInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FHoudiniGeoInfo final
{
public:
	uint8                                         Pad_2E53[0x30];                                    // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniGeoInfo) == 0x000008, "Wrong alignment on FHoudiniGeoInfo");
static_assert(sizeof(FHoudiniGeoInfo) == 0x000030, "Wrong size on FHoudiniGeoInfo");

// ScriptStruct HoudiniEngineRuntime.HoudiniPartInfo
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FHoudiniPartInfo final
{
public:
	uint8                                         Pad_2E54[0x48];                                    // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniPartInfo) == 0x000008, "Wrong alignment on FHoudiniPartInfo");
static_assert(sizeof(FHoudiniPartInfo) == 0x000048, "Wrong size on FHoudiniPartInfo");

// ScriptStruct HoudiniEngineRuntime.HoudiniVolumeInfo
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FHoudiniVolumeInfo final
{
public:
	uint8                                         Pad_2E55[0xB0];                                    // 0x0000(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniVolumeInfo) == 0x000010, "Wrong alignment on FHoudiniVolumeInfo");
static_assert(sizeof(FHoudiniVolumeInfo) == 0x0000B0, "Wrong size on FHoudiniVolumeInfo");

// ScriptStruct HoudiniEngineRuntime.HoudiniCurveInfo
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FHoudiniCurveInfo final
{
public:
	uint8                                         Pad_2E56[0x1C];                                    // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniCurveInfo) == 0x000004, "Wrong alignment on FHoudiniCurveInfo");
static_assert(sizeof(FHoudiniCurveInfo) == 0x00001C, "Wrong size on FHoudiniCurveInfo");

// ScriptStruct HoudiniEngineRuntime.HoudiniMeshSocket
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FHoudiniMeshSocket final
{
public:
	uint8                                         Pad_2E57[0x90];                                    // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniMeshSocket) == 0x000010, "Wrong alignment on FHoudiniMeshSocket");
static_assert(sizeof(FHoudiniMeshSocket) == 0x000090, "Wrong size on FHoudiniMeshSocket");

// ScriptStruct HoudiniEngineRuntime.HoudiniGeoPartObject
// 0x02B0 (0x02B0 - 0x0000)
struct FHoudiniGeoPartObject final
{
public:
	int32                                         AssetId;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E58[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AssetName;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObjectId;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E59[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ObjectName;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GeoId;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartId;                                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartName;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCustomPartName;                                // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5A[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         SplitGroups;                                       // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             TransformMatrix;                                   // 0x0060(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NodePath;                                          // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniPartType                              Type;                                              // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniInstancerType                         InstancerType;                                     // 0x00D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5B[0x6];                                     // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VolumeName;                                        // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEditLayers;                                    // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5C[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VolumeLayerName;                                   // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VolumeTileIndex;                                   // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0104(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEditable;                                       // 0x0105(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTemplated;                                      // 0x0106(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInstanced;                                      // 0x0107(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasGeoChanged;                                    // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPartChanged;                                   // 0x0109(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasTransformChanged;                              // 0x010A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMaterialsChanged;                              // 0x010B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5D[0x174];                                   // 0x010C(0x0174)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHoudiniMeshSocket>             AllMeshSockets;                                    // 0x0280(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHoudiniGenericAttribute>       GenericPropertyAttributes;                         // 0x0290(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bKeepTags;                                         // 0x02A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5E[0xF];                                     // 0x02A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniGeoPartObject) == 0x000010, "Wrong alignment on FHoudiniGeoPartObject");
static_assert(sizeof(FHoudiniGeoPartObject) == 0x0002B0, "Wrong size on FHoudiniGeoPartObject");
static_assert(offsetof(FHoudiniGeoPartObject, AssetId) == 0x000000, "Member 'FHoudiniGeoPartObject::AssetId' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, AssetName) == 0x000008, "Member 'FHoudiniGeoPartObject::AssetName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, ObjectId) == 0x000018, "Member 'FHoudiniGeoPartObject::ObjectId' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, ObjectName) == 0x000020, "Member 'FHoudiniGeoPartObject::ObjectName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, GeoId) == 0x000030, "Member 'FHoudiniGeoPartObject::GeoId' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, PartId) == 0x000034, "Member 'FHoudiniGeoPartObject::PartId' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, PartName) == 0x000038, "Member 'FHoudiniGeoPartObject::PartName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasCustomPartName) == 0x000048, "Member 'FHoudiniGeoPartObject::bHasCustomPartName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, SplitGroups) == 0x000050, "Member 'FHoudiniGeoPartObject::SplitGroups' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, TransformMatrix) == 0x000060, "Member 'FHoudiniGeoPartObject::TransformMatrix' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, NodePath) == 0x0000C0, "Member 'FHoudiniGeoPartObject::NodePath' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, Type) == 0x0000D0, "Member 'FHoudiniGeoPartObject::Type' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, InstancerType) == 0x0000D1, "Member 'FHoudiniGeoPartObject::InstancerType' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, VolumeName) == 0x0000D8, "Member 'FHoudiniGeoPartObject::VolumeName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasEditLayers) == 0x0000E8, "Member 'FHoudiniGeoPartObject::bHasEditLayers' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, VolumeLayerName) == 0x0000F0, "Member 'FHoudiniGeoPartObject::VolumeLayerName' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, VolumeTileIndex) == 0x000100, "Member 'FHoudiniGeoPartObject::VolumeTileIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bIsVisible) == 0x000104, "Member 'FHoudiniGeoPartObject::bIsVisible' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bIsEditable) == 0x000105, "Member 'FHoudiniGeoPartObject::bIsEditable' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bIsTemplated) == 0x000106, "Member 'FHoudiniGeoPartObject::bIsTemplated' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bIsInstanced) == 0x000107, "Member 'FHoudiniGeoPartObject::bIsInstanced' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasGeoChanged) == 0x000108, "Member 'FHoudiniGeoPartObject::bHasGeoChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasPartChanged) == 0x000109, "Member 'FHoudiniGeoPartObject::bHasPartChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasTransformChanged) == 0x00010A, "Member 'FHoudiniGeoPartObject::bHasTransformChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bHasMaterialsChanged) == 0x00010B, "Member 'FHoudiniGeoPartObject::bHasMaterialsChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, AllMeshSockets) == 0x000280, "Member 'FHoudiniGeoPartObject::AllMeshSockets' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, GenericPropertyAttributes) == 0x000290, "Member 'FHoudiniGeoPartObject::GenericPropertyAttributes' has a wrong offset!");
static_assert(offsetof(FHoudiniGeoPartObject, bKeepTags) == 0x0002A0, "Member 'FHoudiniGeoPartObject::bKeepTags' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniBrushInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FHoudiniBrushInfo final
{
public:
	TWeakObjectPtr<class ABrush>                  BrushActor;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5F[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CachedTransform;                                   // 0x0010(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CachedOrigin;                                      // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CachedExtent;                                      // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrushType                                    CachedBrushType;                                   // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E60[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        CachedSurfaceHash;                                 // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniBrushInfo) == 0x000010, "Wrong alignment on FHoudiniBrushInfo");
static_assert(sizeof(FHoudiniBrushInfo) == 0x0000B0, "Wrong size on FHoudiniBrushInfo");
static_assert(offsetof(FHoudiniBrushInfo, BrushActor) == 0x000000, "Member 'FHoudiniBrushInfo::BrushActor' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedTransform) == 0x000010, "Member 'FHoudiniBrushInfo::CachedTransform' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedOrigin) == 0x000070, "Member 'FHoudiniBrushInfo::CachedOrigin' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedExtent) == 0x000088, "Member 'FHoudiniBrushInfo::CachedExtent' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedBrushType) == 0x0000A0, "Member 'FHoudiniBrushInfo::CachedBrushType' has a wrong offset!");
static_assert(offsetof(FHoudiniBrushInfo, CachedSurfaceHash) == 0x0000A8, "Member 'FHoudiniBrushInfo::CachedSurfaceHash' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniLandscapeSplineControlPointData
// 0x0038 (0x0038 - 0x0000)
struct FHoudiniLandscapeSplineControlPointData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E61[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniLandscapeSplineControlPointData) == 0x000008, "Wrong alignment on FHoudiniLandscapeSplineControlPointData");
static_assert(sizeof(FHoudiniLandscapeSplineControlPointData) == 0x000038, "Wrong size on FHoudiniLandscapeSplineControlPointData");
static_assert(offsetof(FHoudiniLandscapeSplineControlPointData, Location) == 0x000000, "Member 'FHoudiniLandscapeSplineControlPointData::Location' has a wrong offset!");
static_assert(offsetof(FHoudiniLandscapeSplineControlPointData, Rotation) == 0x000018, "Member 'FHoudiniLandscapeSplineControlPointData::Rotation' has a wrong offset!");
static_assert(offsetof(FHoudiniLandscapeSplineControlPointData, Width) == 0x000030, "Member 'FHoudiniLandscapeSplineControlPointData::Width' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniLandscapeSplineSegmentData
// 0x0001 (0x0001 - 0x0000)
struct FHoudiniLandscapeSplineSegmentData final
{
public:
	uint8                                         Pad_2E62[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniLandscapeSplineSegmentData) == 0x000001, "Wrong alignment on FHoudiniLandscapeSplineSegmentData");
static_assert(sizeof(FHoudiniLandscapeSplineSegmentData) == 0x000001, "Wrong size on FHoudiniLandscapeSplineSegmentData");

// ScriptStruct HoudiniEngineRuntime.HoudiniInputObjectSettings
// 0x0020 (0x0020 - 0x0000)
struct FHoudiniInputObjectSettings final
{
public:
	EHoudiniXformType                             KeepWorldTransform;                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportAsReference;                                // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportAsReferenceRotScaleEnabled;                 // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportAsReferenceBboxEnabled;                     // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportAsReferenceMaterialEnabled;                 // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExportLODs;                                       // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExportSockets;                                    // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreferNaniteFallbackMesh;                         // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExportColliders;                                  // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExportMaterialParameters;                         // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddRotAndScaleAttributesOnCurves;                 // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLegacyInputCurves;                             // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnrealSplineResolution;                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoudiniLandscapeExportType                   LandscapeExportType;                               // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeExportSelectionOnly;                     // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeAutoSelectComponent;                     // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeExportMaterials;                         // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeExportLighting;                          // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeExportNormalizedUVs;                     // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeExportTileUVs;                           // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeAutoSelectSplines;                       // 0x0017(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeSplinesExportControlPoints;              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeSplinesExportLeftRightCurves;            // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandscapeSplinesExportSplineMeshComponents;       // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergeSplineMeshComponents;                        // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExportEditLayers;                                 // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExportPaintLayers;                                // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExportLevelInstanceContent;                       // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E63[0x1];                                     // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniInputObjectSettings) == 0x000004, "Wrong alignment on FHoudiniInputObjectSettings");
static_assert(sizeof(FHoudiniInputObjectSettings) == 0x000020, "Wrong size on FHoudiniInputObjectSettings");
static_assert(offsetof(FHoudiniInputObjectSettings, KeepWorldTransform) == 0x000000, "Member 'FHoudiniInputObjectSettings::KeepWorldTransform' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bImportAsReference) == 0x000001, "Member 'FHoudiniInputObjectSettings::bImportAsReference' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bImportAsReferenceRotScaleEnabled) == 0x000002, "Member 'FHoudiniInputObjectSettings::bImportAsReferenceRotScaleEnabled' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bImportAsReferenceBboxEnabled) == 0x000003, "Member 'FHoudiniInputObjectSettings::bImportAsReferenceBboxEnabled' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bImportAsReferenceMaterialEnabled) == 0x000004, "Member 'FHoudiniInputObjectSettings::bImportAsReferenceMaterialEnabled' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bExportLODs) == 0x000005, "Member 'FHoudiniInputObjectSettings::bExportLODs' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bExportSockets) == 0x000006, "Member 'FHoudiniInputObjectSettings::bExportSockets' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bPreferNaniteFallbackMesh) == 0x000007, "Member 'FHoudiniInputObjectSettings::bPreferNaniteFallbackMesh' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bExportColliders) == 0x000008, "Member 'FHoudiniInputObjectSettings::bExportColliders' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bExportMaterialParameters) == 0x000009, "Member 'FHoudiniInputObjectSettings::bExportMaterialParameters' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bAddRotAndScaleAttributesOnCurves) == 0x00000A, "Member 'FHoudiniInputObjectSettings::bAddRotAndScaleAttributesOnCurves' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bUseLegacyInputCurves) == 0x00000B, "Member 'FHoudiniInputObjectSettings::bUseLegacyInputCurves' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, UnrealSplineResolution) == 0x00000C, "Member 'FHoudiniInputObjectSettings::UnrealSplineResolution' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, LandscapeExportType) == 0x000010, "Member 'FHoudiniInputObjectSettings::LandscapeExportType' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeExportSelectionOnly) == 0x000011, "Member 'FHoudiniInputObjectSettings::bLandscapeExportSelectionOnly' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeAutoSelectComponent) == 0x000012, "Member 'FHoudiniInputObjectSettings::bLandscapeAutoSelectComponent' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeExportMaterials) == 0x000013, "Member 'FHoudiniInputObjectSettings::bLandscapeExportMaterials' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeExportLighting) == 0x000014, "Member 'FHoudiniInputObjectSettings::bLandscapeExportLighting' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeExportNormalizedUVs) == 0x000015, "Member 'FHoudiniInputObjectSettings::bLandscapeExportNormalizedUVs' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeExportTileUVs) == 0x000016, "Member 'FHoudiniInputObjectSettings::bLandscapeExportTileUVs' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeAutoSelectSplines) == 0x000017, "Member 'FHoudiniInputObjectSettings::bLandscapeAutoSelectSplines' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeSplinesExportControlPoints) == 0x000018, "Member 'FHoudiniInputObjectSettings::bLandscapeSplinesExportControlPoints' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeSplinesExportLeftRightCurves) == 0x000019, "Member 'FHoudiniInputObjectSettings::bLandscapeSplinesExportLeftRightCurves' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bLandscapeSplinesExportSplineMeshComponents) == 0x00001A, "Member 'FHoudiniInputObjectSettings::bLandscapeSplinesExportSplineMeshComponents' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bMergeSplineMeshComponents) == 0x00001B, "Member 'FHoudiniInputObjectSettings::bMergeSplineMeshComponents' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bExportEditLayers) == 0x00001C, "Member 'FHoudiniInputObjectSettings::bExportEditLayers' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bExportPaintLayers) == 0x00001D, "Member 'FHoudiniInputObjectSettings::bExportPaintLayers' has a wrong offset!");
static_assert(offsetof(FHoudiniInputObjectSettings, bExportLevelInstanceContent) == 0x00001E, "Member 'FHoudiniInputObjectSettings::bExportLevelInstanceContent' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniExtents
// 0x0010 (0x0010 - 0x0000)
struct FHoudiniExtents final
{
public:
	struct FIntPoint                              Min;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Max;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniExtents) == 0x000004, "Wrong alignment on FHoudiniExtents");
static_assert(sizeof(FHoudiniExtents) == 0x000010, "Wrong size on FHoudiniExtents");
static_assert(offsetof(FHoudiniExtents, Min) == 0x000000, "Member 'FHoudiniExtents::Min' has a wrong offset!");
static_assert(offsetof(FHoudiniExtents, Max) == 0x000008, "Member 'FHoudiniExtents::Max' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniClearedTargetLayer
// 0x0050 (0x0050 - 0x0000)
struct FHoudiniClearedTargetLayer final
{
public:
	TSet<class FString>                           TargetLayers;                                      // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniClearedTargetLayer) == 0x000008, "Wrong alignment on FHoudiniClearedTargetLayer");
static_assert(sizeof(FHoudiniClearedTargetLayer) == 0x000050, "Wrong size on FHoudiniClearedTargetLayer");
static_assert(offsetof(FHoudiniClearedTargetLayer, TargetLayers) == 0x000000, "Member 'FHoudiniClearedTargetLayer::TargetLayers' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniClearedEditLayers
// 0x0050 (0x0050 - 0x0000)
struct FHoudiniClearedEditLayers final
{
public:
	TMap<class FString, struct FHoudiniClearedTargetLayer> EditLayers;                                        // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniClearedEditLayers) == 0x000008, "Wrong alignment on FHoudiniClearedEditLayers");
static_assert(sizeof(FHoudiniClearedEditLayers) == 0x000050, "Wrong size on FHoudiniClearedEditLayers");
static_assert(offsetof(FHoudiniClearedEditLayers, EditLayers) == 0x000000, "Member 'FHoudiniClearedEditLayers::EditLayers' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniMaterialIdentifier
// 0x0030 (0x0030 - 0x0000)
struct FHoudiniMaterialIdentifier final
{
public:
	uint8                                         Pad_2E64[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MaterialObjectPath;                                // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHoudiniMaterial;                                // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakeMaterialInstance;                             // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E65[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MaterialInstanceParametersSlug;                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniMaterialIdentifier) == 0x000008, "Wrong alignment on FHoudiniMaterialIdentifier");
static_assert(sizeof(FHoudiniMaterialIdentifier) == 0x000030, "Wrong size on FHoudiniMaterialIdentifier");
static_assert(offsetof(FHoudiniMaterialIdentifier, MaterialObjectPath) == 0x000008, "Member 'FHoudiniMaterialIdentifier::MaterialObjectPath' has a wrong offset!");
static_assert(offsetof(FHoudiniMaterialIdentifier, bIsHoudiniMaterial) == 0x000018, "Member 'FHoudiniMaterialIdentifier::bIsHoudiniMaterial' has a wrong offset!");
static_assert(offsetof(FHoudiniMaterialIdentifier, bMakeMaterialInstance) == 0x000019, "Member 'FHoudiniMaterialIdentifier::bMakeMaterialInstance' has a wrong offset!");
static_assert(offsetof(FHoudiniMaterialIdentifier, MaterialInstanceParametersSlug) == 0x000020, "Member 'FHoudiniMaterialIdentifier::MaterialInstanceParametersSlug' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniBakedOutputObjectIdentifier
// 0x0018 (0x0018 - 0x0000)
struct FHoudiniBakedOutputObjectIdentifier final
{
public:
	int32                                         PartId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E66[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SplitIdentifier;                                   // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniBakedOutputObjectIdentifier) == 0x000008, "Wrong alignment on FHoudiniBakedOutputObjectIdentifier");
static_assert(sizeof(FHoudiniBakedOutputObjectIdentifier) == 0x000018, "Wrong size on FHoudiniBakedOutputObjectIdentifier");
static_assert(offsetof(FHoudiniBakedOutputObjectIdentifier, PartId) == 0x000000, "Member 'FHoudiniBakedOutputObjectIdentifier::PartId' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObjectIdentifier, SplitIdentifier) == 0x000008, "Member 'FHoudiniBakedOutputObjectIdentifier::SplitIdentifier' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniInstancedOutput
// 0x0088 (0x0088 - 0x0000)
struct FHoudiniInstancedOutput final
{
public:
	TSoftObjectPtr<class UObject>                 OriginalObject;                                    // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginalObjectIndex;                               // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E67[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     OriginalTransforms;                                // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UObject>>         VariationObjects;                                  // 0x0040(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     VariationTransformOffsets;                         // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 TransformVariationIndices;                         // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 OriginalInstanceIndices;                           // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bChanged;                                          // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStale;                                            // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E68[0x6];                                     // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHoudiniInstancedOutput) == 0x000008, "Wrong alignment on FHoudiniInstancedOutput");
static_assert(sizeof(FHoudiniInstancedOutput) == 0x000088, "Wrong size on FHoudiniInstancedOutput");
static_assert(offsetof(FHoudiniInstancedOutput, OriginalObject) == 0x000000, "Member 'FHoudiniInstancedOutput::OriginalObject' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, OriginalObjectIndex) == 0x000028, "Member 'FHoudiniInstancedOutput::OriginalObjectIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, OriginalTransforms) == 0x000030, "Member 'FHoudiniInstancedOutput::OriginalTransforms' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, VariationObjects) == 0x000040, "Member 'FHoudiniInstancedOutput::VariationObjects' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, VariationTransformOffsets) == 0x000050, "Member 'FHoudiniInstancedOutput::VariationTransformOffsets' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, TransformVariationIndices) == 0x000060, "Member 'FHoudiniInstancedOutput::TransformVariationIndices' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, OriginalInstanceIndices) == 0x000070, "Member 'FHoudiniInstancedOutput::OriginalInstanceIndices' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, bChanged) == 0x000080, "Member 'FHoudiniInstancedOutput::bChanged' has a wrong offset!");
static_assert(offsetof(FHoudiniInstancedOutput, bStale) == 0x000081, "Member 'FHoudiniInstancedOutput::bStale' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniBakedOutputObject
// 0x0100 (0x0100 - 0x0000)
struct FHoudiniBakedOutputObject final
{
public:
	class FString                                 Actor;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Blueprint;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorBakeName;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BakedObject;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BakedComponent;                                    // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         InstancedActors;                                   // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         InstancedComponents;                               // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class FString>              LandscapeLayers;                                   // 0x0068(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FoliageInstancePositions;                          // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UFoliageType*                           FoliageType;                                       // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         LevelInstanceActors;                               // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Landscape;                                         // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BakedSkeleton;                                     // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniBakedOutputObject) == 0x000008, "Wrong alignment on FHoudiniBakedOutputObject");
static_assert(sizeof(FHoudiniBakedOutputObject) == 0x000100, "Wrong size on FHoudiniBakedOutputObject");
static_assert(offsetof(FHoudiniBakedOutputObject, Actor) == 0x000000, "Member 'FHoudiniBakedOutputObject::Actor' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, Blueprint) == 0x000010, "Member 'FHoudiniBakedOutputObject::Blueprint' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, ActorBakeName) == 0x000020, "Member 'FHoudiniBakedOutputObject::ActorBakeName' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, BakedObject) == 0x000028, "Member 'FHoudiniBakedOutputObject::BakedObject' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, BakedComponent) == 0x000038, "Member 'FHoudiniBakedOutputObject::BakedComponent' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, InstancedActors) == 0x000048, "Member 'FHoudiniBakedOutputObject::InstancedActors' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, InstancedComponents) == 0x000058, "Member 'FHoudiniBakedOutputObject::InstancedComponents' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, LandscapeLayers) == 0x000068, "Member 'FHoudiniBakedOutputObject::LandscapeLayers' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, FoliageInstancePositions) == 0x0000B8, "Member 'FHoudiniBakedOutputObject::FoliageInstancePositions' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, FoliageType) == 0x0000C8, "Member 'FHoudiniBakedOutputObject::FoliageType' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, LevelInstanceActors) == 0x0000D0, "Member 'FHoudiniBakedOutputObject::LevelInstanceActors' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, Landscape) == 0x0000E0, "Member 'FHoudiniBakedOutputObject::Landscape' has a wrong offset!");
static_assert(offsetof(FHoudiniBakedOutputObject, BakedSkeleton) == 0x0000F0, "Member 'FHoudiniBakedOutputObject::BakedSkeleton' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniBakedOutput
// 0x0050 (0x0050 - 0x0000)
struct FHoudiniBakedOutput final
{
public:
	TMap<struct FHoudiniBakedOutputObjectIdentifier, struct FHoudiniBakedOutputObject> BakedOutputObjects;                                // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniBakedOutput) == 0x000008, "Wrong alignment on FHoudiniBakedOutput");
static_assert(sizeof(FHoudiniBakedOutput) == 0x000050, "Wrong size on FHoudiniBakedOutput");
static_assert(offsetof(FHoudiniBakedOutput, BakedOutputObjects) == 0x000000, "Member 'FHoudiniBakedOutput::BakedOutputObjects' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.OutputActorOwner
// 0x0010 (0x0010 - 0x0000)
struct FOutputActorOwner final
{
public:
	uint8                                         Pad_2E69[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OutputActor;                                       // 0x0008(0x0008)(ZeroConstructor, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOutputActorOwner) == 0x000008, "Wrong alignment on FOutputActorOwner");
static_assert(sizeof(FOutputActorOwner) == 0x000010, "Wrong size on FOutputActorOwner");
static_assert(offsetof(FOutputActorOwner, OutputActor) == 0x000008, "Member 'FOutputActorOwner::OutputActor' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.TOPWorkResultObject
// 0x0058 (0x0058 - 0x0000)
struct FTOPWorkResultObject final
{
public:
	uint8                                         Pad_2E6A[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0008(0x0010)(ZeroConstructor, NonTransactional, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FilePath;                                          // 0x0018(0x0010)(ZeroConstructor, NonTransactional, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPDGWorkResultState                           State;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E6B[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WorkItemResultInfoIndex;                           // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHoudiniOutput*>                 ResultOutputs;                                     // 0x0030(0x0010)(ZeroConstructor, NonTransactional, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoBakedSinceLastLoad;                           // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E6C[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOutputActorOwner                      OutputActorOwner;                                  // 0x0048(0x0010)(NonTransactional, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTOPWorkResultObject) == 0x000008, "Wrong alignment on FTOPWorkResultObject");
static_assert(sizeof(FTOPWorkResultObject) == 0x000058, "Wrong size on FTOPWorkResultObject");
static_assert(offsetof(FTOPWorkResultObject, Name) == 0x000008, "Member 'FTOPWorkResultObject::Name' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, FilePath) == 0x000018, "Member 'FTOPWorkResultObject::FilePath' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, State) == 0x000028, "Member 'FTOPWorkResultObject::State' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, WorkItemResultInfoIndex) == 0x00002C, "Member 'FTOPWorkResultObject::WorkItemResultInfoIndex' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, ResultOutputs) == 0x000030, "Member 'FTOPWorkResultObject::ResultOutputs' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, bAutoBakedSinceLastLoad) == 0x000040, "Member 'FTOPWorkResultObject::bAutoBakedSinceLastLoad' has a wrong offset!");
static_assert(offsetof(FTOPWorkResultObject, OutputActorOwner) == 0x000048, "Member 'FTOPWorkResultObject::OutputActorOwner' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.TOPWorkResult
// 0x0018 (0x0018 - 0x0000)
struct FTOPWorkResult final
{
public:
	int32                                         WorkItemIndex;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorkItemID;                                        // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTOPWorkResultObject>           ResultObjects;                                     // 0x0008(0x0010)(ZeroConstructor, NonTransactional, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTOPWorkResult) == 0x000008, "Wrong alignment on FTOPWorkResult");
static_assert(sizeof(FTOPWorkResult) == 0x000018, "Wrong size on FTOPWorkResult");
static_assert(offsetof(FTOPWorkResult, WorkItemIndex) == 0x000000, "Member 'FTOPWorkResult::WorkItemIndex' has a wrong offset!");
static_assert(offsetof(FTOPWorkResult, WorkItemID) == 0x000004, "Member 'FTOPWorkResult::WorkItemID' has a wrong offset!");
static_assert(offsetof(FTOPWorkResult, ResultObjects) == 0x000008, "Member 'FTOPWorkResult::ResultObjects' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.WorkItemTallyBase
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FWorkItemTallyBase
{
public:
	uint8                                         Pad_2E6D[0x8];                                     // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorkItemTallyBase) == 0x000008, "Wrong alignment on FWorkItemTallyBase");
static_assert(sizeof(FWorkItemTallyBase) == 0x000008, "Wrong size on FWorkItemTallyBase");

// ScriptStruct HoudiniEngineRuntime.WorkItemTally
// 0x0230 (0x0238 - 0x0008)
struct FWorkItemTally final : public FWorkItemTallyBase
{
public:
	TSet<int32>                                   AllWorkItems;                                      // 0x0008(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   WaitingWorkItems;                                  // 0x0058(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   ScheduledWorkItems;                                // 0x00A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   CookingWorkItems;                                  // 0x00F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   CookedWorkItems;                                   // 0x0148(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   ErroredWorkItems;                                  // 0x0198(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   CookCancelledWorkItems;                            // 0x01E8(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FWorkItemTally) == 0x000008, "Wrong alignment on FWorkItemTally");
static_assert(sizeof(FWorkItemTally) == 0x000238, "Wrong size on FWorkItemTally");
static_assert(offsetof(FWorkItemTally, AllWorkItems) == 0x000008, "Member 'FWorkItemTally::AllWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, WaitingWorkItems) == 0x000058, "Member 'FWorkItemTally::WaitingWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, ScheduledWorkItems) == 0x0000A8, "Member 'FWorkItemTally::ScheduledWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, CookingWorkItems) == 0x0000F8, "Member 'FWorkItemTally::CookingWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, CookedWorkItems) == 0x000148, "Member 'FWorkItemTally::CookedWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, ErroredWorkItems) == 0x000198, "Member 'FWorkItemTally::ErroredWorkItems' has a wrong offset!");
static_assert(offsetof(FWorkItemTally, CookCancelledWorkItems) == 0x0001E8, "Member 'FWorkItemTally::CookCancelledWorkItems' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.AggregatedWorkItemTally
// 0x0020 (0x0028 - 0x0008)
struct FAggregatedWorkItemTally final : public FWorkItemTallyBase
{
public:
	int32                                         TotalWorkItems;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WaitingWorkItems;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ScheduledWorkItems;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CookingWorkItems;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CookedWorkItems;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ErroredWorkItems;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CookCancelledWorkItems;                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E6E[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAggregatedWorkItemTally) == 0x000008, "Wrong alignment on FAggregatedWorkItemTally");
static_assert(sizeof(FAggregatedWorkItemTally) == 0x000028, "Wrong size on FAggregatedWorkItemTally");
static_assert(offsetof(FAggregatedWorkItemTally, TotalWorkItems) == 0x000008, "Member 'FAggregatedWorkItemTally::TotalWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, WaitingWorkItems) == 0x00000C, "Member 'FAggregatedWorkItemTally::WaitingWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, ScheduledWorkItems) == 0x000010, "Member 'FAggregatedWorkItemTally::ScheduledWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, CookingWorkItems) == 0x000014, "Member 'FAggregatedWorkItemTally::CookingWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, CookedWorkItems) == 0x000018, "Member 'FAggregatedWorkItemTally::CookedWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, ErroredWorkItems) == 0x00001C, "Member 'FAggregatedWorkItemTally::ErroredWorkItems' has a wrong offset!");
static_assert(offsetof(FAggregatedWorkItemTally, CookCancelledWorkItems) == 0x000020, "Member 'FAggregatedWorkItemTally::CookCancelledWorkItems' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniPDGWorkResultObjectBakedOutput
// 0x0010 (0x0010 - 0x0000)
struct FHoudiniPDGWorkResultObjectBakedOutput final
{
public:
	TArray<struct FHoudiniBakedOutput>            BakedOutputs;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniPDGWorkResultObjectBakedOutput) == 0x000008, "Wrong alignment on FHoudiniPDGWorkResultObjectBakedOutput");
static_assert(sizeof(FHoudiniPDGWorkResultObjectBakedOutput) == 0x000010, "Wrong size on FHoudiniPDGWorkResultObjectBakedOutput");
static_assert(offsetof(FHoudiniPDGWorkResultObjectBakedOutput, BakedOutputs) == 0x000000, "Member 'FHoudiniPDGWorkResultObjectBakedOutput::BakedOutputs' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniStaticMeshGenerationProperties
// 0x01E0 (0x01E0 - 0x0000)
struct FHoudiniStaticMeshGenerationProperties final
{
public:
	uint8                                         bGeneratedDoubleSidedGeometry : 1;                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2E6F[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      GeneratedPhysMaterial;                             // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBodyInstance                          DefaultBodyInstance;                               // 0x0010(0x0190)(Edit, NativeAccessSpecifierPublic)
	ECollisionTraceFlag                           GeneratedCollisionTraceFlag;                       // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E70[0x3];                                     // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GeneratedLightMapResolution;                       // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWalkableSlopeOverride                 GeneratedWalkableSlopeOverride;                    // 0x01A8(0x0010)(Edit, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         GeneratedLightMapCoordinateIndex;                  // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGeneratedUseMaximumStreamingTexelRatio : 1;       // 0x01BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2E71[0x3];                                     // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GeneratedStreamingDistanceMultiplier;              // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E72[0x4];                                     // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFoliageType_InstancedStaticMesh*       GeneratedFoliageDefaultSettings;                   // 0x01C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAssetUserData*>                 GeneratedAssetUserData;                            // 0x01D0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniStaticMeshGenerationProperties) == 0x000008, "Wrong alignment on FHoudiniStaticMeshGenerationProperties");
static_assert(sizeof(FHoudiniStaticMeshGenerationProperties) == 0x0001E0, "Wrong size on FHoudiniStaticMeshGenerationProperties");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedPhysMaterial) == 0x000008, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedPhysMaterial' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, DefaultBodyInstance) == 0x000010, "Member 'FHoudiniStaticMeshGenerationProperties::DefaultBodyInstance' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedCollisionTraceFlag) == 0x0001A0, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedCollisionTraceFlag' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedLightMapResolution) == 0x0001A4, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedLightMapResolution' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedWalkableSlopeOverride) == 0x0001A8, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedWalkableSlopeOverride' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedLightMapCoordinateIndex) == 0x0001B8, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedLightMapCoordinateIndex' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedStreamingDistanceMultiplier) == 0x0001C0, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedStreamingDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedFoliageDefaultSettings) == 0x0001C8, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedFoliageDefaultSettings' has a wrong offset!");
static_assert(offsetof(FHoudiniStaticMeshGenerationProperties, GeneratedAssetUserData) == 0x0001D0, "Member 'FHoudiniStaticMeshGenerationProperties::GeneratedAssetUserData' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HoudiniSplineComponentInstanceData
// 0x0030 (0x0098 - 0x0068)
struct FHoudiniSplineComponentInstanceData final : public FActorComponentInstanceData
{
public:
	TArray<struct FTransform>                     CurvePoints;                                       // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        DisplayPoints;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 DisplayPointIndexDivider;                          // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoudiniSplineComponentInstanceData) == 0x000008, "Wrong alignment on FHoudiniSplineComponentInstanceData");
static_assert(sizeof(FHoudiniSplineComponentInstanceData) == 0x000098, "Wrong size on FHoudiniSplineComponentInstanceData");
static_assert(offsetof(FHoudiniSplineComponentInstanceData, CurvePoints) == 0x000068, "Member 'FHoudiniSplineComponentInstanceData::CurvePoints' has a wrong offset!");
static_assert(offsetof(FHoudiniSplineComponentInstanceData, DisplayPoints) == 0x000078, "Member 'FHoudiniSplineComponentInstanceData::DisplayPoints' has a wrong offset!");
static_assert(offsetof(FHoudiniSplineComponentInstanceData, DisplayPointIndexDivider) == 0x000088, "Member 'FHoudiniSplineComponentInstanceData::DisplayPointIndexDivider' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.HImageData
// 0x0030 (0x0030 - 0x0000)
struct FHImageData final
{
public:
	int32                                         SizeX;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSlices;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Format;                                            // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         GammaSpace;                                        // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E73[0x2];                                     // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 RawData;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 RawDataMD5;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHImageData) == 0x000008, "Wrong alignment on FHImageData");
static_assert(sizeof(FHImageData) == 0x000030, "Wrong size on FHImageData");
static_assert(offsetof(FHImageData, SizeX) == 0x000000, "Member 'FHImageData::SizeX' has a wrong offset!");
static_assert(offsetof(FHImageData, SizeY) == 0x000004, "Member 'FHImageData::SizeY' has a wrong offset!");
static_assert(offsetof(FHImageData, NumSlices) == 0x000008, "Member 'FHImageData::NumSlices' has a wrong offset!");
static_assert(offsetof(FHImageData, Format) == 0x00000C, "Member 'FHImageData::Format' has a wrong offset!");
static_assert(offsetof(FHImageData, GammaSpace) == 0x00000D, "Member 'FHImageData::GammaSpace' has a wrong offset!");
static_assert(offsetof(FHImageData, RawData) == 0x000010, "Member 'FHImageData::RawData' has a wrong offset!");
static_assert(offsetof(FHImageData, RawDataMD5) == 0x000020, "Member 'FHImageData::RawDataMD5' has a wrong offset!");

// ScriptStruct HoudiniEngineRuntime.CategoryRules
// 0x0020 (0x0020 - 0x0000)
struct FCategoryRules final
{
public:
	TArray<class FString>                         Include;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Exclude;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCategoryRules) == 0x000008, "Wrong alignment on FCategoryRules");
static_assert(sizeof(FCategoryRules) == 0x000020, "Wrong size on FCategoryRules");
static_assert(offsetof(FCategoryRules, Include) == 0x000000, "Member 'FCategoryRules::Include' has a wrong offset!");
static_assert(offsetof(FCategoryRules, Exclude) == 0x000010, "Member 'FCategoryRules::Exclude' has a wrong offset!");

}

