#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Palia

#include "Basic.hpp"

#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Palia_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "S6Core_structs.hpp"
#include "S6Core_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "S6EnhancedInputExtended_structs.hpp"
#include "CommonInput_structs.hpp"
#include "Niagara_classes.hpp"
#include "ValeriaDTOs_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "CinematicCamera_classes.hpp"
#include "OnlineSubsystemValeria_structs.hpp"
#include "ReplicationGraph_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class Palia.ViewComponent
// 0x0000 (0x02A0 - 0x02A0)
class UViewComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewComponent">();
	}
	static class UViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UViewComponent>();
	}
};
static_assert(alignof(UViewComponent) == 0x000010, "Wrong alignment on UViewComponent");
static_assert(sizeof(UViewComponent) == 0x0002A0, "Wrong size on UViewComponent");

// Class Palia.AbilityAnimationComponent
// 0x0228 (0x02C8 - 0x00A0)
class UAbilityAnimationComponent final : public UActorComponent
{
public:
	class UDataTable*                             AnimationMappings;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UDataTable*>          ExtraAnimationMappings;                            // 0x00A8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FAnimationMappingConfig> ExtraAnimationRows;                                // 0x00F8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   LastUsedAnimMappingName;                           // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastUsedAnimWasBlendSpace;                        // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238B[0x7];                                     // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UDataTable*>          AudioAnimNotifyMappings;                           // 0x0158(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMontageNotify;                                   // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyStateBegin;                                // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyStateEnd;                                  // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocomotionTagChanged;                            // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCombatTagChanged;                                // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActiveMontageNotifyStates;                         // 0x0208(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UAICombatStateComponent*                AiCombatState;                                     // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentComponent*                    EquipmentComponent;                                // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimState                             AnimState;                                         // 0x0228(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           LocomotionTag;                                     // 0x0240(0x0008)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           CombatTag;                                         // 0x0248(0x0008)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayAbilityRepAnimMontage         RepAnimMontageInfo;                                // 0x0250(0x0038)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayAbilityLocalAnimMontage       LocalAnimMontageInfo;                              // 0x0288(0x0030)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238C[0x10];                                    // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_OnAnimStateChange(struct FAnimState& OldAnimState);
	void HandleAnimNotifyStateBegin(class FName NotifyName, struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void HandleAnimNotifyStateEnd(class FName NotifyName, struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void HandleEquipmentChanged(class UEquipmentComponent* InEquipmentComponent, const struct FEquipmentItem& Item);
	void HandleEquipmentVisibilityChanged(class UEquipmentComponent* InEquipmentComponent, bool bHidden);
	void HandleOnAnimInitialized();
	void HandleStateChanged(class UCharacterStateMachineComponent* Csm, const struct FCharacterStateChangeParams& Params_0);
	void MontageAction(ERpcMontageAction Event, class UAnimMontage* Montage);
	void MontageActionFromContext(struct FMontageActionContext& Context);
	void OnAbilityEnded(class UGameplayAbility* EndedAbility);
	void OnAbilityStarted(class UGameplayAbility* ActivatedAbility);
	void OnRep_CombatTag(struct FGameplayTag& OldTag);
	void OnRep_LocomotionTag(struct FGameplayTag& OldTag);
	void OnRep_ReplicatedAnimMontage();
	void PlayAnimation(struct FGameplayTag& AnimTag);
	bool PlayMontage(const struct FMontageInfo& MontageInfo);
	void RpcClient_TryChangeState(struct FAnimState& Context, ERpcAction RpcAction);
	void RpcMontageAction(struct FMontageActionContext& Context);
	void RpcServer_MontageAction(struct FMontageActionContext& Context);
	void RpcServer_TryChangeState(struct FAnimState& Context, ERpcAction RpcAction);
	void StopAll(float BlendOut);
	void StopAnimation(struct FGameplayTag& AnimTag);
	bool StopMontage(class UAnimMontage* AnimMontage);
	void TryChangeState(struct FAnimState& Context, ERpcAction RpcAction);

	class UBlendSpace* GetBlendSpace(const struct FGameplayTag& Tag, class FName& MappingQualifier) const;
	class UBlendSpace* GetBlendSpaceByName(class FName& Param_Name, class FName& MappingQualifier) const;
	struct FGameplayTag GetCombatTag() const;
	struct FGameplayTag GetLocomotionTag() const;
	class FName GetMappingNameByTag(const struct FGameplayTag& Tag, class FName& MappingQualifier) const;
	class UAnimMontage* GetMontage(const struct FGameplayTag& Tag, class FName& MappingQualifier) const;
	class UAnimMontage* GetMontageByName(class FName& Param_Name, class FName& MappingQualifier) const;
	class FName GetRowNameAssociatedWithTag(const struct FGameplayTag& Tag) const;
	class UAnimSequence* GetSequence(const struct FGameplayTag& Tag, class FName& MappingQualifier) const;
	class UAnimSequence* GetSequenceByName(class FName& Param_Name, class FName& MappingQualifier) const;
	struct FGameplayTag GetTagAssociatedWithRowName(class FName Param_Name) const;
	bool IsNotifyStateActive(class FName& NotifyStateName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityAnimationComponent">();
	}
	static class UAbilityAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityAnimationComponent>();
	}
};
static_assert(alignof(UAbilityAnimationComponent) == 0x000008, "Wrong alignment on UAbilityAnimationComponent");
static_assert(sizeof(UAbilityAnimationComponent) == 0x0002C8, "Wrong size on UAbilityAnimationComponent");
static_assert(offsetof(UAbilityAnimationComponent, AnimationMappings) == 0x0000A0, "Member 'UAbilityAnimationComponent::AnimationMappings' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, ExtraAnimationMappings) == 0x0000A8, "Member 'UAbilityAnimationComponent::ExtraAnimationMappings' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, ExtraAnimationRows) == 0x0000F8, "Member 'UAbilityAnimationComponent::ExtraAnimationRows' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, LastUsedAnimMappingName) == 0x000148, "Member 'UAbilityAnimationComponent::LastUsedAnimMappingName' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, bLastUsedAnimWasBlendSpace) == 0x000150, "Member 'UAbilityAnimationComponent::bLastUsedAnimWasBlendSpace' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, AudioAnimNotifyMappings) == 0x000158, "Member 'UAbilityAnimationComponent::AudioAnimNotifyMappings' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, OnMontageNotify) == 0x0001A8, "Member 'UAbilityAnimationComponent::OnMontageNotify' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, OnNotifyStateBegin) == 0x0001B8, "Member 'UAbilityAnimationComponent::OnNotifyStateBegin' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, OnNotifyStateEnd) == 0x0001C8, "Member 'UAbilityAnimationComponent::OnNotifyStateEnd' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, OnChanged) == 0x0001D8, "Member 'UAbilityAnimationComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, OnLocomotionTagChanged) == 0x0001E8, "Member 'UAbilityAnimationComponent::OnLocomotionTagChanged' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, OnCombatTagChanged) == 0x0001F8, "Member 'UAbilityAnimationComponent::OnCombatTagChanged' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, ActiveMontageNotifyStates) == 0x000208, "Member 'UAbilityAnimationComponent::ActiveMontageNotifyStates' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, AiCombatState) == 0x000218, "Member 'UAbilityAnimationComponent::AiCombatState' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, EquipmentComponent) == 0x000220, "Member 'UAbilityAnimationComponent::EquipmentComponent' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, AnimState) == 0x000228, "Member 'UAbilityAnimationComponent::AnimState' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, LocomotionTag) == 0x000240, "Member 'UAbilityAnimationComponent::LocomotionTag' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, CombatTag) == 0x000248, "Member 'UAbilityAnimationComponent::CombatTag' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, RepAnimMontageInfo) == 0x000250, "Member 'UAbilityAnimationComponent::RepAnimMontageInfo' has a wrong offset!");
static_assert(offsetof(UAbilityAnimationComponent, LocalAnimMontageInfo) == 0x000288, "Member 'UAbilityAnimationComponent::LocalAnimMontageInfo' has a wrong offset!");

// Class Palia.VAL_DataAsset
// 0x0030 (0x0058 - 0x0028)
class UVAL_DataAsset : public UObject
{
public:
	uint8                                         Pad_2395[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagList                               Tags;                                              // 0x0030(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          IsArchived;                                        // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2396[0x3];                                     // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PersistId;                                         // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static int32 GetInvalidItemPersistId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DataAsset">();
	}
	static class UVAL_DataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DataAsset>();
	}
};
static_assert(alignof(UVAL_DataAsset) == 0x000008, "Wrong alignment on UVAL_DataAsset");
static_assert(sizeof(UVAL_DataAsset) == 0x000058, "Wrong size on UVAL_DataAsset");
static_assert(offsetof(UVAL_DataAsset, Tags) == 0x000030, "Member 'UVAL_DataAsset::Tags' has a wrong offset!");
static_assert(offsetof(UVAL_DataAsset, IsArchived) == 0x000050, "Member 'UVAL_DataAsset::IsArchived' has a wrong offset!");
static_assert(offsetof(UVAL_DataAsset, PersistId) == 0x000054, "Member 'UVAL_DataAsset::PersistId' has a wrong offset!");

// Class Palia.EquipViewActor
// 0x0000 (0x02A8 - 0x02A8)
class AEquipViewActor : public AActor
{
public:
	void OnOwnerAnimNotifyBeginReceived(class FName NotifyName, struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void ReceiveNamedNotify(class FName& NotifyName, class FName& QualifierName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipViewActor">();
	}
	static class AEquipViewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEquipViewActor>();
	}
};
static_assert(alignof(AEquipViewActor) == 0x000008, "Wrong alignment on AEquipViewActor");
static_assert(sizeof(AEquipViewActor) == 0x0002A8, "Wrong size on AEquipViewActor");

// Class Palia.ValeriaAccomplishmentsManager
// 0x00D8 (0x0108 - 0x0030)
class UValeriaAccomplishmentsManager final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnBatchAccomplishmentStatsUpdated;                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBatchAccomplishmentsUpdated;                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStatUpdated;                                     // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAccomplishmentUnlocked;                          // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAccomplishmentRedeemed;                          // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2397[0x88];                                    // 0x0080(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void IncrementCollectionStatForPlayer(class APlayerController* Player, const class FString& StatName, int32 PersistId, int32 Value);
	void SetBooleanStatForPlayer(class APlayerController* Player, const class FString& StatName, bool NewValue);
	void UpdateDoubleStatForPlayer(class APlayerController* Player, const class FString& StatName, EValeriaStatModificationType ModificationType, double Value);
	void UpdateFloatStatForPlayer(class APlayerController* Player, const class FString& StatName, EValeriaStatModificationType ModificationType, float Value);
	void UpdateIntegerStatForPlayer(class APlayerController* Player, const class FString& StatName, EValeriaStatModificationType ModificationType, int32 Value);

	bool CanPlayerRedeemAchievement(class APlayerController* Player, const class FString& AchievementID) const;
	const struct FValeriaOnlineAchievementDefinition GetAchievementDefinition(const class FString& AchievementID) const;
	TArray<struct FValeriaOnlineAchievementDefinition> GetAchievementDefinitions() const;
	TArray<class FString> GetAchievementGroup(const class FString& AccomplishmentId, const class FString& GroupID) const;
	class FString GetAchievementInGroupByTier(int32 Tier, const class FString& GroupID) const;
	TArray<struct FValeriaOnlineAchievement> GetAchievementsForNetId(struct FUniqueNetIdRepl& AccountId) const;
	TArray<struct FValeriaOnlineAchievement> GetAchievementsForPlayer(class APlayerController* Player) const;
	void GetAllStatsForPlayer(class APlayerController* Player, TMap<class FString, class FString>* OutStatNameValueTable) const;
	bool GetBooleanStatForPlayer(class APlayerController* Player, const class FString& StatName, bool* Value) const;
	bool GetCollectionStatForPlayer(class APlayerController* Player, const class FString& StatName, int32 PersistId, int32* Value) const;
	int32 GetCurrentTierOfAchievementGroup(class APlayerController* Player, const class FString& GroupID) const;
	bool GetFloatStatForPlayer(class APlayerController* Player, const class FString& StatName, float* Value) const;
	bool GetIntegerStatForPlayer(class APlayerController* Player, const class FString& StatName, int32* Value) const;
	TArray<struct FAchievementRewards> GetRewardsForAchievement(const class FString& AchievementID) const;
	bool GetStatValueForPlayerAsString(class APlayerController* Player, const class FString& StatName, class FString* Value) const;
	TArray<struct FAchievementUnlockRule> GetUnlockRulesForAchievement(const class FString& AchievementID) const;
	bool HasAchievementUnlocked(class APlayerController* Player, const class FString& AchievementID) const;
	bool HasRedeemedAchievementRewards(class APlayerController* Player, const class FString& AchievementID) const;
	bool HasSetCollectionStatForPlayer(class APlayerController* Player, const class FString& StatName, int32 PersistId, bool* Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaAccomplishmentsManager">();
	}
	static class UValeriaAccomplishmentsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaAccomplishmentsManager>();
	}
};
static_assert(alignof(UValeriaAccomplishmentsManager) == 0x000008, "Wrong alignment on UValeriaAccomplishmentsManager");
static_assert(sizeof(UValeriaAccomplishmentsManager) == 0x000108, "Wrong size on UValeriaAccomplishmentsManager");
static_assert(offsetof(UValeriaAccomplishmentsManager, OnBatchAccomplishmentStatsUpdated) == 0x000030, "Member 'UValeriaAccomplishmentsManager::OnBatchAccomplishmentStatsUpdated' has a wrong offset!");
static_assert(offsetof(UValeriaAccomplishmentsManager, OnBatchAccomplishmentsUpdated) == 0x000040, "Member 'UValeriaAccomplishmentsManager::OnBatchAccomplishmentsUpdated' has a wrong offset!");
static_assert(offsetof(UValeriaAccomplishmentsManager, OnStatUpdated) == 0x000050, "Member 'UValeriaAccomplishmentsManager::OnStatUpdated' has a wrong offset!");
static_assert(offsetof(UValeriaAccomplishmentsManager, OnAccomplishmentUnlocked) == 0x000060, "Member 'UValeriaAccomplishmentsManager::OnAccomplishmentUnlocked' has a wrong offset!");
static_assert(offsetof(UValeriaAccomplishmentsManager, OnAccomplishmentRedeemed) == 0x000070, "Member 'UValeriaAccomplishmentsManager::OnAccomplishmentRedeemed' has a wrong offset!");

// Class Palia.VAL_WwiseMotionBase
// 0x0008 (0x0030 - 0x0028)
class UVAL_WwiseMotionBase : public UObject
{
public:
	uint8                                         Pad_23A7[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_WwiseMotionBase">();
	}
	static class UVAL_WwiseMotionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_WwiseMotionBase>();
	}
};
static_assert(alignof(UVAL_WwiseMotionBase) == 0x000008, "Wrong alignment on UVAL_WwiseMotionBase");
static_assert(sizeof(UVAL_WwiseMotionBase) == 0x000030, "Wrong size on UVAL_WwiseMotionBase");

// Class Palia.Activatable
// 0x0000 (0x0028 - 0x0028)
class IActivatable final : public IInterface
{
public:
	void Activate();
	void Deactivate();

	bool CanActivate() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Activatable">();
	}
	static class IActivatable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IActivatable>();
	}
};
static_assert(alignof(IActivatable) == 0x000008, "Wrong alignment on IActivatable");
static_assert(sizeof(IActivatable) == 0x000028, "Wrong size on IActivatable");

// Class Palia.ActivationManager
// 0x0028 (0x02D0 - 0x02A8)
class AActivationManager final : public AActor
{
public:
	TArray<TSoftClassPtr<class UClass>>           ManagedActorClasses;                               // 0x02A8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   RequiredActorTags;                                 // 0x02B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         MaxActivationsAllowed;                             // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23A8[0x4];                                     // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 PerformActivation(int32 NumToActivate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationManager">();
	}
	static class AActivationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActivationManager>();
	}
};
static_assert(alignof(AActivationManager) == 0x000008, "Wrong alignment on AActivationManager");
static_assert(sizeof(AActivationManager) == 0x0002D0, "Wrong size on AActivationManager");
static_assert(offsetof(AActivationManager, ManagedActorClasses) == 0x0002A8, "Member 'AActivationManager::ManagedActorClasses' has a wrong offset!");
static_assert(offsetof(AActivationManager, RequiredActorTags) == 0x0002B8, "Member 'AActivationManager::RequiredActorTags' has a wrong offset!");
static_assert(offsetof(AActivationManager, MaxActivationsAllowed) == 0x0002C8, "Member 'AActivationManager::MaxActivationsAllowed' has a wrong offset!");

// Class Palia.VAL_GameplayEvent
// 0x0140 (0x0168 - 0x0028)
class UVAL_GameplayEvent : public UObject
{
public:
	EVAL_GameplayEventSourceTargetType            SourceType;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A9[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SourcePlayerRelationship;                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      SourceTagRequirements;                             // 0x0030(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EVAL_GameplayEventSourceTargetType            TargetType;                                        // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23AA[0x3];                                     // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetPlayerRelationship;                          // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      TargetTagRequirements;                             // 0x0080(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSource;                                        // 0x00CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23AB[0x3];                                     // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      SourceCharacter;                                   // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AValeriaPlayerController*               SourcePlayerController;                            // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AValeriaVillagerCharacter*              SourceVillagerCharacter;                           // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AValeriaVillagerController*             SourceVillagerController;                          // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACreatureCharacter*                     SourceCreatureCharacter;                           // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceTags;                                        // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bHasTarget;                                        // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23AC[0x7];                                     // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      TargetCharacter;                                   // 0x0120(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AValeriaPlayerController*               TargetPlayerController;                            // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AValeriaVillagerCharacter*              TargetVillagerCharacter;                           // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AValeriaVillagerController*             TargetVillagerController;                          // 0x0138(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACreatureCharacter*                     TargetCreatureCharacter;                           // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetTags;                                        // 0x0148(0x0020)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent">();
	}
	static class UVAL_GameplayEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent>();
	}
};
static_assert(alignof(UVAL_GameplayEvent) == 0x000008, "Wrong alignment on UVAL_GameplayEvent");
static_assert(sizeof(UVAL_GameplayEvent) == 0x000168, "Wrong size on UVAL_GameplayEvent");
static_assert(offsetof(UVAL_GameplayEvent, SourceType) == 0x000028, "Member 'UVAL_GameplayEvent::SourceType' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, SourcePlayerRelationship) == 0x00002C, "Member 'UVAL_GameplayEvent::SourcePlayerRelationship' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, SourceTagRequirements) == 0x000030, "Member 'UVAL_GameplayEvent::SourceTagRequirements' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, TargetType) == 0x000078, "Member 'UVAL_GameplayEvent::TargetType' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, TargetPlayerRelationship) == 0x00007C, "Member 'UVAL_GameplayEvent::TargetPlayerRelationship' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, TargetTagRequirements) == 0x000080, "Member 'UVAL_GameplayEvent::TargetTagRequirements' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, Count) == 0x0000C8, "Member 'UVAL_GameplayEvent::Count' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, bHasSource) == 0x0000CC, "Member 'UVAL_GameplayEvent::bHasSource' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, SourceCharacter) == 0x0000D0, "Member 'UVAL_GameplayEvent::SourceCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, SourcePlayerController) == 0x0000D8, "Member 'UVAL_GameplayEvent::SourcePlayerController' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, SourceVillagerCharacter) == 0x0000E0, "Member 'UVAL_GameplayEvent::SourceVillagerCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, SourceVillagerController) == 0x0000E8, "Member 'UVAL_GameplayEvent::SourceVillagerController' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, SourceCreatureCharacter) == 0x0000F0, "Member 'UVAL_GameplayEvent::SourceCreatureCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, SourceTags) == 0x0000F8, "Member 'UVAL_GameplayEvent::SourceTags' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, bHasTarget) == 0x000118, "Member 'UVAL_GameplayEvent::bHasTarget' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, TargetCharacter) == 0x000120, "Member 'UVAL_GameplayEvent::TargetCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, TargetPlayerController) == 0x000128, "Member 'UVAL_GameplayEvent::TargetPlayerController' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, TargetVillagerCharacter) == 0x000130, "Member 'UVAL_GameplayEvent::TargetVillagerCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, TargetVillagerController) == 0x000138, "Member 'UVAL_GameplayEvent::TargetVillagerController' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, TargetCreatureCharacter) == 0x000140, "Member 'UVAL_GameplayEvent::TargetCreatureCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent, TargetTags) == 0x000148, "Member 'UVAL_GameplayEvent::TargetTags' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_WaterPlant
// 0x0000 (0x0168 - 0x0168)
class UVAL_GameplayEvent_WaterPlant final : public UVAL_GameplayEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_WaterPlant">();
	}
	static class UVAL_GameplayEvent_WaterPlant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_WaterPlant>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_WaterPlant) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_WaterPlant");
static_assert(sizeof(UVAL_GameplayEvent_WaterPlant) == 0x000168, "Wrong size on UVAL_GameplayEvent_WaterPlant");

// Class Palia.VAL_TimerInstance
// 0x0088 (0x00B0 - 0x0028)
class UVAL_TimerInstance final : public UObject
{
public:
	struct FVAL_TimerStateStruct                  TimerState;                                        // 0x0028(0x0030)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23AD[0x58];                                    // 0x0058(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TimerInstance">();
	}
	static class UVAL_TimerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TimerInstance>();
	}
};
static_assert(alignof(UVAL_TimerInstance) == 0x000008, "Wrong alignment on UVAL_TimerInstance");
static_assert(sizeof(UVAL_TimerInstance) == 0x0000B0, "Wrong size on UVAL_TimerInstance");
static_assert(offsetof(UVAL_TimerInstance, TimerState) == 0x000028, "Member 'UVAL_TimerInstance::TimerState' has a wrong offset!");

// Class Palia.ActorSpawnPointsManager
// 0x00A0 (0x00D0 - 0x0030)
class UActorSpawnPointsManager final : public UGameInstanceSubsystem
{
public:
	TMap<class UClass*, struct FActorSpawnPointList> ActorSpawnPointsAvailable;                         // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AActor*, class AActor*>            ActorSpawnPointsUsed;                              // 0x0080(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnOccupierActorDestroyed(class AActor* OccupierActor);
	void OnSpawnPointActorDestroyed(class AActor* SpawnPointActor);
	void RemoveSpawnPoint(class AActor* SpawnPointActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawnPointsManager">();
	}
	static class UActorSpawnPointsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorSpawnPointsManager>();
	}
};
static_assert(alignof(UActorSpawnPointsManager) == 0x000008, "Wrong alignment on UActorSpawnPointsManager");
static_assert(sizeof(UActorSpawnPointsManager) == 0x0000D0, "Wrong size on UActorSpawnPointsManager");
static_assert(offsetof(UActorSpawnPointsManager, ActorSpawnPointsAvailable) == 0x000030, "Member 'UActorSpawnPointsManager::ActorSpawnPointsAvailable' has a wrong offset!");
static_assert(offsetof(UActorSpawnPointsManager, ActorSpawnPointsUsed) == 0x000080, "Member 'UActorSpawnPointsManager::ActorSpawnPointsUsed' has a wrong offset!");

// Class Palia.PrivateSpaceVillagerDeterminantConfig
// 0x0018 (0x0048 - 0x0030)
class UPrivateSpaceVillagerDeterminantConfig final : public UDataAsset
{
public:
	bool                                          bAllowSimultaneousVisits;                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23AE[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UPrivateSpaceVillagerVisitConfig>> VillagerVisits;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	TArray<class UPrivateSpaceVillagerVisitConfig*> DeterminePrivateSpaceVillagerVisits(class AValeriaCharacter* InValeriaCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrivateSpaceVillagerDeterminantConfig">();
	}
	static class UPrivateSpaceVillagerDeterminantConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrivateSpaceVillagerDeterminantConfig>();
	}
};
static_assert(alignof(UPrivateSpaceVillagerDeterminantConfig) == 0x000008, "Wrong alignment on UPrivateSpaceVillagerDeterminantConfig");
static_assert(sizeof(UPrivateSpaceVillagerDeterminantConfig) == 0x000048, "Wrong size on UPrivateSpaceVillagerDeterminantConfig");
static_assert(offsetof(UPrivateSpaceVillagerDeterminantConfig, bAllowSimultaneousVisits) == 0x000030, "Member 'UPrivateSpaceVillagerDeterminantConfig::bAllowSimultaneousVisits' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerDeterminantConfig, VillagerVisits) == 0x000038, "Member 'UPrivateSpaceVillagerDeterminantConfig::VillagerVisits' has a wrong offset!");

// Class Palia.ActorTagComponent
// 0x0078 (0x0118 - 0x00A0)
class UActorTagComponent final : public UActorComponent
{
public:
	uint8                                         Pad_23AF[0x58];                                    // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnActorTagComponentUpdatedDel;                     // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTagEntry>                      TagValues;                                         // 0x0108(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_TagValues();

	int32 GetTagValue(struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorTagComponent">();
	}
	static class UActorTagComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorTagComponent>();
	}
};
static_assert(alignof(UActorTagComponent) == 0x000008, "Wrong alignment on UActorTagComponent");
static_assert(sizeof(UActorTagComponent) == 0x000118, "Wrong size on UActorTagComponent");
static_assert(offsetof(UActorTagComponent, OnActorTagComponentUpdatedDel) == 0x0000F8, "Member 'UActorTagComponent::OnActorTagComponentUpdatedDel' has a wrong offset!");
static_assert(offsetof(UActorTagComponent, TagValues) == 0x000108, "Member 'UActorTagComponent::TagValues' has a wrong offset!");

// Class Palia.VAL_BatchedDataAsset
// 0x0028 (0x0080 - 0x0058)
class UVAL_BatchedDataAsset : public UVAL_DataAsset
{
public:
	TSoftObjectPtr<class UVAL_ContentBatchAsset>  ContentBatch;                                      // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_BatchedDataAsset">();
	}
	static class UVAL_BatchedDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_BatchedDataAsset>();
	}
};
static_assert(alignof(UVAL_BatchedDataAsset) == 0x000008, "Wrong alignment on UVAL_BatchedDataAsset");
static_assert(sizeof(UVAL_BatchedDataAsset) == 0x000080, "Wrong size on UVAL_BatchedDataAsset");
static_assert(offsetof(UVAL_BatchedDataAsset, ContentBatch) == 0x000058, "Member 'UVAL_BatchedDataAsset::ContentBatch' has a wrong offset!");

// Class Palia.VAL_PlayingCardStack
// 0x0010 (0x0038 - 0x0028)
class UVAL_PlayingCardStack : public UObject
{
public:
	TArray<class UVAL_PlayingCard*>               Cards;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayingCardStack">();
	}
	static class UVAL_PlayingCardStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayingCardStack>();
	}
};
static_assert(alignof(UVAL_PlayingCardStack) == 0x000008, "Wrong alignment on UVAL_PlayingCardStack");
static_assert(sizeof(UVAL_PlayingCardStack) == 0x000038, "Wrong size on UVAL_PlayingCardStack");
static_assert(offsetof(UVAL_PlayingCardStack, Cards) == 0x000028, "Member 'UVAL_PlayingCardStack::Cards' has a wrong offset!");

// Class Palia.HotPotTileStack
// 0x0000 (0x0038 - 0x0038)
class UHotPotTileStack final : public UVAL_PlayingCardStack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotPotTileStack">();
	}
	static class UHotPotTileStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotPotTileStack>();
	}
};
static_assert(alignof(UHotPotTileStack) == 0x000008, "Wrong alignment on UHotPotTileStack");
static_assert(sizeof(UHotPotTileStack) == 0x000038, "Wrong size on UHotPotTileStack");

// Class Palia.ActorTestHarnessComponent
// 0x0020 (0x00C0 - 0x00A0)
class UActorTestHarnessComponent : public UActorComponent
{
public:
	float                                         SecondsBeforeSwitchingServer;                      // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoadTestClient;                                 // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFPSChartEnabled;                                  // 0x00A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23B0[0x2];                                     // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoadTestBotID;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23B1[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentTestCase;                                   // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTestStarted(const class FString& TestCase);
	void OnTestStopped(const class FString& TestCase);
	bool StartLoadTestClient();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorTestHarnessComponent">();
	}
	static class UActorTestHarnessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorTestHarnessComponent>();
	}
};
static_assert(alignof(UActorTestHarnessComponent) == 0x000008, "Wrong alignment on UActorTestHarnessComponent");
static_assert(sizeof(UActorTestHarnessComponent) == 0x0000C0, "Wrong size on UActorTestHarnessComponent");
static_assert(offsetof(UActorTestHarnessComponent, SecondsBeforeSwitchingServer) == 0x0000A0, "Member 'UActorTestHarnessComponent::SecondsBeforeSwitchingServer' has a wrong offset!");
static_assert(offsetof(UActorTestHarnessComponent, bIsLoadTestClient) == 0x0000A4, "Member 'UActorTestHarnessComponent::bIsLoadTestClient' has a wrong offset!");
static_assert(offsetof(UActorTestHarnessComponent, bFPSChartEnabled) == 0x0000A5, "Member 'UActorTestHarnessComponent::bFPSChartEnabled' has a wrong offset!");
static_assert(offsetof(UActorTestHarnessComponent, LoadTestBotID) == 0x0000A8, "Member 'UActorTestHarnessComponent::LoadTestBotID' has a wrong offset!");
static_assert(offsetof(UActorTestHarnessComponent, CurrentTestCase) == 0x0000B0, "Member 'UActorTestHarnessComponent::CurrentTestCase' has a wrong offset!");

// Class Palia.PlayerCraftingHistoryComponent
// 0x0070 (0x0110 - 0x00A0)
class UPlayerCraftingHistoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_23B2[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCraftingHistoryPersistBlock           CraftingHistoryPersistBlock;                       // 0x00A8(0x0058)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B3[0x10];                                    // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasRecipeBeenCraftedBefore(int32 RecipeConfigId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCraftingHistoryComponent">();
	}
	static class UPlayerCraftingHistoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCraftingHistoryComponent>();
	}
};
static_assert(alignof(UPlayerCraftingHistoryComponent) == 0x000008, "Wrong alignment on UPlayerCraftingHistoryComponent");
static_assert(sizeof(UPlayerCraftingHistoryComponent) == 0x000110, "Wrong size on UPlayerCraftingHistoryComponent");
static_assert(offsetof(UPlayerCraftingHistoryComponent, CraftingHistoryPersistBlock) == 0x0000A8, "Member 'UPlayerCraftingHistoryComponent::CraftingHistoryPersistBlock' has a wrong offset!");

// Class Palia.ActorWithGAS
// 0x0018 (0x02C0 - 0x02A8)
class AActorWithGAS final : public AActor
{
public:
	uint8                                         Pad_23B5[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UValeriaGASComponent*                   ValeriaGAS;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UValeriaGASAttributeSet*                AttributeSet;                                      // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorWithGAS">();
	}
	static class AActorWithGAS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorWithGAS>();
	}
};
static_assert(alignof(AActorWithGAS) == 0x000008, "Wrong alignment on AActorWithGAS");
static_assert(sizeof(AActorWithGAS) == 0x0002C0, "Wrong size on AActorWithGAS");
static_assert(offsetof(AActorWithGAS, ValeriaGAS) == 0x0002B0, "Member 'AActorWithGAS::ValeriaGAS' has a wrong offset!");
static_assert(offsetof(AActorWithGAS, AttributeSet) == 0x0002B8, "Member 'AActorWithGAS::AttributeSet' has a wrong offset!");

// Class Palia.GearConfig
// 0x00B8 (0x00E8 - 0x0030)
class UGearConfig final : public UDataAsset
{
public:
	class UGearSlotTypeConfig*                    GearSlotTypeConfig;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectToApplyOnEquip;                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGearAssetToLoad>               AssetsToLoadOnEquip;                               // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsGrantedOnEquip;                                // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsGrantedOnRemove;                               // 0x0090(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EquipView;                                         // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    VillagerCore;                                      // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GearConfig">();
	}
	static class UGearConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGearConfig>();
	}
};
static_assert(alignof(UGearConfig) == 0x000008, "Wrong alignment on UGearConfig");
static_assert(sizeof(UGearConfig) == 0x0000E8, "Wrong size on UGearConfig");
static_assert(offsetof(UGearConfig, GearSlotTypeConfig) == 0x000030, "Member 'UGearConfig::GearSlotTypeConfig' has a wrong offset!");
static_assert(offsetof(UGearConfig, GameplayEffectToApplyOnEquip) == 0x000038, "Member 'UGearConfig::GameplayEffectToApplyOnEquip' has a wrong offset!");
static_assert(offsetof(UGearConfig, AssetsToLoadOnEquip) == 0x000040, "Member 'UGearConfig::AssetsToLoadOnEquip' has a wrong offset!");
static_assert(offsetof(UGearConfig, GameplayTags) == 0x000050, "Member 'UGearConfig::GameplayTags' has a wrong offset!");
static_assert(offsetof(UGearConfig, TagsGrantedOnEquip) == 0x000070, "Member 'UGearConfig::TagsGrantedOnEquip' has a wrong offset!");
static_assert(offsetof(UGearConfig, TagsGrantedOnRemove) == 0x000090, "Member 'UGearConfig::TagsGrantedOnRemove' has a wrong offset!");
static_assert(offsetof(UGearConfig, EquipView) == 0x0000B0, "Member 'UGearConfig::EquipView' has a wrong offset!");
static_assert(offsetof(UGearConfig, VillagerCore) == 0x0000D8, "Member 'UGearConfig::VillagerCore' has a wrong offset!");

// Class Palia.ValeriaGameSession
// 0x0198 (0x0458 - 0x02C0)
class AValeriaGameSession final : public AGameSession
{
public:
	uint8                                         Pad_23B6[0xC0];                                    // 0x02C0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class AOnlineBeaconHost*                      BeaconHost;                                        // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOSSVAL_BeaconHostObject*               BeaconHostObject;                                  // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B7[0x68];                                    // 0x0390(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UAgonesComponent*                       AgonesComponent;                                   // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B8[0x8];                                     // 0x0400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_ServerReserveRequestAsyncStream*   ServerAllocatedRequestAsyncStream;                 // 0x0408(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_ServerRegistrationRequestAsyncStream* ServerRegistrationRequestAsyncStream;              // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_ServerKickAllAsyncStream*          ServerKickAllAsyncStream;                          // 0x0418(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_ServerMaintenanceCancelledAsyncStream* ServerMaintenanceCancelledAsyncStream;             // 0x0420(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_ServerMaintenanceScheduledAsyncStream* ServerMaintenanceScheduledAsyncStream;             // 0x0428(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B9[0x18];                                    // 0x0430(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVAL_ServerMaintenanceData             MaintenanceData;                                   // 0x0448(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void HandleAgonesAllocatedFailed(struct FAgonesError& Error);
	void HandleAgonesAllocatedSucceeded(struct FEmptyResponse& Response);
	void HandleAgonesReadyFailed(struct FAgonesError& Error);
	void HandleAgonesReadySucceeded(struct FEmptyResponse& Response);
	void HandleAgonesReservedFailed(struct FAgonesError& Error);
	void HandleAgonesReservedSucceeded(struct FEmptyResponse& Response);
	void HandleMqttConnect(bool bSuccess);
	void HandleOnAgonesConnectionFailed(struct FAgonesError& Error);
	void HandleOnAgonesConnectionSucceeded(struct FGameServerResponse& Response);
	void HandleOnPlayerCharacterLoaded(struct FGuid& CharacterId, struct FUniqueNetIdRepl& NetId);
	void HandleOnServerAuthTokenReady();
	void HandleOnServerSpaceRegistered(struct FVAL_ServerSpace& ServerSpace);
	void HandleOnServerSpaceUnregistered(struct FVAL_ServerSpace& ServerSpace);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGameSession">();
	}
	static class AValeriaGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaGameSession>();
	}
};
static_assert(alignof(AValeriaGameSession) == 0x000008, "Wrong alignment on AValeriaGameSession");
static_assert(sizeof(AValeriaGameSession) == 0x000458, "Wrong size on AValeriaGameSession");
static_assert(offsetof(AValeriaGameSession, BeaconHost) == 0x000380, "Member 'AValeriaGameSession::BeaconHost' has a wrong offset!");
static_assert(offsetof(AValeriaGameSession, BeaconHostObject) == 0x000388, "Member 'AValeriaGameSession::BeaconHostObject' has a wrong offset!");
static_assert(offsetof(AValeriaGameSession, AgonesComponent) == 0x0003F8, "Member 'AValeriaGameSession::AgonesComponent' has a wrong offset!");
static_assert(offsetof(AValeriaGameSession, ServerAllocatedRequestAsyncStream) == 0x000408, "Member 'AValeriaGameSession::ServerAllocatedRequestAsyncStream' has a wrong offset!");
static_assert(offsetof(AValeriaGameSession, ServerRegistrationRequestAsyncStream) == 0x000410, "Member 'AValeriaGameSession::ServerRegistrationRequestAsyncStream' has a wrong offset!");
static_assert(offsetof(AValeriaGameSession, ServerKickAllAsyncStream) == 0x000418, "Member 'AValeriaGameSession::ServerKickAllAsyncStream' has a wrong offset!");
static_assert(offsetof(AValeriaGameSession, ServerMaintenanceCancelledAsyncStream) == 0x000420, "Member 'AValeriaGameSession::ServerMaintenanceCancelledAsyncStream' has a wrong offset!");
static_assert(offsetof(AValeriaGameSession, ServerMaintenanceScheduledAsyncStream) == 0x000428, "Member 'AValeriaGameSession::ServerMaintenanceScheduledAsyncStream' has a wrong offset!");
static_assert(offsetof(AValeriaGameSession, MaintenanceData) == 0x000448, "Member 'AValeriaGameSession::MaintenanceData' has a wrong offset!");

// Class Palia.VAL_BundleShrineConfigAsset
// 0x00B8 (0x0110 - 0x0058)
class UVAL_BundleShrineConfigAsset final : public UVAL_DataAsset
{
public:
	int32                                         OldBundleConfigId;                                 // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23BA[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BundleName;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0070(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   BundleCompleteDesc;                                // 0x0088(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BundleImage;                                       // 0x00A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      BundleIconPositions;                               // 0x00C8(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSubBundleNavExplicitData>      BundleExplicitData;                                // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuestRewardConfig>             BundleRewards;                                     // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSubBundleShrineConfig>         SubBundles;                                        // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowBundleComplete;                               // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSubBundleComplete;                            // 0x0109(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBundleTutorial;                               // 0x010A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23BB[0x5];                                     // 0x010B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TSoftObjectPtr<class UVAL_BundleShrineConfigAsset> GetAssetByName_Cast(class FName& AssetName);
	static TSoftObjectPtr<class UVAL_BundleShrineConfigAsset> GetAssetByPersistId_Cast(int32 PersistIdToGet);
	static TArray<TSoftObjectPtr<class UVAL_BundleShrineConfigAsset>> GetAssetsOfType_Cast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_BundleShrineConfigAsset">();
	}
	static class UVAL_BundleShrineConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_BundleShrineConfigAsset>();
	}
};
static_assert(alignof(UVAL_BundleShrineConfigAsset) == 0x000008, "Wrong alignment on UVAL_BundleShrineConfigAsset");
static_assert(sizeof(UVAL_BundleShrineConfigAsset) == 0x000110, "Wrong size on UVAL_BundleShrineConfigAsset");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, OldBundleConfigId) == 0x000058, "Member 'UVAL_BundleShrineConfigAsset::OldBundleConfigId' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, BundleName) == 0x000060, "Member 'UVAL_BundleShrineConfigAsset::BundleName' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, DisplayName) == 0x000070, "Member 'UVAL_BundleShrineConfigAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, BundleCompleteDesc) == 0x000088, "Member 'UVAL_BundleShrineConfigAsset::BundleCompleteDesc' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, BundleImage) == 0x0000A0, "Member 'UVAL_BundleShrineConfigAsset::BundleImage' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, BundleIconPositions) == 0x0000C8, "Member 'UVAL_BundleShrineConfigAsset::BundleIconPositions' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, BundleExplicitData) == 0x0000D8, "Member 'UVAL_BundleShrineConfigAsset::BundleExplicitData' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, BundleRewards) == 0x0000E8, "Member 'UVAL_BundleShrineConfigAsset::BundleRewards' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, SubBundles) == 0x0000F8, "Member 'UVAL_BundleShrineConfigAsset::SubBundles' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, bShowBundleComplete) == 0x000108, "Member 'UVAL_BundleShrineConfigAsset::bShowBundleComplete' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, bShowSubBundleComplete) == 0x000109, "Member 'UVAL_BundleShrineConfigAsset::bShowSubBundleComplete' has a wrong offset!");
static_assert(offsetof(UVAL_BundleShrineConfigAsset, bShowBundleTutorial) == 0x00010A, "Member 'UVAL_BundleShrineConfigAsset::bShowBundleTutorial' has a wrong offset!");

// Class Palia.VillagerMasterScheduleConfig
// 0x0050 (0x0080 - 0x0030)
class UVillagerMasterScheduleConfig final : public UDataAsset
{
public:
	TMap<TSoftObjectPtr<class UWorld>, TSoftObjectPtr<class UVillagerWeeklyScheduleConfig>> WeeklySchedulesPerMap;                             // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	bool GetBestScheduleActivity(class UObject* Context, const class FString& LevelName, struct FVillagerScheduleActivity* OutBestScheduleActivity) const;
	bool GetBestWorldForCurrentActivity(class UObject* Context, TSoftObjectPtr<class UWorld>* OutBestWorld) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerMasterScheduleConfig">();
	}
	static class UVillagerMasterScheduleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerMasterScheduleConfig>();
	}
};
static_assert(alignof(UVillagerMasterScheduleConfig) == 0x000008, "Wrong alignment on UVillagerMasterScheduleConfig");
static_assert(sizeof(UVillagerMasterScheduleConfig) == 0x000080, "Wrong size on UVillagerMasterScheduleConfig");
static_assert(offsetof(UVillagerMasterScheduleConfig, WeeklySchedulesPerMap) == 0x000030, "Member 'UVillagerMasterScheduleConfig::WeeklySchedulesPerMap' has a wrong offset!");

// Class Palia.AICombatStateComponent
// 0x0130 (0x01D0 - 0x00A0)
class UAICombatStateComponent final : public UActorComponent
{
public:
	class AActor*                                 HighestThreatReplicatedToClient;                   // 0x00A0(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCombatEnabled;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23BF[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharacterAddedAsThreat;                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FAIBehaviourRanges                     BehaviourRanges;                                   // 0x00C0(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      Speeds;                                            // 0x0100(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         InitialThreatLevel;                                // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseOldThreatSystem;                                // 0x0154(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C0[0x3];                                     // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAbilityId;                                      // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LockedInAbilityUntil;                              // 0x015C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTreeComponent*                 BTComp;                                            // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVitalsComponent*                       Vitals;                                            // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastBlockedDamageAt;                               // 0x0170(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInCombat;                                       // 0x0174(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C1[0x3];                                     // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIThreatList                          ThreatList;                                        // 0x0178(0x0050)(NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TickThreatListTimerHandle;                         // 0x01C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool ActivateAbility(int32 AbilityId);
	void AddCharacterToThreatList(class AValeriaCharacter* Character, bool SendToTopOfThreatList);
	void AddThreat(class AActor* Actor, int32 Threat);
	void DeactivateAbilitiesOutOfRange(class AActor* Target);
	int32 FindBestAbility(class AActor* Target, EValeriaFuncResult* OutResult);
	class AActor* FindTarget();
	void Multicast_DrawMeleeAttackFeedback(class FName SocketName, float Radius);
	void OverwriteThreatList(const struct FAIThreatList& NewThreatList);
	void Server_DrawMeleeAttackFeedback(class FName SocketName, float Radius);
	void SetIsInCombat(bool IsInCombat);
	void SetThreat(class AActor* Actor, int32 Threat);
	void TickThreatList();
	void WasDamaged(class UVitalsComponent* VitalsComp, const struct FVitalsChange& Change);
	void WipeThreatList();

	bool CanMoveDuringAbility() const;
	float GetAwarenessRadius() const;
	struct FAIBehaviourRanges GetBehaviourRanges() const;
	class AActor* GetClosestThreat() const;
	class FString GetDebugString() const;
	class AActor* GetHighestThreatReplicatedToClient() const;
	float GetSpeed(class FName Key) const;
	int32 GetThreatCount() const;
	const struct FAIThreatList GetThreatList() const;
	bool IsAbilityActive(int32 AbilityId) const;
	bool IsInCombat() const;
	bool IsOnThreatList(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICombatStateComponent">();
	}
	static class UAICombatStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICombatStateComponent>();
	}
};
static_assert(alignof(UAICombatStateComponent) == 0x000008, "Wrong alignment on UAICombatStateComponent");
static_assert(sizeof(UAICombatStateComponent) == 0x0001D0, "Wrong size on UAICombatStateComponent");
static_assert(offsetof(UAICombatStateComponent, HighestThreatReplicatedToClient) == 0x0000A0, "Member 'UAICombatStateComponent::HighestThreatReplicatedToClient' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, IsCombatEnabled) == 0x0000A8, "Member 'UAICombatStateComponent::IsCombatEnabled' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, OnCharacterAddedAsThreat) == 0x0000B0, "Member 'UAICombatStateComponent::OnCharacterAddedAsThreat' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, BehaviourRanges) == 0x0000C0, "Member 'UAICombatStateComponent::BehaviourRanges' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, Speeds) == 0x000100, "Member 'UAICombatStateComponent::Speeds' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, InitialThreatLevel) == 0x000150, "Member 'UAICombatStateComponent::InitialThreatLevel' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, UseOldThreatSystem) == 0x000154, "Member 'UAICombatStateComponent::UseOldThreatSystem' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, MaxAbilityId) == 0x000158, "Member 'UAICombatStateComponent::MaxAbilityId' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, LockedInAbilityUntil) == 0x00015C, "Member 'UAICombatStateComponent::LockedInAbilityUntil' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, BTComp) == 0x000160, "Member 'UAICombatStateComponent::BTComp' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, Vitals) == 0x000168, "Member 'UAICombatStateComponent::Vitals' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, LastBlockedDamageAt) == 0x000170, "Member 'UAICombatStateComponent::LastBlockedDamageAt' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, bIsInCombat) == 0x000174, "Member 'UAICombatStateComponent::bIsInCombat' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, ThreatList) == 0x000178, "Member 'UAICombatStateComponent::ThreatList' has a wrong offset!");
static_assert(offsetof(UAICombatStateComponent, TickThreatListTimerHandle) == 0x0001C8, "Member 'UAICombatStateComponent::TickThreatListTimerHandle' has a wrong offset!");

// Class Palia.ChallengeConfig
// 0x0128 (0x0170 - 0x0048)
class UChallengeConfig final : public UGuidDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLootRequirements                      Requirements;                                      // 0x0078(0x00D8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FVillagerQuestRequirement>      Goals;                                             // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuestRewardConfig>             Rewards;                                           // 0x0160(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeConfig">();
	}
	static class UChallengeConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeConfig>();
	}
};
static_assert(alignof(UChallengeConfig) == 0x000008, "Wrong alignment on UChallengeConfig");
static_assert(sizeof(UChallengeConfig) == 0x000170, "Wrong size on UChallengeConfig");
static_assert(offsetof(UChallengeConfig, DisplayName) == 0x000048, "Member 'UChallengeConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(UChallengeConfig, DisplayText) == 0x000060, "Member 'UChallengeConfig::DisplayText' has a wrong offset!");
static_assert(offsetof(UChallengeConfig, Requirements) == 0x000078, "Member 'UChallengeConfig::Requirements' has a wrong offset!");
static_assert(offsetof(UChallengeConfig, Goals) == 0x000150, "Member 'UChallengeConfig::Goals' has a wrong offset!");
static_assert(offsetof(UChallengeConfig, Rewards) == 0x000160, "Member 'UChallengeConfig::Rewards' has a wrong offset!");

// Class Palia.FishMinigameConfig
// 0x0268 (0x0298 - 0x0030)
class UFishMinigameConfig final : public UPrimaryDataAsset
{
public:
	struct FDataTableRowHandle                    SkillXpEarnings;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FishBlueprint;                                     // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> ItemType;                                          // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFishMinigameBehaviorConfig> Behavior;                                          // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuestRewardConfig                     Reward;                                            // 0x00B8(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRotator                               CelebrationRotationOffset;                         // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         DifficultyLevel;                                   // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldStruggle;                                   // 0x024C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C9[0x3];                                     // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            BiteWaitTime;                                      // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            BiteReelReactionTime;                              // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            BiteReelReactionTime_StarQuality;                  // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayArea;                                          // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagePerSecond;                                   // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagePerSecondMultiplier_StarQuality;             // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagePerSecond_OnHold;                            // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagePerSecondMultiplier_OnHold_StarQuality;      // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CA[0x4];                                     // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishMinigameConfig">();
	}
	static class UFishMinigameConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishMinigameConfig>();
	}
};
static_assert(alignof(UFishMinigameConfig) == 0x000008, "Wrong alignment on UFishMinigameConfig");
static_assert(sizeof(UFishMinigameConfig) == 0x000298, "Wrong size on UFishMinigameConfig");
static_assert(offsetof(UFishMinigameConfig, SkillXpEarnings) == 0x000030, "Member 'UFishMinigameConfig::SkillXpEarnings' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, FishBlueprint) == 0x000040, "Member 'UFishMinigameConfig::FishBlueprint' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, ItemType) == 0x000068, "Member 'UFishMinigameConfig::ItemType' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, Behavior) == 0x000090, "Member 'UFishMinigameConfig::Behavior' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, Reward) == 0x0000B8, "Member 'UFishMinigameConfig::Reward' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, CelebrationRotationOffset) == 0x000230, "Member 'UFishMinigameConfig::CelebrationRotationOffset' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, DifficultyLevel) == 0x000248, "Member 'UFishMinigameConfig::DifficultyLevel' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, bShouldStruggle) == 0x00024C, "Member 'UFishMinigameConfig::bShouldStruggle' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, BiteWaitTime) == 0x000250, "Member 'UFishMinigameConfig::BiteWaitTime' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, BiteReelReactionTime) == 0x000260, "Member 'UFishMinigameConfig::BiteReelReactionTime' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, BiteReelReactionTime_StarQuality) == 0x000270, "Member 'UFishMinigameConfig::BiteReelReactionTime_StarQuality' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, PlayArea) == 0x000280, "Member 'UFishMinigameConfig::PlayArea' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, DamagePerSecond) == 0x000284, "Member 'UFishMinigameConfig::DamagePerSecond' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, DamagePerSecondMultiplier_StarQuality) == 0x000288, "Member 'UFishMinigameConfig::DamagePerSecondMultiplier_StarQuality' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, DamagePerSecond_OnHold) == 0x00028C, "Member 'UFishMinigameConfig::DamagePerSecond_OnHold' has a wrong offset!");
static_assert(offsetof(UFishMinigameConfig, DamagePerSecondMultiplier_OnHold_StarQuality) == 0x000290, "Member 'UFishMinigameConfig::DamagePerSecondMultiplier_OnHold_StarQuality' has a wrong offset!");

// Class Palia.AimingComponent
// 0x00A0 (0x0140 - 0x00A0)
class UAimingComponent final : public UActorComponent
{
public:
	bool                                          NeedsToReload;                                     // 0x00A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CB[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BeginCurve;                                        // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeginAimDuration;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomedInBoomDistance;                              // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EndCurve;                                          // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAimDuration;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomedOutBoomDistance;                             // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoomedInTargetOffset;                              // 0x00C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoomedInSocketOffset;                              // 0x00E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoomedOutTargetOffset;                             // 0x00F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoomedOutSocketOffset;                             // 0x0110(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimingState                                  CurrentState;                                      // 0x0128(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAimingAnimationAimOffset                     CurrentAnimationAimOffsetToUse;                    // 0x0129(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23CC[0xE];                                     // 0x012A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    CameraBoom;                                        // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	EAimingState GetAimingState();
	void NotifyBeginAiming();
	void NotifyEndAiming();
	void QueueUpWeaponFire();
	void RemoveQueuedUpWeaponFire();
	void SetAimingState(EAimingState NewState, EAimingAnimationAimOffset Offset);

	float GetAimPitchDirection() const;
	EAimingAnimationAimOffset GetAnimationAimOffsetToUse() const;
	bool HasQueuedUpWeaponFire() const;
	bool IsAiming() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimingComponent">();
	}
	static class UAimingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimingComponent>();
	}
};
static_assert(alignof(UAimingComponent) == 0x000008, "Wrong alignment on UAimingComponent");
static_assert(sizeof(UAimingComponent) == 0x000140, "Wrong size on UAimingComponent");
static_assert(offsetof(UAimingComponent, NeedsToReload) == 0x0000A0, "Member 'UAimingComponent::NeedsToReload' has a wrong offset!");
static_assert(offsetof(UAimingComponent, BeginCurve) == 0x0000A8, "Member 'UAimingComponent::BeginCurve' has a wrong offset!");
static_assert(offsetof(UAimingComponent, BeginAimDuration) == 0x0000B0, "Member 'UAimingComponent::BeginAimDuration' has a wrong offset!");
static_assert(offsetof(UAimingComponent, ZoomedInBoomDistance) == 0x0000B4, "Member 'UAimingComponent::ZoomedInBoomDistance' has a wrong offset!");
static_assert(offsetof(UAimingComponent, EndCurve) == 0x0000B8, "Member 'UAimingComponent::EndCurve' has a wrong offset!");
static_assert(offsetof(UAimingComponent, EndAimDuration) == 0x0000C0, "Member 'UAimingComponent::EndAimDuration' has a wrong offset!");
static_assert(offsetof(UAimingComponent, ZoomedOutBoomDistance) == 0x0000C4, "Member 'UAimingComponent::ZoomedOutBoomDistance' has a wrong offset!");
static_assert(offsetof(UAimingComponent, ZoomedInTargetOffset) == 0x0000C8, "Member 'UAimingComponent::ZoomedInTargetOffset' has a wrong offset!");
static_assert(offsetof(UAimingComponent, ZoomedInSocketOffset) == 0x0000E0, "Member 'UAimingComponent::ZoomedInSocketOffset' has a wrong offset!");
static_assert(offsetof(UAimingComponent, ZoomedOutTargetOffset) == 0x0000F8, "Member 'UAimingComponent::ZoomedOutTargetOffset' has a wrong offset!");
static_assert(offsetof(UAimingComponent, ZoomedOutSocketOffset) == 0x000110, "Member 'UAimingComponent::ZoomedOutSocketOffset' has a wrong offset!");
static_assert(offsetof(UAimingComponent, CurrentState) == 0x000128, "Member 'UAimingComponent::CurrentState' has a wrong offset!");
static_assert(offsetof(UAimingComponent, CurrentAnimationAimOffsetToUse) == 0x000129, "Member 'UAimingComponent::CurrentAnimationAimOffsetToUse' has a wrong offset!");
static_assert(offsetof(UAimingComponent, CameraBoom) == 0x000138, "Member 'UAimingComponent::CameraBoom' has a wrong offset!");

// Class Palia.VillagerDialogueGlobalConfig
// 0x0070 (0x00A0 - 0x0030)
class UVillagerDialogueGlobalConfig final : public UDataAsset
{
public:
	float                                         VeryFastCharacterScrollInterval;                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastCharacterScrollInterval;                       // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediumCharacterScrollInterval;                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowCharacterScrollInterval;                       // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerySlowCharacterScrollInterval;                   // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallbackMultiCharacterSpacing;                     // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMultiCharacterRotation;                         // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CD[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            MultiCharacterSpacing;                             // 0x0050(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerDialogueGlobalConfig">();
	}
	static class UVillagerDialogueGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerDialogueGlobalConfig>();
	}
};
static_assert(alignof(UVillagerDialogueGlobalConfig) == 0x000008, "Wrong alignment on UVillagerDialogueGlobalConfig");
static_assert(sizeof(UVillagerDialogueGlobalConfig) == 0x0000A0, "Wrong size on UVillagerDialogueGlobalConfig");
static_assert(offsetof(UVillagerDialogueGlobalConfig, VeryFastCharacterScrollInterval) == 0x000030, "Member 'UVillagerDialogueGlobalConfig::VeryFastCharacterScrollInterval' has a wrong offset!");
static_assert(offsetof(UVillagerDialogueGlobalConfig, FastCharacterScrollInterval) == 0x000034, "Member 'UVillagerDialogueGlobalConfig::FastCharacterScrollInterval' has a wrong offset!");
static_assert(offsetof(UVillagerDialogueGlobalConfig, MediumCharacterScrollInterval) == 0x000038, "Member 'UVillagerDialogueGlobalConfig::MediumCharacterScrollInterval' has a wrong offset!");
static_assert(offsetof(UVillagerDialogueGlobalConfig, SlowCharacterScrollInterval) == 0x00003C, "Member 'UVillagerDialogueGlobalConfig::SlowCharacterScrollInterval' has a wrong offset!");
static_assert(offsetof(UVillagerDialogueGlobalConfig, VerySlowCharacterScrollInterval) == 0x000040, "Member 'UVillagerDialogueGlobalConfig::VerySlowCharacterScrollInterval' has a wrong offset!");
static_assert(offsetof(UVillagerDialogueGlobalConfig, FallbackMultiCharacterSpacing) == 0x000044, "Member 'UVillagerDialogueGlobalConfig::FallbackMultiCharacterSpacing' has a wrong offset!");
static_assert(offsetof(UVillagerDialogueGlobalConfig, MaxMultiCharacterRotation) == 0x000048, "Member 'UVillagerDialogueGlobalConfig::MaxMultiCharacterRotation' has a wrong offset!");
static_assert(offsetof(UVillagerDialogueGlobalConfig, MultiCharacterSpacing) == 0x000050, "Member 'UVillagerDialogueGlobalConfig::MultiCharacterSpacing' has a wrong offset!");

// Class Palia.AISenseConfig_ValeriaHearing
// 0x0028 (0x0070 - 0x0048)
class UAISenseConfig_ValeriaHearing final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_ValeriaHearing>    Implementation;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultHearingRange;                               // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRangeForQuietActions;                       // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRangeForNormalActions;                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRangeForLoudActions;                        // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRangeForStealthedActions;                   // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StealthMask;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CE[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_ValeriaHearing">();
	}
	static class UAISenseConfig_ValeriaHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_ValeriaHearing>();
	}
};
static_assert(alignof(UAISenseConfig_ValeriaHearing) == 0x000008, "Wrong alignment on UAISenseConfig_ValeriaHearing");
static_assert(sizeof(UAISenseConfig_ValeriaHearing) == 0x000070, "Wrong size on UAISenseConfig_ValeriaHearing");
static_assert(offsetof(UAISenseConfig_ValeriaHearing, Implementation) == 0x000048, "Member 'UAISenseConfig_ValeriaHearing::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_ValeriaHearing, DefaultHearingRange) == 0x000050, "Member 'UAISenseConfig_ValeriaHearing::DefaultHearingRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_ValeriaHearing, HearingRangeForQuietActions) == 0x000054, "Member 'UAISenseConfig_ValeriaHearing::HearingRangeForQuietActions' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_ValeriaHearing, HearingRangeForNormalActions) == 0x000058, "Member 'UAISenseConfig_ValeriaHearing::HearingRangeForNormalActions' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_ValeriaHearing, HearingRangeForLoudActions) == 0x00005C, "Member 'UAISenseConfig_ValeriaHearing::HearingRangeForLoudActions' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_ValeriaHearing, HearingRangeForStealthedActions) == 0x000060, "Member 'UAISenseConfig_ValeriaHearing::HearingRangeForStealthedActions' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_ValeriaHearing, StealthMask) == 0x000064, "Member 'UAISenseConfig_ValeriaHearing::StealthMask' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_ValeriaHearing, DetectionByAffiliation) == 0x000068, "Member 'UAISenseConfig_ValeriaHearing::DetectionByAffiliation' has a wrong offset!");

// Class Palia.AISenseEvent_ValeriaHearing
// 0x0040 (0x0068 - 0x0028)
class UAISenseEvent_ValeriaHearing final : public UAISenseEvent
{
public:
	struct FAIValeriaNoiseEvent                   Event;                                             // 0x0028(0x0040)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_ValeriaHearing">();
	}
	static class UAISenseEvent_ValeriaHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_ValeriaHearing>();
	}
};
static_assert(alignof(UAISenseEvent_ValeriaHearing) == 0x000008, "Wrong alignment on UAISenseEvent_ValeriaHearing");
static_assert(sizeof(UAISenseEvent_ValeriaHearing) == 0x000068, "Wrong size on UAISenseEvent_ValeriaHearing");
static_assert(offsetof(UAISenseEvent_ValeriaHearing, Event) == 0x000028, "Member 'UAISenseEvent_ValeriaHearing::Event' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_ItemAbstract
// 0x0078 (0x01E0 - 0x0168)
class UVAL_GameplayEvent_ItemAbstract : public UVAL_GameplayEvent
{
public:
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> Item;                                              // 0x0168(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      TagQuery;                                          // 0x0190(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         QualityStars;                                      // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   MinimumRarity;                                     // 0x01DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CF[0x3];                                     // 0x01DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_ItemAbstract">();
	}
	static class UVAL_GameplayEvent_ItemAbstract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_ItemAbstract>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_ItemAbstract) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_ItemAbstract");
static_assert(sizeof(UVAL_GameplayEvent_ItemAbstract) == 0x0001E0, "Wrong size on UVAL_GameplayEvent_ItemAbstract");
static_assert(offsetof(UVAL_GameplayEvent_ItemAbstract, Item) == 0x000168, "Member 'UVAL_GameplayEvent_ItemAbstract::Item' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_ItemAbstract, TagQuery) == 0x000190, "Member 'UVAL_GameplayEvent_ItemAbstract::TagQuery' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_ItemAbstract, QualityStars) == 0x0001D8, "Member 'UVAL_GameplayEvent_ItemAbstract::QualityStars' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_ItemAbstract, MinimumRarity) == 0x0001DC, "Member 'UVAL_GameplayEvent_ItemAbstract::MinimumRarity' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_GiftItem
// 0x0020 (0x0200 - 0x01E0)
class UVAL_GameplayEvent_GiftItem final : public UVAL_GameplayEvent_ItemAbstract
{
public:
	EVillagerGiftRewardLevel                      RewardLevel;                                       // 0x01E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactOnly;                                        // 0x01E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D0[0x6];                                     // 0x01E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    Villager;                                          // 0x01E8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   VillagerName;                                      // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_GiftItem">();
	}
	static class UVAL_GameplayEvent_GiftItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_GiftItem>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_GiftItem) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_GiftItem");
static_assert(sizeof(UVAL_GameplayEvent_GiftItem) == 0x000200, "Wrong size on UVAL_GameplayEvent_GiftItem");
static_assert(offsetof(UVAL_GameplayEvent_GiftItem, RewardLevel) == 0x0001E0, "Member 'UVAL_GameplayEvent_GiftItem::RewardLevel' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_GiftItem, bExactOnly) == 0x0001E1, "Member 'UVAL_GameplayEvent_GiftItem::bExactOnly' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_GiftItem, Villager) == 0x0001E8, "Member 'UVAL_GameplayEvent_GiftItem::Villager' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_GiftItem, VillagerName) == 0x0001F8, "Member 'UVAL_GameplayEvent_GiftItem::VillagerName' has a wrong offset!");

// Class Palia.AISense_ValeriaHearing
// 0x0060 (0x00D8 - 0x0078)
class UAISense_ValeriaHearing final : public UAISense
{
public:
	TArray<struct FAIValeriaNoiseEvent>           NoiseEvents;                                       // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_23D1[0x50];                                    // 0x0088(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportValeriaNoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, class AActor* Instigator, EValeriaNoiseEventVolume Volume, int32 StealthMask, class FName Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_ValeriaHearing">();
	}
	static class UAISense_ValeriaHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_ValeriaHearing>();
	}
};
static_assert(alignof(UAISense_ValeriaHearing) == 0x000008, "Wrong alignment on UAISense_ValeriaHearing");
static_assert(sizeof(UAISense_ValeriaHearing) == 0x0000D8, "Wrong size on UAISense_ValeriaHearing");
static_assert(offsetof(UAISense_ValeriaHearing, NoiseEvents) == 0x000078, "Member 'UAISense_ValeriaHearing::NoiseEvents' has a wrong offset!");

// Class Palia.QueryManager
// 0x0228 (0x0258 - 0x0030)
class UQueryManager final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnServerSpaceRegistered;                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerSpaceUnregistered;                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<EVAL_ServerSpaceType, struct FVAL_ServerSpaceContainer> ServerSpaces;                                      // 0x0050(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FTargetPointArray>   TargetPoints;                                      // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class AHousingPlotActor*>              HousingPlots;                                      // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class UTeleportTravelConfigAsset*, class UTeleportDestinationComponent*> LocalDestinationRegistry;                          // 0x0100(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FPrivateSpaceDestination>       PSDestinationRegistry;                             // 0x0150(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<struct FSessionActorId, struct FSessionActorRecord> SessionIdToActor;                                  // 0x0160(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FSessionActorId>   ActorToSessionId;                                  // 0x01B0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_23D3[0x58];                                    // 0x0200(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FreeHousingPlotActor(class AHousingPlotActor* HousingPlot);
	void OnServerSpaceRegistered__DelegateSignature(struct FVAL_ServerSpace& ServerSpace);
	void OnServerSpaceUnregistered__DelegateSignature(struct FVAL_ServerSpace& ServerSpace);
	class AHousingPlotActor* SpawnNewHousingPlotActor(class AActor* Requestor);

	class AHousingPlotActor* FindAvailableHousingPlotActorByName(class AValeriaCharacter* Character, const class FString& Param_Name) const;
	class AValeriaTargetPoint* FindClosestTargetPoint(class FName Tag, const struct FVector& Position) const;
	class AHousingPlotActor* FindHousingPlotByActorName(const class FString& ActorName) const;
	class AHousingPlotActor* FindOccupiedHousingPlotByHousingId(struct FGuid& HousingId) const;
	class AHousingPlotActor* FindOccupiedHousingPlotByOwnerId(struct FGuid& OwnerId) const;
	struct FGuid FindPlayerGuidByName(const class FString& PlayerName) const;
	class AValeriaTargetPoint* FindRandomTargetPoint(class FName Tag) const;
	class AValeriaCharacter* FindValeriaCharacterByPlayerGuid(struct FGuid& PlayerGuid) const;
	class AHousingPlotActor* GetHousingPlotByHousingPlotSlot(int32 Slot) const;
	bool IsReadyToQueryForMapInfo() const;
	bool WorldSupportsLoadingHousingPlotActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QueryManager">();
	}
	static class UQueryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQueryManager>();
	}
};
static_assert(alignof(UQueryManager) == 0x000008, "Wrong alignment on UQueryManager");
static_assert(sizeof(UQueryManager) == 0x000258, "Wrong size on UQueryManager");
static_assert(offsetof(UQueryManager, OnServerSpaceRegistered) == 0x000030, "Member 'UQueryManager::OnServerSpaceRegistered' has a wrong offset!");
static_assert(offsetof(UQueryManager, OnServerSpaceUnregistered) == 0x000040, "Member 'UQueryManager::OnServerSpaceUnregistered' has a wrong offset!");
static_assert(offsetof(UQueryManager, ServerSpaces) == 0x000050, "Member 'UQueryManager::ServerSpaces' has a wrong offset!");
static_assert(offsetof(UQueryManager, TargetPoints) == 0x0000A0, "Member 'UQueryManager::TargetPoints' has a wrong offset!");
static_assert(offsetof(UQueryManager, HousingPlots) == 0x0000F0, "Member 'UQueryManager::HousingPlots' has a wrong offset!");
static_assert(offsetof(UQueryManager, LocalDestinationRegistry) == 0x000100, "Member 'UQueryManager::LocalDestinationRegistry' has a wrong offset!");
static_assert(offsetof(UQueryManager, PSDestinationRegistry) == 0x000150, "Member 'UQueryManager::PSDestinationRegistry' has a wrong offset!");
static_assert(offsetof(UQueryManager, SessionIdToActor) == 0x000160, "Member 'UQueryManager::SessionIdToActor' has a wrong offset!");
static_assert(offsetof(UQueryManager, ActorToSessionId) == 0x0001B0, "Member 'UQueryManager::ActorToSessionId' has a wrong offset!");

// Class Palia.CameraTargetActor
// 0x0010 (0x02B8 - 0x02A8)
class ACameraTargetActor final : public AActor
{
public:
	class USpringArmComponent*                    CameraBoom;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       FollowCamera;                                      // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraTargetActor">();
	}
	static class ACameraTargetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraTargetActor>();
	}
};
static_assert(alignof(ACameraTargetActor) == 0x000008, "Wrong alignment on ACameraTargetActor");
static_assert(sizeof(ACameraTargetActor) == 0x0002B8, "Wrong size on ACameraTargetActor");
static_assert(offsetof(ACameraTargetActor, CameraBoom) == 0x0002A8, "Member 'ACameraTargetActor::CameraBoom' has a wrong offset!");
static_assert(offsetof(ACameraTargetActor, FollowCamera) == 0x0002B0, "Member 'ACameraTargetActor::FollowCamera' has a wrong offset!");

// Class Palia.AkCulledComponent
// 0x0110 (0x03B0 - 0x02A0)
class UAkCulledComponent final : public USceneComponent
{
public:
	uint8                                         Pad_23D5[0x10];                                    // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkAudioEvent;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          CurrentlyPlayingEvent;                             // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionRefreshInterval;                          // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationScalingFactor;                          // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStart;                                        // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D6[0x3];                                     // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinUpdateTime;                                     // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxUpdateTime;                                     // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebounceDistance;                                  // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCullRadius;                               // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D7[0x3];                                     // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCullRadius;                                     // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCullRadiusSquared;                              // 0x02E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x02E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkComponent*                           AssociatedAkComponent;                             // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlaying;                                        // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAdditionalLoopingEvents;                       // 0x02F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D8[0x6];                                     // 0x02F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UAkAudioEvent*, struct FTrackedLoopEventIds> AdditionalLoopingEvents;                           // 0x02F8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          bHasTrackedRtpcs;                                  // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D9[0x7];                                     // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UAkRtpc*, float>                   TrackedRtpcs;                                      // 0x0350(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          bDisableOnConstrainedPlatforms;                    // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DA[0xF];                                     // 0x03A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PostAkEvent(class UAkAudioEvent* AkEvent);
	void PostAssociatedAkEvent();
	void RemoveAkComponent(int32 FadeDuration);
	void SetRtpc(class UAkRtpc* Rtpc, float Value, int32 InterpolationTimeMs);
	void SpawnAkComponent();
	void Stop(int32 FadeDuration);
	void StopAkEvent(class UAkAudioEvent* AkEvent, int32 FadeDuration);
	void Update();
	void UpdateCullRadius();

	float GetAttenuationRadius() const;
	float GetCullRadius() const;
	bool HasActiveEvents() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkCulledComponent">();
	}
	static class UAkCulledComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkCulledComponent>();
	}
};
static_assert(alignof(UAkCulledComponent) == 0x000010, "Wrong alignment on UAkCulledComponent");
static_assert(sizeof(UAkCulledComponent) == 0x0003B0, "Wrong size on UAkCulledComponent");
static_assert(offsetof(UAkCulledComponent, AkAudioEvent) == 0x0002B0, "Member 'UAkCulledComponent::AkAudioEvent' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, CurrentlyPlayingEvent) == 0x0002B8, "Member 'UAkCulledComponent::CurrentlyPlayingEvent' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, OcclusionRefreshInterval) == 0x0002C0, "Member 'UAkCulledComponent::OcclusionRefreshInterval' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, AttenuationScalingFactor) == 0x0002C4, "Member 'UAkCulledComponent::AttenuationScalingFactor' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, bAutoStart) == 0x0002C8, "Member 'UAkCulledComponent::bAutoStart' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, MinUpdateTime) == 0x0002CC, "Member 'UAkCulledComponent::MinUpdateTime' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, MaxUpdateTime) == 0x0002D0, "Member 'UAkCulledComponent::MaxUpdateTime' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, DebounceDistance) == 0x0002D4, "Member 'UAkCulledComponent::DebounceDistance' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, bOverrideCullRadius) == 0x0002D8, "Member 'UAkCulledComponent::bOverrideCullRadius' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, MaxCullRadius) == 0x0002DC, "Member 'UAkCulledComponent::MaxCullRadius' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, MaxCullRadiusSquared) == 0x0002E0, "Member 'UAkCulledComponent::MaxCullRadiusSquared' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, PlayingID) == 0x0002E4, "Member 'UAkCulledComponent::PlayingID' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, AssociatedAkComponent) == 0x0002E8, "Member 'UAkCulledComponent::AssociatedAkComponent' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, bIsPlaying) == 0x0002F0, "Member 'UAkCulledComponent::bIsPlaying' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, bHasAdditionalLoopingEvents) == 0x0002F1, "Member 'UAkCulledComponent::bHasAdditionalLoopingEvents' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, AdditionalLoopingEvents) == 0x0002F8, "Member 'UAkCulledComponent::AdditionalLoopingEvents' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, bHasTrackedRtpcs) == 0x000348, "Member 'UAkCulledComponent::bHasTrackedRtpcs' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, TrackedRtpcs) == 0x000350, "Member 'UAkCulledComponent::TrackedRtpcs' has a wrong offset!");
static_assert(offsetof(UAkCulledComponent, bDisableOnConstrainedPlatforms) == 0x0003A0, "Member 'UAkCulledComponent::bDisableOnConstrainedPlatforms' has a wrong offset!");

// Class Palia.RecipeInventoryComponent
// 0x0110 (0x01B0 - 0x00A0)
class URecipeInventoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_23DC[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnlocked;                                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DevOnly_OnLocked;                                  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<int32>                                 InspirationRecipeChoices;                          // 0x00D8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRecipeInventoryPersistBlock           RecipeInventoryPersistBlock;                       // 0x00E8(0x0060)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23DD[0x68];                                    // 0x0148(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAvailable(int32 RecipeConfigId, struct FRecipeLearnedFrom& Source);
	bool AddAvailable_Internal(int32 InRecipeConfigId, TArray<int32>* OutAdded, struct FRecipeLearnedFrom& Source);
	void Cheat_GiveRecipeIngredients(int32 RecipeConfigId, bool bGiveToAllPresentPlayers, bool bGiveStarQuality, int32 Multiplier);
	void OnLevelProgressed(ESkillType SkillType);
	void OnReplicatedAndShouldBroadcast();
	void OnValeriaCharacterChanged(class AValeriaCharacter* ValeriaCharacter, EValeriaCharacterEvent ValeriaCharacterEvent);
	void ProcessPendingAdds();
	void RpcClient_AddRecipes(TArray<int32>& RecipeConfigIds);
	void RpcServer_Cheat_GiveRecipeIngredients(int32 RecipeConfigId, bool bGiveToAllPresentPlayers, bool bGiveStarQuality, int32 Multiplier);
	void RpcServer_Cheat_LockAll();
	void RpcServer_Cheat_UnlockAll();

	bool DoesItemMappingExist(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& InputItemType, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& OutputItemType) const;
	TArray<TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>> GetItemMappings(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& InputItemType) const;
	bool IsAvailable(int32 RecipeConfigId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecipeInventoryComponent">();
	}
	static class URecipeInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecipeInventoryComponent>();
	}
};
static_assert(alignof(URecipeInventoryComponent) == 0x000008, "Wrong alignment on URecipeInventoryComponent");
static_assert(sizeof(URecipeInventoryComponent) == 0x0001B0, "Wrong size on URecipeInventoryComponent");
static_assert(offsetof(URecipeInventoryComponent, OnChanged) == 0x0000A8, "Member 'URecipeInventoryComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(URecipeInventoryComponent, OnUnlocked) == 0x0000B8, "Member 'URecipeInventoryComponent::OnUnlocked' has a wrong offset!");
static_assert(offsetof(URecipeInventoryComponent, DevOnly_OnLocked) == 0x0000C8, "Member 'URecipeInventoryComponent::DevOnly_OnLocked' has a wrong offset!");
static_assert(offsetof(URecipeInventoryComponent, InspirationRecipeChoices) == 0x0000D8, "Member 'URecipeInventoryComponent::InspirationRecipeChoices' has a wrong offset!");
static_assert(offsetof(URecipeInventoryComponent, RecipeInventoryPersistBlock) == 0x0000E8, "Member 'URecipeInventoryComponent::RecipeInventoryPersistBlock' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_CurrencyAbstract
// 0x0028 (0x0190 - 0x0168)
class UVAL_GameplayEvent_CurrencyAbstract : public UVAL_GameplayEvent
{
public:
	TSoftObjectPtr<class UCurrencyConfig>         CurrencyConfig;                                    // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_CurrencyAbstract">();
	}
	static class UVAL_GameplayEvent_CurrencyAbstract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_CurrencyAbstract>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_CurrencyAbstract) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_CurrencyAbstract");
static_assert(sizeof(UVAL_GameplayEvent_CurrencyAbstract) == 0x000190, "Wrong size on UVAL_GameplayEvent_CurrencyAbstract");
static_assert(offsetof(UVAL_GameplayEvent_CurrencyAbstract, CurrencyConfig) == 0x000168, "Member 'UVAL_GameplayEvent_CurrencyAbstract::CurrencyConfig' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_SpendCurrency
// 0x0000 (0x0190 - 0x0190)
class UVAL_GameplayEvent_SpendCurrency final : public UVAL_GameplayEvent_CurrencyAbstract
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_SpendCurrency">();
	}
	static class UVAL_GameplayEvent_SpendCurrency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_SpendCurrency>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_SpendCurrency) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_SpendCurrency");
static_assert(sizeof(UVAL_GameplayEvent_SpendCurrency) == 0x000190, "Wrong size on UVAL_GameplayEvent_SpendCurrency");

// Class Palia.InWorldLocationDef
// 0x00E0 (0x0110 - 0x0030)
class UInWorldLocationDef final : public UDataAsset
{
public:
	TSoftObjectPtr<class UWorld>                  LocationLevel;                                     // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPrivateSpaceConfig>     LocationPrivateSpace;                              // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULimitedEventDataAsset>  LocationLimitedEvent;                              // 0x0080(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LocationActorType;                                 // 0x00A8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocationActorName;                                 // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocationActorTag;                                  // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  LocationActorExact;                                // 0x00E0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocationActorIsArea;                              // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E6[0x3];                                     // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationAreaRadiusOverride;                        // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InWorldLocationDef">();
	}
	static class UInWorldLocationDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInWorldLocationDef>();
	}
};
static_assert(alignof(UInWorldLocationDef) == 0x000008, "Wrong alignment on UInWorldLocationDef");
static_assert(sizeof(UInWorldLocationDef) == 0x000110, "Wrong size on UInWorldLocationDef");
static_assert(offsetof(UInWorldLocationDef, LocationLevel) == 0x000030, "Member 'UInWorldLocationDef::LocationLevel' has a wrong offset!");
static_assert(offsetof(UInWorldLocationDef, LocationPrivateSpace) == 0x000058, "Member 'UInWorldLocationDef::LocationPrivateSpace' has a wrong offset!");
static_assert(offsetof(UInWorldLocationDef, LocationLimitedEvent) == 0x000080, "Member 'UInWorldLocationDef::LocationLimitedEvent' has a wrong offset!");
static_assert(offsetof(UInWorldLocationDef, LocationActorType) == 0x0000A8, "Member 'UInWorldLocationDef::LocationActorType' has a wrong offset!");
static_assert(offsetof(UInWorldLocationDef, LocationActorName) == 0x0000D0, "Member 'UInWorldLocationDef::LocationActorName' has a wrong offset!");
static_assert(offsetof(UInWorldLocationDef, LocationActorTag) == 0x0000D8, "Member 'UInWorldLocationDef::LocationActorTag' has a wrong offset!");
static_assert(offsetof(UInWorldLocationDef, LocationActorExact) == 0x0000E0, "Member 'UInWorldLocationDef::LocationActorExact' has a wrong offset!");
static_assert(offsetof(UInWorldLocationDef, bLocationActorIsArea) == 0x000108, "Member 'UInWorldLocationDef::bLocationActorIsArea' has a wrong offset!");
static_assert(offsetof(UInWorldLocationDef, LocationAreaRadiusOverride) == 0x00010C, "Member 'UInWorldLocationDef::LocationAreaRadiusOverride' has a wrong offset!");

// Class Palia.AkEventDebugActor
// 0x00B0 (0x0358 - 0x02A8)
class AAkEventDebugActor final : public AActor
{
public:
	class AActor*                                 FollowActor;                                       // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkComponent*                           FollowAkComponent;                                 // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkAudioEvent;                                      // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Positions;                                         // 0x02C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E7[0x20];                                    // 0x02D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AudioEvent;                                        // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerCameraManager*                   PlayerCameraManager;                               // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 OwningActor;                                       // 0x0300(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           DestroyTimerHandle;                                // 0x0308(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TrackingTimerHandle;                               // 0x0310(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ActionTimerHandle;                                 // 0x0318(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23E8[0x38];                                    // 0x0320(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroySelf();
	void OnFinishedPlaying();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkEventDebugActor">();
	}
	static class AAkEventDebugActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAkEventDebugActor>();
	}
};
static_assert(alignof(AAkEventDebugActor) == 0x000008, "Wrong alignment on AAkEventDebugActor");
static_assert(sizeof(AAkEventDebugActor) == 0x000358, "Wrong size on AAkEventDebugActor");
static_assert(offsetof(AAkEventDebugActor, FollowActor) == 0x0002A8, "Member 'AAkEventDebugActor::FollowActor' has a wrong offset!");
static_assert(offsetof(AAkEventDebugActor, FollowAkComponent) == 0x0002B0, "Member 'AAkEventDebugActor::FollowAkComponent' has a wrong offset!");
static_assert(offsetof(AAkEventDebugActor, AkAudioEvent) == 0x0002B8, "Member 'AAkEventDebugActor::AkAudioEvent' has a wrong offset!");
static_assert(offsetof(AAkEventDebugActor, Positions) == 0x0002C0, "Member 'AAkEventDebugActor::Positions' has a wrong offset!");
static_assert(offsetof(AAkEventDebugActor, AudioEvent) == 0x0002F0, "Member 'AAkEventDebugActor::AudioEvent' has a wrong offset!");
static_assert(offsetof(AAkEventDebugActor, PlayerCameraManager) == 0x0002F8, "Member 'AAkEventDebugActor::PlayerCameraManager' has a wrong offset!");
static_assert(offsetof(AAkEventDebugActor, OwningActor) == 0x000300, "Member 'AAkEventDebugActor::OwningActor' has a wrong offset!");
static_assert(offsetof(AAkEventDebugActor, DestroyTimerHandle) == 0x000308, "Member 'AAkEventDebugActor::DestroyTimerHandle' has a wrong offset!");
static_assert(offsetof(AAkEventDebugActor, TrackingTimerHandle) == 0x000310, "Member 'AAkEventDebugActor::TrackingTimerHandle' has a wrong offset!");
static_assert(offsetof(AAkEventDebugActor, ActionTimerHandle) == 0x000318, "Member 'AAkEventDebugActor::ActionTimerHandle' has a wrong offset!");

// Class Palia.PrivateSpaceLevelHandle
// 0x00E8 (0x0110 - 0x0028)
class UPrivateSpaceLevelHandle final : public UObject
{
public:
	int32                                         SlotId;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E9[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaPlayerController*               Instigator;                                        // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HandleID;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AValeriaPlayerController*>       VisitingPlayers;                                   // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSublevelAndTransform>          Levels;                                            // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_23EA[0x8];                                     // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LevelSpawnTransform;                               // 0x0070(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrivateSpaceConfig*                    PrivateSpaceConfig;                                // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitializedPrivateSpace;                          // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23EB[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AValeriaTargetPoint*>            TargetPoints;                                      // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrivateSpaceReady;                               // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         LocalLevelReady : 1;                               // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         RemoteLevelReady : 1;                              // 0x0100(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PendingUnload : 1;                                 // 0x0100(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_23EC[0xF];                                     // 0x0101(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLevelShown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrivateSpaceLevelHandle">();
	}
	static class UPrivateSpaceLevelHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrivateSpaceLevelHandle>();
	}
};
static_assert(alignof(UPrivateSpaceLevelHandle) == 0x000010, "Wrong alignment on UPrivateSpaceLevelHandle");
static_assert(sizeof(UPrivateSpaceLevelHandle) == 0x000110, "Wrong size on UPrivateSpaceLevelHandle");
static_assert(offsetof(UPrivateSpaceLevelHandle, SlotId) == 0x000028, "Member 'UPrivateSpaceLevelHandle::SlotId' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceLevelHandle, Instigator) == 0x000030, "Member 'UPrivateSpaceLevelHandle::Instigator' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceLevelHandle, HandleID) == 0x000038, "Member 'UPrivateSpaceLevelHandle::HandleID' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceLevelHandle, VisitingPlayers) == 0x000048, "Member 'UPrivateSpaceLevelHandle::VisitingPlayers' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceLevelHandle, Levels) == 0x000058, "Member 'UPrivateSpaceLevelHandle::Levels' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceLevelHandle, LevelSpawnTransform) == 0x000070, "Member 'UPrivateSpaceLevelHandle::LevelSpawnTransform' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceLevelHandle, PrivateSpaceConfig) == 0x0000D0, "Member 'UPrivateSpaceLevelHandle::PrivateSpaceConfig' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceLevelHandle, bInitializedPrivateSpace) == 0x0000D8, "Member 'UPrivateSpaceLevelHandle::bInitializedPrivateSpace' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceLevelHandle, TargetPoints) == 0x0000E0, "Member 'UPrivateSpaceLevelHandle::TargetPoints' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceLevelHandle, OnPrivateSpaceReady) == 0x0000F0, "Member 'UPrivateSpaceLevelHandle::OnPrivateSpaceReady' has a wrong offset!");

// Class Palia.AnimStateFunctions
// 0x0000 (0x0028 - 0x0028)
class UAnimStateFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool IsEmpty(struct FAnimState& AnimState);
	static bool IsIdle(struct FAnimState& AnimState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimStateFunctions">();
	}
	static class UAnimStateFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimStateFunctions>();
	}
};
static_assert(alignof(UAnimStateFunctions) == 0x000008, "Wrong alignment on UAnimStateFunctions");
static_assert(sizeof(UAnimStateFunctions) == 0x000028, "Wrong size on UAnimStateFunctions");

// Class Palia.ShippingBinGlobalConfig
// 0x0010 (0x0040 - 0x0030)
class UShippingBinGlobalConfig final : public UDataAsset
{
public:
	TArray<struct FTimeOfDayHourMinute>           TimesToSellBin;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShippingBinGlobalConfig">();
	}
	static class UShippingBinGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShippingBinGlobalConfig>();
	}
};
static_assert(alignof(UShippingBinGlobalConfig) == 0x000008, "Wrong alignment on UShippingBinGlobalConfig");
static_assert(sizeof(UShippingBinGlobalConfig) == 0x000040, "Wrong size on UShippingBinGlobalConfig");
static_assert(offsetof(UShippingBinGlobalConfig, TimesToSellBin) == 0x000030, "Member 'UShippingBinGlobalConfig::TimesToSellBin' has a wrong offset!");

// Class Palia.ValeriaGASComponent
// 0x00E0 (0x1330 - 0x1250)
class UValeriaGASComponent final : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_23EF[0x8];                                     // 0x1250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UValeriaGASGameplayAbility>> GameplayAbilities;                                 // 0x1258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotEnoughStamina;                                // 0x1268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TimeInputStaysQueued;                              // 0x1278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeForInputToBeConsideredHold;                    // 0x127C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAbilityEnd;                                      // 0x1280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAbilitySpecEventData>  AbilityEventDataPendingAdds;                       // 0x1290(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          ShouldTick;                                        // 0x12A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnableOnlyWhenInteractedWith;                      // 0x12A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23F0[0x6];                                     // 0x12A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecHandle>     RuntimeAbilityHandles;                             // 0x12A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGameplayAbilitySpecHandle             CurrentLMBAbilityHandle;                           // 0x12B8(0x0004)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayAbilitySpecHandle             CurrentRMBAbilityHandle;                           // 0x12BC(0x0004)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayAbilitySpecHandle             CurrentSpacebarAbilityHandle;                      // 0x12C0(0x0004)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23F1[0x4];                                     // 0x12C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecHandle>     AdditionalAbilityHandles;                          // 0x12C8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          SendAltInputsToLMBAbility;                         // 0x12D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          CancelAbilityOnSprint;                             // 0x12D9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ShouldQueueSprintToggle;                           // 0x12DA(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnterSprintOnAbilityEnd;                           // 0x12DB(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBagSlotLocation                       CurrentlyEquippedLocation;                         // 0x12DC(0x0008)(Net, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23F2[0x4];                                     // 0x12E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> CurrentItemType;                                   // 0x12E8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23F3[0x20];                                    // 0x1310(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMovementBlocker();
	bool CanCurrentlyMove();
	void HandleGameplayEffectApplied(class UAbilitySystemComponent* Target, struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle);
	bool IsAbilityMarkedLockedIn();
	void MarkAbilityLockedIn();
	struct FSelfUseEventResult OnClientUseEquippedInward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	struct FSelfUseEventResult OnClientUseEquippedOutward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void RemoveMovementBlocker();
	void RpcServer_EndActiveAbility();
	bool TryActivateAbilitiesByTagWithGameplayEvent(struct FGameplayTagContainer& GameplayTagContainer, struct FGameplayEventData& Payload);
	void TryCancelAbilitiesByTag(struct FGameplayTagContainer& GameplayTagContainer);
	void UnmarkAbilityLockedIn();

	bool IsMovementBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGASComponent">();
	}
	static class UValeriaGASComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGASComponent>();
	}
};
static_assert(alignof(UValeriaGASComponent) == 0x000008, "Wrong alignment on UValeriaGASComponent");
static_assert(sizeof(UValeriaGASComponent) == 0x001330, "Wrong size on UValeriaGASComponent");
static_assert(offsetof(UValeriaGASComponent, GameplayAbilities) == 0x001258, "Member 'UValeriaGASComponent::GameplayAbilities' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, OnNotEnoughStamina) == 0x001268, "Member 'UValeriaGASComponent::OnNotEnoughStamina' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, TimeInputStaysQueued) == 0x001278, "Member 'UValeriaGASComponent::TimeInputStaysQueued' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, TimeForInputToBeConsideredHold) == 0x00127C, "Member 'UValeriaGASComponent::TimeForInputToBeConsideredHold' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, OnAbilityEnd) == 0x001280, "Member 'UValeriaGASComponent::OnAbilityEnd' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, AbilityEventDataPendingAdds) == 0x001290, "Member 'UValeriaGASComponent::AbilityEventDataPendingAdds' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, ShouldTick) == 0x0012A0, "Member 'UValeriaGASComponent::ShouldTick' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, EnableOnlyWhenInteractedWith) == 0x0012A1, "Member 'UValeriaGASComponent::EnableOnlyWhenInteractedWith' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, RuntimeAbilityHandles) == 0x0012A8, "Member 'UValeriaGASComponent::RuntimeAbilityHandles' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, CurrentLMBAbilityHandle) == 0x0012B8, "Member 'UValeriaGASComponent::CurrentLMBAbilityHandle' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, CurrentRMBAbilityHandle) == 0x0012BC, "Member 'UValeriaGASComponent::CurrentRMBAbilityHandle' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, CurrentSpacebarAbilityHandle) == 0x0012C0, "Member 'UValeriaGASComponent::CurrentSpacebarAbilityHandle' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, AdditionalAbilityHandles) == 0x0012C8, "Member 'UValeriaGASComponent::AdditionalAbilityHandles' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, SendAltInputsToLMBAbility) == 0x0012D8, "Member 'UValeriaGASComponent::SendAltInputsToLMBAbility' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, CancelAbilityOnSprint) == 0x0012D9, "Member 'UValeriaGASComponent::CancelAbilityOnSprint' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, ShouldQueueSprintToggle) == 0x0012DA, "Member 'UValeriaGASComponent::ShouldQueueSprintToggle' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, EnterSprintOnAbilityEnd) == 0x0012DB, "Member 'UValeriaGASComponent::EnterSprintOnAbilityEnd' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, CurrentlyEquippedLocation) == 0x0012DC, "Member 'UValeriaGASComponent::CurrentlyEquippedLocation' has a wrong offset!");
static_assert(offsetof(UValeriaGASComponent, CurrentItemType) == 0x0012E8, "Member 'UValeriaGASComponent::CurrentItemType' has a wrong offset!");

// Class Palia.ChallengesSubsystem
// 0x0000 (0x0030 - 0x0030)
class UChallengesSubsystem final : public UGameInstanceSubsystem
{
public:
	void GetDisplayInfo(class AValeriaCharacter* Character, TArray<struct FChallengeDisplayInfo>* Infos);
	struct FTimespan GetTimeTillExpiration(class UObject* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesSubsystem">();
	}
	static class UChallengesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengesSubsystem>();
	}
};
static_assert(alignof(UChallengesSubsystem) == 0x000008, "Wrong alignment on UChallengesSubsystem");
static_assert(sizeof(UChallengesSubsystem) == 0x000030, "Wrong size on UChallengesSubsystem");

// Class Palia.VAL_PlayerSupport
// 0x0020 (0x00C0 - 0x00A0)
class UVAL_PlayerSupport final : public UActorComponent
{
public:
	uint8                                         Pad_23F7[0x20];                                    // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerSupport">();
	}
	static class UVAL_PlayerSupport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerSupport>();
	}
};
static_assert(alignof(UVAL_PlayerSupport) == 0x000008, "Wrong alignment on UVAL_PlayerSupport");
static_assert(sizeof(UVAL_PlayerSupport) == 0x0000C0, "Wrong size on UVAL_PlayerSupport");

// Class Palia.ArcadeCommandComponent
// 0x0040 (0x00E0 - 0x00A0)
class UArcadeCommandComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnScoresReceived;                                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FArcadeInputState                      CurrentInputState;                                 // 0x00B0(0x0030)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	struct FArcadeInputState ConsumeArcadeInputState();
	void RpcClient_SendLeaderboardScores(TArray<struct FArcadeLeaderboardEntry>& Scores);
	void RpcServer_SendArcadeGameCommand(const struct FArcadeGameCommand& Command);
	void SendArcadeGameCommand(const struct FArcadeGameCommand& Command);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArcadeCommandComponent">();
	}
	static class UArcadeCommandComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArcadeCommandComponent>();
	}
};
static_assert(alignof(UArcadeCommandComponent) == 0x000008, "Wrong alignment on UArcadeCommandComponent");
static_assert(sizeof(UArcadeCommandComponent) == 0x0000E0, "Wrong size on UArcadeCommandComponent");
static_assert(offsetof(UArcadeCommandComponent, OnScoresReceived) == 0x0000A0, "Member 'UArcadeCommandComponent::OnScoresReceived' has a wrong offset!");
static_assert(offsetof(UArcadeCommandComponent, CurrentInputState) == 0x0000B0, "Member 'UArcadeCommandComponent::CurrentInputState' has a wrong offset!");

// Class Palia.FishViewComponent
// 0x0018 (0x00B8 - 0x00A0)
class UFishViewComponent final : public UActorComponent
{
public:
	float                                         Speed;                                             // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeed;                                          // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedAtAnimPlaybackOne;                            // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateLerp;                                         // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnBlend;                                         // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TransitionDone;                                    // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimStateFish                                AnimState;                                         // 0x00B5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAnimStateFish                                AnimStatePrev;                                     // 0x00B6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23F8[0x1];                                     // 0x00B7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EAnimStateFish GetState() const;
	EAnimStateFish GetStatePrev() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishViewComponent">();
	}
	static class UFishViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishViewComponent>();
	}
};
static_assert(alignof(UFishViewComponent) == 0x000008, "Wrong alignment on UFishViewComponent");
static_assert(sizeof(UFishViewComponent) == 0x0000B8, "Wrong size on UFishViewComponent");
static_assert(offsetof(UFishViewComponent, Speed) == 0x0000A0, "Member 'UFishViewComponent::Speed' has a wrong offset!");
static_assert(offsetof(UFishViewComponent, MinSpeed) == 0x0000A4, "Member 'UFishViewComponent::MinSpeed' has a wrong offset!");
static_assert(offsetof(UFishViewComponent, SpeedAtAnimPlaybackOne) == 0x0000A8, "Member 'UFishViewComponent::SpeedAtAnimPlaybackOne' has a wrong offset!");
static_assert(offsetof(UFishViewComponent, StateLerp) == 0x0000AC, "Member 'UFishViewComponent::StateLerp' has a wrong offset!");
static_assert(offsetof(UFishViewComponent, TurnBlend) == 0x0000B0, "Member 'UFishViewComponent::TurnBlend' has a wrong offset!");
static_assert(offsetof(UFishViewComponent, TransitionDone) == 0x0000B4, "Member 'UFishViewComponent::TransitionDone' has a wrong offset!");
static_assert(offsetof(UFishViewComponent, AnimState) == 0x0000B5, "Member 'UFishViewComponent::AnimState' has a wrong offset!");
static_assert(offsetof(UFishViewComponent, AnimStatePrev) == 0x0000B6, "Member 'UFishViewComponent::AnimStatePrev' has a wrong offset!");

// Class Palia.SubgameConfig
// 0x0068 (0x0098 - 0x0030)
class USubgameConfig : public UDataAsset
{
public:
	TSubclassOf<class USubgameManagerComponent>   SubgameManagerClass;                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USubgameInputHandlerComponent> SubgameInputHandlerClass;                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumConcurrentPlayers;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayersRequiredToBegin;                            // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTransitionTime;                              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F9[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestRewardConfig>             Rewards;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAkRtpc*                                SubgameMixRtpc;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASubgameCutawayScene>       SubgameCutawaySceneToCreate;                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SubgameScreen;                                     // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsSubgameValid(class FString* Error) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubgameConfig">();
	}
	static class USubgameConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubgameConfig>();
	}
};
static_assert(alignof(USubgameConfig) == 0x000008, "Wrong alignment on USubgameConfig");
static_assert(sizeof(USubgameConfig) == 0x000098, "Wrong size on USubgameConfig");
static_assert(offsetof(USubgameConfig, SubgameManagerClass) == 0x000030, "Member 'USubgameConfig::SubgameManagerClass' has a wrong offset!");
static_assert(offsetof(USubgameConfig, SubgameInputHandlerClass) == 0x000038, "Member 'USubgameConfig::SubgameInputHandlerClass' has a wrong offset!");
static_assert(offsetof(USubgameConfig, MaxNumConcurrentPlayers) == 0x000040, "Member 'USubgameConfig::MaxNumConcurrentPlayers' has a wrong offset!");
static_assert(offsetof(USubgameConfig, PlayersRequiredToBegin) == 0x000044, "Member 'USubgameConfig::PlayersRequiredToBegin' has a wrong offset!");
static_assert(offsetof(USubgameConfig, CameraTransitionTime) == 0x000048, "Member 'USubgameConfig::CameraTransitionTime' has a wrong offset!");
static_assert(offsetof(USubgameConfig, Rewards) == 0x000050, "Member 'USubgameConfig::Rewards' has a wrong offset!");
static_assert(offsetof(USubgameConfig, SubgameMixRtpc) == 0x000060, "Member 'USubgameConfig::SubgameMixRtpc' has a wrong offset!");
static_assert(offsetof(USubgameConfig, SubgameCutawaySceneToCreate) == 0x000068, "Member 'USubgameConfig::SubgameCutawaySceneToCreate' has a wrong offset!");
static_assert(offsetof(USubgameConfig, SubgameScreen) == 0x000070, "Member 'USubgameConfig::SubgameScreen' has a wrong offset!");

// Class Palia.VillagerRelationshipRewardsMetaConfigDataAsset
// 0x0020 (0x0050 - 0x0030)
class UVillagerRelationshipRewardsMetaConfigDataAsset final : public UDataAsset
{
public:
	TArray<struct FVillagerRelationshipIntervalReward> RewardsForFriendshipLevel;                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVillagerRelationshipIntervalReward> RewardsForRomanceLevel;                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerRelationshipRewardsMetaConfigDataAsset">();
	}
	static class UVillagerRelationshipRewardsMetaConfigDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerRelationshipRewardsMetaConfigDataAsset>();
	}
};
static_assert(alignof(UVillagerRelationshipRewardsMetaConfigDataAsset) == 0x000008, "Wrong alignment on UVillagerRelationshipRewardsMetaConfigDataAsset");
static_assert(sizeof(UVillagerRelationshipRewardsMetaConfigDataAsset) == 0x000050, "Wrong size on UVillagerRelationshipRewardsMetaConfigDataAsset");
static_assert(offsetof(UVillagerRelationshipRewardsMetaConfigDataAsset, RewardsForFriendshipLevel) == 0x000030, "Member 'UVillagerRelationshipRewardsMetaConfigDataAsset::RewardsForFriendshipLevel' has a wrong offset!");
static_assert(offsetof(UVillagerRelationshipRewardsMetaConfigDataAsset, RewardsForRomanceLevel) == 0x000040, "Member 'UVillagerRelationshipRewardsMetaConfigDataAsset::RewardsForRomanceLevel' has a wrong offset!");

// Class Palia.ArcadeConfig
// 0x0008 (0x00A0 - 0x0098)
class UArcadeConfig final : public USubgameConfig
{
public:
	struct FGameplayTag                           ArcadeMachineHighScoreTag;                         // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArcadeConfig">();
	}
	static class UArcadeConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArcadeConfig>();
	}
};
static_assert(alignof(UArcadeConfig) == 0x000008, "Wrong alignment on UArcadeConfig");
static_assert(sizeof(UArcadeConfig) == 0x0000A0, "Wrong size on UArcadeConfig");
static_assert(offsetof(UArcadeConfig, ArcadeMachineHighScoreTag) == 0x000098, "Member 'UArcadeConfig::ArcadeMachineHighScoreTag' has a wrong offset!");

// Class Palia.CapsuleCollisionOverrideComponent
// 0x0018 (0x00B8 - 0x00A0)
class UCapsuleCollisionOverrideComponent final : public UActorComponent
{
public:
	class UCapsuleComponent*                      OwnerCapsule;                                      // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CollisionProfileOriginal;                          // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CollisionProfileOverride;                          // 0x00B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnReplicatedNotify();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapsuleCollisionOverrideComponent">();
	}
	static class UCapsuleCollisionOverrideComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCapsuleCollisionOverrideComponent>();
	}
};
static_assert(alignof(UCapsuleCollisionOverrideComponent) == 0x000008, "Wrong alignment on UCapsuleCollisionOverrideComponent");
static_assert(sizeof(UCapsuleCollisionOverrideComponent) == 0x0000B8, "Wrong size on UCapsuleCollisionOverrideComponent");
static_assert(offsetof(UCapsuleCollisionOverrideComponent, OwnerCapsule) == 0x0000A0, "Member 'UCapsuleCollisionOverrideComponent::OwnerCapsule' has a wrong offset!");
static_assert(offsetof(UCapsuleCollisionOverrideComponent, CollisionProfileOriginal) == 0x0000A8, "Member 'UCapsuleCollisionOverrideComponent::CollisionProfileOriginal' has a wrong offset!");
static_assert(offsetof(UCapsuleCollisionOverrideComponent, CollisionProfileOverride) == 0x0000B0, "Member 'UCapsuleCollisionOverrideComponent::CollisionProfileOverride' has a wrong offset!");

// Class Palia.ArcadeMachineActor
// 0x0198 (0x0440 - 0x02A8)
class AArcadeMachineActor final : public AActor
{
public:
	TArray<struct FArcadeLeaderboardEntry>        RequiredVillagerScores;                            // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FArcadeLeaderboardEntry>        ExtraVillagerScores;                               // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ArcadeMachineHighScoreTag;                         // 0x02C8(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentlyPlaying;                               // 0x02D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23FB[0x7];                                     // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentlyPlayingActor;                             // 0x02D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  Server_CurrentReplayId;                            // 0x02E0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FArcadeReplicatedReplayFrameArray      Server_ReplicatedReplayFrames;                     // 0x02F0(0x0128)(Net, NativeAccessSpecifierPrivate)
	struct FGuid                                  Client_CurrentReplayId;                            // 0x0418(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Client_CurrentFrameIndex;                          // 0x0428(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Client_ReplayInputsConsumed;                       // 0x042C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FArcadeInputState>              Client_CurrentReplayInputs;                        // 0x0430(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void Client_OnReplayInputReplicated();
	struct FArcadeInputState ConsumeReplayInput();
	int32 ConvertReplayGuidToSeed(const struct FGuid& Guid);
	struct FGuid GetCurrentReplayGuid();
	int32 GetNumberOfReplayInputsToConsume();
	void OnCurrentReplayInputsChanged();

	bool IsMachineLocked() const;
	bool ViewingOthersIsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArcadeMachineActor">();
	}
	static class AArcadeMachineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArcadeMachineActor>();
	}
};
static_assert(alignof(AArcadeMachineActor) == 0x000008, "Wrong alignment on AArcadeMachineActor");
static_assert(sizeof(AArcadeMachineActor) == 0x000440, "Wrong size on AArcadeMachineActor");
static_assert(offsetof(AArcadeMachineActor, RequiredVillagerScores) == 0x0002A8, "Member 'AArcadeMachineActor::RequiredVillagerScores' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, ExtraVillagerScores) == 0x0002B8, "Member 'AArcadeMachineActor::ExtraVillagerScores' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, ArcadeMachineHighScoreTag) == 0x0002C8, "Member 'AArcadeMachineActor::ArcadeMachineHighScoreTag' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, bIsCurrentlyPlaying) == 0x0002D0, "Member 'AArcadeMachineActor::bIsCurrentlyPlaying' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, CurrentlyPlayingActor) == 0x0002D8, "Member 'AArcadeMachineActor::CurrentlyPlayingActor' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, Server_CurrentReplayId) == 0x0002E0, "Member 'AArcadeMachineActor::Server_CurrentReplayId' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, Server_ReplicatedReplayFrames) == 0x0002F0, "Member 'AArcadeMachineActor::Server_ReplicatedReplayFrames' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, Client_CurrentReplayId) == 0x000418, "Member 'AArcadeMachineActor::Client_CurrentReplayId' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, Client_CurrentFrameIndex) == 0x000428, "Member 'AArcadeMachineActor::Client_CurrentFrameIndex' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, Client_ReplayInputsConsumed) == 0x00042C, "Member 'AArcadeMachineActor::Client_ReplayInputsConsumed' has a wrong offset!");
static_assert(offsetof(AArcadeMachineActor, Client_CurrentReplayInputs) == 0x000430, "Member 'AArcadeMachineActor::Client_CurrentReplayInputs' has a wrong offset!");

// Class Palia.FishMinigameBehaviorActionsConfig
// 0x0010 (0x0040 - 0x0030)
class UFishMinigameBehaviorActionsConfig final : public UDataAsset
{
public:
	TArray<struct FFishingLevelSegmentAction>     Actions;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishMinigameBehaviorActionsConfig">();
	}
	static class UFishMinigameBehaviorActionsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishMinigameBehaviorActionsConfig>();
	}
};
static_assert(alignof(UFishMinigameBehaviorActionsConfig) == 0x000008, "Wrong alignment on UFishMinigameBehaviorActionsConfig");
static_assert(sizeof(UFishMinigameBehaviorActionsConfig) == 0x000040, "Wrong size on UFishMinigameBehaviorActionsConfig");
static_assert(offsetof(UFishMinigameBehaviorActionsConfig, Actions) == 0x000030, "Member 'UFishMinigameBehaviorActionsConfig::Actions' has a wrong offset!");

// Class Palia.ArcadeMachineBase
// 0x0068 (0x0310 - 0x02A8)
class AArcadeMachineBase : public AActor
{
public:
	class USceneComponent*                        ArcadeMachineRootComponent;                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractableSphereCollider;                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       CameraComponent;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkComponent;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USubgameActivatorComponent*             SubgameActivatorComponent;                         // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FArcadeLeaderboardEntry>        RequiredVillagerScores;                            // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FArcadeLeaderboardEntry>        ExtraVillagerScores;                               // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FArcadeLeaderboardEntry>        LeaderboardEntries;                                // 0x02F8(0x0010)(BlueprintVisible, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ArcadeMachineHighScoreTag;                         // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddLeaderboardEntryToSortedArray(TArray<struct FArcadeLeaderboardEntry>* Leaderboard, struct FArcadeLeaderboardEntry& Entry);
	void AddLeaderboardScore(class AValeriaCharacter* InCharacter, int32 InScore);
	void LoadLeaderboardScores(int32 NumScoresToRetrieve);
	void SetArcadeMachineHighScoreTag(struct FGameplayTag& InGameplayTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArcadeMachineBase">();
	}
	static class AArcadeMachineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArcadeMachineBase>();
	}
};
static_assert(alignof(AArcadeMachineBase) == 0x000008, "Wrong alignment on AArcadeMachineBase");
static_assert(sizeof(AArcadeMachineBase) == 0x000310, "Wrong size on AArcadeMachineBase");
static_assert(offsetof(AArcadeMachineBase, ArcadeMachineRootComponent) == 0x0002A8, "Member 'AArcadeMachineBase::ArcadeMachineRootComponent' has a wrong offset!");
static_assert(offsetof(AArcadeMachineBase, InteractableSphereCollider) == 0x0002B0, "Member 'AArcadeMachineBase::InteractableSphereCollider' has a wrong offset!");
static_assert(offsetof(AArcadeMachineBase, CameraComponent) == 0x0002B8, "Member 'AArcadeMachineBase::CameraComponent' has a wrong offset!");
static_assert(offsetof(AArcadeMachineBase, AkComponent) == 0x0002C0, "Member 'AArcadeMachineBase::AkComponent' has a wrong offset!");
static_assert(offsetof(AArcadeMachineBase, InteractableComponent) == 0x0002C8, "Member 'AArcadeMachineBase::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AArcadeMachineBase, SubgameActivatorComponent) == 0x0002D0, "Member 'AArcadeMachineBase::SubgameActivatorComponent' has a wrong offset!");
static_assert(offsetof(AArcadeMachineBase, RequiredVillagerScores) == 0x0002D8, "Member 'AArcadeMachineBase::RequiredVillagerScores' has a wrong offset!");
static_assert(offsetof(AArcadeMachineBase, ExtraVillagerScores) == 0x0002E8, "Member 'AArcadeMachineBase::ExtraVillagerScores' has a wrong offset!");
static_assert(offsetof(AArcadeMachineBase, LeaderboardEntries) == 0x0002F8, "Member 'AArcadeMachineBase::LeaderboardEntries' has a wrong offset!");
static_assert(offsetof(AArcadeMachineBase, ArcadeMachineHighScoreTag) == 0x000308, "Member 'AArcadeMachineBase::ArcadeMachineHighScoreTag' has a wrong offset!");

// Class Palia.RecipeInteractionConfig
// 0x0108 (0x0138 - 0x0030)
class URecipeInteractionConfig final : public UDataAsset
{
public:
	ERecipeInteractionMode                        InteractionMode;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FD[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              InteractionIcon;                                   // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMinigameQTEStyle                             MinigameStyle;                                     // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterAttachPoint                         InteractablePropCharacterAttachPoint;              // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FE[0x6];                                     // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionText;                                   // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         InteractionToleranceSecs;                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FF[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityToolConfig                     Tool;                                              // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     PlayerMarkerMovementCurve;                         // 0x0098(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EEasingFunc                                   PlayerMarkerMovementEasingFunc;                    // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2400[0x3];                                     // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerMarkerMovementEasingFuncBlendExp;            // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMarkerPositionMinAlpha;                      // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCyclesPerAnimation;                             // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MistakeTriggersPenalty;                            // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2401[0x7];                                     // 0x0131(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecipeInteractionConfig">();
	}
	static class URecipeInteractionConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecipeInteractionConfig>();
	}
};
static_assert(alignof(URecipeInteractionConfig) == 0x000008, "Wrong alignment on URecipeInteractionConfig");
static_assert(sizeof(URecipeInteractionConfig) == 0x000138, "Wrong size on URecipeInteractionConfig");
static_assert(offsetof(URecipeInteractionConfig, InteractionMode) == 0x000030, "Member 'URecipeInteractionConfig::InteractionMode' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, InteractionIcon) == 0x000038, "Member 'URecipeInteractionConfig::InteractionIcon' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, MinigameStyle) == 0x000060, "Member 'URecipeInteractionConfig::MinigameStyle' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, InteractablePropCharacterAttachPoint) == 0x000061, "Member 'URecipeInteractionConfig::InteractablePropCharacterAttachPoint' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, InteractionText) == 0x000068, "Member 'URecipeInteractionConfig::InteractionText' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, InteractionToleranceSecs) == 0x000080, "Member 'URecipeInteractionConfig::InteractionToleranceSecs' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, Tool) == 0x000088, "Member 'URecipeInteractionConfig::Tool' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, PlayerMarkerMovementCurve) == 0x000098, "Member 'URecipeInteractionConfig::PlayerMarkerMovementCurve' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, PlayerMarkerMovementEasingFunc) == 0x000120, "Member 'URecipeInteractionConfig::PlayerMarkerMovementEasingFunc' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, PlayerMarkerMovementEasingFuncBlendExp) == 0x000124, "Member 'URecipeInteractionConfig::PlayerMarkerMovementEasingFuncBlendExp' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, TargetMarkerPositionMinAlpha) == 0x000128, "Member 'URecipeInteractionConfig::TargetMarkerPositionMinAlpha' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, NumCyclesPerAnimation) == 0x00012C, "Member 'URecipeInteractionConfig::NumCyclesPerAnimation' has a wrong offset!");
static_assert(offsetof(URecipeInteractionConfig, MistakeTriggersPenalty) == 0x000130, "Member 'URecipeInteractionConfig::MistakeTriggersPenalty' has a wrong offset!");

// Class Palia.FishingComponent
// 0x08B0 (0x0950 - 0x00A0)
class UFishingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2402[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFishingRodMovement;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2403[0x8];                                     // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFishingMiniGameViewState              ViewStateOnServer;                                 // 0x00D0(0x0120)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectedBait;                                    // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectedNoBait;                                  // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFishingStateChanged;                             // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReceivedFishingEncouragement;                    // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFishCaught;                                      // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   Server_SelectedFishConfigToCatch_Deprecated;       // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFishMinigameConfig*                    Server_SelectedFishToCatch;                        // 0x0248(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2404[0x18];                                    // 0x0250(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ControllerRodPositionTimerHandle;                  // 0x0268(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CameraViewTarget;                                  // 0x0270(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CastingProjectile;                                 // 0x0278(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2405[0x4E0];                                   // 0x0280(0x04E0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStartFishingParams                    StartFishingParams;                                // 0x0760(0x0090)(NoDestructor, NativeAccessSpecifierPrivate)
	class AValeriaCharacter*                      CachedCharOwner;                                   // 0x07F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AValeriaPlayerController*               CachedPlayerController;                            // 0x07F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraTargetComponent*                 CachedCameraTarget;                                // 0x0800(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       CachedCameraComponent;                             // 0x0808(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFishingViewComponent*                  CachedFishingView;                                 // 0x0810(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterStateMachineComponent*        CharacterStateMachine;                             // 0x0818(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaBaseMovementComponent*          MovementComponent;                                 // 0x0820(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPaused;                                         // 0x0828(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2406[0x18];                                    // 0x0829(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWasPaused;                                        // 0x0841(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2407[0x2];                                     // 0x0842(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeLastEncouragedSomeone;                         // 0x0844(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CastDestination;                                   // 0x0848(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CastTimeOfActualDeploy;                            // 0x0860(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCastHasBeenDeployed;                              // 0x0864(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2408[0x3];                                     // 0x0865(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UValeriaWaterBodyComponent> PreviousSourceWaterBody;                           // 0x0868(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<int32>                                   ItemIdsOfFishesCaught;                             // 0x0870(0x0050)(NativeAccessSpecifierPrivate)
	struct FFishingPersistBlock                   FishingPersistBlock;                               // 0x08C0(0x0058)(NativeAccessSpecifierPrivate)
	int64                                         TimeLastFishingSessionStartedAt;                   // 0x0918(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 OverrideNextFishToCatch;                           // 0x0920(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   OverrideNextFishToCatch_Deprecated;                // 0x0930(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2409[0x18];                                    // 0x0938(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimDoneFishing();
	bool CanStartFishing(struct FNotification* ErrorNotification);
	void ExitFishingCSMState();
	EFishingSafeTier GetCurrentSafetyTier();
	void GetDebugInfo(EFishingState_NEW* CurrentFishingState, EFFishingLevelSegmentActionType* FishActionType, int32* CurrentSegmentNextIndex, int32* TotalSegments, float* CurrentActionLerpPctg, float* TimePassed, float* ActionStated, float* ActionTargetLocation, float* CurrentBobberSpeed, float* CurrentBobberPosition, float* TotalTaskTime, float* RawTaskTimeWithoutPause, float* TimeInCurrentTask, class FString* FishName, float* SafeZonePosition);
	void HandleCharacterStateChanged(class UCharacterStateMachineComponent* Csm, const struct FCharacterStateChangeParams& Params_0);
	void HandleEquipmentChanged(class UEquipmentComponent* Equipment, const struct FEquipmentItem& Item);
	void MoveRodPosition(float Delta);
	void OnBobberDestroyed(class AActor* DestroyedActor);
	void OnBobberHitSomething(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Character, const struct FInteractEventParams& EventParams);
	struct FSelfUseEventResult OnClientUseEquippedInward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnReplicated_ViewStateOnServer();
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void RetryBaitSelectFromPersistBlock(class UInventoryComponent* Inventory);
	void RodTurn(float Rate);
	void RodTurn_ApplyBrakeForce();
	void RodTurnAtRate(float Rate);
	void RpcClient_FishCaught(const struct FFishCaughtResult& Result);
	void RpcClient_InitializeSelectedBait(class UVAL_ItemTypeDefinitionAsset* BaitItemType);
	void RpcClient_ReceiveEncouragement(class AValeriaCharacter* FromVc);
	void RpcClient_StartFishingAt_Deprecated(class FName& FishConfigToCatch);
	void RpcClient_StartFishingFor(TSoftObjectPtr<class UFishMinigameConfig>& FishToCatch, int32 NumQualityStars);
	void RpcServer_CheatApplyCoopFishingBuff();
	void RpcServer_CheatOverrideNextFishToCatch(const class FString& FishToCatch);
	void RpcServer_CheatOverrideNextFishToCatch_Deprecated(class FName FishToCatch);
	void RpcServer_EndFishing(struct FFishingEndContext& Context);
	void RpcServer_EndFishingState();
	void RpcServer_FishStartedBiting(class UValeriaWaterBodyComponent* WaterBody);
	void RpcServer_NotifyServerBaitSelected(class UVAL_ItemTypeDefinitionAsset* BaitItemType);
	void RpcServer_SelectLoot(struct FFishingRPCSelectLootParams& RPCLootParams);
	void RpcServer_SetFishingState(ECharacterState NewState);
	void RpcServer_UpdateViewStateOnServer(const struct FFishingMiniGameViewState& ViewState);
	void SetFishingState(EFishingState_OLD NewState);
	void SetHookedFishVisibility(bool IsVisible);

	class UFishingViewComponent* GetCachedFishingViewComponent() const;
	class AActor* GetCastingBobber() const;
	EFishingState_OLD GetFishingState() const;
	struct FValeriaItem GetFishItemFromFishConfigName(class FName& FishConfigName) const;
	struct FValeriaItem GetNoBaitSelectedItem() const;
	struct FValeriaItem GetSelectedBait() const;
	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;
	class FName SelectFishingLootForWaterType(class FName& WaterType, bool bMatchAll, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& OptionalBaitItemType, bool bCheckBaitInInventory) const;
	class FName SelectRandomFishFromLootTable(class FName& LootTableRowName, bool bShouldLog) const;
	bool ShouldCurrentFishStruggle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishingComponent">();
	}
	static class UFishingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishingComponent>();
	}
};
static_assert(alignof(UFishingComponent) == 0x000010, "Wrong alignment on UFishingComponent");
static_assert(sizeof(UFishingComponent) == 0x000950, "Wrong size on UFishingComponent");
static_assert(offsetof(UFishingComponent, OnFishingRodMovement) == 0x0000B8, "Member 'UFishingComponent::OnFishingRodMovement' has a wrong offset!");
static_assert(offsetof(UFishingComponent, ViewStateOnServer) == 0x0000D0, "Member 'UFishingComponent::ViewStateOnServer' has a wrong offset!");
static_assert(offsetof(UFishingComponent, OnSelectedBait) == 0x0001F0, "Member 'UFishingComponent::OnSelectedBait' has a wrong offset!");
static_assert(offsetof(UFishingComponent, OnSelectedNoBait) == 0x000200, "Member 'UFishingComponent::OnSelectedNoBait' has a wrong offset!");
static_assert(offsetof(UFishingComponent, OnFishingStateChanged) == 0x000210, "Member 'UFishingComponent::OnFishingStateChanged' has a wrong offset!");
static_assert(offsetof(UFishingComponent, OnReceivedFishingEncouragement) == 0x000220, "Member 'UFishingComponent::OnReceivedFishingEncouragement' has a wrong offset!");
static_assert(offsetof(UFishingComponent, OnFishCaught) == 0x000230, "Member 'UFishingComponent::OnFishCaught' has a wrong offset!");
static_assert(offsetof(UFishingComponent, Server_SelectedFishConfigToCatch_Deprecated) == 0x000240, "Member 'UFishingComponent::Server_SelectedFishConfigToCatch_Deprecated' has a wrong offset!");
static_assert(offsetof(UFishingComponent, Server_SelectedFishToCatch) == 0x000248, "Member 'UFishingComponent::Server_SelectedFishToCatch' has a wrong offset!");
static_assert(offsetof(UFishingComponent, ControllerRodPositionTimerHandle) == 0x000268, "Member 'UFishingComponent::ControllerRodPositionTimerHandle' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CameraViewTarget) == 0x000270, "Member 'UFishingComponent::CameraViewTarget' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CastingProjectile) == 0x000278, "Member 'UFishingComponent::CastingProjectile' has a wrong offset!");
static_assert(offsetof(UFishingComponent, StartFishingParams) == 0x000760, "Member 'UFishingComponent::StartFishingParams' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CachedCharOwner) == 0x0007F0, "Member 'UFishingComponent::CachedCharOwner' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CachedPlayerController) == 0x0007F8, "Member 'UFishingComponent::CachedPlayerController' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CachedCameraTarget) == 0x000800, "Member 'UFishingComponent::CachedCameraTarget' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CachedCameraComponent) == 0x000808, "Member 'UFishingComponent::CachedCameraComponent' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CachedFishingView) == 0x000810, "Member 'UFishingComponent::CachedFishingView' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CharacterStateMachine) == 0x000818, "Member 'UFishingComponent::CharacterStateMachine' has a wrong offset!");
static_assert(offsetof(UFishingComponent, MovementComponent) == 0x000820, "Member 'UFishingComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(UFishingComponent, bIsPaused) == 0x000828, "Member 'UFishingComponent::bIsPaused' has a wrong offset!");
static_assert(offsetof(UFishingComponent, bWasPaused) == 0x000841, "Member 'UFishingComponent::bWasPaused' has a wrong offset!");
static_assert(offsetof(UFishingComponent, TimeLastEncouragedSomeone) == 0x000844, "Member 'UFishingComponent::TimeLastEncouragedSomeone' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CastDestination) == 0x000848, "Member 'UFishingComponent::CastDestination' has a wrong offset!");
static_assert(offsetof(UFishingComponent, CastTimeOfActualDeploy) == 0x000860, "Member 'UFishingComponent::CastTimeOfActualDeploy' has a wrong offset!");
static_assert(offsetof(UFishingComponent, bCastHasBeenDeployed) == 0x000864, "Member 'UFishingComponent::bCastHasBeenDeployed' has a wrong offset!");
static_assert(offsetof(UFishingComponent, PreviousSourceWaterBody) == 0x000868, "Member 'UFishingComponent::PreviousSourceWaterBody' has a wrong offset!");
static_assert(offsetof(UFishingComponent, ItemIdsOfFishesCaught) == 0x000870, "Member 'UFishingComponent::ItemIdsOfFishesCaught' has a wrong offset!");
static_assert(offsetof(UFishingComponent, FishingPersistBlock) == 0x0008C0, "Member 'UFishingComponent::FishingPersistBlock' has a wrong offset!");
static_assert(offsetof(UFishingComponent, TimeLastFishingSessionStartedAt) == 0x000918, "Member 'UFishingComponent::TimeLastFishingSessionStartedAt' has a wrong offset!");
static_assert(offsetof(UFishingComponent, OverrideNextFishToCatch) == 0x000920, "Member 'UFishingComponent::OverrideNextFishToCatch' has a wrong offset!");
static_assert(offsetof(UFishingComponent, OverrideNextFishToCatch_Deprecated) == 0x000930, "Member 'UFishingComponent::OverrideNextFishToCatch_Deprecated' has a wrong offset!");

// Class Palia.SubgameManagerComponent
// 0x0068 (0x0108 - 0x00A0)
class USubgameManagerComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCharacterEnteredSubgameManager;                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterExitedSubgameManager;                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSubgameStateChange;                              // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         CompletedScreenTime;                               // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2418[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      OwningCharacter;                                   // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AValeriaCharacter*>              PlayingCharacters;                                 // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ESubgameState                                 SubgameState;                                      // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2419[0x7];                                     // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USubgameConfig*                         SubgameConfig;                                     // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241A[0x8];                                     // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginSubgame();
	void BPIE_BeginSubgame();
	void BPIE_CharacterEnteredSubgame(class AValeriaCharacter* EnteringCharacter);
	void BPIE_CharacterExitedSubgame(class AValeriaCharacter* EnteringCharacter, ESubgameResult SubgameResult);
	void BPIE_CompleteSubgame();
	void CompleteSubgame();
	void DestroyAfterDelay();
	void EnterSubgame(class AValeriaCharacter* EnteringCharacter);
	void ExitSubgame(class AValeriaCharacter* ExitingCharacter, ESubgameResult SubgameResult);
	void HandleCharacterEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void InitializeSubgame(class USubgameConfig* InSubgameConfig, class AValeriaCharacter* CreatingCharacter);
	void OnRep_SubgameState(ESubgameState PreviousState);
	void RemoveAllCharacters(ESubgameResult InSubgameResult);
	void TransitionBackToMainCamera(class AValeriaPlayerController* ValeriaPlayerController);
	void TransitionToSubgameCamera(class AValeriaPlayerController* ValeriaPlayerController);

	class AActor* BPNE_GetSubgameCameraActor(class AValeriaPlayerController* PlayerController) const;
	bool BPNE_ShouldFadeToBlackOnCameraChange() const;
	bool CanJoin(class AValeriaCharacter* InValeriaCharacter) const;
	int32 GetNumActivePlayingCharacters() const;
	ESubgameState GetSubgameState() const;
	bool IsCharacterPlaying(class AValeriaCharacter* InValeriaCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubgameManagerComponent">();
	}
	static class USubgameManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubgameManagerComponent>();
	}
};
static_assert(alignof(USubgameManagerComponent) == 0x000008, "Wrong alignment on USubgameManagerComponent");
static_assert(sizeof(USubgameManagerComponent) == 0x000108, "Wrong size on USubgameManagerComponent");
static_assert(offsetof(USubgameManagerComponent, OnCharacterEnteredSubgameManager) == 0x0000A0, "Member 'USubgameManagerComponent::OnCharacterEnteredSubgameManager' has a wrong offset!");
static_assert(offsetof(USubgameManagerComponent, OnCharacterExitedSubgameManager) == 0x0000B0, "Member 'USubgameManagerComponent::OnCharacterExitedSubgameManager' has a wrong offset!");
static_assert(offsetof(USubgameManagerComponent, OnSubgameStateChange) == 0x0000C0, "Member 'USubgameManagerComponent::OnSubgameStateChange' has a wrong offset!");
static_assert(offsetof(USubgameManagerComponent, CompletedScreenTime) == 0x0000D0, "Member 'USubgameManagerComponent::CompletedScreenTime' has a wrong offset!");
static_assert(offsetof(USubgameManagerComponent, OwningCharacter) == 0x0000D8, "Member 'USubgameManagerComponent::OwningCharacter' has a wrong offset!");
static_assert(offsetof(USubgameManagerComponent, PlayingCharacters) == 0x0000E0, "Member 'USubgameManagerComponent::PlayingCharacters' has a wrong offset!");
static_assert(offsetof(USubgameManagerComponent, SubgameState) == 0x0000F0, "Member 'USubgameManagerComponent::SubgameState' has a wrong offset!");
static_assert(offsetof(USubgameManagerComponent, SubgameConfig) == 0x0000F8, "Member 'USubgameManagerComponent::SubgameConfig' has a wrong offset!");

// Class Palia.VillagerMailInboxComponent
// 0x0090 (0x0130 - 0x00A0)
class UVillagerMailInboxComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2420[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FMailInboxPersistBlock                 MailInboxPersistBlock;                             // 0x00B8(0x0060)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2421[0x8];                                     // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CheckForMailArrivalHandle;                         // 0x0120(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           CheckForAutoSendMailHandle;                        // 0x0128(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CheckForMailArrival();
	void OnInboxReplicated();
	void RpcServer_CollectReward(int32 PersistId, int32 RewardIndex, int64 SentTimestamp);
	void RpcServer_MarkMessageAsOpened(int32 PersistId, int64 SentTimestamp);
	void RpcServer_MarkMessageAsRead(int32 PersistId, int64 SentTimestamp);

	int64 FindMostRecentDeliveredMailTimestamp() const;
	int64 FindMostRecentSentMailTimestamp(int32 PersistId) const;
	bool HasNewMail() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerMailInboxComponent">();
	}
	static class UVillagerMailInboxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerMailInboxComponent>();
	}
};
static_assert(alignof(UVillagerMailInboxComponent) == 0x000008, "Wrong alignment on UVillagerMailInboxComponent");
static_assert(sizeof(UVillagerMailInboxComponent) == 0x000130, "Wrong size on UVillagerMailInboxComponent");
static_assert(offsetof(UVillagerMailInboxComponent, OnChanged) == 0x0000A8, "Member 'UVillagerMailInboxComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UVillagerMailInboxComponent, MailInboxPersistBlock) == 0x0000B8, "Member 'UVillagerMailInboxComponent::MailInboxPersistBlock' has a wrong offset!");
static_assert(offsetof(UVillagerMailInboxComponent, CheckForMailArrivalHandle) == 0x000120, "Member 'UVillagerMailInboxComponent::CheckForMailArrivalHandle' has a wrong offset!");
static_assert(offsetof(UVillagerMailInboxComponent, CheckForAutoSendMailHandle) == 0x000128, "Member 'UVillagerMailInboxComponent::CheckForAutoSendMailHandle' has a wrong offset!");

// Class Palia.ArcadeSubgameManagerComponent
// 0x0010 (0x0118 - 0x0108)
class UArcadeSubgameManagerComponent final : public USubgameManagerComponent
{
public:
	class UArcadeConfig*                          ArcadeConfig;                                      // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AArcadeMachineBase*                     ManagedArcadeMachine;                              // 0x0110(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArcadeSubgameManagerComponent">();
	}
	static class UArcadeSubgameManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArcadeSubgameManagerComponent>();
	}
};
static_assert(alignof(UArcadeSubgameManagerComponent) == 0x000008, "Wrong alignment on UArcadeSubgameManagerComponent");
static_assert(sizeof(UArcadeSubgameManagerComponent) == 0x000118, "Wrong size on UArcadeSubgameManagerComponent");
static_assert(offsetof(UArcadeSubgameManagerComponent, ArcadeConfig) == 0x000108, "Member 'UArcadeSubgameManagerComponent::ArcadeConfig' has a wrong offset!");
static_assert(offsetof(UArcadeSubgameManagerComponent, ManagedArcadeMachine) == 0x000110, "Member 'UArcadeSubgameManagerComponent::ManagedArcadeMachine' has a wrong offset!");

// Class Palia.ArraySorter
// 0x0028 (0x0050 - 0x0028)
class UArraySorter final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnCompare;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<int32>                                 SortedIndices;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          PreviousCompareResult;                             // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2425[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCompareResult(bool IsLeftLessThanRight);
	void Sort(int32 NumberOfElements);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArraySorter">();
	}
	static class UArraySorter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArraySorter>();
	}
};
static_assert(alignof(UArraySorter) == 0x000008, "Wrong alignment on UArraySorter");
static_assert(sizeof(UArraySorter) == 0x000050, "Wrong size on UArraySorter");
static_assert(offsetof(UArraySorter, OnCompare) == 0x000028, "Member 'UArraySorter::OnCompare' has a wrong offset!");
static_assert(offsetof(UArraySorter, SortedIndices) == 0x000038, "Member 'UArraySorter::SortedIndices' has a wrong offset!");
static_assert(offsetof(UArraySorter, PreviousCompareResult) == 0x000048, "Member 'UArraySorter::PreviousCompareResult' has a wrong offset!");

// Class Palia.VAL_GameConfigSubsystem
// 0x0138 (0x0168 - 0x0030)
class UVAL_GameConfigSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnGameConfigReady;                                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameConfigTableUpdated;                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimerHandle                           FetchManifestTimerHandle;                          // 0x0050(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           UpdateGameConfigsTimerHandle;                      // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_GameDataTableConfiguration*        GameDataTableConfig;                               // 0x0060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, int32>                    UpdatedTableVersions;                              // 0x0068(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     OriginalData;                                      // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2426[0x18];                                    // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ManifestLastModified;                              // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ManifestETag;                                      // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class FString>                           ActivelyDownloadingGameConfigs;                    // 0x0100(0x0050)(NativeAccessSpecifierPrivate)
	class FString                                 GameConfigsDownloadUrlRoot;                        // 0x0150(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PollingInterval;                                   // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2427[0x4];                                     // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FetchManifest();
	void OnGameConfigReady__DelegateSignature(const class FString& TableName);
	void OnGameConfigTableUpdated__DelegateSignature(class UDataTable* Table);
	void StartGameConfigService();
	void UpdateGameConfigs();

	const TArray<TSoftObjectPtr<class UDataTable>> GetConfigTables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameConfigSubsystem">();
	}
	static class UVAL_GameConfigSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameConfigSubsystem>();
	}
};
static_assert(alignof(UVAL_GameConfigSubsystem) == 0x000008, "Wrong alignment on UVAL_GameConfigSubsystem");
static_assert(sizeof(UVAL_GameConfigSubsystem) == 0x000168, "Wrong size on UVAL_GameConfigSubsystem");
static_assert(offsetof(UVAL_GameConfigSubsystem, OnGameConfigReady) == 0x000030, "Member 'UVAL_GameConfigSubsystem::OnGameConfigReady' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, OnGameConfigTableUpdated) == 0x000040, "Member 'UVAL_GameConfigSubsystem::OnGameConfigTableUpdated' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, FetchManifestTimerHandle) == 0x000050, "Member 'UVAL_GameConfigSubsystem::FetchManifestTimerHandle' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, UpdateGameConfigsTimerHandle) == 0x000058, "Member 'UVAL_GameConfigSubsystem::UpdateGameConfigsTimerHandle' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, GameDataTableConfig) == 0x000060, "Member 'UVAL_GameConfigSubsystem::GameDataTableConfig' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, UpdatedTableVersions) == 0x000068, "Member 'UVAL_GameConfigSubsystem::UpdatedTableVersions' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, OriginalData) == 0x0000B8, "Member 'UVAL_GameConfigSubsystem::OriginalData' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, ManifestLastModified) == 0x0000E0, "Member 'UVAL_GameConfigSubsystem::ManifestLastModified' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, ManifestETag) == 0x0000F0, "Member 'UVAL_GameConfigSubsystem::ManifestETag' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, ActivelyDownloadingGameConfigs) == 0x000100, "Member 'UVAL_GameConfigSubsystem::ActivelyDownloadingGameConfigs' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, GameConfigsDownloadUrlRoot) == 0x000150, "Member 'UVAL_GameConfigSubsystem::GameConfigsDownloadUrlRoot' has a wrong offset!");
static_assert(offsetof(UVAL_GameConfigSubsystem, PollingInterval) == 0x000160, "Member 'UVAL_GameConfigSubsystem::PollingInterval' has a wrong offset!");

// Class Palia.AudioFoliageManagerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UAudioFoliageManagerComponent : public UActorComponent
{
public:
	TArray<struct FVector> SortVectorsByClosest(TArray<struct FVector>& Vectors, const struct FVector& Center);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioFoliageManagerComponent">();
	}
	static class UAudioFoliageManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioFoliageManagerComponent>();
	}
};
static_assert(alignof(UAudioFoliageManagerComponent) == 0x000008, "Wrong alignment on UAudioFoliageManagerComponent");
static_assert(sizeof(UAudioFoliageManagerComponent) == 0x0000A0, "Wrong size on UAudioFoliageManagerComponent");

// Class Palia.ConfigurableTriggerVolume
// 0x0078 (0x0118 - 0x00A0)
class UConfigurableTriggerVolume final : public UActorComponent
{
public:
	struct FTimeOfDayFilter                       TimeOfDayRequirement;                              // 0x00A0(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TimeInsideVolumeRequired;                          // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2428[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestActivityPrereq>           RequiredQuestActivity;                             // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            RequiredVillagersInVolume;                         // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPersistentTagFilter>           PlayerTagRequirements;                             // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPersistentTagWriteback>        PlayerTagWriteback;                                // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          RevertWritebackOnExit;                             // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyToVillagers;                                  // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2429[0x16];                                    // 0x0102(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActorBeginOverlap(class AActor* MyActor, class AActor* OtherActor);
	void ActorEndOverlap(class AActor* MyActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigurableTriggerVolume">();
	}
	static class UConfigurableTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigurableTriggerVolume>();
	}
};
static_assert(alignof(UConfigurableTriggerVolume) == 0x000008, "Wrong alignment on UConfigurableTriggerVolume");
static_assert(sizeof(UConfigurableTriggerVolume) == 0x000118, "Wrong size on UConfigurableTriggerVolume");
static_assert(offsetof(UConfigurableTriggerVolume, TimeOfDayRequirement) == 0x0000A0, "Member 'UConfigurableTriggerVolume::TimeOfDayRequirement' has a wrong offset!");
static_assert(offsetof(UConfigurableTriggerVolume, TimeInsideVolumeRequired) == 0x0000B8, "Member 'UConfigurableTriggerVolume::TimeInsideVolumeRequired' has a wrong offset!");
static_assert(offsetof(UConfigurableTriggerVolume, RequiredQuestActivity) == 0x0000C0, "Member 'UConfigurableTriggerVolume::RequiredQuestActivity' has a wrong offset!");
static_assert(offsetof(UConfigurableTriggerVolume, RequiredVillagersInVolume) == 0x0000D0, "Member 'UConfigurableTriggerVolume::RequiredVillagersInVolume' has a wrong offset!");
static_assert(offsetof(UConfigurableTriggerVolume, PlayerTagRequirements) == 0x0000E0, "Member 'UConfigurableTriggerVolume::PlayerTagRequirements' has a wrong offset!");
static_assert(offsetof(UConfigurableTriggerVolume, PlayerTagWriteback) == 0x0000F0, "Member 'UConfigurableTriggerVolume::PlayerTagWriteback' has a wrong offset!");
static_assert(offsetof(UConfigurableTriggerVolume, RevertWritebackOnExit) == 0x000100, "Member 'UConfigurableTriggerVolume::RevertWritebackOnExit' has a wrong offset!");
static_assert(offsetof(UConfigurableTriggerVolume, ApplyToVillagers) == 0x000101, "Member 'UConfigurableTriggerVolume::ApplyToVillagers' has a wrong offset!");

// Class Palia.AudioFoliageRustleDataAsset
// 0x0050 (0x0080 - 0x0030)
class UAudioFoliageRustleDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<TSoftObjectPtr<class UStaticMesh>, class UAkAudioEvent*> RustleAudioByMesh;                                 // 0x0030(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioFoliageRustleDataAsset">();
	}
	static class UAudioFoliageRustleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioFoliageRustleDataAsset>();
	}
};
static_assert(alignof(UAudioFoliageRustleDataAsset) == 0x000008, "Wrong alignment on UAudioFoliageRustleDataAsset");
static_assert(sizeof(UAudioFoliageRustleDataAsset) == 0x000080, "Wrong size on UAudioFoliageRustleDataAsset");
static_assert(offsetof(UAudioFoliageRustleDataAsset, RustleAudioByMesh) == 0x000030, "Member 'UAudioFoliageRustleDataAsset::RustleAudioByMesh' has a wrong offset!");

// Class Palia.VAL_SunSettings
// 0x0030 (0x0060 - 0x0030)
class UVAL_SunSettings final : public UDataAsset
{
public:
	float                                         MorningThreshold;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EveningThreshold;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SunriseHour;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SunriseMinute;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SunriseSecond;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SunsetHour;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SunsetMinute;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SunsetSecond;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DaylightFadeInStart;                               // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DaylightFadeInEnd;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DaylightFadeOutStart;                              // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DaylightFadeOutEnd;                                // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_SunSettings">();
	}
	static class UVAL_SunSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_SunSettings>();
	}
};
static_assert(alignof(UVAL_SunSettings) == 0x000008, "Wrong alignment on UVAL_SunSettings");
static_assert(sizeof(UVAL_SunSettings) == 0x000060, "Wrong size on UVAL_SunSettings");
static_assert(offsetof(UVAL_SunSettings, MorningThreshold) == 0x000030, "Member 'UVAL_SunSettings::MorningThreshold' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, EveningThreshold) == 0x000034, "Member 'UVAL_SunSettings::EveningThreshold' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, SunriseHour) == 0x000038, "Member 'UVAL_SunSettings::SunriseHour' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, SunriseMinute) == 0x00003C, "Member 'UVAL_SunSettings::SunriseMinute' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, SunriseSecond) == 0x000040, "Member 'UVAL_SunSettings::SunriseSecond' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, SunsetHour) == 0x000044, "Member 'UVAL_SunSettings::SunsetHour' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, SunsetMinute) == 0x000048, "Member 'UVAL_SunSettings::SunsetMinute' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, SunsetSecond) == 0x00004C, "Member 'UVAL_SunSettings::SunsetSecond' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, DaylightFadeInStart) == 0x000050, "Member 'UVAL_SunSettings::DaylightFadeInStart' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, DaylightFadeInEnd) == 0x000054, "Member 'UVAL_SunSettings::DaylightFadeInEnd' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, DaylightFadeOutStart) == 0x000058, "Member 'UVAL_SunSettings::DaylightFadeOutStart' has a wrong offset!");
static_assert(offsetof(UVAL_SunSettings, DaylightFadeOutEnd) == 0x00005C, "Member 'UVAL_SunSettings::DaylightFadeOutEnd' has a wrong offset!");

// Class Palia.AudioManager
// 0x0058 (0x0088 - 0x0030)
class UAudioManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_242A[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class AAkEventDebugActor*>        AudioDebugActors;                                  // 0x0038(0x0050)(NativeAccessSpecifierPrivate)

public:
	void OnAAkEventDebugActorDestroyed(class AActor* Actor);
	void SetDebugDisplayOutOfRange(bool bShowDebugInfo);
	void SetDebugDisplayStatus(bool bShowDebugInfo);
	void UnregisterDebugActor(int32 PlayingID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioManager">();
	}
	static class UAudioManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioManager>();
	}
};
static_assert(alignof(UAudioManager) == 0x000008, "Wrong alignment on UAudioManager");
static_assert(sizeof(UAudioManager) == 0x000088, "Wrong size on UAudioManager");
static_assert(offsetof(UAudioManager, AudioDebugActors) == 0x000038, "Member 'UAudioManager::AudioDebugActors' has a wrong offset!");

// Class Palia.AuthManager
// 0x0110 (0x0140 - 0x0030)
class UAuthManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             LoggedIn;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SignedInAsCharacter;                               // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LogInFailure;                                      // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RegisterSuccess;                                   // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RegisterFailure;                                   // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LoginResetStatusDelegate;                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LinkedSuccess;                                     // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LinkedFailure;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UnlinkSuccess;                                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UnlinkFailure;                                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlatformRegisterSuccess;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlatformRegisterFailure;                           // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJWTTokenRefreshCompleted;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_242B[0x40];                                    // 0x0100(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeCharacter(const class FString& CharacterName, const class FString& Nickname);
	void FakeLogin(int32 LocalUserNum, const class FString& AccountUsername, const class FString& CharacterName);
	void HandleOnCharacterSelected(struct FOSSVAL_SelectedCharacter& SelectedCharacter);
	void HandleOnPlatformIdentityLinked(int32 ForLocalUserNum, bool bWasSuccessful, const class FString& ErrorMessage, int32 ErrorCode);
	void HandleOnPlatformIdentityRegistered(int32 ForLocalUserNum, bool bWasSuccessful, const class FString& ErrorMessage, int32 ErrorCode);
	void HandleOnPlatformLinked(int32 ForLocalUserNum, bool bWasSuccessful, const struct FGuid& InAccountId, const class FString& InAccountUsername, const class FString& ErrorMessage, int32 ErrorCode);
	void HandleOnPlatformLoggedIn(int32 ForLocalUserNum, bool WasSuccessful, const struct FGuid& InAccountId, const class FString& InAccountUsername, const class FString& ErrorMessage, int32 ErrorCode);
	void HandleOnPlatformUnlinked(int32 ForLocalUserNum, bool bWasSuccessful, const struct FGuid& InAccountId, const class FString& ErrorMessage, int32 ErrorCode);
	void HandleRegisterAccountFailed(int32 ForLocalUserNum, class FText& ErrorMessage);
	void HandleRegisterAccountSucceeded(int32 ForLocalUserNum, struct FValeriaUserDTO& NewUser);
	void LoginResetHandler(int32 ForLocalUserNum, bool bWasSuccessful, const struct FValeriaUserDTO& ResultsData);
	void OnJWTTokenRefreshCompleted__DelegateSignature(bool bSucceeded, int32 ErrorCode);
	void QuickRegisterUser(const class FString& NewUserName);
	void SetAccountUsername(const class FString& AccountUsername);
	void SetPassword(const class FString& Password);
	void StartBaseLogin();
	void StartLink(bool bUseHeadlessAccount);
	void StartLogin();
	void StartLoginResetUser(const struct FValeriaUserDTO& LoginData);
	void StartRegister(const class FString& Email, const class FString& Language, bool Subscribed, bool HasReferral, struct FGuid& ReferralCodeId);
	void StartRegisterUser(const struct FValeriaUserDTO& NewUserDTO);
	void StartUnlink();
	void UnbindFromLoginFailure(class UObject* Handle);

	class FString GenerateRandomUserName() const;
	struct FGuid GetAccountId() const;
	class FString GetAccountUsername() const;
	struct FGuid GetCharacterId() const;
	class FString GetCharacterName() const;
	struct FUniqueNetIdRepl GetNetId() const;
	int32 GetValidJWTTokenErrorCode() const;
	bool HasValidJWT() const;
	bool IsLoggedIn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthManager">();
	}
	static class UAuthManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthManager>();
	}
};
static_assert(alignof(UAuthManager) == 0x000008, "Wrong alignment on UAuthManager");
static_assert(sizeof(UAuthManager) == 0x000140, "Wrong size on UAuthManager");
static_assert(offsetof(UAuthManager, LoggedIn) == 0x000030, "Member 'UAuthManager::LoggedIn' has a wrong offset!");
static_assert(offsetof(UAuthManager, SignedInAsCharacter) == 0x000040, "Member 'UAuthManager::SignedInAsCharacter' has a wrong offset!");
static_assert(offsetof(UAuthManager, LogInFailure) == 0x000050, "Member 'UAuthManager::LogInFailure' has a wrong offset!");
static_assert(offsetof(UAuthManager, RegisterSuccess) == 0x000060, "Member 'UAuthManager::RegisterSuccess' has a wrong offset!");
static_assert(offsetof(UAuthManager, RegisterFailure) == 0x000070, "Member 'UAuthManager::RegisterFailure' has a wrong offset!");
static_assert(offsetof(UAuthManager, LoginResetStatusDelegate) == 0x000080, "Member 'UAuthManager::LoginResetStatusDelegate' has a wrong offset!");
static_assert(offsetof(UAuthManager, LinkedSuccess) == 0x000090, "Member 'UAuthManager::LinkedSuccess' has a wrong offset!");
static_assert(offsetof(UAuthManager, LinkedFailure) == 0x0000A0, "Member 'UAuthManager::LinkedFailure' has a wrong offset!");
static_assert(offsetof(UAuthManager, UnlinkSuccess) == 0x0000B0, "Member 'UAuthManager::UnlinkSuccess' has a wrong offset!");
static_assert(offsetof(UAuthManager, UnlinkFailure) == 0x0000C0, "Member 'UAuthManager::UnlinkFailure' has a wrong offset!");
static_assert(offsetof(UAuthManager, PlatformRegisterSuccess) == 0x0000D0, "Member 'UAuthManager::PlatformRegisterSuccess' has a wrong offset!");
static_assert(offsetof(UAuthManager, PlatformRegisterFailure) == 0x0000E0, "Member 'UAuthManager::PlatformRegisterFailure' has a wrong offset!");
static_assert(offsetof(UAuthManager, OnJWTTokenRefreshCompleted) == 0x0000F0, "Member 'UAuthManager::OnJWTTokenRefreshCompleted' has a wrong offset!");

// Class Palia.CharacterCustomManager
// 0x00E0 (0x0110 - 0x0030)
class UCharacterCustomManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             CharacterCreated;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CharacterUpdated;                                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CharacterDeleted;                                  // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CharactersReceived;                                // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CharacterReceived;                                 // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CharactersReceivedFailed;                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefreshedAllOurCharacters;                       // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterRenderStudioRegistered;                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_243D[0x30];                                    // 0x00B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AVAL_CharacterRenderStudio*             CharacterRenderStudio;                             // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVAL_CharacterCustomization_ColorsDataAsset* ColorsDataAsset;                                   // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        CachedCharacterCustomizationSettingsObjects;       // 0x00F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_243E[0x10];                                    // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterRenderStudioRegistered__DelegateSignature(class AVAL_CharacterRenderStudio* Studio);
	void OnRefreshedAllOurCharacters__DelegateSignature(class UCharacterCustomManager* CharacterCustomManager);
	void OnRegisterCharacter_Failure__DelegateSignature(class FText ErrorMessage, int32 ErrorCode);
	void OnRegisterCharacter_Successful__DelegateSignature(const class FString& CharacterName);
	bool TryGetAllOurCharacters(TArray<struct FVALDTOS_MetaCharacterFormat>* OutOurCharacters);
	void UpdateCharacter(const struct FVALDTOS_MetaCharacterFormat& CharacterData);

	class AVAL_CharacterRenderStudio* GetCharacterRenderStudio() const;
	const class UVAL_CharacterCustomization_ColorsDataAsset* GetColorsDataAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCustomManager">();
	}
	static class UCharacterCustomManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCustomManager>();
	}
};
static_assert(alignof(UCharacterCustomManager) == 0x000008, "Wrong alignment on UCharacterCustomManager");
static_assert(sizeof(UCharacterCustomManager) == 0x000110, "Wrong size on UCharacterCustomManager");
static_assert(offsetof(UCharacterCustomManager, CharacterCreated) == 0x000030, "Member 'UCharacterCustomManager::CharacterCreated' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, CharacterUpdated) == 0x000040, "Member 'UCharacterCustomManager::CharacterUpdated' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, CharacterDeleted) == 0x000050, "Member 'UCharacterCustomManager::CharacterDeleted' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, CharactersReceived) == 0x000060, "Member 'UCharacterCustomManager::CharactersReceived' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, CharacterReceived) == 0x000070, "Member 'UCharacterCustomManager::CharacterReceived' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, CharactersReceivedFailed) == 0x000080, "Member 'UCharacterCustomManager::CharactersReceivedFailed' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, OnRefreshedAllOurCharacters) == 0x000090, "Member 'UCharacterCustomManager::OnRefreshedAllOurCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, OnCharacterRenderStudioRegistered) == 0x0000A0, "Member 'UCharacterCustomManager::OnCharacterRenderStudioRegistered' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, CharacterRenderStudio) == 0x0000E0, "Member 'UCharacterCustomManager::CharacterRenderStudio' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, ColorsDataAsset) == 0x0000E8, "Member 'UCharacterCustomManager::ColorsDataAsset' has a wrong offset!");
static_assert(offsetof(UCharacterCustomManager, CachedCharacterCustomizationSettingsObjects) == 0x0000F0, "Member 'UCharacterCustomManager::CachedCharacterCustomizationSettingsObjects' has a wrong offset!");

// Class Palia.VillagerGiftPreferenceMetaConfigDataAsset
// 0x00A0 (0x00D0 - 0x0030)
class UVillagerGiftPreferenceMetaConfigDataAsset final : public UDataAsset
{
public:
	TMap<EVillagerGiftDifficultyGrouping, int32>  NumberOfPreferencesPerDifficulty;                  // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EVillagerGiftDifficultyGrouping, int32>  MinLevelPerDifficulty;                             // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerGiftPreferenceMetaConfigDataAsset">();
	}
	static class UVillagerGiftPreferenceMetaConfigDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerGiftPreferenceMetaConfigDataAsset>();
	}
};
static_assert(alignof(UVillagerGiftPreferenceMetaConfigDataAsset) == 0x000008, "Wrong alignment on UVillagerGiftPreferenceMetaConfigDataAsset");
static_assert(sizeof(UVillagerGiftPreferenceMetaConfigDataAsset) == 0x0000D0, "Wrong size on UVillagerGiftPreferenceMetaConfigDataAsset");
static_assert(offsetof(UVillagerGiftPreferenceMetaConfigDataAsset, NumberOfPreferencesPerDifficulty) == 0x000030, "Member 'UVillagerGiftPreferenceMetaConfigDataAsset::NumberOfPreferencesPerDifficulty' has a wrong offset!");
static_assert(offsetof(UVillagerGiftPreferenceMetaConfigDataAsset, MinLevelPerDifficulty) == 0x000080, "Member 'UVillagerGiftPreferenceMetaConfigDataAsset::MinLevelPerDifficulty' has a wrong offset!");

// Class Palia.VAL_BingoBoardgamePlayerComponent
// 0x0120 (0x01C0 - 0x00A0)
class UVAL_BingoBoardgamePlayerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnBingoBoardgameDataUpdated;                       // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DataStalenessThresholdSeconds;                     // 0x00B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2441[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBingoBoardgamesConfiguration> CurrentConfigurationSoftReference;                 // 0x00B8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBingoBoardgamesConfiguration*          CurrentConfiguration;                              // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVAL_BingoBoardgameReplicatedState     BingoBoardgameReplicatedState;                     // 0x00E8(0x0080)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FVAL_OnContributeBingoItemsDelegates> ContributeItemsRequestIdToResponseDelegatesMap;    // 0x0168(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2442[0x8];                                     // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientReceiveResponse_ContributeItems_Failure(struct FGuid& RequestID, class FText& ErrorMessage);
	void ClientReceiveResponse_ContributeItems_Success(struct FGuid& RequestID, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 BingoCellIndex, int32 UpdatedTotal, int32 ContributedQuantity);
	void ContributeItems(int32 BingoCellIndex, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 Quantity, TDelegate<void(class UVAL_BingoBoardgamePlayerComponent* BingoBoardgamePlayerComponent, int32 BingoCellIndex, int32 QuantityContributed)>& OnSuccess, TDelegate<void(class UVAL_BingoBoardgamePlayerComponent* BingoBoardgamePlayerComponent, class FText& ErrorMessage)>& OnFailure);
	void FetchBingoBoardData();
	void HandlePlayerStateIdentityInitialized(class AVAL_PlayerState* PlayerState);
	void OnBingoBoardgameDataUpdated__DelegateSignature(class UVAL_BingoBoardgamePlayerComponent* BingoBoardgamePlayerComponent);
	void OnRep_BingoBoardgameReplicatedState();
	void ServerFetchBingoBoardData();
	void ServerMakeRequest_ContributeItems(int32 BingoCellIndex, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 Quantity, struct FGuid& RequestID);
	bool TryGetBingoBoardgameData(struct FBingoBoardTemplateData* OutBingoBoardTemplate, struct FBingoBoardgameState* OutBingoBoardgameState, bool bAllowFetch);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_BingoBoardgamePlayerComponent">();
	}
	static class UVAL_BingoBoardgamePlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_BingoBoardgamePlayerComponent>();
	}
};
static_assert(alignof(UVAL_BingoBoardgamePlayerComponent) == 0x000008, "Wrong alignment on UVAL_BingoBoardgamePlayerComponent");
static_assert(sizeof(UVAL_BingoBoardgamePlayerComponent) == 0x0001C0, "Wrong size on UVAL_BingoBoardgamePlayerComponent");
static_assert(offsetof(UVAL_BingoBoardgamePlayerComponent, OnBingoBoardgameDataUpdated) == 0x0000A0, "Member 'UVAL_BingoBoardgamePlayerComponent::OnBingoBoardgameDataUpdated' has a wrong offset!");
static_assert(offsetof(UVAL_BingoBoardgamePlayerComponent, DataStalenessThresholdSeconds) == 0x0000B0, "Member 'UVAL_BingoBoardgamePlayerComponent::DataStalenessThresholdSeconds' has a wrong offset!");
static_assert(offsetof(UVAL_BingoBoardgamePlayerComponent, CurrentConfigurationSoftReference) == 0x0000B8, "Member 'UVAL_BingoBoardgamePlayerComponent::CurrentConfigurationSoftReference' has a wrong offset!");
static_assert(offsetof(UVAL_BingoBoardgamePlayerComponent, CurrentConfiguration) == 0x0000E0, "Member 'UVAL_BingoBoardgamePlayerComponent::CurrentConfiguration' has a wrong offset!");
static_assert(offsetof(UVAL_BingoBoardgamePlayerComponent, BingoBoardgameReplicatedState) == 0x0000E8, "Member 'UVAL_BingoBoardgamePlayerComponent::BingoBoardgameReplicatedState' has a wrong offset!");
static_assert(offsetof(UVAL_BingoBoardgamePlayerComponent, ContributeItemsRequestIdToResponseDelegatesMap) == 0x000168, "Member 'UVAL_BingoBoardgamePlayerComponent::ContributeItemsRequestIdToResponseDelegatesMap' has a wrong offset!");

// Class Palia.VAL_GameplayConditionDef
// 0x0000 (0x0030 - 0x0030)
class UVAL_GameplayConditionDef : public UDataAsset
{
public:
	bool GetAutoDescription(class FText* OutDescription, class UObject* Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayConditionDef">();
	}
	static class UVAL_GameplayConditionDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayConditionDef>();
	}
};
static_assert(alignof(UVAL_GameplayConditionDef) == 0x000008, "Wrong alignment on UVAL_GameplayConditionDef");
static_assert(sizeof(UVAL_GameplayConditionDef) == 0x000030, "Wrong size on UVAL_GameplayConditionDef");

// Class Palia.BingoBoardgamesConfiguration
// 0x0010 (0x0040 - 0x0030)
class UBingoBoardgamesConfiguration final : public UDataAsset
{
public:
	TArray<struct FBingoBoardTemplateData>        BingoBoards;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BingoBoardgamesConfiguration">();
	}
	static class UBingoBoardgamesConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBingoBoardgamesConfiguration>();
	}
};
static_assert(alignof(UBingoBoardgamesConfiguration) == 0x000008, "Wrong alignment on UBingoBoardgamesConfiguration");
static_assert(sizeof(UBingoBoardgamesConfiguration) == 0x000040, "Wrong size on UBingoBoardgamesConfiguration");
static_assert(offsetof(UBingoBoardgamesConfiguration, BingoBoards) == 0x000030, "Member 'UBingoBoardgamesConfiguration::BingoBoards' has a wrong offset!");

// Class Palia.StoreInteractorComponent
// 0x0010 (0x00B0 - 0x00A0)
class UStoreInteractorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_244A[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVillagerStoreConfig*                   StoreConfig;                                       // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Character, const struct FInteractEventParams& EventParams);

	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;
	bool IsStoreOpen(class AValeriaCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreInteractorComponent">();
	}
	static class UStoreInteractorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreInteractorComponent>();
	}
};
static_assert(alignof(UStoreInteractorComponent) == 0x000008, "Wrong alignment on UStoreInteractorComponent");
static_assert(sizeof(UStoreInteractorComponent) == 0x0000B0, "Wrong size on UStoreInteractorComponent");
static_assert(offsetof(UStoreInteractorComponent, StoreConfig) == 0x0000A8, "Member 'UStoreInteractorComponent::StoreConfig' has a wrong offset!");

// Class Palia.VAL_BingoBoardgameBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_BingoBoardgameBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetBingoBoardLinearArraySize();
	static int32 GetBingoBoardSquareSize();
	static void GetBingoCellCartesianFromIndex(int32 Param_Index, int32* OutColumnIndex, int32* OutRowIndex);
	static int32 GetBingoCellIndexFromCartesian(int32 ColumnIndex, int32 RowIndex);
	static bool IsBillboardQuestsFeatureEnabled();
	static bool TryGetBingoCellFromBoardgameStateByCartesian(struct FBingoBoardgameState& BoardgameState, int32 ColumnIndex, int32 RowIndex, int32* OutProgress);
	static bool TryGetBingoCellFromBoardgameStateByIndex(struct FBingoBoardgameState& BoardgameState, int32 Param_Index, int32* OutProgress);
	static bool TryGetBingoCellFromTemplateByCartesian(struct FBingoBoardTemplateData& Template, int32 ColumnIndex, int32 RowIndex, struct FBingoBoardGridCellTemplate* OutBingoCell);
	static bool TryGetBingoCellFromTemplateByIndex(struct FBingoBoardTemplateData& Template, int32 Param_Index, struct FBingoBoardGridCellTemplate* OutBingoCell);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_BingoBoardgameBlueprintFunctionLibrary">();
	}
	static class UVAL_BingoBoardgameBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_BingoBoardgameBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UVAL_BingoBoardgameBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UVAL_BingoBoardgameBlueprintFunctionLibrary");
static_assert(sizeof(UVAL_BingoBoardgameBlueprintFunctionLibrary) == 0x000028, "Wrong size on UVAL_BingoBoardgameBlueprintFunctionLibrary");

// Class Palia.BookReadingComponent
// 0x0058 (0x00F8 - 0x00A0)
class UBookReadingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2455[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBookReadingPersistBlock               BookReadingPersistBlock;                           // 0x00A8(0x0050)(Net, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BookReadingComponent">();
	}
	static class UBookReadingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBookReadingComponent>();
	}
};
static_assert(alignof(UBookReadingComponent) == 0x000008, "Wrong alignment on UBookReadingComponent");
static_assert(sizeof(UBookReadingComponent) == 0x0000F8, "Wrong size on UBookReadingComponent");
static_assert(offsetof(UBookReadingComponent, BookReadingPersistBlock) == 0x0000A8, "Member 'UBookReadingComponent::BookReadingPersistBlock' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_ViewMail
// 0x0018 (0x0180 - 0x0168)
class UVAL_GameplayEvent_ViewMail final : public UVAL_GameplayEvent
{
public:
	struct FDataTableRowHandle                    MailToView;                                        // 0x0168(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MailPersistId;                                     // 0x0178(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2456[0x4];                                     // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_ViewMail">();
	}
	static class UVAL_GameplayEvent_ViewMail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_ViewMail>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_ViewMail) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_ViewMail");
static_assert(sizeof(UVAL_GameplayEvent_ViewMail) == 0x000180, "Wrong size on UVAL_GameplayEvent_ViewMail");
static_assert(offsetof(UVAL_GameplayEvent_ViewMail, MailToView) == 0x000168, "Member 'UVAL_GameplayEvent_ViewMail::MailToView' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_ViewMail, MailPersistId) == 0x000178, "Member 'UVAL_GameplayEvent_ViewMail::MailPersistId' has a wrong offset!");

// Class Palia.VAL_TeleporterBase
// 0x0078 (0x0320 - 0x02A8)
class AVAL_TeleporterBase : public AActor
{
public:
	class USceneComponent*                        TeleporterRoot;                                    // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeleportOriginComponent*               TeleportOrigin;                                    // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeleportDestinationComponent*          TeleportDestination;                               // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTrackingTargetComponent*               PlayerCompassTarget;                               // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTeleportTravelConfigAsset> DefaultTeleportTo;                                 // 0x02C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTeleportTravelConfigAsset> DefaultAddress;                                    // 0x02F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCrossMapTracking;                             // 0x0318(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldNetMulticastCharacterArrival;               // 0x0319(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2457[0x6];                                     // 0x031A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ExecuteTeleport(class AValeriaCharacter* Character);
	void Implementation_OnCharacterArrival_AllClients(class AValeriaCharacter* Character);
	void Implementation_OnCharacterArrival_Client(class AValeriaCharacter* Character);
	void Implementation_OnCharacterArrival_Server(class AValeriaCharacter* Character);
	void Implementation_OnTeleport_Client(class AValeriaCharacter* Character);
	void Implementation_OnTeleport_Server(class AValeriaCharacter* Character);
	void NetMulticast_NotifyOfCharacterArrival(class AValeriaCharacter* Character);
	void OnCharacterArrival(class AValeriaCharacter* Character);
	void Server_ExecuteTeleport(class AValeriaCharacter* Character);

	int32 GetCrossMapTrackingTypes(class AValeriaCharacter* Character) const;
	TSoftObjectPtr<class UWorld> GetTeleportToLevel(class AValeriaCharacter* Character) const;
	const class ULimitedEventDataAsset* GetTeleportToLimitedEvent(class AValeriaCharacter* Character) const;
	TSoftObjectPtr<class UPrivateSpaceConfig> GetTeleportToPrivateSpace(class AValeriaCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TeleporterBase">();
	}
	static class AVAL_TeleporterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_TeleporterBase>();
	}
};
static_assert(alignof(AVAL_TeleporterBase) == 0x000008, "Wrong alignment on AVAL_TeleporterBase");
static_assert(sizeof(AVAL_TeleporterBase) == 0x000320, "Wrong size on AVAL_TeleporterBase");
static_assert(offsetof(AVAL_TeleporterBase, TeleporterRoot) == 0x0002A8, "Member 'AVAL_TeleporterBase::TeleporterRoot' has a wrong offset!");
static_assert(offsetof(AVAL_TeleporterBase, TeleportOrigin) == 0x0002B0, "Member 'AVAL_TeleporterBase::TeleportOrigin' has a wrong offset!");
static_assert(offsetof(AVAL_TeleporterBase, TeleportDestination) == 0x0002B8, "Member 'AVAL_TeleporterBase::TeleportDestination' has a wrong offset!");
static_assert(offsetof(AVAL_TeleporterBase, PlayerCompassTarget) == 0x0002C0, "Member 'AVAL_TeleporterBase::PlayerCompassTarget' has a wrong offset!");
static_assert(offsetof(AVAL_TeleporterBase, DefaultTeleportTo) == 0x0002C8, "Member 'AVAL_TeleporterBase::DefaultTeleportTo' has a wrong offset!");
static_assert(offsetof(AVAL_TeleporterBase, DefaultAddress) == 0x0002F0, "Member 'AVAL_TeleporterBase::DefaultAddress' has a wrong offset!");
static_assert(offsetof(AVAL_TeleporterBase, bShowCrossMapTracking) == 0x000318, "Member 'AVAL_TeleporterBase::bShowCrossMapTracking' has a wrong offset!");
static_assert(offsetof(AVAL_TeleporterBase, bShouldNetMulticastCharacterArrival) == 0x000319, "Member 'AVAL_TeleporterBase::bShouldNetMulticastCharacterArrival' has a wrong offset!");

// Class Palia.VAL_InteractionTeleporter
// 0x00B0 (0x03D0 - 0x0320)
class AVAL_InteractionTeleporter final : public AVAL_TeleporterBase
{
public:
	uint8                                         Pad_2459[0x8];                                     // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReevaluatePrivateSpaceVillagersTime;               // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReevaluateInteractableVillagersTime;               // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReevaluateInteractableVillagersRange;              // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TeleporterInteractionCooldown;                     // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckQuestValidityForDialogueRoomInteraction;     // 0x0340(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_245A[0x7];                                     // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrivateSpaceManager*                   PrivateSpaceManager;                               // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrivateSpaceConfig*                    PrivateSpaceConfig;                                // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ReevaluatePrivateSpaceVillagersTimerHandle;        // 0x0358(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPrivateSpaceScheduledVillagerDialogueRoomSpawnInfo> PrivateSpaceScheduledVillagerDialogueRoomSpawnInfos; // 0x0360(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<int32, bool>                             InteractableVillagers;                             // 0x0370(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ReevaluateInteractableVillagersTimerHandle;        // 0x03C0(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeleporterInteractionOnCooldown;                  // 0x03C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_245B[0x7];                                     // 0x03C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_EndTeleporterInteractionCooldown();
	void Client_ReevaluateInteractableVillagers();
	void Implementation_OnTeleportBegin_Client(class AValeriaCharacter* Character);
	void Implementation_OnTeleportBegin_Server(class AValeriaCharacter* Character);
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Player, const struct FInteractEventParams& Params_0);
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void Server_ReevaluatePrivateSpaceVillagers();

	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_InteractionTeleporter">();
	}
	static class AVAL_InteractionTeleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_InteractionTeleporter>();
	}
};
static_assert(alignof(AVAL_InteractionTeleporter) == 0x000008, "Wrong alignment on AVAL_InteractionTeleporter");
static_assert(sizeof(AVAL_InteractionTeleporter) == 0x0003D0, "Wrong size on AVAL_InteractionTeleporter");
static_assert(offsetof(AVAL_InteractionTeleporter, InteractableComponent) == 0x000328, "Member 'AVAL_InteractionTeleporter::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, ReevaluatePrivateSpaceVillagersTime) == 0x000330, "Member 'AVAL_InteractionTeleporter::ReevaluatePrivateSpaceVillagersTime' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, ReevaluateInteractableVillagersTime) == 0x000334, "Member 'AVAL_InteractionTeleporter::ReevaluateInteractableVillagersTime' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, ReevaluateInteractableVillagersRange) == 0x000338, "Member 'AVAL_InteractionTeleporter::ReevaluateInteractableVillagersRange' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, TeleporterInteractionCooldown) == 0x00033C, "Member 'AVAL_InteractionTeleporter::TeleporterInteractionCooldown' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, bCheckQuestValidityForDialogueRoomInteraction) == 0x000340, "Member 'AVAL_InteractionTeleporter::bCheckQuestValidityForDialogueRoomInteraction' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, PrivateSpaceManager) == 0x000348, "Member 'AVAL_InteractionTeleporter::PrivateSpaceManager' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, PrivateSpaceConfig) == 0x000350, "Member 'AVAL_InteractionTeleporter::PrivateSpaceConfig' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, ReevaluatePrivateSpaceVillagersTimerHandle) == 0x000358, "Member 'AVAL_InteractionTeleporter::ReevaluatePrivateSpaceVillagersTimerHandle' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, PrivateSpaceScheduledVillagerDialogueRoomSpawnInfos) == 0x000360, "Member 'AVAL_InteractionTeleporter::PrivateSpaceScheduledVillagerDialogueRoomSpawnInfos' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, InteractableVillagers) == 0x000370, "Member 'AVAL_InteractionTeleporter::InteractableVillagers' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, ReevaluateInteractableVillagersTimerHandle) == 0x0003C0, "Member 'AVAL_InteractionTeleporter::ReevaluateInteractableVillagersTimerHandle' has a wrong offset!");
static_assert(offsetof(AVAL_InteractionTeleporter, bTeleporterInteractionOnCooldown) == 0x0003C8, "Member 'AVAL_InteractionTeleporter::bTeleporterInteractionOnCooldown' has a wrong offset!");

// Class Palia.BTTaskCreatureMoveForward
// 0x0000 (0x0098 - 0x0098)
class UBTTaskCreatureMoveForward final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTaskCreatureMoveForward">();
	}
	static class UBTTaskCreatureMoveForward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTaskCreatureMoveForward>();
	}
};
static_assert(alignof(UBTTaskCreatureMoveForward) == 0x000008, "Wrong alignment on UBTTaskCreatureMoveForward");
static_assert(sizeof(UBTTaskCreatureMoveForward) == 0x000098, "Wrong size on UBTTaskCreatureMoveForward");

// Class Palia.VAL_QuantityCondition
// 0x0010 (0x0040 - 0x0030)
class UVAL_QuantityCondition : public UVAL_GameplayConditionDef
{
public:
	int32                                         AmountRequired;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasUpperLimit;                                    // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2461[0x3];                                     // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmountUpperLimit;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2462[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_QuantityCondition">();
	}
	static class UVAL_QuantityCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_QuantityCondition>();
	}
};
static_assert(alignof(UVAL_QuantityCondition) == 0x000008, "Wrong alignment on UVAL_QuantityCondition");
static_assert(sizeof(UVAL_QuantityCondition) == 0x000040, "Wrong size on UVAL_QuantityCondition");
static_assert(offsetof(UVAL_QuantityCondition, AmountRequired) == 0x000030, "Member 'UVAL_QuantityCondition::AmountRequired' has a wrong offset!");
static_assert(offsetof(UVAL_QuantityCondition, bHasUpperLimit) == 0x000034, "Member 'UVAL_QuantityCondition::bHasUpperLimit' has a wrong offset!");
static_assert(offsetof(UVAL_QuantityCondition, AmountUpperLimit) == 0x000038, "Member 'UVAL_QuantityCondition::AmountUpperLimit' has a wrong offset!");

// Class Palia.VAL_SkillLevelCondition
// 0x0008 (0x0048 - 0x0040)
class UVAL_SkillLevelCondition final : public UVAL_QuantityCondition
{
public:
	ESkillType                                    Skill;                                             // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2463[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_SkillLevelCondition">();
	}
	static class UVAL_SkillLevelCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_SkillLevelCondition>();
	}
};
static_assert(alignof(UVAL_SkillLevelCondition) == 0x000008, "Wrong alignment on UVAL_SkillLevelCondition");
static_assert(sizeof(UVAL_SkillLevelCondition) == 0x000048, "Wrong size on UVAL_SkillLevelCondition");
static_assert(offsetof(UVAL_SkillLevelCondition, Skill) == 0x000040, "Member 'UVAL_SkillLevelCondition::Skill' has a wrong offset!");

// Class Palia.BTTask_CreatureBecomeAware
// 0x0010 (0x0080 - 0x0070)
class UBTTask_CreatureBecomeAware final : public UBTTaskNode
{
public:
	float                                         NavigationCheckRadius;                             // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpImpulseStrength;                               // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Duration;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovementDuration;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CreatureBecomeAware">();
	}
	static class UBTTask_CreatureBecomeAware* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CreatureBecomeAware>();
	}
};
static_assert(alignof(UBTTask_CreatureBecomeAware) == 0x000008, "Wrong alignment on UBTTask_CreatureBecomeAware");
static_assert(sizeof(UBTTask_CreatureBecomeAware) == 0x000080, "Wrong size on UBTTask_CreatureBecomeAware");
static_assert(offsetof(UBTTask_CreatureBecomeAware, NavigationCheckRadius) == 0x000070, "Member 'UBTTask_CreatureBecomeAware::NavigationCheckRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureBecomeAware, JumpImpulseStrength) == 0x000074, "Member 'UBTTask_CreatureBecomeAware::JumpImpulseStrength' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureBecomeAware, Duration) == 0x000078, "Member 'UBTTask_CreatureBecomeAware::Duration' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureBecomeAware, MovementDuration) == 0x00007C, "Member 'UBTTask_CreatureBecomeAware::MovementDuration' has a wrong offset!");

// Class Palia.ValeriaGASAT_ToggleCollision
// 0x0000 (0x0080 - 0x0080)
class UValeriaGASAT_ToggleCollision final : public UAbilityTask
{
public:
	static class UValeriaGASAT_ToggleCollision* CreateToggleCollisionProxy(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, bool EnableCollision, class FName ColliderTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGASAT_ToggleCollision">();
	}
	static class UValeriaGASAT_ToggleCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGASAT_ToggleCollision>();
	}
};
static_assert(alignof(UValeriaGASAT_ToggleCollision) == 0x000008, "Wrong alignment on UValeriaGASAT_ToggleCollision");
static_assert(sizeof(UValeriaGASAT_ToggleCollision) == 0x000080, "Wrong size on UValeriaGASAT_ToggleCollision");

// Class Palia.BundleShrineConfig
// 0x00B8 (0x00E8 - 0x0030)
class UBundleShrineConfig final : public UDataAsset
{
public:
	int32                                         PersistId;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2466[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BundleName;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   BundleCompleteDesc;                                // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BundleImage;                                       // 0x0078(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      BundleIconPositions;                               // 0x00A0(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSubBundleNavExplicitData>      BundleExplicitData;                                // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuestRewardConfig>             BundleRewards;                                     // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSubBundleShrineConfig>         SubBundles;                                        // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowBundleComplete;                               // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSubBundleComplete;                            // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBundleTutorial;                               // 0x00E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2467[0x5];                                     // 0x00E3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BundleShrineConfig">();
	}
	static class UBundleShrineConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBundleShrineConfig>();
	}
};
static_assert(alignof(UBundleShrineConfig) == 0x000008, "Wrong alignment on UBundleShrineConfig");
static_assert(sizeof(UBundleShrineConfig) == 0x0000E8, "Wrong size on UBundleShrineConfig");
static_assert(offsetof(UBundleShrineConfig, PersistId) == 0x000030, "Member 'UBundleShrineConfig::PersistId' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, BundleName) == 0x000038, "Member 'UBundleShrineConfig::BundleName' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, DisplayName) == 0x000048, "Member 'UBundleShrineConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, BundleCompleteDesc) == 0x000060, "Member 'UBundleShrineConfig::BundleCompleteDesc' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, BundleImage) == 0x000078, "Member 'UBundleShrineConfig::BundleImage' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, BundleIconPositions) == 0x0000A0, "Member 'UBundleShrineConfig::BundleIconPositions' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, BundleExplicitData) == 0x0000B0, "Member 'UBundleShrineConfig::BundleExplicitData' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, BundleRewards) == 0x0000C0, "Member 'UBundleShrineConfig::BundleRewards' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, SubBundles) == 0x0000D0, "Member 'UBundleShrineConfig::SubBundles' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, bShowBundleComplete) == 0x0000E0, "Member 'UBundleShrineConfig::bShowBundleComplete' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, bShowSubBundleComplete) == 0x0000E1, "Member 'UBundleShrineConfig::bShowSubBundleComplete' has a wrong offset!");
static_assert(offsetof(UBundleShrineConfig, bShowBundleTutorial) == 0x0000E2, "Member 'UBundleShrineConfig::bShowBundleTutorial' has a wrong offset!");

// Class Palia.VAL_GameplayUIBridgeInterface
// 0x0000 (0x0028 - 0x0028)
class IVAL_GameplayUIBridgeInterface final : public IInterface
{
public:
	void CloseMenuHub();
	void CloseSubgameScreen();
	void HandleGameplayAbilityActivated(class UValeriaGASGameplayAbility* GameplayAbility);
	void HandleGameplayAbilityDeactivated(class UValeriaGASGameplayAbility* GameplayAbility);
	bool HasAnyHousingPlotsTeleportOptions(class AVAL_TeleporterBase* Teleporter);
	void OpenAmmoMenu(EAmmoType AmmoType);
	void OpenBook(int32 BookId);
	void OpenBundleDropOffMenu(class UVAL_BundleShrineConfigAsset* BundleShrineConfigAsset);
	void OpenCommunityActivities();
	void OpenCrafter(class UCrafterComponent* CrafterComponent);
	void OpenCVarMenu();
	void OpenDyeConfirmation(EWishType WishType);
	void OpenFullscreenInventory();
	void OpenGameplayInteractiveModal(class UGameplayInteractivePopupDataAsset* PopupAsset);
	void OpenHomeTeleporter(class AVAL_TeleporterBase* Teleporter);
	void OpenHouseUpgrade(class ULevelerComponent* Leveler);
	void OpenHousingEdit(class AHousingPlotActor* HousingPlot);
	void OpenInteractStore(class UVillagerStoreConfig* StoreConfig);
	void OpenItemVariantCustomizer(class UItemVariantCustomizerComponent* Customizer);
	void OpenMailbox();
	void OpenMenuHub();
	void OpenNewsInbox();
	void OpenPaliaPass();
	void OpenPetBonus(TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Pet>>& Items);
	void OpenPlayerStorage();
	void OpenPremiumStore(struct FVAL_OpenStorePayload& Payload);
	void OpenRecipeInspiration();
	void OpenRepairStation(class AActor* RepairStationActor, bool bAllowPurchases, bool bAllowRepairKitsFromStorage);
	void OpenRequestItem(class FName TagName);
	void OpenShippingBin(class UShippingBinComponent* ShippingBinComponent);
	void OpenSignTeleporter(class AActor* TeleporterActor);
	void OpenStables(class AActor* StablesActor);
	void OpenSubgameScreen(class USubgameConfig* InSubgameConfig);
	void OpenTourBoard();
	void OpenWishView(TArray<struct FWishTreeEntry>& Wishes, class UVillagerWishDataAsset* VillagerWishOverride);
	void ToggleCollectionsMenu(EVAL_CollectionsTabState& TabState);
	void ToggleGameplayMenuMode(EVAL_GameplayMenuMode Mode);

	bool IsModalWidgetActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayUIBridgeInterface">();
	}
	static class IVAL_GameplayUIBridgeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVAL_GameplayUIBridgeInterface>();
	}
};
static_assert(alignof(IVAL_GameplayUIBridgeInterface) == 0x000008, "Wrong alignment on IVAL_GameplayUIBridgeInterface");
static_assert(sizeof(IVAL_GameplayUIBridgeInterface) == 0x000028, "Wrong size on IVAL_GameplayUIBridgeInterface");

// Class Palia.BTTask_CreatureDespawn
// 0x0008 (0x00A0 - 0x0098)
class UBTTask_CreatureDespawn final : public UBTTask_BlackboardBase
{
public:
	float                                         DespawnDuration;                                   // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InterruptDespawnOnHit;                             // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_246A[0x3];                                     // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CreatureDespawn">();
	}
	static class UBTTask_CreatureDespawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CreatureDespawn>();
	}
};
static_assert(alignof(UBTTask_CreatureDespawn) == 0x000008, "Wrong alignment on UBTTask_CreatureDespawn");
static_assert(sizeof(UBTTask_CreatureDespawn) == 0x0000A0, "Wrong size on UBTTask_CreatureDespawn");
static_assert(offsetof(UBTTask_CreatureDespawn, DespawnDuration) == 0x000098, "Member 'UBTTask_CreatureDespawn::DespawnDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureDespawn, InterruptDespawnOnHit) == 0x00009C, "Member 'UBTTask_CreatureDespawn::InterruptDespawnOnHit' has a wrong offset!");

// Class Palia.BTTask_CreatureDie
// 0x0000 (0x0070 - 0x0070)
class UBTTask_CreatureDie final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CreatureDie">();
	}
	static class UBTTask_CreatureDie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CreatureDie>();
	}
};
static_assert(alignof(UBTTask_CreatureDie) == 0x000008, "Wrong alignment on UBTTask_CreatureDie");
static_assert(sizeof(UBTTask_CreatureDie) == 0x000070, "Wrong size on UBTTask_CreatureDie");

// Class Palia.CinematicSequenceConfig
// 0x0120 (0x0150 - 0x0030)
class UCinematicSequenceConfig final : public UDataAsset
{
public:
	class FString                                 CinematicSequenceName;                             // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          LevelSequenceAsset;                                // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CinematicViewedTag;                                // 0x0068(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCinematicSequenceOptions              SequenceOptions;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCinematicAudioOptions                 AudioOptions;                                      // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCinematicLevelData                    LevelData;                                         // 0x0098(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCinSequenceSubtitlesConfig> SubtitleData;                                      // 0x0118(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          ActorObjectsToHide;                                // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicSequenceConfig">();
	}
	static class UCinematicSequenceConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinematicSequenceConfig>();
	}
};
static_assert(alignof(UCinematicSequenceConfig) == 0x000008, "Wrong alignment on UCinematicSequenceConfig");
static_assert(sizeof(UCinematicSequenceConfig) == 0x000150, "Wrong size on UCinematicSequenceConfig");
static_assert(offsetof(UCinematicSequenceConfig, CinematicSequenceName) == 0x000030, "Member 'UCinematicSequenceConfig::CinematicSequenceName' has a wrong offset!");
static_assert(offsetof(UCinematicSequenceConfig, LevelSequenceAsset) == 0x000040, "Member 'UCinematicSequenceConfig::LevelSequenceAsset' has a wrong offset!");
static_assert(offsetof(UCinematicSequenceConfig, CinematicViewedTag) == 0x000068, "Member 'UCinematicSequenceConfig::CinematicViewedTag' has a wrong offset!");
static_assert(offsetof(UCinematicSequenceConfig, SequenceOptions) == 0x000070, "Member 'UCinematicSequenceConfig::SequenceOptions' has a wrong offset!");
static_assert(offsetof(UCinematicSequenceConfig, AudioOptions) == 0x000080, "Member 'UCinematicSequenceConfig::AudioOptions' has a wrong offset!");
static_assert(offsetof(UCinematicSequenceConfig, LevelData) == 0x000098, "Member 'UCinematicSequenceConfig::LevelData' has a wrong offset!");
static_assert(offsetof(UCinematicSequenceConfig, SubtitleData) == 0x000118, "Member 'UCinematicSequenceConfig::SubtitleData' has a wrong offset!");
static_assert(offsetof(UCinematicSequenceConfig, ActorObjectsToHide) == 0x000140, "Member 'UCinematicSequenceConfig::ActorObjectsToHide' has a wrong offset!");

// Class Palia.ValeriaGASAttributeSet
// 0x0070 (0x00A0 - 0x0030)
class UValeriaGASAttributeSet final : public UAttributeSet
{
public:
	struct FGameplayAttributeData                 Health;                                            // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealth;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Stamina;                                           // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxStamina;                                        // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MovementSpeed;                                     // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHealthChanged;                                   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVitalsComponent*                       OwnerVitals;                                       // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideImmunity;                                 // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_246B[0x7];                                     // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Health(struct FGameplayAttributeData& OldValue);
	void OnRep_MaxHealth(struct FGameplayAttributeData& OldValue);
	void OnRep_MaxStamina(struct FGameplayAttributeData& OldValue);
	void OnRep_MovementSpeed(struct FGameplayAttributeData& OldValue);
	void OnRep_Stamina(struct FGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGASAttributeSet">();
	}
	static class UValeriaGASAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGASAttributeSet>();
	}
};
static_assert(alignof(UValeriaGASAttributeSet) == 0x000008, "Wrong alignment on UValeriaGASAttributeSet");
static_assert(sizeof(UValeriaGASAttributeSet) == 0x0000A0, "Wrong size on UValeriaGASAttributeSet");
static_assert(offsetof(UValeriaGASAttributeSet, Health) == 0x000030, "Member 'UValeriaGASAttributeSet::Health' has a wrong offset!");
static_assert(offsetof(UValeriaGASAttributeSet, MaxHealth) == 0x000040, "Member 'UValeriaGASAttributeSet::MaxHealth' has a wrong offset!");
static_assert(offsetof(UValeriaGASAttributeSet, Stamina) == 0x000050, "Member 'UValeriaGASAttributeSet::Stamina' has a wrong offset!");
static_assert(offsetof(UValeriaGASAttributeSet, MaxStamina) == 0x000060, "Member 'UValeriaGASAttributeSet::MaxStamina' has a wrong offset!");
static_assert(offsetof(UValeriaGASAttributeSet, MovementSpeed) == 0x000070, "Member 'UValeriaGASAttributeSet::MovementSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaGASAttributeSet, OnHealthChanged) == 0x000080, "Member 'UValeriaGASAttributeSet::OnHealthChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGASAttributeSet, OwnerVitals) == 0x000090, "Member 'UValeriaGASAttributeSet::OwnerVitals' has a wrong offset!");
static_assert(offsetof(UValeriaGASAttributeSet, bOverrideImmunity) == 0x000098, "Member 'UValeriaGASAttributeSet::bOverrideImmunity' has a wrong offset!");

// Class Palia.CameraTargetComponent
// 0x0060 (0x0100 - 0x00A0)
class UCameraTargetComponent final : public UActorComponent
{
public:
	class ACameraTargetActor*                     CameraActor;                                       // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCameraTarget                          Target;                                            // 0x00A8(0x0030)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           RefreshTargetsTimerHandle;                         // 0x00D8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_246C[0x20];                                    // 0x00E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_LookUp(float Rate);
	void Client_LookUpAtRate(float Rate);
	void Client_Turn(float Rate);
	void Client_TurnAtRate(float Rate);

	class AActor* GetTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraTargetComponent">();
	}
	static class UCameraTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraTargetComponent>();
	}
};
static_assert(alignof(UCameraTargetComponent) == 0x000008, "Wrong alignment on UCameraTargetComponent");
static_assert(sizeof(UCameraTargetComponent) == 0x000100, "Wrong size on UCameraTargetComponent");
static_assert(offsetof(UCameraTargetComponent, CameraActor) == 0x0000A0, "Member 'UCameraTargetComponent::CameraActor' has a wrong offset!");
static_assert(offsetof(UCameraTargetComponent, Target) == 0x0000A8, "Member 'UCameraTargetComponent::Target' has a wrong offset!");
static_assert(offsetof(UCameraTargetComponent, RefreshTargetsTimerHandle) == 0x0000D8, "Member 'UCameraTargetComponent::RefreshTargetsTimerHandle' has a wrong offset!");

// Class Palia.VillagerScheduleConfig
// 0x0050 (0x0080 - 0x0030)
class UVillagerScheduleConfig final : public UDataAsset
{
public:
	TMap<class FName, struct FVillagerScheduleActivity> VillagerScheduledActivities;                       // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	bool GetBestScheduleActivity(class UObject* Context, struct FVillagerScheduleActivity* OutBestScheduleActivity) const;
	const TMap<class FName, struct FVillagerScheduleActivity> GetVillagerScheduledActivities() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerScheduleConfig">();
	}
	static class UVillagerScheduleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerScheduleConfig>();
	}
};
static_assert(alignof(UVillagerScheduleConfig) == 0x000008, "Wrong alignment on UVillagerScheduleConfig");
static_assert(sizeof(UVillagerScheduleConfig) == 0x000080, "Wrong size on UVillagerScheduleConfig");
static_assert(offsetof(UVillagerScheduleConfig, VillagerScheduledActivities) == 0x000030, "Member 'UVillagerScheduleConfig::VillagerScheduledActivities' has a wrong offset!");

// Class Palia.BTTask_CreatureEscape
// 0x0008 (0x00A0 - 0x0098)
class UBTTask_CreatureEscape final : public UBTTask_BlackboardBase
{
public:
	float                                         NavAcceptanceRadius;                               // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReachTestIncludesAgentRadius;                     // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReachTestIncludesGoalRadius;                      // 0x009D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDelayBeforeDespawn;                               // 0x009E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldUseEscapeSpeedMultiplier;                   // 0x009F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleArrivedAtEscapeDestination(class UBehaviorTreeComponent* OwnerComp);
	void HandleEscapeDestinationLost(class UBehaviorTreeComponent* OwnerComp);
	void HandleFinishedDespawnDelay(class UBehaviorTreeComponent* OwnerComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CreatureEscape">();
	}
	static class UBTTask_CreatureEscape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CreatureEscape>();
	}
};
static_assert(alignof(UBTTask_CreatureEscape) == 0x000008, "Wrong alignment on UBTTask_CreatureEscape");
static_assert(sizeof(UBTTask_CreatureEscape) == 0x0000A0, "Wrong size on UBTTask_CreatureEscape");
static_assert(offsetof(UBTTask_CreatureEscape, NavAcceptanceRadius) == 0x000098, "Member 'UBTTask_CreatureEscape::NavAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEscape, bReachTestIncludesAgentRadius) == 0x00009C, "Member 'UBTTask_CreatureEscape::bReachTestIncludesAgentRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEscape, bReachTestIncludesGoalRadius) == 0x00009D, "Member 'UBTTask_CreatureEscape::bReachTestIncludesGoalRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEscape, bDelayBeforeDespawn) == 0x00009E, "Member 'UBTTask_CreatureEscape::bDelayBeforeDespawn' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEscape, bShouldUseEscapeSpeedMultiplier) == 0x00009F, "Member 'UBTTask_CreatureEscape::bShouldUseEscapeSpeedMultiplier' has a wrong offset!");

// Class Palia.VAL_DeductibleCondition
// 0x0008 (0x0048 - 0x0040)
class UVAL_DeductibleCondition : public UVAL_QuantityCondition
{
public:
	bool                                          bDeductOnComplete;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246E[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DeductibleCondition">();
	}
	static class UVAL_DeductibleCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DeductibleCondition>();
	}
};
static_assert(alignof(UVAL_DeductibleCondition) == 0x000008, "Wrong alignment on UVAL_DeductibleCondition");
static_assert(sizeof(UVAL_DeductibleCondition) == 0x000048, "Wrong size on UVAL_DeductibleCondition");
static_assert(offsetof(UVAL_DeductibleCondition, bDeductOnComplete) == 0x000040, "Member 'UVAL_DeductibleCondition::bDeductOnComplete' has a wrong offset!");

// Class Palia.VAL_HasItemTagCondition
// 0x0018 (0x0060 - 0x0048)
class UVAL_HasItemTagCondition final : public UVAL_DeductibleCondition
{
public:
	struct FGameplayTag                           RequiredTag;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlsoCheckStorage;                                 // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlsoCheckLockbox;                                 // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246F[0x2];                                     // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumQualityStars;                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   MinimumRarity;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2470[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasItemTagCondition">();
	}
	static class UVAL_HasItemTagCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasItemTagCondition>();
	}
};
static_assert(alignof(UVAL_HasItemTagCondition) == 0x000008, "Wrong alignment on UVAL_HasItemTagCondition");
static_assert(sizeof(UVAL_HasItemTagCondition) == 0x000060, "Wrong size on UVAL_HasItemTagCondition");
static_assert(offsetof(UVAL_HasItemTagCondition, RequiredTag) == 0x000048, "Member 'UVAL_HasItemTagCondition::RequiredTag' has a wrong offset!");
static_assert(offsetof(UVAL_HasItemTagCondition, bAlsoCheckStorage) == 0x000050, "Member 'UVAL_HasItemTagCondition::bAlsoCheckStorage' has a wrong offset!");
static_assert(offsetof(UVAL_HasItemTagCondition, bAlsoCheckLockbox) == 0x000051, "Member 'UVAL_HasItemTagCondition::bAlsoCheckLockbox' has a wrong offset!");
static_assert(offsetof(UVAL_HasItemTagCondition, MinimumQualityStars) == 0x000054, "Member 'UVAL_HasItemTagCondition::MinimumQualityStars' has a wrong offset!");
static_assert(offsetof(UVAL_HasItemTagCondition, MinimumRarity) == 0x000058, "Member 'UVAL_HasItemTagCondition::MinimumRarity' has a wrong offset!");

// Class Palia.BTTask_CreatureEvade
// 0x0038 (0x00D0 - 0x0098)
class UBTTask_CreatureEvade final : public UBTTask_BlackboardBase
{
public:
	float                                         PathRefreshFrequency;                              // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumTimeToEvade;                                // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaximumTimeToEvade;                                // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DistanceFromThreatsToStopEvading;                  // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PathDistanceToCompleteOnStopEvading;               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InitialDirectionAngleNoise;                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SubsequentAngleInterval;                           // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumEvadeTimeAfterTeleport;                     // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumViablePathDistance;                         // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetPathDistance;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinPauseTimeAfterEvadePathComplete;                // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxPauseTimeAfterEvadePathComplete;                // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NavAcceptanceRadius;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanInterrupt;                                     // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReachTestIncludesAgentRadius;                     // 0x00CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReachTestIncludesGoalRadius;                      // 0x00CE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseAdditionalRadomizedEvadeTime;                  // 0x00CF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CreatureEvade">();
	}
	static class UBTTask_CreatureEvade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CreatureEvade>();
	}
};
static_assert(alignof(UBTTask_CreatureEvade) == 0x000008, "Wrong alignment on UBTTask_CreatureEvade");
static_assert(sizeof(UBTTask_CreatureEvade) == 0x0000D0, "Wrong size on UBTTask_CreatureEvade");
static_assert(offsetof(UBTTask_CreatureEvade, PathRefreshFrequency) == 0x000098, "Member 'UBTTask_CreatureEvade::PathRefreshFrequency' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, MinimumTimeToEvade) == 0x00009C, "Member 'UBTTask_CreatureEvade::MinimumTimeToEvade' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, MaximumTimeToEvade) == 0x0000A0, "Member 'UBTTask_CreatureEvade::MaximumTimeToEvade' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, DistanceFromThreatsToStopEvading) == 0x0000A4, "Member 'UBTTask_CreatureEvade::DistanceFromThreatsToStopEvading' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, PathDistanceToCompleteOnStopEvading) == 0x0000A8, "Member 'UBTTask_CreatureEvade::PathDistanceToCompleteOnStopEvading' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, InitialDirectionAngleNoise) == 0x0000AC, "Member 'UBTTask_CreatureEvade::InitialDirectionAngleNoise' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, SubsequentAngleInterval) == 0x0000B0, "Member 'UBTTask_CreatureEvade::SubsequentAngleInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, MinimumEvadeTimeAfterTeleport) == 0x0000B4, "Member 'UBTTask_CreatureEvade::MinimumEvadeTimeAfterTeleport' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, MinimumViablePathDistance) == 0x0000B8, "Member 'UBTTask_CreatureEvade::MinimumViablePathDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, TargetPathDistance) == 0x0000BC, "Member 'UBTTask_CreatureEvade::TargetPathDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, MinPauseTimeAfterEvadePathComplete) == 0x0000C0, "Member 'UBTTask_CreatureEvade::MinPauseTimeAfterEvadePathComplete' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, MaxPauseTimeAfterEvadePathComplete) == 0x0000C4, "Member 'UBTTask_CreatureEvade::MaxPauseTimeAfterEvadePathComplete' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, NavAcceptanceRadius) == 0x0000C8, "Member 'UBTTask_CreatureEvade::NavAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, bCanInterrupt) == 0x0000CC, "Member 'UBTTask_CreatureEvade::bCanInterrupt' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, bReachTestIncludesAgentRadius) == 0x0000CD, "Member 'UBTTask_CreatureEvade::bReachTestIncludesAgentRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, bReachTestIncludesGoalRadius) == 0x0000CE, "Member 'UBTTask_CreatureEvade::bReachTestIncludesGoalRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_CreatureEvade, bUseAdditionalRadomizedEvadeTime) == 0x0000CF, "Member 'UBTTask_CreatureEvade::bUseAdditionalRadomizedEvadeTime' has a wrong offset!");

// Class Palia.VAL_PremiumStoreRequestSwitch
// 0x0078 (0x00A0 - 0x0028)
class UVAL_PremiumStoreRequestSwitch final : public UObject
{
public:
	uint8                                         Pad_2471[0x78];                                    // 0x0028(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PremiumStoreRequestSwitch">();
	}
	static class UVAL_PremiumStoreRequestSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PremiumStoreRequestSwitch>();
	}
};
static_assert(alignof(UVAL_PremiumStoreRequestSwitch) == 0x000008, "Wrong alignment on UVAL_PremiumStoreRequestSwitch");
static_assert(sizeof(UVAL_PremiumStoreRequestSwitch) == 0x0000A0, "Wrong size on UVAL_PremiumStoreRequestSwitch");

// Class Palia.BTTask_CreatureHitReact
// 0x0000 (0x0098 - 0x0098)
class UBTTask_CreatureHitReact final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CreatureHitReact">();
	}
	static class UBTTask_CreatureHitReact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CreatureHitReact>();
	}
};
static_assert(alignof(UBTTask_CreatureHitReact) == 0x000008, "Wrong alignment on UBTTask_CreatureHitReact");
static_assert(sizeof(UBTTask_CreatureHitReact) == 0x000098, "Wrong size on UBTTask_CreatureHitReact");

// Class Palia.BundleVaultComponent
// 0x0040 (0x00E0 - 0x00A0)
class UBundleVaultComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2472[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBundleShrineConfig*                    BundleConfig;                                      // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAL_BundleShrineConfigAsset*           BundleShrineConfigAsset;                           // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InteractText;                                      // 0x00B8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FPersistentTagWriteback>        PlayerTagWritebackOnInteract;                      // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Player, const struct FInteractEventParams& EventParams);
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);

	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BundleVaultComponent">();
	}
	static class UBundleVaultComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBundleVaultComponent>();
	}
};
static_assert(alignof(UBundleVaultComponent) == 0x000008, "Wrong alignment on UBundleVaultComponent");
static_assert(sizeof(UBundleVaultComponent) == 0x0000E0, "Wrong size on UBundleVaultComponent");
static_assert(offsetof(UBundleVaultComponent, BundleConfig) == 0x0000A8, "Member 'UBundleVaultComponent::BundleConfig' has a wrong offset!");
static_assert(offsetof(UBundleVaultComponent, BundleShrineConfigAsset) == 0x0000B0, "Member 'UBundleVaultComponent::BundleShrineConfigAsset' has a wrong offset!");
static_assert(offsetof(UBundleVaultComponent, InteractText) == 0x0000B8, "Member 'UBundleVaultComponent::InteractText' has a wrong offset!");
static_assert(offsetof(UBundleVaultComponent, PlayerTagWritebackOnInteract) == 0x0000D0, "Member 'UBundleVaultComponent::PlayerTagWritebackOnInteract' has a wrong offset!");

// Class Palia.BTTask_CreatureSpecialAbility
// 0x0000 (0x0098 - 0x0098)
class UBTTask_CreatureSpecialAbility final : public UBTTask_BlackboardBase
{
public:
	void HandleFinishedSpecialAbility(class UBehaviorTreeComponent* OwnerComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CreatureSpecialAbility">();
	}
	static class UBTTask_CreatureSpecialAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CreatureSpecialAbility>();
	}
};
static_assert(alignof(UBTTask_CreatureSpecialAbility) == 0x000008, "Wrong alignment on UBTTask_CreatureSpecialAbility");
static_assert(sizeof(UBTTask_CreatureSpecialAbility) == 0x000098, "Wrong size on UBTTask_CreatureSpecialAbility");

// Class Palia.ExperiencePackageConfig
// 0x00F0 (0x0120 - 0x0030)
class UExperiencePackageConfig final : public UPrimaryDataAsset
{
public:
	class FName                                   AssetCategoryName;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Map;                                               // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbleToReturnToWhereLeftOff;                       // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2477[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_EnvironmentProfileSet*             DefaultEnvironmentProfileSet;                      // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataLayerStatesConfig>  DataLayerConfig;                                   // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SpawnConfig;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FExperienceEventData>           ExperienceEventData;                               // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllowPlayerPlots;                                 // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2478[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTeleportTravelConfigAsset> DefaultDestination;                                // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTeleportTravelConfigAsset> InitialPrivateSpace;                               // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerStartTag;                                    // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevelopmentVersion;                                // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2479[0x4];                                     // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExperiencePackageConfig">();
	}
	static class UExperiencePackageConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExperiencePackageConfig>();
	}
};
static_assert(alignof(UExperiencePackageConfig) == 0x000008, "Wrong alignment on UExperiencePackageConfig");
static_assert(sizeof(UExperiencePackageConfig) == 0x000120, "Wrong size on UExperiencePackageConfig");
static_assert(offsetof(UExperiencePackageConfig, AssetCategoryName) == 0x000030, "Member 'UExperiencePackageConfig::AssetCategoryName' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, Map) == 0x000038, "Member 'UExperiencePackageConfig::Map' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, bAbleToReturnToWhereLeftOff) == 0x000060, "Member 'UExperiencePackageConfig::bAbleToReturnToWhereLeftOff' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, DefaultEnvironmentProfileSet) == 0x000068, "Member 'UExperiencePackageConfig::DefaultEnvironmentProfileSet' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, DataLayerConfig) == 0x000070, "Member 'UExperiencePackageConfig::DataLayerConfig' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, SpawnConfig) == 0x000098, "Member 'UExperiencePackageConfig::SpawnConfig' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, ExperienceEventData) == 0x0000A0, "Member 'UExperiencePackageConfig::ExperienceEventData' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, bAllowPlayerPlots) == 0x0000B0, "Member 'UExperiencePackageConfig::bAllowPlayerPlots' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, DefaultDestination) == 0x0000B8, "Member 'UExperiencePackageConfig::DefaultDestination' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, InitialPrivateSpace) == 0x0000E0, "Member 'UExperiencePackageConfig::InitialPrivateSpace' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, PlayerStartTag) == 0x000108, "Member 'UExperiencePackageConfig::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(UExperiencePackageConfig, DevelopmentVersion) == 0x000118, "Member 'UExperiencePackageConfig::DevelopmentVersion' has a wrong offset!");

// Class Palia.VAl_MatchmakingSettings
// 0x0318 (0x0350 - 0x0038)
class UVAl_MatchmakingSettings final : public UDeveloperSettings
{
public:
	float                                         MatchmakingTimeout;                                // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoinStatusInitialPingWaitTime;                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoinStatusPingWaitTime;                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_247A[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   JoinStatusValidErrorCodes;                         // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ClientNetworkOrTravelFailureText;                  // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersistFailureText;                                // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   AlreadyMatchmakingText;                            // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   InvalidPlayerText;                                 // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   RequestCreationFailedText;                         // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   RequestTicketCreationTimedOutText;                 // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   TicketCreationFailed;                              // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ServerRPCSendFailText;                             // 0x0140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   BeaconClientFailSpawnText;                         // 0x0158(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   BeaconClientFailedToConnectText;                   // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   TicketValidationTimedOutText;                      // 0x0188(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   TicketRejectedText;                                // 0x01A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PlayerControllerNotFound;                          // 0x01B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   KickedDueToNotAcceptedPlayerText;                  // 0x01D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   LoginQueueFailureText;                             // 0x01E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ServerRPCAuthInjectorFailText;                     // 0x0200(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ExitLoginQueueFailureText;                         // 0x0218(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ExitLoginQueueTimeOutText;                         // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   LoginQueueNumberText;                              // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FOSSVAL_MatchmakingCustomErrorContainer MatchmakingCustomErrorCodeTextTable;               // 0x0260(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FOSSVAL_MatchmakingCustomErrorContainer External_MatchmakingCustomErrorCodeTextTable;      // 0x02B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FOSSVAL_MatchmakingCustomErrorContainer Internal_MatchmakingCustomErrorCodeTextTable;      // 0x0300(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAl_MatchmakingSettings">();
	}
	static class UVAl_MatchmakingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAl_MatchmakingSettings>();
	}
};
static_assert(alignof(UVAl_MatchmakingSettings) == 0x000008, "Wrong alignment on UVAl_MatchmakingSettings");
static_assert(sizeof(UVAl_MatchmakingSettings) == 0x000350, "Wrong size on UVAl_MatchmakingSettings");
static_assert(offsetof(UVAl_MatchmakingSettings, MatchmakingTimeout) == 0x000038, "Member 'UVAl_MatchmakingSettings::MatchmakingTimeout' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, JoinStatusInitialPingWaitTime) == 0x00003C, "Member 'UVAl_MatchmakingSettings::JoinStatusInitialPingWaitTime' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, JoinStatusPingWaitTime) == 0x000040, "Member 'UVAl_MatchmakingSettings::JoinStatusPingWaitTime' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, JoinStatusValidErrorCodes) == 0x000048, "Member 'UVAl_MatchmakingSettings::JoinStatusValidErrorCodes' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, ClientNetworkOrTravelFailureText) == 0x000098, "Member 'UVAl_MatchmakingSettings::ClientNetworkOrTravelFailureText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, PersistFailureText) == 0x0000B0, "Member 'UVAl_MatchmakingSettings::PersistFailureText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, AlreadyMatchmakingText) == 0x0000C8, "Member 'UVAl_MatchmakingSettings::AlreadyMatchmakingText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, InvalidPlayerText) == 0x0000E0, "Member 'UVAl_MatchmakingSettings::InvalidPlayerText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, RequestCreationFailedText) == 0x0000F8, "Member 'UVAl_MatchmakingSettings::RequestCreationFailedText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, RequestTicketCreationTimedOutText) == 0x000110, "Member 'UVAl_MatchmakingSettings::RequestTicketCreationTimedOutText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, TicketCreationFailed) == 0x000128, "Member 'UVAl_MatchmakingSettings::TicketCreationFailed' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, ServerRPCSendFailText) == 0x000140, "Member 'UVAl_MatchmakingSettings::ServerRPCSendFailText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, BeaconClientFailSpawnText) == 0x000158, "Member 'UVAl_MatchmakingSettings::BeaconClientFailSpawnText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, BeaconClientFailedToConnectText) == 0x000170, "Member 'UVAl_MatchmakingSettings::BeaconClientFailedToConnectText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, TicketValidationTimedOutText) == 0x000188, "Member 'UVAl_MatchmakingSettings::TicketValidationTimedOutText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, TicketRejectedText) == 0x0001A0, "Member 'UVAl_MatchmakingSettings::TicketRejectedText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, PlayerControllerNotFound) == 0x0001B8, "Member 'UVAl_MatchmakingSettings::PlayerControllerNotFound' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, KickedDueToNotAcceptedPlayerText) == 0x0001D0, "Member 'UVAl_MatchmakingSettings::KickedDueToNotAcceptedPlayerText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, LoginQueueFailureText) == 0x0001E8, "Member 'UVAl_MatchmakingSettings::LoginQueueFailureText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, ServerRPCAuthInjectorFailText) == 0x000200, "Member 'UVAl_MatchmakingSettings::ServerRPCAuthInjectorFailText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, ExitLoginQueueFailureText) == 0x000218, "Member 'UVAl_MatchmakingSettings::ExitLoginQueueFailureText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, ExitLoginQueueTimeOutText) == 0x000230, "Member 'UVAl_MatchmakingSettings::ExitLoginQueueTimeOutText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, LoginQueueNumberText) == 0x000248, "Member 'UVAl_MatchmakingSettings::LoginQueueNumberText' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, MatchmakingCustomErrorCodeTextTable) == 0x000260, "Member 'UVAl_MatchmakingSettings::MatchmakingCustomErrorCodeTextTable' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, External_MatchmakingCustomErrorCodeTextTable) == 0x0002B0, "Member 'UVAl_MatchmakingSettings::External_MatchmakingCustomErrorCodeTextTable' has a wrong offset!");
static_assert(offsetof(UVAl_MatchmakingSettings, Internal_MatchmakingCustomErrorCodeTextTable) == 0x000300, "Member 'UVAl_MatchmakingSettings::Internal_MatchmakingCustomErrorCodeTextTable' has a wrong offset!");

// Class Palia.BTTask_CreatureStunned
// 0x0000 (0x0070 - 0x0070)
class UBTTask_CreatureStunned final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CreatureStunned">();
	}
	static class UBTTask_CreatureStunned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CreatureStunned>();
	}
};
static_assert(alignof(UBTTask_CreatureStunned) == 0x000008, "Wrong alignment on UBTTask_CreatureStunned");
static_assert(sizeof(UBTTask_CreatureStunned) == 0x000070, "Wrong size on UBTTask_CreatureStunned");

// Class Palia.VAL_HasRelationshipCondition
// 0x0018 (0x0048 - 0x0030)
class UVAL_HasRelationshipCondition final : public UVAL_GameplayConditionDef
{
public:
	struct FDataTableRowHandle                    VillagerCore;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ERelationshipType                             RelationshipType;                                  // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_247B[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelationshipLevel;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasRelationshipCondition">();
	}
	static class UVAL_HasRelationshipCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasRelationshipCondition>();
	}
};
static_assert(alignof(UVAL_HasRelationshipCondition) == 0x000008, "Wrong alignment on UVAL_HasRelationshipCondition");
static_assert(sizeof(UVAL_HasRelationshipCondition) == 0x000048, "Wrong size on UVAL_HasRelationshipCondition");
static_assert(offsetof(UVAL_HasRelationshipCondition, VillagerCore) == 0x000030, "Member 'UVAL_HasRelationshipCondition::VillagerCore' has a wrong offset!");
static_assert(offsetof(UVAL_HasRelationshipCondition, RelationshipType) == 0x000040, "Member 'UVAL_HasRelationshipCondition::RelationshipType' has a wrong offset!");
static_assert(offsetof(UVAL_HasRelationshipCondition, RelationshipLevel) == 0x000044, "Member 'UVAL_HasRelationshipCondition::RelationshipLevel' has a wrong offset!");

// Class Palia.BTTask_CreatureWander
// 0x0008 (0x0078 - 0x0070)
class UBTTask_CreatureWander final : public UBTTaskNode
{
public:
	float                                         WanderRadius;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_247C[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CreatureWander">();
	}
	static class UBTTask_CreatureWander* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CreatureWander>();
	}
};
static_assert(alignof(UBTTask_CreatureWander) == 0x000008, "Wrong alignment on UBTTask_CreatureWander");
static_assert(sizeof(UBTTask_CreatureWander) == 0x000078, "Wrong size on UBTTask_CreatureWander");
static_assert(offsetof(UBTTask_CreatureWander, WanderRadius) == 0x000070, "Member 'UBTTask_CreatureWander::WanderRadius' has a wrong offset!");

// Class Palia.ValeriaOutfitPostAnimInstance
// 0x0060 (0x03B0 - 0x0350)
class UValeriaOutfitPostAnimInstance final : public UAnimInstance
{
public:
	class AValeriaMoveablePawn*                   PawnOwner;                                         // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ExternalForce;                                     // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DynamicsAlphaCurve;                                // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingExternalForce;                              // 0x0370(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastFrameRightVector;                              // 0x0388(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterLinearForceMultiplier;                    // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterAngularForceMultiplier;                   // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_247D[0x8];                                     // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddExternalForce(const struct FVector& InForce);
	void ClearExternalForce();
	void ConsumePendingExternalForce();
	void UpdateLastFrameRightVector();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaOutfitPostAnimInstance">();
	}
	static class UValeriaOutfitPostAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaOutfitPostAnimInstance>();
	}
};
static_assert(alignof(UValeriaOutfitPostAnimInstance) == 0x000010, "Wrong alignment on UValeriaOutfitPostAnimInstance");
static_assert(sizeof(UValeriaOutfitPostAnimInstance) == 0x0003B0, "Wrong size on UValeriaOutfitPostAnimInstance");
static_assert(offsetof(UValeriaOutfitPostAnimInstance, PawnOwner) == 0x000348, "Member 'UValeriaOutfitPostAnimInstance::PawnOwner' has a wrong offset!");
static_assert(offsetof(UValeriaOutfitPostAnimInstance, ExternalForce) == 0x000350, "Member 'UValeriaOutfitPostAnimInstance::ExternalForce' has a wrong offset!");
static_assert(offsetof(UValeriaOutfitPostAnimInstance, DynamicsAlphaCurve) == 0x000368, "Member 'UValeriaOutfitPostAnimInstance::DynamicsAlphaCurve' has a wrong offset!");
static_assert(offsetof(UValeriaOutfitPostAnimInstance, PendingExternalForce) == 0x000370, "Member 'UValeriaOutfitPostAnimInstance::PendingExternalForce' has a wrong offset!");
static_assert(offsetof(UValeriaOutfitPostAnimInstance, LastFrameRightVector) == 0x000388, "Member 'UValeriaOutfitPostAnimInstance::LastFrameRightVector' has a wrong offset!");
static_assert(offsetof(UValeriaOutfitPostAnimInstance, CharacterLinearForceMultiplier) == 0x0003A0, "Member 'UValeriaOutfitPostAnimInstance::CharacterLinearForceMultiplier' has a wrong offset!");
static_assert(offsetof(UValeriaOutfitPostAnimInstance, CharacterAngularForceMultiplier) == 0x0003A4, "Member 'UValeriaOutfitPostAnimInstance::CharacterAngularForceMultiplier' has a wrong offset!");

// Class Palia.CardTable
// 0x0010 (0x02B8 - 0x02A8)
class ACardTable final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnSubgameStateChange;                              // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void HandleSubgameManagerChanged(class USubgameActivatorComponent* SubgameActivator, class USubgameManagerComponent* SubgameManager);
	void HandleSubgameStateChange(class USubgameManagerComponent* SubgameManager, ESubgameState CurrentState);
	void OnSubgameStateChange__DelegateSignature(class ACardTable* Table, ESubgameState CurrentState);

	ESubgameState GetSubgameState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CardTable">();
	}
	static class ACardTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACardTable>();
	}
};
static_assert(alignof(ACardTable) == 0x000008, "Wrong alignment on ACardTable");
static_assert(sizeof(ACardTable) == 0x0002B8, "Wrong size on ACardTable");
static_assert(offsetof(ACardTable, OnSubgameStateChange) == 0x0002A8, "Member 'ACardTable::OnSubgameStateChange' has a wrong offset!");

// Class Palia.VAL_KickPlayerAsyncStream
// 0x0020 (0x0048 - 0x0028)
class UVAL_KickPlayerAsyncStream final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnKickPlayerMessage;                               // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2480[0x10];                                    // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMessage(const class FString& Topic, TArray<uint8>& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_KickPlayerAsyncStream">();
	}
	static class UVAL_KickPlayerAsyncStream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_KickPlayerAsyncStream>();
	}
};
static_assert(alignof(UVAL_KickPlayerAsyncStream) == 0x000008, "Wrong alignment on UVAL_KickPlayerAsyncStream");
static_assert(sizeof(UVAL_KickPlayerAsyncStream) == 0x000048, "Wrong size on UVAL_KickPlayerAsyncStream");
static_assert(offsetof(UVAL_KickPlayerAsyncStream, OnKickPlayerMessage) == 0x000028, "Member 'UVAL_KickPlayerAsyncStream::OnKickPlayerMessage' has a wrong offset!");

// Class Palia.BTTask_PerformAbility
// 0x0008 (0x00A0 - 0x0098)
class UBTTask_PerformAbility final : public UBTTask_BlackboardBase
{
public:
	int32                                         AbilityIndexToPerform;                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityCooldown;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_PerformAbility">();
	}
	static class UBTTask_PerformAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_PerformAbility>();
	}
};
static_assert(alignof(UBTTask_PerformAbility) == 0x000008, "Wrong alignment on UBTTask_PerformAbility");
static_assert(sizeof(UBTTask_PerformAbility) == 0x0000A0, "Wrong size on UBTTask_PerformAbility");
static_assert(offsetof(UBTTask_PerformAbility, AbilityIndexToPerform) == 0x000098, "Member 'UBTTask_PerformAbility::AbilityIndexToPerform' has a wrong offset!");
static_assert(offsetof(UBTTask_PerformAbility, AbilityCooldown) == 0x00009C, "Member 'UBTTask_PerformAbility::AbilityCooldown' has a wrong offset!");

// Class Palia.BTTask_ReturnToIdle
// 0x0000 (0x0070 - 0x0070)
class UBTTask_ReturnToIdle final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ReturnToIdle">();
	}
	static class UBTTask_ReturnToIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ReturnToIdle>();
	}
};
static_assert(alignof(UBTTask_ReturnToIdle) == 0x000008, "Wrong alignment on UBTTask_ReturnToIdle");
static_assert(sizeof(UBTTask_ReturnToIdle) == 0x000070, "Wrong size on UBTTask_ReturnToIdle");

// Class Palia.InventoryComponent
// 0x0128 (0x01C8 - 0x00A0)
class UInventoryComponent : public UActorComponent
{
public:
	uint8                                         Pad_2481[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DefaultBagConfigIDs;                               // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInventoryBag>                  Bags;                                              // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	int32                                         ItemsCollected;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2482[0x4];                                     // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   TagsToTrackForStats;                               // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemAdded;                                       // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAfterItemAddedToInventory;                       // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInvFullErrorRequested;                           // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInventoryUpgraded;                               // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2483[0x28];                                    // 0x0140(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FValeriaItem>                   ItemAddedNotifQueue;                               // 0x0168(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2484[0x50];                                    // 0x0178(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddItem(const struct FValeriaItem& ItemToAdd, EInventoryAddItemFlags Param_Flags);
	int32 AddItemToBag(const struct FValeriaItem& ItemToAdd, EInventoryAddItemFlags Param_Flags, struct FGameplayTag& BagType);
	TArray<int32> GetBagIndicesMatchingBagTypes(TArray<struct FGameplayTag>& InBagTypes);
	struct FUseEventResult OnClientUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnRep_Bags();
	bool RemoveItem(struct FInventory_RemoveContext& RemoveContext);
	struct FValeriaItem RemoveItemByType(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 Amount);
	void RpcClient_ItemAdded(const struct FValeriaItem& Item);
	void RpcClient_OnAfterItemAddedToInventory(const struct FValeriaItem& Item);
	void RpcServer_CHEAT_AcquireBagType(EBagUpgradeType BagType);
	void RpcServer_CHEAT_RemoveBagType(EBagUpgradeType BagType);
	void RpcServer_RemoveAllItems(bool bIncludeTools);
	void RpcServer_SetActiveActionBarIndex(int32 RowIndex, int32 ColsPerRow);
	void SetActiveActionBarIndex(int32 RowIndex, int32 ColsPerRow);

	bool AreInventorySlotsFull() const;
	bool AreSlotsFull() const;
	bool AreStorageSlotsFull(bool bShouldCountOverflowSlots) const;
	bool CanAddItemFully(struct FValeriaItem& Item) const;
	bool CanAddItemsFully(TArray<struct FValeriaItem>& Items) const;
	bool CanAddItemTypeHere(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType) const;
	bool CanOverflowAddToInventory(struct FBagSlotLocation& OverflowItemLocation) const;
	bool CanStorageAddToInventory(struct FValeriaItem& Item) const;
	bool ContainsItemByCategory(EItemCategory ItemCategory) const;
	bool ContainsItemByTag(struct FGameplayTag& Tag) const;
	bool ContainsItemByType(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 Amount) const;
	bool ContainsItemByTypeOrTag(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, struct FGameplayTag& IngredientTag, int32 Amount, struct FGameplayTag& BagType) const;
	struct FBagSlotLocation FindItemByTag(struct FGameplayTag& ItemTag, bool bRequireStarQuality) const;
	struct FBagSlotLocation FindItemByTagInBag(struct FGameplayTag& ItemTag, struct FGameplayTag& BagTag, bool bRequireStarQuality) const;
	struct FBagSlotLocation FindItemByType(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, bool bRequireStarQuality) const;
	struct FBagSlotLocation FindItemByTypeAndVariant(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 TintPersistID, bool bRequireStarQuality) const;
	struct FBagSlotLocation FindItemByTypeInBag(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, struct FGameplayTag& BagTag, bool bRequireStarQuality) const;
	TArray<struct FValeriaItem> GetAllPlaceableItemsInBag(struct FGameplayTagContainer& IncludeTag, struct FGameplayTagContainer& ExcludeTag) const;
	int32 GetBagIndexForGamePlayTag(struct FGameplayTag& GameplayTag) const;
	struct FGameplayTag GetBagTypeAtActionBarIndex(int32 RowIndex, int32 ColumnIndex, int32 ColsPerRow) const;
	struct FGameplayTag GetBagTypeForBagIndex(int32 BagIndex) const;
	struct FValeriaItem GetItemAt(const struct FBagSlotLocation& Location) const;
	struct FValeriaItem GetItemAtActionBarIndex(int32 RowIndex, int32 ColumnIndex, int32 ColsPerRow) const;
	TArray<struct FValeriaItem> GetItemsWithTags(struct FGameplayTagContainer& IncludeTag, struct FGameplayTagContainer& ExcludeTag) const;
	struct FBagSlotLocation GetLocationAtActionBarIndex(int32 RowIndex, int32 ColumnIndex, int32 ColsPerRow) const;
	void GetNextValidItemInRowFromActionBarIndex(int32 RowIndex, int32 StartingColumnIndex, int32 ColsPerRow, bool bCanWrapAround, bool bForwardIterate, int32* OutColumnIndexFound, struct FValeriaItem* OutItemFound) const;
	int32 GetNumberOfActionBarRows(int32 ColsPerRow) const;
	int32 GetNumberOfOverflowSlots() const;
	class UStorageComponent* GetStorageComponent() const;
	TArray<struct FBagSlotLocation> GetToolsForToolWheel() const;
	int32 GetTotalMaxSlots() const;
	int32 GetTotalMaxSlotsForActionBar() const;
	int32 GetTotalMaxSlotsInBag(int32 BagIndex) const;
	bool IsBagInActionBar(int32 BagIndex) const;
	bool IsLocationInActiveActionBar(struct FBagSlotLocation& Location) const;
	bool IsShippingBin() const;
	int32 K2_GetItemAmountByTag(struct FGameplayTag& IngredientTag, struct FStarQualityConstraint& StarQualityConstraint) const;
	int32 K2_GetItemAmountByType(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, struct FStarQualityConstraint& StarQualityConstraint) const;
	void NotifyInventoryFull(class FText NotificationText) const;
	void NotifyInventoryUpgraded(class FText NotificationText) const;
	struct FNotification ShouldBlockGathering(class AValeriaCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x0001C8, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, DefaultBagConfigIDs) == 0x0000B8, "Member 'UInventoryComponent::DefaultBagConfigIDs' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, Bags) == 0x0000C8, "Member 'UInventoryComponent::Bags' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemsCollected) == 0x0000D8, "Member 'UInventoryComponent::ItemsCollected' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, TagsToTrackForStats) == 0x0000E0, "Member 'UInventoryComponent::TagsToTrackForStats' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemAdded) == 0x0000F0, "Member 'UInventoryComponent::OnItemAdded' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnAfterItemAddedToInventory) == 0x000100, "Member 'UInventoryComponent::OnAfterItemAddedToInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnChanged) == 0x000110, "Member 'UInventoryComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnInvFullErrorRequested) == 0x000120, "Member 'UInventoryComponent::OnInvFullErrorRequested' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnInventoryUpgraded) == 0x000130, "Member 'UInventoryComponent::OnInventoryUpgraded' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemAddedNotifQueue) == 0x000168, "Member 'UInventoryComponent::ItemAddedNotifQueue' has a wrong offset!");

// Class Palia.CrafterAutomaticInventoryComponent
// 0x0018 (0x01E0 - 0x01C8)
class UCrafterAutomaticInventoryComponent final : public UInventoryComponent
{
public:
	uint8                                         Pad_249E[0x10];                                    // 0x01C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrafterComponent_Automatic*            CrafterComponent;                                  // 0x01D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const struct FGameplayTag GetInputHopperBagType() const;
	class UCrafterComponent_Automatic* GetInventoryComponent() const;
	const struct FGameplayTag GetOutputHopperBagType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrafterAutomaticInventoryComponent">();
	}
	static class UCrafterAutomaticInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrafterAutomaticInventoryComponent>();
	}
};
static_assert(alignof(UCrafterAutomaticInventoryComponent) == 0x000008, "Wrong alignment on UCrafterAutomaticInventoryComponent");
static_assert(sizeof(UCrafterAutomaticInventoryComponent) == 0x0001E0, "Wrong size on UCrafterAutomaticInventoryComponent");
static_assert(offsetof(UCrafterAutomaticInventoryComponent, CrafterComponent) == 0x0001D8, "Member 'UCrafterAutomaticInventoryComponent::CrafterComponent' has a wrong offset!");

// Class Palia.VAL_PremiumStoreRequestPS5
// 0x0068 (0x0090 - 0x0028)
class UVAL_PremiumStoreRequestPS5 final : public UObject
{
public:
	uint8                                         Pad_249F[0x68];                                    // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PremiumStoreRequestPS5">();
	}
	static class UVAL_PremiumStoreRequestPS5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PremiumStoreRequestPS5>();
	}
};
static_assert(alignof(UVAL_PremiumStoreRequestPS5) == 0x000008, "Wrong alignment on UVAL_PremiumStoreRequestPS5");
static_assert(sizeof(UVAL_PremiumStoreRequestPS5) == 0x000090, "Wrong size on UVAL_PremiumStoreRequestPS5");

// Class Palia.BTTask_WaitCustom
// 0x0010 (0x0088 - 0x0078)
class UBTTask_WaitCustom final : public UBTTask_Wait
{
public:
	TArray<float>                                 AllowedWaitTimes;                                  // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_WaitCustom">();
	}
	static class UBTTask_WaitCustom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_WaitCustom>();
	}
};
static_assert(alignof(UBTTask_WaitCustom) == 0x000008, "Wrong alignment on UBTTask_WaitCustom");
static_assert(sizeof(UBTTask_WaitCustom) == 0x000088, "Wrong size on UBTTask_WaitCustom");
static_assert(offsetof(UBTTask_WaitCustom, AllowedWaitTimes) == 0x000078, "Member 'UBTTask_WaitCustom::AllowedWaitTimes' has a wrong offset!");

// Class Palia.GearSlotTypeConfig
// 0x0048 (0x0078 - 0x0030)
class UGearSlotTypeConfig final : public UDataAsset
{
public:
	int32                                         PersistId;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A0[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   GearSlotDescription;                               // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             GearSlotIcon;                                      // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GearSlotAmount;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisibleByDefault;                                // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeAutoEquippedOnFirstUse;                      // 0x0075(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A1[0x2];                                     // 0x0076(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GearSlotTypeConfig">();
	}
	static class UGearSlotTypeConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGearSlotTypeConfig>();
	}
};
static_assert(alignof(UGearSlotTypeConfig) == 0x000008, "Wrong alignment on UGearSlotTypeConfig");
static_assert(sizeof(UGearSlotTypeConfig) == 0x000078, "Wrong size on UGearSlotTypeConfig");
static_assert(offsetof(UGearSlotTypeConfig, PersistId) == 0x000030, "Member 'UGearSlotTypeConfig::PersistId' has a wrong offset!");
static_assert(offsetof(UGearSlotTypeConfig, DisplayName) == 0x000038, "Member 'UGearSlotTypeConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(UGearSlotTypeConfig, GearSlotDescription) == 0x000050, "Member 'UGearSlotTypeConfig::GearSlotDescription' has a wrong offset!");
static_assert(offsetof(UGearSlotTypeConfig, GearSlotIcon) == 0x000068, "Member 'UGearSlotTypeConfig::GearSlotIcon' has a wrong offset!");
static_assert(offsetof(UGearSlotTypeConfig, GearSlotAmount) == 0x000070, "Member 'UGearSlotTypeConfig::GearSlotAmount' has a wrong offset!");
static_assert(offsetof(UGearSlotTypeConfig, IsVisibleByDefault) == 0x000074, "Member 'UGearSlotTypeConfig::IsVisibleByDefault' has a wrong offset!");
static_assert(offsetof(UGearSlotTypeConfig, bCanBeAutoEquippedOnFirstUse) == 0x000075, "Member 'UGearSlotTypeConfig::bCanBeAutoEquippedOnFirstUse' has a wrong offset!");

// Class Palia.Bubble_Base
// 0x0068 (0x0310 - 0x02A8)
class ABubble_Base final : public AActor
{
public:
	class UValeriaGASComponent*                   ValeriaGASComponent;                               // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVitalsComponent*                       VitalsComponent;                                   // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULootComponent*                         LootComponent;                                     // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticipationTrackingComponent*        ParticipationTracking;                             // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UValeriaGASAttributeSet*                AttributeSet;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDeathComponent*                        DeathComponent;                                    // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifetimeSeconds;                                   // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatUpSpeed;                                      // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralMovementPeriod;                             // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralMovementDistance;                           // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSlowAmount;                               // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A2[0x3];                                     // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideSlowValue;                                 // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginalSpawnLocation;                             // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomPhaseShift;                                  // 0x0308(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A3[0x4];                                     // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleDeathServer(class UDeathComponent* InDeathComponent);
	void HandleDownedServer(class UVitalsComponent* Vitals);

	class UValeriaGASAttributeSet* GetAttributeSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bubble_Base">();
	}
	static class ABubble_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABubble_Base>();
	}
};
static_assert(alignof(ABubble_Base) == 0x000008, "Wrong alignment on ABubble_Base");
static_assert(sizeof(ABubble_Base) == 0x000310, "Wrong size on ABubble_Base");
static_assert(offsetof(ABubble_Base, ValeriaGASComponent) == 0x0002A8, "Member 'ABubble_Base::ValeriaGASComponent' has a wrong offset!");
static_assert(offsetof(ABubble_Base, VitalsComponent) == 0x0002B0, "Member 'ABubble_Base::VitalsComponent' has a wrong offset!");
static_assert(offsetof(ABubble_Base, LootComponent) == 0x0002B8, "Member 'ABubble_Base::LootComponent' has a wrong offset!");
static_assert(offsetof(ABubble_Base, ParticipationTracking) == 0x0002C0, "Member 'ABubble_Base::ParticipationTracking' has a wrong offset!");
static_assert(offsetof(ABubble_Base, AttributeSet) == 0x0002C8, "Member 'ABubble_Base::AttributeSet' has a wrong offset!");
static_assert(offsetof(ABubble_Base, DeathComponent) == 0x0002D0, "Member 'ABubble_Base::DeathComponent' has a wrong offset!");
static_assert(offsetof(ABubble_Base, LifetimeSeconds) == 0x0002D8, "Member 'ABubble_Base::LifetimeSeconds' has a wrong offset!");
static_assert(offsetof(ABubble_Base, FloatUpSpeed) == 0x0002DC, "Member 'ABubble_Base::FloatUpSpeed' has a wrong offset!");
static_assert(offsetof(ABubble_Base, LateralMovementPeriod) == 0x0002E0, "Member 'ABubble_Base::LateralMovementPeriod' has a wrong offset!");
static_assert(offsetof(ABubble_Base, LateralMovementDistance) == 0x0002E4, "Member 'ABubble_Base::LateralMovementDistance' has a wrong offset!");
static_assert(offsetof(ABubble_Base, bOverrideSlowAmount) == 0x0002E8, "Member 'ABubble_Base::bOverrideSlowAmount' has a wrong offset!");
static_assert(offsetof(ABubble_Base, OverrideSlowValue) == 0x0002EC, "Member 'ABubble_Base::OverrideSlowValue' has a wrong offset!");
static_assert(offsetof(ABubble_Base, OriginalSpawnLocation) == 0x0002F0, "Member 'ABubble_Base::OriginalSpawnLocation' has a wrong offset!");
static_assert(offsetof(ABubble_Base, RandomPhaseShift) == 0x000308, "Member 'ABubble_Base::RandomPhaseShift' has a wrong offset!");

// Class Palia.ValeriaEmoteComponent
// 0x00E8 (0x0188 - 0x00A0)
class UValeriaEmoteComponent final : public UActorComponent
{
public:
	uint8                                         Pad_24A4[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEquippedEmotesChanged;                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVALDATA_EmotePersistBlock             EmotePersistBlock;                                 // 0x00B8(0x0050)(Net, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             EmotePlaybackStarted;                              // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EmotePlaybackEnded;                                // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CanPlayEmotesOfType;                               // 0x0128(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EmoteCooldownTimeAmount;                           // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxEmotePoints;                                    // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24A5[0x4];                                     // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEmoteDataAsset*>                EquippedEmotes;                                    // 0x0138(0x0010)(Edit, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UEmoteDataAsset*>                DefaultEquippedEmotes;                             // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int64                                         CooldownExpirationTimestampMs;                     // 0x0158(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentEmotePoints;                                // 0x0160(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24A6[0x4];                                     // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActiveEmotePlaybackLog                CurrentEmotePlaying;                               // 0x0168(0x0010)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FTimerHandle>                   PendingCooldownHandles;                            // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	bool Client_AssignEmoteToWheel(int32 WheelIndex, struct FGuid& EmoteId);
	bool Client_ClearAssignedEmote(int32 WheelIndex);
	bool Client_ClearAssignedEmotes();
	bool Client_ResetAssignedEmotes();
	void EmptyAllEmotePointsCheat();
	TArray<class UEmoteDataAsset*> GetEquippedEmotes();
	void HandleEmotePlaybackInternal(class UEmoteDataAsset* EmoteData);
	void HandleEquipmentChanged(class UEquipmentComponent* EquipmentComponent, const struct FEquipmentItem& Item);
	void OnRep_EquippedEmotes();
	void OnRep_SimulatedEmotePlaying();
	bool PlayEmoteByAsset(class UEmoteDataAsset* EmoteDataAssetToPlay, const struct FPlayEmoteOptionalParams& OptionalParams);
	void PrepareNetworkEmoteData(class UEmoteDataAsset* EmoteData);
	void RefillAllEmotePointsCheat();
	void RequestPlaybackOfEmote(class UEmoteDataAsset* EmoteToPlay);
	void RpcClient_PlayEmote(class UEmoteDataAsset* EmoteDataAssetToPlay, const struct FPlayEmoteOptionalParams& OptionalParams);
	void SetEmotePointsToValue(int32 NewValue);
	void StopCurrentEmote();

	bool CanPlayOutEmote(class UEmoteDataAsset* EmoteData) const;
	bool DoesCharacterHaveEmoteCooldowns() const;
	float GetCooldownTimeMaximum() const;
	float GetCooldownTimeRemaining() const;
	int32 GetCurrentEmotePoints() const;
	int32 GetMaxEmotePoints() const;
	const class UEmoteDataAsset* GetPlayingEmoteDataAsset() const;
	bool HasEmotePoints() const;
	bool IsEmoteEquipped(class UEmoteDataAsset* Emote) const;
	bool IsEmoteEquippedById(struct FGuid& EmoteId) const;
	bool IsPlayingEmote() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaEmoteComponent">();
	}
	static class UValeriaEmoteComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaEmoteComponent>();
	}
};
static_assert(alignof(UValeriaEmoteComponent) == 0x000008, "Wrong alignment on UValeriaEmoteComponent");
static_assert(sizeof(UValeriaEmoteComponent) == 0x000188, "Wrong size on UValeriaEmoteComponent");
static_assert(offsetof(UValeriaEmoteComponent, OnEquippedEmotesChanged) == 0x0000A8, "Member 'UValeriaEmoteComponent::OnEquippedEmotesChanged' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, EmotePersistBlock) == 0x0000B8, "Member 'UValeriaEmoteComponent::EmotePersistBlock' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, EmotePlaybackStarted) == 0x000108, "Member 'UValeriaEmoteComponent::EmotePlaybackStarted' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, EmotePlaybackEnded) == 0x000118, "Member 'UValeriaEmoteComponent::EmotePlaybackEnded' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, CanPlayEmotesOfType) == 0x000128, "Member 'UValeriaEmoteComponent::CanPlayEmotesOfType' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, EmoteCooldownTimeAmount) == 0x00012C, "Member 'UValeriaEmoteComponent::EmoteCooldownTimeAmount' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, MaxEmotePoints) == 0x000130, "Member 'UValeriaEmoteComponent::MaxEmotePoints' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, EquippedEmotes) == 0x000138, "Member 'UValeriaEmoteComponent::EquippedEmotes' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, DefaultEquippedEmotes) == 0x000148, "Member 'UValeriaEmoteComponent::DefaultEquippedEmotes' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, CooldownExpirationTimestampMs) == 0x000158, "Member 'UValeriaEmoteComponent::CooldownExpirationTimestampMs' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, CurrentEmotePoints) == 0x000160, "Member 'UValeriaEmoteComponent::CurrentEmotePoints' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, CurrentEmotePlaying) == 0x000168, "Member 'UValeriaEmoteComponent::CurrentEmotePlaying' has a wrong offset!");
static_assert(offsetof(UValeriaEmoteComponent, PendingCooldownHandles) == 0x000178, "Member 'UValeriaEmoteComponent::PendingCooldownHandles' has a wrong offset!");

// Class Palia.BurstNetSpeedComponent
// 0x0010 (0x00B0 - 0x00A0)
class UBurstNetSpeedComponent final : public UActorComponent
{
public:
	int32                                         BurstNetSpeed;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BurstNetSpeedDuration;                             // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24AD[0x8];                                     // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableBurstOfNetSpeed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BurstNetSpeedComponent">();
	}
	static class UBurstNetSpeedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBurstNetSpeedComponent>();
	}
};
static_assert(alignof(UBurstNetSpeedComponent) == 0x000008, "Wrong alignment on UBurstNetSpeedComponent");
static_assert(sizeof(UBurstNetSpeedComponent) == 0x0000B0, "Wrong size on UBurstNetSpeedComponent");
static_assert(offsetof(UBurstNetSpeedComponent, BurstNetSpeed) == 0x0000A0, "Member 'UBurstNetSpeedComponent::BurstNetSpeed' has a wrong offset!");
static_assert(offsetof(UBurstNetSpeedComponent, BurstNetSpeedDuration) == 0x0000A4, "Member 'UBurstNetSpeedComponent::BurstNetSpeedDuration' has a wrong offset!");

// Class Palia.VAL_SequencerStandardBindingsDataAsset
// 0x0058 (0x0088 - 0x0030)
class UVAL_SequencerStandardBindingsDataAsset final : public UDataAsset
{
public:
	TMap<EVAL_CharacterBodyType, class FName>     StandardPlayerBindingsByBody;                      // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   StandardPlayerBindingDefault;                      // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_SequencerStandardBindingsDataAsset">();
	}
	static class UVAL_SequencerStandardBindingsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_SequencerStandardBindingsDataAsset>();
	}
};
static_assert(alignof(UVAL_SequencerStandardBindingsDataAsset) == 0x000008, "Wrong alignment on UVAL_SequencerStandardBindingsDataAsset");
static_assert(sizeof(UVAL_SequencerStandardBindingsDataAsset) == 0x000088, "Wrong size on UVAL_SequencerStandardBindingsDataAsset");
static_assert(offsetof(UVAL_SequencerStandardBindingsDataAsset, StandardPlayerBindingsByBody) == 0x000030, "Member 'UVAL_SequencerStandardBindingsDataAsset::StandardPlayerBindingsByBody' has a wrong offset!");
static_assert(offsetof(UVAL_SequencerStandardBindingsDataAsset, StandardPlayerBindingDefault) == 0x000080, "Member 'UVAL_SequencerStandardBindingsDataAsset::StandardPlayerBindingDefault' has a wrong offset!");

// Class Palia.BuffComponent
// 0x00A8 (0x0148 - 0x00A0)
class UBuffComponent final : public UActorComponent
{
public:
	uint8                                         Pad_24AE[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStarted;                                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStopped;                                         // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	TArray<struct FBuffActivation>                ActiveBuffs;                                       // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24AF[0x60];                                    // 0x00E8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddBuff(int32 BuffConfigId);
	void Client_AddSlimeTrailDebuff(int32 SlimeTier);
	void Client_ForceRemoveBuffInstance(int32 BuffInstanceId);
	void OnReplicatedAndShouldBroadcast();
	bool RemoveBuffByConfig(int32 BuffConfigId);
	bool RemoveBuffInstance(int32 InstanceId);
	void RpcServer_AddSlimeTrailDebuff(int32 SlimeTier);
	void RpcServer_CheatClearAllBuffs();
	void RpcServer_ForceRemoveBuffInstance(int32 BuffInstanceId);

	int32 ApplyEffectQuantifier(EBuffEffect Effect, int32 base) const;
	bool BuffIsActive(int32 InstanceId) const;
	float GetEffectQuantifier(EBuffEffect Effect) const;
	int32 GetInstanceId(int32 BuffConfigId) const;
	float GetPercentUsed(int32 InstanceId) const;
	float GetPercentUsedFromActivation(struct FBuffActivation& BuffActivation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffComponent">();
	}
	static class UBuffComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffComponent>();
	}
};
static_assert(alignof(UBuffComponent) == 0x000008, "Wrong alignment on UBuffComponent");
static_assert(sizeof(UBuffComponent) == 0x000148, "Wrong size on UBuffComponent");
static_assert(offsetof(UBuffComponent, OnChanged) == 0x0000A8, "Member 'UBuffComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UBuffComponent, OnStarted) == 0x0000B8, "Member 'UBuffComponent::OnStarted' has a wrong offset!");
static_assert(offsetof(UBuffComponent, OnStopped) == 0x0000C8, "Member 'UBuffComponent::OnStopped' has a wrong offset!");
static_assert(offsetof(UBuffComponent, ActiveBuffs) == 0x0000D8, "Member 'UBuffComponent::ActiveBuffs' has a wrong offset!");

// Class Palia.BuffGroupConfig
// 0x0000 (0x0030 - 0x0030)
class UBuffGroupConfig final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffGroupConfig">();
	}
	static class UBuffGroupConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffGroupConfig>();
	}
};
static_assert(alignof(UBuffGroupConfig) == 0x000008, "Wrong alignment on UBuffGroupConfig");
static_assert(sizeof(UBuffGroupConfig) == 0x000030, "Wrong size on UBuffGroupConfig");

// Class Palia.FishMinigameWaterBodyConfig
// 0x0018 (0x0048 - 0x0030)
class UFishMinigameWaterBodyConfig final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UFishMinigameSpawnPoolConfig>> SpawnPools;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         SpawnedQualityStars;                               // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24B6[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishMinigameWaterBodyConfig">();
	}
	static class UFishMinigameWaterBodyConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishMinigameWaterBodyConfig>();
	}
};
static_assert(alignof(UFishMinigameWaterBodyConfig) == 0x000008, "Wrong alignment on UFishMinigameWaterBodyConfig");
static_assert(sizeof(UFishMinigameWaterBodyConfig) == 0x000048, "Wrong size on UFishMinigameWaterBodyConfig");
static_assert(offsetof(UFishMinigameWaterBodyConfig, SpawnPools) == 0x000030, "Member 'UFishMinigameWaterBodyConfig::SpawnPools' has a wrong offset!");
static_assert(offsetof(UFishMinigameWaterBodyConfig, SpawnedQualityStars) == 0x000040, "Member 'UFishMinigameWaterBodyConfig::SpawnedQualityStars' has a wrong offset!");

// Class Palia.ValeriaGameMode
// 0x0280 (0x0610 - 0x0390)
class AValeriaGameMode : public AGameMode
{
public:
	float                                         MaxTimePerFrameToSpendSpawningPlaceables;          // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNumPlaceablesToSpawnPerBurst;                   // 0x0394(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNumPlaceablesToDestroyPerBurst;                 // 0x0398(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24B7[0x4];                                     // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerCharacterLoaded;                           // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24B8[0x8];                                     // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WorldId;                                           // 0x03B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPendingHousingPersistActorsQueue> PendingHousingPlotSpawnQueue;                      // 0x03C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_24B9[0x98];                                    // 0x03D8(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FPersistActorId, class AActor*>   PersistedActors;                                   // 0x0470(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FUniqueNetIdRepl, struct FPlayerLoadingData> LoadingPlayers;                                    // 0x04C0(0x0050)(NativeAccessSpecifierPrivate)
	class USpawnOnFoliageManager*                 SpawnOnFoliageManager;                             // 0x0510(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24BA[0x8];                                     // 0x0518(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FUniqueNetIdRepl, struct FTravelDestination> Destinations;                                      // 0x0520(0x0050)(NativeAccessSpecifierPrivate)
	struct FPersistActorsToDestroyQueue           PersistActorsToDestroy;                            // 0x0570(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bStartingLoadoutWasFound;                          // 0x05C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24BB[0x3];                                     // 0x05C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeTillNextDequeueAndSpawn;                       // 0x05C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_KickPlayerAsyncStream*             KickPlayerAsyncStream;                             // 0x05C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24BC[0x8];                                     // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDefaultDestinationsConfig*             DefaultDestinations;                               // 0x05D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24BD[0x30];                                    // 0x05E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleKickPlayerMessage(struct FVAL_AsyncMessageKickPlayer& KickPlayerMessage);
	void HandleLimitedEventStateChange(class ALimitedEventManagerBase* LimitedEventManager, bool bIsEventActive);
	void HandleMqttConnect(bool bSuccess);
	void OnPlayerCharacterLoaded__DelegateSignature(struct FGuid& CharacterId, struct FUniqueNetIdRepl& NetId);
	void PersistedActorWasDestroyed(class AActor* ActorDestroyed);
	void SpawnVillagers(class UDataTable* InVillagerSpawnConfigDataTable, class ULimitedEventDataAsset* InEventDataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGameMode">();
	}
	static class AValeriaGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaGameMode>();
	}
};
static_assert(alignof(AValeriaGameMode) == 0x000008, "Wrong alignment on AValeriaGameMode");
static_assert(sizeof(AValeriaGameMode) == 0x000610, "Wrong size on AValeriaGameMode");
static_assert(offsetof(AValeriaGameMode, MaxTimePerFrameToSpendSpawningPlaceables) == 0x000390, "Member 'AValeriaGameMode::MaxTimePerFrameToSpendSpawningPlaceables' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, MinNumPlaceablesToSpawnPerBurst) == 0x000394, "Member 'AValeriaGameMode::MinNumPlaceablesToSpawnPerBurst' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, MinNumPlaceablesToDestroyPerBurst) == 0x000398, "Member 'AValeriaGameMode::MinNumPlaceablesToDestroyPerBurst' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, OnPlayerCharacterLoaded) == 0x0003A0, "Member 'AValeriaGameMode::OnPlayerCharacterLoaded' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, WorldId) == 0x0003B8, "Member 'AValeriaGameMode::WorldId' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, PendingHousingPlotSpawnQueue) == 0x0003C8, "Member 'AValeriaGameMode::PendingHousingPlotSpawnQueue' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, PersistedActors) == 0x000470, "Member 'AValeriaGameMode::PersistedActors' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, LoadingPlayers) == 0x0004C0, "Member 'AValeriaGameMode::LoadingPlayers' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, SpawnOnFoliageManager) == 0x000510, "Member 'AValeriaGameMode::SpawnOnFoliageManager' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, Destinations) == 0x000520, "Member 'AValeriaGameMode::Destinations' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, PersistActorsToDestroy) == 0x000570, "Member 'AValeriaGameMode::PersistActorsToDestroy' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, bStartingLoadoutWasFound) == 0x0005C0, "Member 'AValeriaGameMode::bStartingLoadoutWasFound' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, TimeTillNextDequeueAndSpawn) == 0x0005C4, "Member 'AValeriaGameMode::TimeTillNextDequeueAndSpawn' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, KickPlayerAsyncStream) == 0x0005C8, "Member 'AValeriaGameMode::KickPlayerAsyncStream' has a wrong offset!");
static_assert(offsetof(AValeriaGameMode, DefaultDestinations) == 0x0005D8, "Member 'AValeriaGameMode::DefaultDestinations' has a wrong offset!");

// Class Palia.VillageValeriaGameMode
// 0x0008 (0x0618 - 0x0610)
class AVillageValeriaGameMode : public AValeriaGameMode
{
public:
	uint8                                         Pad_24BF[0x8];                                     // 0x0610(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillageValeriaGameMode">();
	}
	static class AVillageValeriaGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVillageValeriaGameMode>();
	}
};
static_assert(alignof(AVillageValeriaGameMode) == 0x000008, "Wrong alignment on AVillageValeriaGameMode");
static_assert(sizeof(AVillageValeriaGameMode) == 0x000618, "Wrong size on AVillageValeriaGameMode");

// Class Palia.VAL_TrailerRecordGameMode
// 0x0018 (0x0630 - 0x0618)
class AVAL_TrailerRecordGameMode final : public AVillageValeriaGameMode
{
public:
	bool                                          bCinematicMode;                                    // 0x0618(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidePlayer;                                       // 0x0619(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideHud;                                          // 0x061A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventMovement;                                  // 0x061B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventTurning;                                   // 0x061C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnVillagersOnSchedule;                         // 0x061D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C0[0x2];                                     // 0x061E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverrideWorldStartTimeHour;                        // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverrideWorldStartTimeMinute;                      // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideWorldStartNormalizedDayTime;               // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipStandardBeginPlay;                            // 0x062C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C1[0x3];                                     // 0x062D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWorldTimeForTrailer(int32 Hour, int32 Minute);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TrailerRecordGameMode">();
	}
	static class AVAL_TrailerRecordGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_TrailerRecordGameMode>();
	}
};
static_assert(alignof(AVAL_TrailerRecordGameMode) == 0x000008, "Wrong alignment on AVAL_TrailerRecordGameMode");
static_assert(sizeof(AVAL_TrailerRecordGameMode) == 0x000630, "Wrong size on AVAL_TrailerRecordGameMode");
static_assert(offsetof(AVAL_TrailerRecordGameMode, bCinematicMode) == 0x000618, "Member 'AVAL_TrailerRecordGameMode::bCinematicMode' has a wrong offset!");
static_assert(offsetof(AVAL_TrailerRecordGameMode, bHidePlayer) == 0x000619, "Member 'AVAL_TrailerRecordGameMode::bHidePlayer' has a wrong offset!");
static_assert(offsetof(AVAL_TrailerRecordGameMode, bHideHud) == 0x00061A, "Member 'AVAL_TrailerRecordGameMode::bHideHud' has a wrong offset!");
static_assert(offsetof(AVAL_TrailerRecordGameMode, bPreventMovement) == 0x00061B, "Member 'AVAL_TrailerRecordGameMode::bPreventMovement' has a wrong offset!");
static_assert(offsetof(AVAL_TrailerRecordGameMode, bPreventTurning) == 0x00061C, "Member 'AVAL_TrailerRecordGameMode::bPreventTurning' has a wrong offset!");
static_assert(offsetof(AVAL_TrailerRecordGameMode, bSpawnVillagersOnSchedule) == 0x00061D, "Member 'AVAL_TrailerRecordGameMode::bSpawnVillagersOnSchedule' has a wrong offset!");
static_assert(offsetof(AVAL_TrailerRecordGameMode, OverrideWorldStartTimeHour) == 0x000620, "Member 'AVAL_TrailerRecordGameMode::OverrideWorldStartTimeHour' has a wrong offset!");
static_assert(offsetof(AVAL_TrailerRecordGameMode, OverrideWorldStartTimeMinute) == 0x000624, "Member 'AVAL_TrailerRecordGameMode::OverrideWorldStartTimeMinute' has a wrong offset!");
static_assert(offsetof(AVAL_TrailerRecordGameMode, OverrideWorldStartNormalizedDayTime) == 0x000628, "Member 'AVAL_TrailerRecordGameMode::OverrideWorldStartNormalizedDayTime' has a wrong offset!");
static_assert(offsetof(AVAL_TrailerRecordGameMode, bSkipStandardBeginPlay) == 0x00062C, "Member 'AVAL_TrailerRecordGameMode::bSkipStandardBeginPlay' has a wrong offset!");

// Class Palia.ValeriaMoveablePawn
// 0x0190 (0x04C0 - 0x0330)
class AValeriaMoveablePawn : public APawn
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaBaseMovementComponent*          MovementComponent;                                 // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVisibilityComponent*                   VisibilityComponent;                               // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBasedMovementInfo                     BasedMovement;                                     // 0x0350(0x0050)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FBasedMovementInfo                     ReplicatedBasedMovement;                           // 0x03A0(0x0050)(Net, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         ReplicatedMovementMode;                            // 0x03F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInBaseReplication;                                // 0x03F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C2[0x6];                                     // 0x03F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMeshRelevancyToLocalPlayerUpdated;               // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsMeshRelevantToLocalPlayer;                      // 0x0408(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C3[0x3];                                     // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResyncMeshTimeRemaining;                           // 0x040C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DesyncMeshOriginalOffset;                          // 0x0410(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C4[0x8];                                     // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  DesyncMeshOriginalLocQuat;                         // 0x0430(0x0020)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bProxyIsJumpForceApplied : 1;                      // 0x0450(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPressedJump : 1;                                  // 0x0450(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientUpdating : 1;                               // 0x0450(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientWasFalling : 1;                             // 0x0450(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSimGravityDisabled : 1;                           // 0x0450(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientCheckEncroachmentOnNetUpdate : 1;           // 0x0450(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWasJumping : 1;                                   // 0x0450(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_24C5[0x3];                                     // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpKeyHoldTime;                                   // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForceTimeRemaining;                            // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProxyJumpForceStartedTime;                         // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpMaxHoldTime;                                   // 0x0460(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JumpMaxCount;                                      // 0x0464(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JumpCurrentCount;                                  // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JumpCurrentCountPreJump;                           // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C6[0x8];                                     // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReachedJumpApex;                                 // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C7[0x10];                                    // 0x0488(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             MovementModeChangedDelegate;                       // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterMovementUpdated;                        // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C8[0x8];                                     // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyMontageByMappingDelta(class FName& NewMappingName, class FName& OldMappingName, bool bSyncLoad);
	void ClientCheatFly();
	void ClientCheatGhost();
	void ClientCheatWalk();
	void DesyncMesh(bool bLocation, bool bRotation);
	void Jump();
	void K2_OnMovementModeChanged(EMovementMode PrevMovementMode, EMovementMode NewMovementMode, uint8 PrevCustomMode, uint8 NewCustomMode);
	void K2_UpdateCustomMovement(float DeltaTime);
	void LaunchCharacter(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride);
	void OnJumped();
	void OnLanded(struct FHitResult& Hit);
	void OnLaunched(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride);
	void OnRep_ReplicatedBasedMovement();
	void OnWalkingOffLedge(struct FVector& PreviousFloorImpactNormal, struct FVector& PreviousFloorContactNormal, struct FVector& PreviousLocation, float TimeDelta);
	float PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, class FName& StartSectionName);
	void PlayMontageByMapping(class FName& MappingName, float InPlayRate, class FName& StartSectionName, bool bCanHardJump, bool bSyncLoad);
	void ResyncMesh(float Duration);
	void StopAnimMontage(class UAnimMontage* AnimMontage);
	void StopJumping();
	void StopMontageByMapping(class FName& MappingName);

	bool CanJump() const;
	bool CanJumpInternal() const;
	class UAnimMontage* FindMontageByMapping(class FName& MappingName, class FName& MappingQualifier) const;
	class UAnimMontage* GetCurrentMontage() const;
	class FName GetLastUsedAnimMappingName() const;
	bool IsJumping() const;
	bool IsJumpProvidingForce() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaMoveablePawn">();
	}
	static class AValeriaMoveablePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaMoveablePawn>();
	}
};
static_assert(alignof(AValeriaMoveablePawn) == 0x000010, "Wrong alignment on AValeriaMoveablePawn");
static_assert(sizeof(AValeriaMoveablePawn) == 0x0004C0, "Wrong size on AValeriaMoveablePawn");
static_assert(offsetof(AValeriaMoveablePawn, Mesh) == 0x000330, "Member 'AValeriaMoveablePawn::Mesh' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, MovementComponent) == 0x000338, "Member 'AValeriaMoveablePawn::MovementComponent' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, CapsuleComponent) == 0x000340, "Member 'AValeriaMoveablePawn::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, VisibilityComponent) == 0x000348, "Member 'AValeriaMoveablePawn::VisibilityComponent' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, BasedMovement) == 0x000350, "Member 'AValeriaMoveablePawn::BasedMovement' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, ReplicatedBasedMovement) == 0x0003A0, "Member 'AValeriaMoveablePawn::ReplicatedBasedMovement' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, ReplicatedMovementMode) == 0x0003F0, "Member 'AValeriaMoveablePawn::ReplicatedMovementMode' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, bInBaseReplication) == 0x0003F1, "Member 'AValeriaMoveablePawn::bInBaseReplication' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, OnMeshRelevancyToLocalPlayerUpdated) == 0x0003F8, "Member 'AValeriaMoveablePawn::OnMeshRelevancyToLocalPlayerUpdated' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, bIsMeshRelevantToLocalPlayer) == 0x000408, "Member 'AValeriaMoveablePawn::bIsMeshRelevantToLocalPlayer' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, ResyncMeshTimeRemaining) == 0x00040C, "Member 'AValeriaMoveablePawn::ResyncMeshTimeRemaining' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, DesyncMeshOriginalOffset) == 0x000410, "Member 'AValeriaMoveablePawn::DesyncMeshOriginalOffset' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, DesyncMeshOriginalLocQuat) == 0x000430, "Member 'AValeriaMoveablePawn::DesyncMeshOriginalLocQuat' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, JumpKeyHoldTime) == 0x000454, "Member 'AValeriaMoveablePawn::JumpKeyHoldTime' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, JumpForceTimeRemaining) == 0x000458, "Member 'AValeriaMoveablePawn::JumpForceTimeRemaining' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, ProxyJumpForceStartedTime) == 0x00045C, "Member 'AValeriaMoveablePawn::ProxyJumpForceStartedTime' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, JumpMaxHoldTime) == 0x000460, "Member 'AValeriaMoveablePawn::JumpMaxHoldTime' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, JumpMaxCount) == 0x000464, "Member 'AValeriaMoveablePawn::JumpMaxCount' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, JumpCurrentCount) == 0x000468, "Member 'AValeriaMoveablePawn::JumpCurrentCount' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, JumpCurrentCountPreJump) == 0x00046C, "Member 'AValeriaMoveablePawn::JumpCurrentCountPreJump' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, OnReachedJumpApex) == 0x000478, "Member 'AValeriaMoveablePawn::OnReachedJumpApex' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, MovementModeChangedDelegate) == 0x000498, "Member 'AValeriaMoveablePawn::MovementModeChangedDelegate' has a wrong offset!");
static_assert(offsetof(AValeriaMoveablePawn, OnCharacterMovementUpdated) == 0x0004A8, "Member 'AValeriaMoveablePawn::OnCharacterMovementUpdated' has a wrong offset!");

// Class Palia.VAL_GameplayEventConditionState
// 0x0018 (0x0040 - 0x0028)
class UVAL_GameplayEventConditionState final : public UObject
{
public:
	int32                                         Count;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24CE[0x14];                                    // 0x002C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEventConditionState">();
	}
	static class UVAL_GameplayEventConditionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEventConditionState>();
	}
};
static_assert(alignof(UVAL_GameplayEventConditionState) == 0x000008, "Wrong alignment on UVAL_GameplayEventConditionState");
static_assert(sizeof(UVAL_GameplayEventConditionState) == 0x000040, "Wrong size on UVAL_GameplayEventConditionState");
static_assert(offsetof(UVAL_GameplayEventConditionState, Count) == 0x000028, "Member 'UVAL_GameplayEventConditionState::Count' has a wrong offset!");

// Class Palia.CreatureCharacter
// 0x0120 (0x05E0 - 0x04C0)
#pragma pack(push, 0x1)
class alignas(0x10) ACreatureCharacter : public AValeriaMoveablePawn
{
public:
	uint8                                         Pad_24CF[0x10];                                    // 0x04C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHealthChanged;                                   // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ECurrentBehavior                              CurrentBehavior;                                   // 0x04E0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D0[0x7];                                     // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    CreatureConfig;                                    // 0x04E8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnCreaturePathChangedEvents;               // 0x04F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDelayDestroyOnDeath;                              // 0x04F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCantEscape;                                       // 0x04FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D1[0x5];                                     // 0x04FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAICombatStateComponent*                CombatState;                                       // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULootComponent*                         LootComponent;                                     // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVitalsComponent*                       Vitals;                                            // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaGASComponent*                   ValeriaGAS;                                        // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDeathComponent*                        Death;                                             // 0x0520(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDespawnComponent*                      Despawn;                                           // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitReactComponent*                     HitReact;                                          // 0x0530(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticipationTrackingComponent*        ParticipationTracking;                             // 0x0538(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaGASAttributeSet*                AttributeSet;                                      // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHuntingCreatureTeleportComponent*      TeleportComponent;                                 // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMirrorImageSpawningComponent*          MirrorImageComponent;                              // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D2[0x8];                                     // 0x0558(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasBeenAlerted;                                   // 0x0560(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasValidEscapeDestination;                        // 0x0561(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D3[0x6];                                     // 0x0562(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCreatureAlertTriggered;                          // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCreatureEscapeDestinationLost;                   // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCreatureArrivedAtEscapeDestination;              // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCreatureDelayBeforeDespawnFinished;              // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCreatureSpecialAbilityFinished;                  // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bIsAnInsect;                                       // 0x05B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D4[0x3];                                     // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EscapeValueForInsectCatching;                      // 0x05BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EscapeValuePercentIncreasePerStar;                 // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EscapeValueFlatIncreasePerStar;                    // 0x05C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         QualityStars;                                      // 0x05C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D5[0x4];                                     // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DispelTag;                                         // 0x05D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DelayBeforeDespawn();
	void DoBehaviorMovement(ECurrentBehavior NewBehavior, const struct FRootMotionSource_MoveToForce& RootMotionSource);
	bool FindEscapeDestination(struct FVector* OutDestination);
	class UAICombatStateComponent* GetCombatState();
	class UDeathComponent* GetDeathComponent();
	class UDespawnComponent* GetDespawnComponent();
	class UValeriaGASComponent* GetGAS();
	class UHitReactComponent* GetHitReact();
	class UParticipationTrackingComponent* GetParticipationTracking();
	class UVitalsComponent* GetVitals();
	void HandleArrivedAtEscapeDestination(const struct FAIRequestID& RequestID, EPathFollowingResult Result);
	void HandleDeathServer(class UDeathComponent* DeathComponent);
	void HandleGameplayEffectAppliedToSelf(class UAbilitySystemComponent* Target, struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle);
	void NotifyEscapeDestinationFound();
	void NotifyEscapeDestinationLost();
	void NotifyEvadeStart();
	void NotifyEvadeStop();
	void OnCreatureKnockbackStarted(class AActor* Attacker, const struct FVector& KnockBackDirection, const struct FVector& FinalDestination);
	void OnCreaturesPathChanged(const struct FVector& StartPosition, const struct FVector& EndPosition);
	void OnCreatureWasAlerted();
	void RpcNetMulticast_NotifyEvadeStart();
	void RpcNetMulticast_NotifyEvadeStop();
	void RpcNetMulticast_OnPathChanged(const struct FVector& StartPosition, const struct FVector& EndPosition);
	void RpcNetMulticast_TriggerCreatureAlert();
	void Server_TryHidingDespawnTelemetry(class AActor* HidingSpotActor, bool HiddenSuccessfully, bool DisplacedDifferentCreature, const class FString& DisplacedCreatureClassName);
	void ServerNotifyEvadeStart();
	void ServerNotifyEvadeStop();
	void SkipCreatureAlert();
	void TriggerCreatureAlert();
	void TryDoSpecialAbility();

	float CalculateMaxSpeed() const;
	class UValeriaGASAttributeSet* GetAttributeSet() const;
	class ULootComponent* GetLootComponent() const;
	int32 GetQualityStars() const;
	bool HasBeenAlerted() const;
	bool IsDispelActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatureCharacter">();
	}
	static class ACreatureCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACreatureCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACreatureCharacter) == 0x000010, "Wrong alignment on ACreatureCharacter");
static_assert(sizeof(ACreatureCharacter) == 0x0005E0, "Wrong size on ACreatureCharacter");
static_assert(offsetof(ACreatureCharacter, OnHealthChanged) == 0x0004D0, "Member 'ACreatureCharacter::OnHealthChanged' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, CurrentBehavior) == 0x0004E0, "Member 'ACreatureCharacter::CurrentBehavior' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, CreatureConfig) == 0x0004E8, "Member 'ACreatureCharacter::CreatureConfig' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, bTriggerOnCreaturePathChangedEvents) == 0x0004F8, "Member 'ACreatureCharacter::bTriggerOnCreaturePathChangedEvents' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, bDelayDestroyOnDeath) == 0x0004F9, "Member 'ACreatureCharacter::bDelayDestroyOnDeath' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, bCantEscape) == 0x0004FA, "Member 'ACreatureCharacter::bCantEscape' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, CombatState) == 0x000500, "Member 'ACreatureCharacter::CombatState' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, LootComponent) == 0x000508, "Member 'ACreatureCharacter::LootComponent' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, Vitals) == 0x000510, "Member 'ACreatureCharacter::Vitals' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, ValeriaGAS) == 0x000518, "Member 'ACreatureCharacter::ValeriaGAS' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, Death) == 0x000520, "Member 'ACreatureCharacter::Death' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, Despawn) == 0x000528, "Member 'ACreatureCharacter::Despawn' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, HitReact) == 0x000530, "Member 'ACreatureCharacter::HitReact' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, ParticipationTracking) == 0x000538, "Member 'ACreatureCharacter::ParticipationTracking' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, AttributeSet) == 0x000540, "Member 'ACreatureCharacter::AttributeSet' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, TeleportComponent) == 0x000548, "Member 'ACreatureCharacter::TeleportComponent' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, MirrorImageComponent) == 0x000550, "Member 'ACreatureCharacter::MirrorImageComponent' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, bHasBeenAlerted) == 0x000560, "Member 'ACreatureCharacter::bHasBeenAlerted' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, bHasValidEscapeDestination) == 0x000561, "Member 'ACreatureCharacter::bHasValidEscapeDestination' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, OnCreatureAlertTriggered) == 0x000568, "Member 'ACreatureCharacter::OnCreatureAlertTriggered' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, OnCreatureEscapeDestinationLost) == 0x000578, "Member 'ACreatureCharacter::OnCreatureEscapeDestinationLost' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, OnCreatureArrivedAtEscapeDestination) == 0x000588, "Member 'ACreatureCharacter::OnCreatureArrivedAtEscapeDestination' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, OnCreatureDelayBeforeDespawnFinished) == 0x000598, "Member 'ACreatureCharacter::OnCreatureDelayBeforeDespawnFinished' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, OnCreatureSpecialAbilityFinished) == 0x0005A8, "Member 'ACreatureCharacter::OnCreatureSpecialAbilityFinished' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, bIsAnInsect) == 0x0005B8, "Member 'ACreatureCharacter::bIsAnInsect' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, EscapeValueForInsectCatching) == 0x0005BC, "Member 'ACreatureCharacter::EscapeValueForInsectCatching' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, EscapeValuePercentIncreasePerStar) == 0x0005C0, "Member 'ACreatureCharacter::EscapeValuePercentIncreasePerStar' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, EscapeValueFlatIncreasePerStar) == 0x0005C4, "Member 'ACreatureCharacter::EscapeValueFlatIncreasePerStar' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, QualityStars) == 0x0005C8, "Member 'ACreatureCharacter::QualityStars' has a wrong offset!");
static_assert(offsetof(ACreatureCharacter, DispelTag) == 0x0005D0, "Member 'ACreatureCharacter::DispelTag' has a wrong offset!");

// Class Palia.VAL_AsyncAction_Matchmaking
// 0x00C0 (0x00F0 - 0x0030)
class UVAL_AsyncAction_Matchmaking final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnResultObtained;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24DA[0x8];                                     // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOSSVAL_MatchmakingRequestContext      RequestContext;                                    // 0x0048(0x00A8)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UVAL_AsyncAction_Matchmaking* StartMatchmaking(class ULocalPlayer* LocalPlayer, struct FOSSVAL_MatchmakingRequestContext& Context);

	void OnResultObtained__DelegateSignature(struct FOSSVAL_MatchmakingRequestContext& Param_RequestContext, struct FOSSVAL_MatchmakingResult& Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AsyncAction_Matchmaking">();
	}
	static class UVAL_AsyncAction_Matchmaking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AsyncAction_Matchmaking>();
	}
};
static_assert(alignof(UVAL_AsyncAction_Matchmaking) == 0x000008, "Wrong alignment on UVAL_AsyncAction_Matchmaking");
static_assert(sizeof(UVAL_AsyncAction_Matchmaking) == 0x0000F0, "Wrong size on UVAL_AsyncAction_Matchmaking");
static_assert(offsetof(UVAL_AsyncAction_Matchmaking, OnResultObtained) == 0x000030, "Member 'UVAL_AsyncAction_Matchmaking::OnResultObtained' has a wrong offset!");
static_assert(offsetof(UVAL_AsyncAction_Matchmaking, RequestContext) == 0x000048, "Member 'UVAL_AsyncAction_Matchmaking::RequestContext' has a wrong offset!");

// Class Palia.BugCatchingCreatureCharacter
// 0x0030 (0x0610 - 0x05E0)
class ABugCatchingCreatureCharacter final : public ACreatureCharacter
{
public:
	FMulticastInlineDelegateProperty_             OnLODFeatureToggled;                               // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24DB[0x18];                                    // 0x05E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseLODFeatures;                                   // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24DC[0xF];                                     // 0x0601(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnChangedThrottleBucket(class UValeriaBaseMovementComponent* ValeriaMoveComponent);

	bool IsLODFeatureActive(EVAL_BugCatchingLODFeature Feature) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BugCatchingCreatureCharacter">();
	}
	static class ABugCatchingCreatureCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABugCatchingCreatureCharacter>();
	}
};
static_assert(alignof(ABugCatchingCreatureCharacter) == 0x000010, "Wrong alignment on ABugCatchingCreatureCharacter");
static_assert(sizeof(ABugCatchingCreatureCharacter) == 0x000610, "Wrong size on ABugCatchingCreatureCharacter");
static_assert(offsetof(ABugCatchingCreatureCharacter, OnLODFeatureToggled) == 0x0005D8, "Member 'ABugCatchingCreatureCharacter::OnLODFeatureToggled' has a wrong offset!");
static_assert(offsetof(ABugCatchingCreatureCharacter, bUseLODFeatures) == 0x000600, "Member 'ABugCatchingCreatureCharacter::bUseLODFeatures' has a wrong offset!");

// Class Palia.BugReportSubsystem
// 0x0068 (0x0098 - 0x0030)
class UBugReportSubsystem final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnFailedToReportBug;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24DD[0x58];                                    // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReportBug(const class FString& Summary);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BugReportSubsystem">();
	}
	static class UBugReportSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBugReportSubsystem>();
	}
};
static_assert(alignof(UBugReportSubsystem) == 0x000008, "Wrong alignment on UBugReportSubsystem");
static_assert(sizeof(UBugReportSubsystem) == 0x000098, "Wrong size on UBugReportSubsystem");
static_assert(offsetof(UBugReportSubsystem, OnFailedToReportBug) == 0x000030, "Member 'UBugReportSubsystem::OnFailedToReportBug' has a wrong offset!");

// Class Palia.VAL_KnowsRecipeCondition
// 0x0018 (0x0048 - 0x0030)
class UVAL_KnowsRecipeCondition final : public UVAL_GameplayConditionDef
{
public:
	struct FDataTableRowHandle                    Recipe;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EKnowsRecipeConditionStatus                   Status;                                            // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24DE[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_KnowsRecipeCondition">();
	}
	static class UVAL_KnowsRecipeCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_KnowsRecipeCondition>();
	}
};
static_assert(alignof(UVAL_KnowsRecipeCondition) == 0x000008, "Wrong alignment on UVAL_KnowsRecipeCondition");
static_assert(sizeof(UVAL_KnowsRecipeCondition) == 0x000048, "Wrong size on UVAL_KnowsRecipeCondition");
static_assert(offsetof(UVAL_KnowsRecipeCondition, Recipe) == 0x000030, "Member 'UVAL_KnowsRecipeCondition::Recipe' has a wrong offset!");
static_assert(offsetof(UVAL_KnowsRecipeCondition, Status) == 0x000040, "Member 'UVAL_KnowsRecipeCondition::Status' has a wrong offset!");

// Class Palia.VAL_ScoreDefinition
// 0x0030 (0x0088 - 0x0058)
class UVAL_ScoreDefinition final : public UVAL_DataAsset
{
public:
	bool                                          bIsLowScoreBetter;                                 // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepresentsTime;                                   // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMinValue;                                      // 0x005A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24DF[0x1];                                     // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinValue;                                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMaxValue;                                      // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E0[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxValue;                                          // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlwaysEnabled;                                  // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E1[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ScoresRequiredForAchievementProgress;              // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShouldBroadcastCourseCompletion;                  // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E2[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ScoreDefinition">();
	}
	static class UVAL_ScoreDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ScoreDefinition>();
	}
};
static_assert(alignof(UVAL_ScoreDefinition) == 0x000008, "Wrong alignment on UVAL_ScoreDefinition");
static_assert(sizeof(UVAL_ScoreDefinition) == 0x000088, "Wrong size on UVAL_ScoreDefinition");
static_assert(offsetof(UVAL_ScoreDefinition, bIsLowScoreBetter) == 0x000058, "Member 'UVAL_ScoreDefinition::bIsLowScoreBetter' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreDefinition, bRepresentsTime) == 0x000059, "Member 'UVAL_ScoreDefinition::bRepresentsTime' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreDefinition, bHasMinValue) == 0x00005A, "Member 'UVAL_ScoreDefinition::bHasMinValue' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreDefinition, MinValue) == 0x00005C, "Member 'UVAL_ScoreDefinition::MinValue' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreDefinition, bHasMaxValue) == 0x000060, "Member 'UVAL_ScoreDefinition::bHasMaxValue' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreDefinition, MaxValue) == 0x000064, "Member 'UVAL_ScoreDefinition::MaxValue' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreDefinition, bIsAlwaysEnabled) == 0x000068, "Member 'UVAL_ScoreDefinition::bIsAlwaysEnabled' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreDefinition, ScoresRequiredForAchievementProgress) == 0x000070, "Member 'UVAL_ScoreDefinition::ScoresRequiredForAchievementProgress' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreDefinition, bShouldBroadcastCourseCompletion) == 0x000080, "Member 'UVAL_ScoreDefinition::bShouldBroadcastCourseCompletion' has a wrong offset!");

// Class Palia.BundlesComponent
// 0x0090 (0x0130 - 0x00A0)
class UBundlesComponent final : public UActorComponent
{
public:
	uint8                                         Pad_24E3[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBundlePersistUpdated;                            // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBundleCompleted;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSubBundleCompleted;                              // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FBundlePersistBlock                    BundleProgressPersistBlock;                        // 0x00D8(0x0058)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void Client_Cheat_CompleteSubBundle(class UVAL_BundleShrineConfigAsset* BundleConfig, int32 SubBundleId);
	void Client_Cheat_GiveSubBundleRequirements(class UVAL_BundleShrineConfigAsset* BundleConfig, int32 SubBundleId);
	bool Client_GrantBundleRewards(TSoftObjectPtr<class UVAL_BundleShrineConfigAsset>& bundleConfigPtr, EValeriaFuncResult* OutResult);
	bool Client_GrantSubBundleRewards(TSoftObjectPtr<class UVAL_BundleShrineConfigAsset>& bundleConfigPtr, int32 SubBundleId, EValeriaFuncResult* OutResult);
	void Client_InitializeBundle(class UVAL_BundleShrineConfigAsset* BundleConfig);
	bool Client_RemoveAndApplyBundleItems(TSoftObjectPtr<class UVAL_BundleShrineConfigAsset>& bundleConfigPtr, int32 SubBundleId, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 Amount, EValeriaFuncResult* OutResult);
	void OnRep_BundlePersistBlock();
	void RpcClient_BundleCompleted(TSoftObjectPtr<class UVAL_BundleShrineConfigAsset>& BundleConfig);
	void RpcClient_SubBundleCompleted(TSoftObjectPtr<class UVAL_BundleShrineConfigAsset>& BundleConfig, int32 SubBundleId);
	void RpcServer_Cheat_CompleteSubBundle(class UVAL_BundleShrineConfigAsset* BundleConfig, int32 SubBundleId);
	void RpcServer_Cheat_GiveSubBundleRequirements(class UVAL_BundleShrineConfigAsset* BundleConfig, int32 SubBundleId);
	void RpcServer_GrantBundleRewards(TSoftObjectPtr<class UVAL_BundleShrineConfigAsset>& bundleConfigPtr);
	void RpcServer_GrantSubBundleRewards(TSoftObjectPtr<class UVAL_BundleShrineConfigAsset>& bundleConfigPtr, int32 SubBundleId);
	void RpcServer_InitializeBundle(class UVAL_BundleShrineConfigAsset* BundleConfig);
	void RpcServer_RemoveAndApplyBundleItems(TSoftObjectPtr<class UVAL_BundleShrineConfigAsset>& bundleConfigPtr, int32 SubBundleId, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 Amount);

	int32 GetSubBundleRequirementCompletedCount(int32 BundleId, int32 SubBundleId) const;
	int32 GetSubmittedItemCount(int32 BundleId, int32 SubBundleId, int32 RequirementId) const;
	bool IsBundleComplete(int32 BundleId) const;
	bool IsBundleRewardGranted(int32 BundleId) const;
	bool IsSubBundleComplete(int32 BundleId, int32 SubBundleId) const;
	bool IsSubBundleRequirementComplete(int32 BundleId, int32 SubBundleId, int32 RequirementId) const;
	bool IsSubBundleRewardGranted(int32 BundleId, int32 SubBundleId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BundlesComponent">();
	}
	static class UBundlesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBundlesComponent>();
	}
};
static_assert(alignof(UBundlesComponent) == 0x000008, "Wrong alignment on UBundlesComponent");
static_assert(sizeof(UBundlesComponent) == 0x000130, "Wrong size on UBundlesComponent");
static_assert(offsetof(UBundlesComponent, OnBundlePersistUpdated) == 0x0000A8, "Member 'UBundlesComponent::OnBundlePersistUpdated' has a wrong offset!");
static_assert(offsetof(UBundlesComponent, OnBundleCompleted) == 0x0000B8, "Member 'UBundlesComponent::OnBundleCompleted' has a wrong offset!");
static_assert(offsetof(UBundlesComponent, OnSubBundleCompleted) == 0x0000C8, "Member 'UBundlesComponent::OnSubBundleCompleted' has a wrong offset!");
static_assert(offsetof(UBundlesComponent, BundleProgressPersistBlock) == 0x0000D8, "Member 'UBundlesComponent::BundleProgressPersistBlock' has a wrong offset!");

// Class Palia.CreatureSpawnBoxComponent
// 0x0000 (0x05B0 - 0x05B0)
class UCreatureSpawnBoxComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatureSpawnBoxComponent">();
	}
	static class UCreatureSpawnBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreatureSpawnBoxComponent>();
	}
};
static_assert(alignof(UCreatureSpawnBoxComponent) == 0x000010, "Wrong alignment on UCreatureSpawnBoxComponent");
static_assert(sizeof(UCreatureSpawnBoxComponent) == 0x0005B0, "Wrong size on UCreatureSpawnBoxComponent");

// Class Palia.ValeriaGameUserSettings
// 0x01C0 (0x0308 - 0x0148)
class UValeriaGameUserSettings final : public UGameUserSettings
{
public:
	bool                                          bFirstRunSetupDone;                                // 0x0148(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstRunSetupNeedRestart;                         // 0x0149(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F5[0x2];                                     // 0x014A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FValeriaGameplaySettings               GameplaySettings;                                  // 0x014C(0x0018)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F6[0x4];                                     // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FValeriaInputSettings                  InputSettings;                                     // 0x0168(0x0038)(BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FValeriaAudioSettings                  AudioSettings;                                     // 0x01A0(0x0014)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FValeriaGraphicSettings                GraphicSettings;                                   // 0x01B4(0x0008)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F7[0x4];                                     // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FValeriaMenuSettings                   MenuSettings;                                      // 0x01C0(0x0058)(BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FValeriaLoginSettings                  LoginSettings;                                     // 0x0218(0x0010)(BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FValeriaPrivacySettings                PrivacySettings;                                   // 0x0228(0x0002)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FValeriaAccessibilitySettings          AccessbilitySettings;                              // 0x022A(0x0003)(BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          OnlyShowNewAnnouncements;                          // 0x022D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F8[0x2];                                     // 0x022E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastAnnouncementTimestamp;                         // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastStoreUpdateTimestamp;                          // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EulaAccepted;                                      // 0x0240(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrivacyPolicyAccepted;                             // 0x0241(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrossplayNotificationDisplayed;                   // 0x0242(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrossplayNotificationInChat;                      // 0x0243(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F9[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             InventorySettingsChanged;                          // 0x0248(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GraphicSettingsChanged;                            // 0x0258(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AudioSettingsChanged;                              // 0x0268(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChatSettingsChanged;                               // 0x0278(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             InputSettingsChanged;                              // 0x0288(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CameraSettingsChanged;                             // 0x0298(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ReticleSettingsChanged;                            // 0x02A8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MovementSettingsChanged;                           // 0x02B8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DebugSettingsChanged;                              // 0x02C8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MenuSettingsChanged;                               // 0x02D8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ServerSettingsChanged;                             // 0x02E8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AccessibilitySettingsChanged;                      // 0x02F8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static float ConvertMouseSensitivityConfigValueToSettingValue(float ConfigValue);
	static float ConvertMouseSensitivitySettingValueToConfigValue(float SettingValue);
	static class UValeriaGameUserSettings* GetValeriaGameUserSettings();

	bool GetFirstRunSetupNeedRestart();
	void Privacy_SetDefaultChannelsToOff(bool Off);
	void Privacy_SetHideSocialInformation(bool Hidden);
	void SetAllowCameraShake(bool Enable);
	void SetAllowEatingWhenFull(bool AllowEating);
	void SetCompletedQuestCategoryExpanded(bool bExpanded);
	void SetControllerAimSensitivityMultiplier(float SensitivityMultiplier);
	void SetControllerForceFeedbackScale(float Scale);
	void SetControllerXAxisSensitivity(float Sensitivity);
	void SetControllerYAxisSensitivity(float Sensitivity);
	void SetCrossplayNotificationDisplayed(bool bDisplayed);
	void SetCrossplayNotificationInChat(bool bDisplayed);
	void SetDialogueVolume(float Value);
	void SetEnableActionBarWrapping(bool EnableActionBarWrapping);
	void SetEnableCameraAssist(bool Enable);
	void SetEnableControllerForceFeedback(bool bEnable);
	void SetEnableReticle(bool Enable);
	void SetEnableWorldMapGrid(bool Enable);
	void SetEulaAccepted(bool Accepted);
	void SetFishingCastSpeed(float InFishingCastSpeed);
	void SetFOV(float Value);
	void SetGamma(float Value);
	void SetHideChatTimestamp(bool Enable);
	void SetHUDOpacity(EVAL_HUDOpacity HUDOpacityType);
	void SetInvertControllerXAxis(bool Enable);
	void SetInvertControllerYAxis(bool Enable);
	void SetInvertThumbstick(bool Enable);
	void SetInvertXAxis(bool Enable);
	void SetInvertYAxis(bool Enable);
	void SetLastAnnouncementTimestamp(const struct FDateTime& AnnouncementTimestamp);
	void SetLastLoginName(const class FString& LastLoginName);
	void SetLastSelectedQuestId(int32 InLastSelectedQuestId);
	void SetLastStoreUpdateTimestamp(const struct FDateTime& StoreUpdateTimestamp);
	void SetMaxGoldRepairSlider(bool MaxSlider);
	void SetMaxToolkitRepairSlider(bool MaxSlider);
	void SetMixProfile(EAudioMixProfiles AudioMixProfile);
	void SetMouseAimSensitivityMultiplier(float SensitivityMultiplier);
	void SetMouseSensitivity(float Sensitivity);
	void SetMusicVolume(float Value);
	void SetMuteFocus(bool MuteNotInFocus);
	void SetNumStorageBagsInActionBar(int32 NumStorageBags);
	void SetOnlyShowOnce(bool OnlyShowOnce);
	void SetOverallVolume(float Value);
	void SetPanningRule(EPanningRule PanningRule);
	void SetPrivacyPolicyAccepted(bool Accepted);
	void SetQuestCategoryExpanded(EVAL_QuestCategory InQuestCategory, bool bExpanded);
	void SetRepairAll(bool RepairAll);
	void SetShowCookingCamera(bool ShowCookingCamera);
	void SetShowServerPing(bool ShowServerPing);
	void SetSoundVolume(float Value);
	void SetSprintType(ESprintType SprintType);

	bool GetCompletedQuestCategoryExpanded() const;
	bool GetEnableCameraAssist() const;
	EVAL_HUDOpacity GetHUDOpacity() const;
	int32 GetLastSelectedQuestId() const;
	bool GetQuestCategoryExpanded(EVAL_QuestCategory InQuestCategory) const;
	bool GetShowCookingCamera() const;
	bool IsInvertThumbstick() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGameUserSettings">();
	}
	static class UValeriaGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGameUserSettings>();
	}
};
static_assert(alignof(UValeriaGameUserSettings) == 0x000008, "Wrong alignment on UValeriaGameUserSettings");
static_assert(sizeof(UValeriaGameUserSettings) == 0x000308, "Wrong size on UValeriaGameUserSettings");
static_assert(offsetof(UValeriaGameUserSettings, bFirstRunSetupDone) == 0x000148, "Member 'UValeriaGameUserSettings::bFirstRunSetupDone' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, bFirstRunSetupNeedRestart) == 0x000149, "Member 'UValeriaGameUserSettings::bFirstRunSetupNeedRestart' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, GameplaySettings) == 0x00014C, "Member 'UValeriaGameUserSettings::GameplaySettings' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, InputSettings) == 0x000168, "Member 'UValeriaGameUserSettings::InputSettings' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, AudioSettings) == 0x0001A0, "Member 'UValeriaGameUserSettings::AudioSettings' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, GraphicSettings) == 0x0001B4, "Member 'UValeriaGameUserSettings::GraphicSettings' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, MenuSettings) == 0x0001C0, "Member 'UValeriaGameUserSettings::MenuSettings' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, LoginSettings) == 0x000218, "Member 'UValeriaGameUserSettings::LoginSettings' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, PrivacySettings) == 0x000228, "Member 'UValeriaGameUserSettings::PrivacySettings' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, AccessbilitySettings) == 0x00022A, "Member 'UValeriaGameUserSettings::AccessbilitySettings' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, OnlyShowNewAnnouncements) == 0x00022D, "Member 'UValeriaGameUserSettings::OnlyShowNewAnnouncements' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, LastAnnouncementTimestamp) == 0x000230, "Member 'UValeriaGameUserSettings::LastAnnouncementTimestamp' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, LastStoreUpdateTimestamp) == 0x000238, "Member 'UValeriaGameUserSettings::LastStoreUpdateTimestamp' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, EulaAccepted) == 0x000240, "Member 'UValeriaGameUserSettings::EulaAccepted' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, PrivacyPolicyAccepted) == 0x000241, "Member 'UValeriaGameUserSettings::PrivacyPolicyAccepted' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, bCrossplayNotificationDisplayed) == 0x000242, "Member 'UValeriaGameUserSettings::bCrossplayNotificationDisplayed' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, bCrossplayNotificationInChat) == 0x000243, "Member 'UValeriaGameUserSettings::bCrossplayNotificationInChat' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, InventorySettingsChanged) == 0x000248, "Member 'UValeriaGameUserSettings::InventorySettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, GraphicSettingsChanged) == 0x000258, "Member 'UValeriaGameUserSettings::GraphicSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, AudioSettingsChanged) == 0x000268, "Member 'UValeriaGameUserSettings::AudioSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, ChatSettingsChanged) == 0x000278, "Member 'UValeriaGameUserSettings::ChatSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, InputSettingsChanged) == 0x000288, "Member 'UValeriaGameUserSettings::InputSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, CameraSettingsChanged) == 0x000298, "Member 'UValeriaGameUserSettings::CameraSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, ReticleSettingsChanged) == 0x0002A8, "Member 'UValeriaGameUserSettings::ReticleSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, MovementSettingsChanged) == 0x0002B8, "Member 'UValeriaGameUserSettings::MovementSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, DebugSettingsChanged) == 0x0002C8, "Member 'UValeriaGameUserSettings::DebugSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, MenuSettingsChanged) == 0x0002D8, "Member 'UValeriaGameUserSettings::MenuSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, ServerSettingsChanged) == 0x0002E8, "Member 'UValeriaGameUserSettings::ServerSettingsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameUserSettings, AccessibilitySettingsChanged) == 0x0002F8, "Member 'UValeriaGameUserSettings::AccessibilitySettingsChanged' has a wrong offset!");

// Class Palia.ChapaaChaseManager
// 0x01A0 (0x0448 - 0x02A8)
class AChapaaChaseManager final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnChapaaChaseStateChange;                          // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChapaaChaseCurrentGameChange;                    // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChapaaChaseParticipantChange;                    // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FCreatureSpawnEntry>            CreatureSpawnConfig;                               // 0x02D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MaxRunTimeSeconds;                                 // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCaptureGoal;                                   // 0x02EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FA[0x3];                                     // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GoalCapturesPerPlayer;                             // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWaveIntervalSeconds;                          // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinWaveCreatureSpawn;                              // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxWaveCreatureSpawn;                              // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CreatureSpawnPerPlayer;                            // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LimitCreaturesPerPlayer;                           // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLimitCreatures;                                 // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDelay;                                      // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCreaturesHeld;                                  // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupRewardPerCaughtChapaa;                        // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurrencyConfig*                        CurrencyToAward;                                   // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameStartTimestamp;                                // 0x0320(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FB[0xC];                                     // 0x0324(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_ItemTypeDefinitionAsset*           TempCreatureItemToEquip;                           // 0x0330(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameBestCreatureCapture;                       // 0x0338(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameTotalCreatureCapture;                      // 0x0348(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameBestScore;                                 // 0x0358(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameTotalScore;                                // 0x0368(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordPartyStats;                                 // 0x0378(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FC[0x7];                                     // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StatNameBestCreatureCapture_Party;                 // 0x0380(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameTotalCreatureCapture_Party;                // 0x0390(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FD[0x10];                                    // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EChappaChaseState                             CurrentState;                                      // 0x03B0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24FE[0x7];                                     // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          PlayerParticipationBox;                            // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCreatureSpawnBoxComponent*             DefaultSpawnBox;                                   // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    RootBillboard;                                     // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverridePlayerCount;                              // 0x03D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24FF[0x3];                                     // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverridePlayerCount;                               // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2500[0x38];                                    // 0x03D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChapaaChaseParticipant>        CurrentParticipantInfo;                            // 0x0410(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ACreatureCharacter*>             SpawnedCreatures;                                  // 0x0420(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2501[0x8];                                     // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentGameCaptureGoal;                            // 0x0438(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentGameCaptureCount;                           // 0x043C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentGameScore;                                  // 0x0440(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPreviousGameSuccess;                              // 0x0444(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2502[0x3];                                     // 0x0445(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 CaptureCreatures(class AValeriaPlayerController* Player);
	void HandleCreatureDestroyed(class AActor* DestroyedActor);
	void HandleParticipationBoxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void HandleParticipationBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void HandlePlayerEnteringCinematic(class AValeriaPlayerController* Player);
	void Initialize();
	void OnRep_CurrentGameInfo();
	void OnRep_CurrentParticipantInfo();
	void OnRep_CurrentState(EChappaChaseState OldState);
	bool PickUpCreature(class AValeriaPlayerController* Player, class ACreatureCharacter* Creature);
	void ProcessParticipantJoin();
	void SetEnableSpawning(bool bEnable);
	void SetState(EChappaChaseState NewState);
	bool Start();
	bool Stop();
	void TryDropCreatures(class AValeriaPlayerController* Player);

	bool CanPickUpCreature(class AValeriaPlayerController* Player, class ACreatureCharacter* Creature) const;
	TArray<struct FChapaaChaseParticipant> GetAllParticipants() const;
	TArray<struct FChapaaChaseParticipant> GetAllParticipantsSorted() const;
	int32 GetCreatureCaptureValue(TSubclassOf<class ACreatureCharacter> InCreatureClass) const;
	int32 GetCurrentGameCaptureCount() const;
	int32 GetCurrentGameCaptureGoal() const;
	int32 GetCurrentGameScore() const;
	int32 GetParticipantCreatureHeldCount(class AValeriaPlayerController* InPlayer) const;
	bool GetParticipantInfo(class AValeriaPlayerController* Player, struct FChapaaChaseParticipant* OutParticipantInfo) const;
	bool GetPreviousGameSuccess() const;
	EChappaChaseState GetState() const;
	bool IsInProgress() const;
	bool IsPlayerParticipating(const struct FChapaaChaseParticipant& Player) const;
	bool IsReadyToPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChapaaChaseManager">();
	}
	static class AChapaaChaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChapaaChaseManager>();
	}
};
static_assert(alignof(AChapaaChaseManager) == 0x000008, "Wrong alignment on AChapaaChaseManager");
static_assert(sizeof(AChapaaChaseManager) == 0x000448, "Wrong size on AChapaaChaseManager");
static_assert(offsetof(AChapaaChaseManager, OnChapaaChaseStateChange) == 0x0002A8, "Member 'AChapaaChaseManager::OnChapaaChaseStateChange' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, OnChapaaChaseCurrentGameChange) == 0x0002B8, "Member 'AChapaaChaseManager::OnChapaaChaseCurrentGameChange' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, OnChapaaChaseParticipantChange) == 0x0002C8, "Member 'AChapaaChaseManager::OnChapaaChaseParticipantChange' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, CreatureSpawnConfig) == 0x0002D8, "Member 'AChapaaChaseManager::CreatureSpawnConfig' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, MaxRunTimeSeconds) == 0x0002E8, "Member 'AChapaaChaseManager::MaxRunTimeSeconds' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, bUseCaptureGoal) == 0x0002EC, "Member 'AChapaaChaseManager::bUseCaptureGoal' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, GoalCapturesPerPlayer) == 0x0002F0, "Member 'AChapaaChaseManager::GoalCapturesPerPlayer' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, SpawnWaveIntervalSeconds) == 0x0002F4, "Member 'AChapaaChaseManager::SpawnWaveIntervalSeconds' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, MinWaveCreatureSpawn) == 0x0002F8, "Member 'AChapaaChaseManager::MinWaveCreatureSpawn' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, MaxWaveCreatureSpawn) == 0x0002FC, "Member 'AChapaaChaseManager::MaxWaveCreatureSpawn' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, CreatureSpawnPerPlayer) == 0x000300, "Member 'AChapaaChaseManager::CreatureSpawnPerPlayer' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, LimitCreaturesPerPlayer) == 0x000304, "Member 'AChapaaChaseManager::LimitCreaturesPerPlayer' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, MaxLimitCreatures) == 0x000308, "Member 'AChapaaChaseManager::MaxLimitCreatures' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, InitialDelay) == 0x00030C, "Member 'AChapaaChaseManager::InitialDelay' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, MaxCreaturesHeld) == 0x000310, "Member 'AChapaaChaseManager::MaxCreaturesHeld' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, GroupRewardPerCaughtChapaa) == 0x000314, "Member 'AChapaaChaseManager::GroupRewardPerCaughtChapaa' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, CurrencyToAward) == 0x000318, "Member 'AChapaaChaseManager::CurrencyToAward' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, GameStartTimestamp) == 0x000320, "Member 'AChapaaChaseManager::GameStartTimestamp' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, TempCreatureItemToEquip) == 0x000330, "Member 'AChapaaChaseManager::TempCreatureItemToEquip' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, StatNameBestCreatureCapture) == 0x000338, "Member 'AChapaaChaseManager::StatNameBestCreatureCapture' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, StatNameTotalCreatureCapture) == 0x000348, "Member 'AChapaaChaseManager::StatNameTotalCreatureCapture' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, StatNameBestScore) == 0x000358, "Member 'AChapaaChaseManager::StatNameBestScore' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, StatNameTotalScore) == 0x000368, "Member 'AChapaaChaseManager::StatNameTotalScore' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, bRecordPartyStats) == 0x000378, "Member 'AChapaaChaseManager::bRecordPartyStats' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, StatNameBestCreatureCapture_Party) == 0x000380, "Member 'AChapaaChaseManager::StatNameBestCreatureCapture_Party' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, StatNameTotalCreatureCapture_Party) == 0x000390, "Member 'AChapaaChaseManager::StatNameTotalCreatureCapture_Party' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, CurrentState) == 0x0003B0, "Member 'AChapaaChaseManager::CurrentState' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, PlayerParticipationBox) == 0x0003B8, "Member 'AChapaaChaseManager::PlayerParticipationBox' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, DefaultSpawnBox) == 0x0003C0, "Member 'AChapaaChaseManager::DefaultSpawnBox' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, RootBillboard) == 0x0003C8, "Member 'AChapaaChaseManager::RootBillboard' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, bOverridePlayerCount) == 0x0003D0, "Member 'AChapaaChaseManager::bOverridePlayerCount' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, OverridePlayerCount) == 0x0003D4, "Member 'AChapaaChaseManager::OverridePlayerCount' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, CurrentParticipantInfo) == 0x000410, "Member 'AChapaaChaseManager::CurrentParticipantInfo' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, SpawnedCreatures) == 0x000420, "Member 'AChapaaChaseManager::SpawnedCreatures' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, CurrentGameCaptureGoal) == 0x000438, "Member 'AChapaaChaseManager::CurrentGameCaptureGoal' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, CurrentGameCaptureCount) == 0x00043C, "Member 'AChapaaChaseManager::CurrentGameCaptureCount' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, CurrentGameScore) == 0x000440, "Member 'AChapaaChaseManager::CurrentGameScore' has a wrong offset!");
static_assert(offsetof(AChapaaChaseManager, bPreviousGameSuccess) == 0x000444, "Member 'AChapaaChaseManager::bPreviousGameSuccess' has a wrong offset!");

// Class Palia.CharacterCustomizationItemConfig
// 0x0028 (0x0050 - 0x0028)
class UCharacterCustomizationItemConfig final : public UObject
{
public:
	uint8                                         Pad_250C[0x4];                                     // 0x0028(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ECustomizationItemSlot                        ItemSlot;                                          // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250D[0x3];                                     // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Mesh;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBasicItem;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250E[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Weights;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCustomizationItemConfig">();
	}
	static class UCharacterCustomizationItemConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCustomizationItemConfig>();
	}
};
static_assert(alignof(UCharacterCustomizationItemConfig) == 0x000008, "Wrong alignment on UCharacterCustomizationItemConfig");
static_assert(sizeof(UCharacterCustomizationItemConfig) == 0x000050, "Wrong size on UCharacterCustomizationItemConfig");
static_assert(offsetof(UCharacterCustomizationItemConfig, ItemSlot) == 0x00002C, "Member 'UCharacterCustomizationItemConfig::ItemSlot' has a wrong offset!");
static_assert(offsetof(UCharacterCustomizationItemConfig, Mesh) == 0x000030, "Member 'UCharacterCustomizationItemConfig::Mesh' has a wrong offset!");
static_assert(offsetof(UCharacterCustomizationItemConfig, IsBasicItem) == 0x000038, "Member 'UCharacterCustomizationItemConfig::IsBasicItem' has a wrong offset!");
static_assert(offsetof(UCharacterCustomizationItemConfig, Weights) == 0x000040, "Member 'UCharacterCustomizationItemConfig::Weights' has a wrong offset!");

// Class Palia.ValeriaLocalPlayer
// 0x0078 (0x0338 - 0x02C0)
class UValeriaLocalPlayer final : public US6Core_LocalPlayer
{
public:
	class FString                                 GameLoginOptions;                                  // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectedCharacterChanged;                        // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPawnChanged;                                     // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FOSSVAL_SelectedCharacter              SelectedCharacter;                                 // 0x02F0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_250F[0x8];                                     // 0x0330(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnChanged__DelegateSignature(class APawn* Pawn);
	void OnSelectedCharacterChanged__DelegateSignature(struct FOSSVAL_SelectedCharacter& Param_SelectedCharacter);

	class APawn* GetCurrentPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaLocalPlayer">();
	}
	static class UValeriaLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaLocalPlayer>();
	}
};
static_assert(alignof(UValeriaLocalPlayer) == 0x000008, "Wrong alignment on UValeriaLocalPlayer");
static_assert(sizeof(UValeriaLocalPlayer) == 0x000338, "Wrong size on UValeriaLocalPlayer");
static_assert(offsetof(UValeriaLocalPlayer, GameLoginOptions) == 0x0002C0, "Member 'UValeriaLocalPlayer::GameLoginOptions' has a wrong offset!");
static_assert(offsetof(UValeriaLocalPlayer, OnSelectedCharacterChanged) == 0x0002D0, "Member 'UValeriaLocalPlayer::OnSelectedCharacterChanged' has a wrong offset!");
static_assert(offsetof(UValeriaLocalPlayer, OnPawnChanged) == 0x0002E0, "Member 'UValeriaLocalPlayer::OnPawnChanged' has a wrong offset!");
static_assert(offsetof(UValeriaLocalPlayer, SelectedCharacter) == 0x0002F0, "Member 'UValeriaLocalPlayer::SelectedCharacter' has a wrong offset!");

// Class Palia.ValeriaItemConfigBlueprintFunctions
// 0x0000 (0x0028 - 0x0028)
class UValeriaItemConfigBlueprintFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UCharacterCustomizationItemConfig* FromFullBodyConfig(class UObject* Context, const struct FCharacterCustomizationFullBodyConfig& FullBodyConfig);
	static class UCharacterCustomizationItemConfig* FromLegsConfig(class UObject* Context, const struct FCharacterCustomizationLegsConfig& LegsConfig);
	static class UCharacterCustomizationItemConfig* FromTorsoConfig(class UObject* Context, const struct FCharacterCustomizationTorsoConfig& TorsoConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaItemConfigBlueprintFunctions">();
	}
	static class UValeriaItemConfigBlueprintFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaItemConfigBlueprintFunctions>();
	}
};
static_assert(alignof(UValeriaItemConfigBlueprintFunctions) == 0x000008, "Wrong alignment on UValeriaItemConfigBlueprintFunctions");
static_assert(sizeof(UValeriaItemConfigBlueprintFunctions) == 0x000028, "Wrong size on UValeriaItemConfigBlueprintFunctions");

// Class Palia.ValeriaReplicationGraphNode_HousingPlot
// 0x0000 (0x0050 - 0x0050)
class UValeriaReplicationGraphNode_HousingPlot final : public UReplicationGraphNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaReplicationGraphNode_HousingPlot">();
	}
	static class UValeriaReplicationGraphNode_HousingPlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaReplicationGraphNode_HousingPlot>();
	}
};
static_assert(alignof(UValeriaReplicationGraphNode_HousingPlot) == 0x000008, "Wrong alignment on UValeriaReplicationGraphNode_HousingPlot");
static_assert(sizeof(UValeriaReplicationGraphNode_HousingPlot) == 0x000050, "Wrong size on UValeriaReplicationGraphNode_HousingPlot");

// Class Palia.TimedBaseComponent
// 0x0038 (0x00D8 - 0x00A0)
class UTimedBaseComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCooldownStatusChanged;                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ECooldownTimerType                            CooldownType;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2510[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumDaysCooldown;                                   // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CooldownLengthSecs;                                // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCooldownComplete;                                 // 0x00BC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2511[0x1B];                                    // 0x00BD(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bCooldownComplete();
	void Server_UpdateLastResetTimestamp();
	void UpdateLastResetTimestamp();

	int64 GetCooldownTimeRemainingMs() const;
	int64 GetLastResetTimestamp() const;
	bool IsCooldownComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedBaseComponent">();
	}
	static class UTimedBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedBaseComponent>();
	}
};
static_assert(alignof(UTimedBaseComponent) == 0x000008, "Wrong alignment on UTimedBaseComponent");
static_assert(sizeof(UTimedBaseComponent) == 0x0000D8, "Wrong size on UTimedBaseComponent");
static_assert(offsetof(UTimedBaseComponent, OnCooldownStatusChanged) == 0x0000A0, "Member 'UTimedBaseComponent::OnCooldownStatusChanged' has a wrong offset!");
static_assert(offsetof(UTimedBaseComponent, CooldownType) == 0x0000B0, "Member 'UTimedBaseComponent::CooldownType' has a wrong offset!");
static_assert(offsetof(UTimedBaseComponent, NumDaysCooldown) == 0x0000B4, "Member 'UTimedBaseComponent::NumDaysCooldown' has a wrong offset!");
static_assert(offsetof(UTimedBaseComponent, CooldownLengthSecs) == 0x0000B8, "Member 'UTimedBaseComponent::CooldownLengthSecs' has a wrong offset!");
static_assert(offsetof(UTimedBaseComponent, bCooldownComplete) == 0x0000BC, "Member 'UTimedBaseComponent::bCooldownComplete' has a wrong offset!");

// Class Palia.CharacterRespecComponent
// 0x0010 (0x00E8 - 0x00D8)
class UCharacterRespecComponent final : public UTimedBaseComponent
{
public:
	TWeakObjectPtr<class UVAL_CharacterCustomizationComponent> CharCustComp;                                      // 0x00D8(0x0008)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2512[0x8];                                     // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CharacterCustomizationComponentSet();
	void SetCharacterCustomizationComponent(class UVAL_CharacterCustomizationComponent* Param_CharCustComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterRespecComponent">();
	}
	static class UCharacterRespecComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterRespecComponent>();
	}
};
static_assert(alignof(UCharacterRespecComponent) == 0x000008, "Wrong alignment on UCharacterRespecComponent");
static_assert(sizeof(UCharacterRespecComponent) == 0x0000E8, "Wrong size on UCharacterRespecComponent");
static_assert(offsetof(UCharacterRespecComponent, CharCustComp) == 0x0000D8, "Member 'UCharacterRespecComponent::CharCustComp' has a wrong offset!");

// Class Palia.ValeriaPetCharacter
// 0x0000 (0x04C0 - 0x04C0)
class AValeriaPetCharacter final : public AValeriaMoveablePawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaPetCharacter">();
	}
	static class AValeriaPetCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaPetCharacter>();
	}
};
static_assert(alignof(AValeriaPetCharacter) == 0x000010, "Wrong alignment on AValeriaPetCharacter");
static_assert(sizeof(AValeriaPetCharacter) == 0x0004C0, "Wrong size on AValeriaPetCharacter");

// Class Palia.CharacterStateChangeInteraction
// 0x0040 (0x00E0 - 0x00A0)
class UCharacterStateChangeInteraction final : public UActorComponent
{
public:
	uint8                                         Pad_2513[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimState                             AnimState;                                         // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	ECharacterState                               CharacterState;                                    // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2514[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);

	bool CheckCanGather(class AValeriaCharacter* Character) const;
	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStateChangeInteraction">();
	}
	static class UCharacterStateChangeInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStateChangeInteraction>();
	}
};
static_assert(alignof(UCharacterStateChangeInteraction) == 0x000008, "Wrong alignment on UCharacterStateChangeInteraction");
static_assert(sizeof(UCharacterStateChangeInteraction) == 0x0000E0, "Wrong size on UCharacterStateChangeInteraction");
static_assert(offsetof(UCharacterStateChangeInteraction, AnimState) == 0x0000A8, "Member 'UCharacterStateChangeInteraction::AnimState' has a wrong offset!");
static_assert(offsetof(UCharacterStateChangeInteraction, CharacterState) == 0x0000C0, "Member 'UCharacterStateChangeInteraction::CharacterState' has a wrong offset!");
static_assert(offsetof(UCharacterStateChangeInteraction, Text) == 0x0000C8, "Member 'UCharacterStateChangeInteraction::Text' has a wrong offset!");

// Class Palia.CharacterStateMachineComponent
// 0x0130 (0x01D0 - 0x00A0)
class UCharacterStateMachineComponent final : public UActorComponent
{
public:
	uint8                                         Pad_251B[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharacterStateChanged;                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitingCharacterState;                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnteredCharacterState;                           // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AValeriaCharacter*                      CachedCharacter;                                   // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UValeriaCharacterMoveComponent*         CachedMovement;                                    // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251C[0xD8];                                    // 0x00E8(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECharacterState>                       CurrentStateStack;                                 // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	bool ChangeState(ECharacterState NewState, const struct FCharacterStateChangeParams& Params_0);
	void EndState(ECharacterState StateTypeToEnd, const struct FCharacterStateChangeParams& Params_0);
	void OnControllerAttachedToCharacter(class AValeriaPlayerController* Player, class AValeriaCharacter* Character);
	void OnEnteredCharacterState__DelegateSignature(class UCharacterStateMachineComponent* Csm, struct FCharacterStateChangeParams& Params_0, TArray<ECharacterState>& StatesExited, ECharacterState StateEntered);
	void OnExitingCharacterState__DelegateSignature(class UCharacterStateMachineComponent* Csm, struct FCharacterStateChangeParams& Params_0, ECharacterState StateBeingExited, ECharacterState StateBeingEntered);
	void RevertToWorldState();
	void RpcClient_ChangeState(ECharacterState State, const struct FCharacterStateChangeParams& Params_0);
	void RpcClient_EndState(ECharacterState State, const struct FCharacterStateChangeParams& Params_0);
	void RpcClient_RevertToWorldState();
	void RpcClient_ToggleState(ECharacterState State, const struct FCharacterStateChangeParams& Params_0);
	void RpcServer_ChangeMovementMode(ECharacterMoveMode Mode);
	void ToggleState(ECharacterState StateTypeToToggle, const struct FCharacterStateChangeParams& Params_0);

	bool AllowDashCancelling() const;
	bool CanChangeActionBar() const;
	bool CanSprint() const;
	bool CanTransitionTo(ECharacterState State) const;
	bool CanTriggerAbility() const;
	bool CustomCameraControl() const;
	bool FishingInputIsEnabled() const;
	ECharacterState GetCurrentStateType() const;
	bool IsEquippedHidden() const;
	bool IsOnStack(ECharacterState State) const;
	bool JumpByInputIsEnabled() const;
	bool MovementByInputIsEnabled() const;
	EMovementRelativeTo MovementRelativeTo() const;
	bool PlacementInputIsEnabled() const;
	bool ShouldHideInventoryToolbar() const;
	bool StartPlacementInputIsEnabled() const;
	bool UseEquippedInputEnabled(bool Inward, bool Pressed) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStateMachineComponent">();
	}
	static class UCharacterStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStateMachineComponent>();
	}
};
static_assert(alignof(UCharacterStateMachineComponent) == 0x000008, "Wrong alignment on UCharacterStateMachineComponent");
static_assert(sizeof(UCharacterStateMachineComponent) == 0x0001D0, "Wrong size on UCharacterStateMachineComponent");
static_assert(offsetof(UCharacterStateMachineComponent, OnCharacterStateChanged) == 0x0000A8, "Member 'UCharacterStateMachineComponent::OnCharacterStateChanged' has a wrong offset!");
static_assert(offsetof(UCharacterStateMachineComponent, OnExitingCharacterState) == 0x0000B8, "Member 'UCharacterStateMachineComponent::OnExitingCharacterState' has a wrong offset!");
static_assert(offsetof(UCharacterStateMachineComponent, OnEnteredCharacterState) == 0x0000C8, "Member 'UCharacterStateMachineComponent::OnEnteredCharacterState' has a wrong offset!");
static_assert(offsetof(UCharacterStateMachineComponent, CachedCharacter) == 0x0000D8, "Member 'UCharacterStateMachineComponent::CachedCharacter' has a wrong offset!");
static_assert(offsetof(UCharacterStateMachineComponent, CachedMovement) == 0x0000E0, "Member 'UCharacterStateMachineComponent::CachedMovement' has a wrong offset!");
static_assert(offsetof(UCharacterStateMachineComponent, CurrentStateStack) == 0x0001C0, "Member 'UCharacterStateMachineComponent::CurrentStateStack' has a wrong offset!");

// Class Palia.ValeriaGASGameplayAbility
// 0x0080 (0x0438 - 0x03B8)
class UValeriaGASGameplayAbility : public UGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             InputPressedDelegate;                              // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             InputReleasedDelegate;                             // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AltInputPressedDelegate;                           // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AltInputReleasedDelegate;                          // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bShouldBlockActionBarWhenActive;                   // 0x03F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlockPlacementModeWhenActive;               // 0x03F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseAltLocomotionTag;                        // 0x03FA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2526[0x35];                                    // 0x03FB(0x0035)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBagSlotLocation                       EquipLocationAtActivation;                         // 0x0430(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void ConsumeInput();
	void InterruptAbility();
	bool IsInputQueued();
	void LoadAbilityAssets(class AValeriaCharacter* ValeriaCharacter);
	void OnAltInputPressedCallback();
	void OnAltInputReleasedCallback();
	void OnInputPressedCallback();
	void OnInputReleasedCallback();

	struct FBagSlotLocation GetEquipLocationOfAbility() const;
	class AValeriaCharacter* GetValeriaCharacterFromActorInfo() const;
	class AValeriaPlayerController* GetValeriaPlayerControllerFromActorInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGASGameplayAbility">();
	}
	static class UValeriaGASGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGASGameplayAbility>();
	}
};
static_assert(alignof(UValeriaGASGameplayAbility) == 0x000008, "Wrong alignment on UValeriaGASGameplayAbility");
static_assert(sizeof(UValeriaGASGameplayAbility) == 0x000438, "Wrong size on UValeriaGASGameplayAbility");
static_assert(offsetof(UValeriaGASGameplayAbility, InputPressedDelegate) == 0x0003B8, "Member 'UValeriaGASGameplayAbility::InputPressedDelegate' has a wrong offset!");
static_assert(offsetof(UValeriaGASGameplayAbility, InputReleasedDelegate) == 0x0003C8, "Member 'UValeriaGASGameplayAbility::InputReleasedDelegate' has a wrong offset!");
static_assert(offsetof(UValeriaGASGameplayAbility, AltInputPressedDelegate) == 0x0003D8, "Member 'UValeriaGASGameplayAbility::AltInputPressedDelegate' has a wrong offset!");
static_assert(offsetof(UValeriaGASGameplayAbility, AltInputReleasedDelegate) == 0x0003E8, "Member 'UValeriaGASGameplayAbility::AltInputReleasedDelegate' has a wrong offset!");
static_assert(offsetof(UValeriaGASGameplayAbility, bShouldBlockActionBarWhenActive) == 0x0003F8, "Member 'UValeriaGASGameplayAbility::bShouldBlockActionBarWhenActive' has a wrong offset!");
static_assert(offsetof(UValeriaGASGameplayAbility, bShouldBlockPlacementModeWhenActive) == 0x0003F9, "Member 'UValeriaGASGameplayAbility::bShouldBlockPlacementModeWhenActive' has a wrong offset!");
static_assert(offsetof(UValeriaGASGameplayAbility, bShouldUseAltLocomotionTag) == 0x0003FA, "Member 'UValeriaGASGameplayAbility::bShouldUseAltLocomotionTag' has a wrong offset!");
static_assert(offsetof(UValeriaGASGameplayAbility, EquipLocationAtActivation) == 0x000430, "Member 'UValeriaGASGameplayAbility::EquipLocationAtActivation' has a wrong offset!");

// Class Palia.ChatManager
// 0x0278 (0x02A8 - 0x0030)
class UChatManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnRequestOpenChannel;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSessionConnected;                                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSessionDisconnected;                             // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewChatMessage;                                  // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewControlMessage;                               // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterMuted;                                  // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerMuted;                                     // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestDisplayChatError;                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestDisplayChatUnreachable;                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestDisplayChatRetryLogin;                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestActivateChat;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestInactiveChat;                             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestInpurBarChangeMessageTarget;              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestInputBarInsertText;                       // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerDelimiterMessageTriggered;                 // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisplayReconnectChat;                            // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPermissionsChanged;                              // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2527[0x40];                                    // 0x0140(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ReconnectTimerHandle;                              // 0x0180(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2528[0x120];                                   // 0x0188(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTexture2D* ChatImageTextureFromBufferString(const class FString& ImageData);

	void AddChatPermission(EVAL_ChatPermissions Permission);
	void ChatSessionReadyHandler();
	void EchoChatNotification(const struct FMessageTarget& MessageTarget, const class FString& NotificationContent);
	void EchoChatNotificationToSelf(const class FString& Message);
	void EchoValeriaChatMessage(const struct FValeriaChatMessage& ChatMessage);
	TArray<struct FVAL_ChatProximityEntity> GetPlayersInChatProximity();
	void HandleOnChannelMsgReceived(struct FS6Vivox_ChannelTextMsg& Msg);
	void HandleOnDirectMsgReceived(struct FS6Vivox_TextMsg& Msg);
	void HandleOnPartyStateChanged(EVAL_PartyManagerState State);
	void HandleOnPawnChanged(class APawn* Pawn);
	void HandleOnServerIdChanged(const class FString& ID);
	void HandleOnServerMaintenanceCancelled();
	void HandleOnServerMaintenanceScheduled(struct FVAL_ServerMaintenanceData& ServerMaintenanceData);
	void HandleOnSignedInAsCharacter(const class FString& CharacterName, int32 LocalUserNum, const struct FGuid& CharacterId);
	void HandleOnVivoxLoggedIn();
	void HandleOnVivoxLoginFailed(int32 ErrorCode, const class FString& ErrorMsg);
	void HandlePlayerGuildChanged(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem, const struct FGuid& NewGuildId);
	void OnCharacterMuted__DelegateSignature(class FName CharacterName, bool bMuted);
	void OnChatPermissionsChanged__DelegateSignature(EVAL_ChatPermissions Permissions);
	void OnPlayerMuted__DelegateSignature(const struct FUniqueNetIdRepl& PlayerNetId, bool bMuted);
	void OnRequestActivateChat__DelegateSignature();
	void OnRequestDisplayChatErrorMessage__DelegateSignature(class FText ErrorText);
	void OnRequestDisplayChatRetryLogin__DelegateSignature(class FText ErrorText);
	void OnRequestDisplayChatUnreachable__DelegateSignature(class FText ErrorText);
	void OnRequestInactivateChat__DelegateSignature();
	void OnRequestInputBarChangeMessageTarget__DelegateSignature(const struct FMessageTarget& MessageTarget);
	void OnRequestInputBarInsertText__DelegateSignature(class FText& Text);
	void OnRequestOpenChannel__DelegateSignature(const struct FMessageTarget& MessageTarget);
	void OnServerDelimiterMessageTriggered__DelegateSignature();
	void RemoveChatPermission(EVAL_ChatPermissions Permission);
	void RequestMuteUser(bool bMute, class FName& CharacterName);
	void RequestMuteUser_New(bool bMute, struct FUniqueNetIdRepl& PlayerNetId, const class FString& CharacterName);
	void RequestOpenChannel(struct FMessageTarget& MessageTarget);
	void SendChatImage(const struct FMessageTarget& MessageTarget, class UTextureRenderTarget2D* ImageTexture);
	void SendChatMessage(const struct FMessageTarget& MessageTarget, const class FString& HumanMessage);
	void SendChatNotification(const struct FMessageTarget& MessageTarget, const class FString& NotificationContent);
	void SendControlMessage(const struct FMessageTarget& MessageTarget, const struct FControlMessage& ControlMessage);
	void SendValeriaChatMessage(const struct FValeriaChatMessage& ChatMessage);
	void SessionConnectionFailureHandler(const class FString& Error);
	void ValChat_OnDisplayReconnectChat__DelegateSignature(bool bReconnecting, const class FString& ErrorMsg);

	class FString GetChatErrorMsg() const;
	EVAL_ChatPermissions GetChatPermissionFlags() const;
	class FString GetServerName() const;
	bool HasChatPermission(EVAL_ChatPermissions Permission) const;
	bool IsConnected() const;
	bool IsReconnectingToChat() const;
	bool IsUserMuted(class FName& CharacterName) const;
	bool IsUserMuted_New(struct FUniqueNetIdRepl& PlayerNetId) const;
	int32 MaximumCharacterLimit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatManager">();
	}
	static class UChatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatManager>();
	}
};
static_assert(alignof(UChatManager) == 0x000008, "Wrong alignment on UChatManager");
static_assert(sizeof(UChatManager) == 0x0002A8, "Wrong size on UChatManager");
static_assert(offsetof(UChatManager, OnRequestOpenChannel) == 0x000030, "Member 'UChatManager::OnRequestOpenChannel' has a wrong offset!");
static_assert(offsetof(UChatManager, OnSessionConnected) == 0x000040, "Member 'UChatManager::OnSessionConnected' has a wrong offset!");
static_assert(offsetof(UChatManager, OnSessionDisconnected) == 0x000050, "Member 'UChatManager::OnSessionDisconnected' has a wrong offset!");
static_assert(offsetof(UChatManager, OnNewChatMessage) == 0x000060, "Member 'UChatManager::OnNewChatMessage' has a wrong offset!");
static_assert(offsetof(UChatManager, OnNewControlMessage) == 0x000070, "Member 'UChatManager::OnNewControlMessage' has a wrong offset!");
static_assert(offsetof(UChatManager, OnCharacterMuted) == 0x000080, "Member 'UChatManager::OnCharacterMuted' has a wrong offset!");
static_assert(offsetof(UChatManager, OnPlayerMuted) == 0x000090, "Member 'UChatManager::OnPlayerMuted' has a wrong offset!");
static_assert(offsetof(UChatManager, OnRequestDisplayChatError) == 0x0000A0, "Member 'UChatManager::OnRequestDisplayChatError' has a wrong offset!");
static_assert(offsetof(UChatManager, OnRequestDisplayChatUnreachable) == 0x0000B0, "Member 'UChatManager::OnRequestDisplayChatUnreachable' has a wrong offset!");
static_assert(offsetof(UChatManager, OnRequestDisplayChatRetryLogin) == 0x0000C0, "Member 'UChatManager::OnRequestDisplayChatRetryLogin' has a wrong offset!");
static_assert(offsetof(UChatManager, OnRequestActivateChat) == 0x0000D0, "Member 'UChatManager::OnRequestActivateChat' has a wrong offset!");
static_assert(offsetof(UChatManager, OnRequestInactiveChat) == 0x0000E0, "Member 'UChatManager::OnRequestInactiveChat' has a wrong offset!");
static_assert(offsetof(UChatManager, OnRequestInpurBarChangeMessageTarget) == 0x0000F0, "Member 'UChatManager::OnRequestInpurBarChangeMessageTarget' has a wrong offset!");
static_assert(offsetof(UChatManager, OnRequestInputBarInsertText) == 0x000100, "Member 'UChatManager::OnRequestInputBarInsertText' has a wrong offset!");
static_assert(offsetof(UChatManager, OnServerDelimiterMessageTriggered) == 0x000110, "Member 'UChatManager::OnServerDelimiterMessageTriggered' has a wrong offset!");
static_assert(offsetof(UChatManager, OnDisplayReconnectChat) == 0x000120, "Member 'UChatManager::OnDisplayReconnectChat' has a wrong offset!");
static_assert(offsetof(UChatManager, OnPermissionsChanged) == 0x000130, "Member 'UChatManager::OnPermissionsChanged' has a wrong offset!");
static_assert(offsetof(UChatManager, ReconnectTimerHandle) == 0x000180, "Member 'UChatManager::ReconnectTimerHandle' has a wrong offset!");

// Class Palia.CheatSetConfig
// 0x0098 (0x00E0 - 0x0048)
class UCheatSetConfig final : public UGuidDataAsset
{
public:
	bool                                          bRepeatable;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2532[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPersistentTagWriteback>        PlayerTagWritebacks;                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FValeriaItem>                   ItemsToGive;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            VillagersToMarkAsMet;                              // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UVAL_QuestDef*>                  QuestsToGrant;                                     // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UVAL_QuestDef*>                  QuestsToComplete;                                  // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UVAL_DialogueAsset>> DialoguesToMarkSeen;                               // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UPrivateSpaceVillagerVisitConfig*> HousingPlotVillagerVisitsToGrant;                  // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UPrivateSpaceVillagerVisitConfig*> HousingPlotVillagerVisitsToComplete;               // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuestRewardConfig>             AdditionalRewards;                                 // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatSetConfig">();
	}
	static class UCheatSetConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatSetConfig>();
	}
};
static_assert(alignof(UCheatSetConfig) == 0x000008, "Wrong alignment on UCheatSetConfig");
static_assert(sizeof(UCheatSetConfig) == 0x0000E0, "Wrong size on UCheatSetConfig");
static_assert(offsetof(UCheatSetConfig, bRepeatable) == 0x000048, "Member 'UCheatSetConfig::bRepeatable' has a wrong offset!");
static_assert(offsetof(UCheatSetConfig, PlayerTagWritebacks) == 0x000050, "Member 'UCheatSetConfig::PlayerTagWritebacks' has a wrong offset!");
static_assert(offsetof(UCheatSetConfig, ItemsToGive) == 0x000060, "Member 'UCheatSetConfig::ItemsToGive' has a wrong offset!");
static_assert(offsetof(UCheatSetConfig, VillagersToMarkAsMet) == 0x000070, "Member 'UCheatSetConfig::VillagersToMarkAsMet' has a wrong offset!");
static_assert(offsetof(UCheatSetConfig, QuestsToGrant) == 0x000080, "Member 'UCheatSetConfig::QuestsToGrant' has a wrong offset!");
static_assert(offsetof(UCheatSetConfig, QuestsToComplete) == 0x000090, "Member 'UCheatSetConfig::QuestsToComplete' has a wrong offset!");
static_assert(offsetof(UCheatSetConfig, DialoguesToMarkSeen) == 0x0000A0, "Member 'UCheatSetConfig::DialoguesToMarkSeen' has a wrong offset!");
static_assert(offsetof(UCheatSetConfig, HousingPlotVillagerVisitsToGrant) == 0x0000B0, "Member 'UCheatSetConfig::HousingPlotVillagerVisitsToGrant' has a wrong offset!");
static_assert(offsetof(UCheatSetConfig, HousingPlotVillagerVisitsToComplete) == 0x0000C0, "Member 'UCheatSetConfig::HousingPlotVillagerVisitsToComplete' has a wrong offset!");
static_assert(offsetof(UCheatSetConfig, AdditionalRewards) == 0x0000D0, "Member 'UCheatSetConfig::AdditionalRewards' has a wrong offset!");

// Class Palia.ValeriaProjectile
// 0x00E8 (0x0390 - 0x02A8)
class AValeriaProjectile final : public AActor
{
public:
	class USphereComponent*                       CollisionComponent;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileLifetime;                                // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectilePhysicsImpulsePower;                     // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBeforeGravityKicksIn;                          // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScaleWhenItKicksIn;                         // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NameForAnalytics;                                  // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstantCatchTrappedInsects;                       // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2533[0x7];                                     // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHitValidTargetClientSide;                        // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitValidTargetServerSide;                        // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UValeriaGASComponent*                   ValeriaGAS;                                        // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsOnHit;                                      // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         ProjectileId;                                      // 0x0318(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2534[0x4];                                     // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_ItemTypeDefinitionAsset*           ToolFiredBy;                                       // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> AmmoItemType;                                      // 0x0328(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PositionHistoryDistance;                           // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2535[0x4];                                     // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasProjectileHitAnything;                         // 0x0358(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2536[0x17];                                    // 0x0359(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HitActorAccordingToServer;                         // 0x0370(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2537[0x18];                                    // 0x0378(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_HandleOverlapWithWaterBegan(class AActor* WaterActor);
	void Client_PerformClientAuthoritativeHit(class AActor* HitActor, TArray<class AActor*>& AOEHitActors);
	void NotifyOverlappedParticipationBox();
	void PauseProjectile();
	void RpcClient_DisplayHit(class AActor* HitActor, const struct FVector& HitLocation);
	void Server_PerformClientAuthoritativeHit(class AActor* HitActor, TArray<class AActor*>& AOEHitActors);

	int32 GetSelectedColor() const;
	bool HasPassedWithinDistanceOfPoint(const struct FVector& TargetLocation, int32 Distance) const;
	bool ShouldIgnoreProjectile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaProjectile">();
	}
	static class AValeriaProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaProjectile>();
	}
};
static_assert(alignof(AValeriaProjectile) == 0x000008, "Wrong alignment on AValeriaProjectile");
static_assert(sizeof(AValeriaProjectile) == 0x000390, "Wrong size on AValeriaProjectile");
static_assert(offsetof(AValeriaProjectile, CollisionComponent) == 0x0002A8, "Member 'AValeriaProjectile::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, ProjectileMovementComponent) == 0x0002B0, "Member 'AValeriaProjectile::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, ProjectileLifetime) == 0x0002B8, "Member 'AValeriaProjectile::ProjectileLifetime' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, ProjectilePhysicsImpulsePower) == 0x0002BC, "Member 'AValeriaProjectile::ProjectilePhysicsImpulsePower' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, TimeBeforeGravityKicksIn) == 0x0002C0, "Member 'AValeriaProjectile::TimeBeforeGravityKicksIn' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, GravityScaleWhenItKicksIn) == 0x0002C4, "Member 'AValeriaProjectile::GravityScaleWhenItKicksIn' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, NameForAnalytics) == 0x0002C8, "Member 'AValeriaProjectile::NameForAnalytics' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, bInstantCatchTrappedInsects) == 0x0002D8, "Member 'AValeriaProjectile::bInstantCatchTrappedInsects' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, OnHitValidTargetClientSide) == 0x0002E0, "Member 'AValeriaProjectile::OnHitValidTargetClientSide' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, OnHitValidTargetServerSide) == 0x0002F0, "Member 'AValeriaProjectile::OnHitValidTargetServerSide' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, ValeriaGAS) == 0x000300, "Member 'AValeriaProjectile::ValeriaGAS' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, EffectsOnHit) == 0x000308, "Member 'AValeriaProjectile::EffectsOnHit' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, ProjectileId) == 0x000318, "Member 'AValeriaProjectile::ProjectileId' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, ToolFiredBy) == 0x000320, "Member 'AValeriaProjectile::ToolFiredBy' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, AmmoItemType) == 0x000328, "Member 'AValeriaProjectile::AmmoItemType' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, PositionHistoryDistance) == 0x000350, "Member 'AValeriaProjectile::PositionHistoryDistance' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, bHasProjectileHitAnything) == 0x000358, "Member 'AValeriaProjectile::bHasProjectileHitAnything' has a wrong offset!");
static_assert(offsetof(AValeriaProjectile, HitActorAccordingToServer) == 0x000370, "Member 'AValeriaProjectile::HitActorAccordingToServer' has a wrong offset!");

// Class Palia.CinematicManagerComponent
// 0x0068 (0x0108 - 0x00A0)
class UCinematicManagerComponent final : public UActorComponent
{
public:
	class AValeriaSpatialAudioVolume*             CurrentAudioVolume;                                // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AValeriaPlayerController*               ValeriaPlayerController;                           // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AValeriaCharacter*                      ValeriaCharacter;                                  // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelStreamingDynamic*                 CinematicLevelLoaded;                              // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AS6WorldPartitionStreamer*              WorldPartitionStreamer;                            // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCinematicSequenceConfig*               ActiveCinConfig;                                   // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AS6WorldPartitionStreamer>  WorldPartitionStreamerClass;                       // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnToggleCreatureVisibility;                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCinLevelLoaded;                                  // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCinLevelUnloaded;                                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void BeginCineLevelLoad(class UCinematicSequenceConfig* CinConfig);
	void CinematicLevelTeleportCheck(class UCinematicSequenceConfig* CinConfig);
	void ConcludeCinematicMode(class UCinematicSequenceConfig* CinConfig);
	void HandleCinematicLevelLoaded();
	void HandleCinematicLevelShown();
	void HandleCinematicLevelUnloaded();
	void HandlePlayerTeleportComplete(class AValeriaCharacter* InValeriaCharacter, ETeleportTravelType TeleportTravelType, TSoftObjectPtr<class UPrivateSpaceConfig> PrivateSpaceConfig);
	void HandlePossessionChanged(class AValeriaPlayerController* InValeriaPlayerController);
	void HandleWorldPartitionAreaLoaded();
	void PrimeCinematicMode(class UCinematicSequenceConfig* CinConfig);
	void RpcServer_HidePlayerOnRemoteClients(bool Hide);
	void RpcServer_PerformCinematicSetup(class UCinematicSequenceConfig* CinConfig);
	void RpcServer_PerformCinematicTeardown(class UCinematicSequenceConfig* CinConfig);
	void TryPlayCinematic(class UCinematicSequenceConfig* CinConfig);

	const class UCinematicSequenceConfig* GetActiveCinematicSequenceConfig() const;
	bool NeedToTravelForCinematic(class UCinematicSequenceConfig* CinematicConfig) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicManagerComponent">();
	}
	static class UCinematicManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinematicManagerComponent>();
	}
};
static_assert(alignof(UCinematicManagerComponent) == 0x000008, "Wrong alignment on UCinematicManagerComponent");
static_assert(sizeof(UCinematicManagerComponent) == 0x000108, "Wrong size on UCinematicManagerComponent");
static_assert(offsetof(UCinematicManagerComponent, CurrentAudioVolume) == 0x0000A0, "Member 'UCinematicManagerComponent::CurrentAudioVolume' has a wrong offset!");
static_assert(offsetof(UCinematicManagerComponent, ValeriaPlayerController) == 0x0000A8, "Member 'UCinematicManagerComponent::ValeriaPlayerController' has a wrong offset!");
static_assert(offsetof(UCinematicManagerComponent, ValeriaCharacter) == 0x0000B0, "Member 'UCinematicManagerComponent::ValeriaCharacter' has a wrong offset!");
static_assert(offsetof(UCinematicManagerComponent, CinematicLevelLoaded) == 0x0000B8, "Member 'UCinematicManagerComponent::CinematicLevelLoaded' has a wrong offset!");
static_assert(offsetof(UCinematicManagerComponent, WorldPartitionStreamer) == 0x0000C0, "Member 'UCinematicManagerComponent::WorldPartitionStreamer' has a wrong offset!");
static_assert(offsetof(UCinematicManagerComponent, ActiveCinConfig) == 0x0000C8, "Member 'UCinematicManagerComponent::ActiveCinConfig' has a wrong offset!");
static_assert(offsetof(UCinematicManagerComponent, WorldPartitionStreamerClass) == 0x0000D0, "Member 'UCinematicManagerComponent::WorldPartitionStreamerClass' has a wrong offset!");
static_assert(offsetof(UCinematicManagerComponent, OnToggleCreatureVisibility) == 0x0000D8, "Member 'UCinematicManagerComponent::OnToggleCreatureVisibility' has a wrong offset!");
static_assert(offsetof(UCinematicManagerComponent, OnCinLevelLoaded) == 0x0000E8, "Member 'UCinematicManagerComponent::OnCinLevelLoaded' has a wrong offset!");
static_assert(offsetof(UCinematicManagerComponent, OnCinLevelUnloaded) == 0x0000F8, "Member 'UCinematicManagerComponent::OnCinLevelUnloaded' has a wrong offset!");

// Class Palia.CinSequenceSubtitlesConfig
// 0x0010 (0x0040 - 0x0030)
class UCinSequenceSubtitlesConfig final : public UDataAsset
{
public:
	TArray<struct FCinematicSubtitleData>         Subtitles;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinSequenceSubtitlesConfig">();
	}
	static class UCinSequenceSubtitlesConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinSequenceSubtitlesConfig>();
	}
};
static_assert(alignof(UCinSequenceSubtitlesConfig) == 0x000008, "Wrong alignment on UCinSequenceSubtitlesConfig");
static_assert(sizeof(UCinSequenceSubtitlesConfig) == 0x000040, "Wrong size on UCinSequenceSubtitlesConfig");
static_assert(offsetof(UCinSequenceSubtitlesConfig, Subtitles) == 0x000030, "Member 'UCinSequenceSubtitlesConfig::Subtitles' has a wrong offset!");

// Class Palia.ValeriaContainerHashesConfig
// 0x0020 (0x0058 - 0x0038)
class UValeriaContainerHashesConfig final : public UDeveloperSettings
{
public:
	TArray<struct FValeriaContainerHash>          CharacterContainerHashes;                          // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FValeriaContainerHash>          HousingContainerHashes;                            // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaContainerHashesConfig">();
	}
	static class UValeriaContainerHashesConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaContainerHashesConfig>();
	}
};
static_assert(alignof(UValeriaContainerHashesConfig) == 0x000008, "Wrong alignment on UValeriaContainerHashesConfig");
static_assert(sizeof(UValeriaContainerHashesConfig) == 0x000058, "Wrong size on UValeriaContainerHashesConfig");
static_assert(offsetof(UValeriaContainerHashesConfig, CharacterContainerHashes) == 0x000038, "Member 'UValeriaContainerHashesConfig::CharacterContainerHashes' has a wrong offset!");
static_assert(offsetof(UValeriaContainerHashesConfig, HousingContainerHashes) == 0x000048, "Member 'UValeriaContainerHashesConfig::HousingContainerHashes' has a wrong offset!");

// Class Palia.ContentBatchManagerComponent
// 0x0010 (0x00B0 - 0x00A0)
class UContentBatchManagerComponent final : public UActorComponent
{
public:
	TArray<int32>                                 EnabledContentBatchPersistIds;                     // 0x00A0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	bool IsContentBatchEnabled(int32 ContentBatchPersistId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentBatchManagerComponent">();
	}
	static class UContentBatchManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentBatchManagerComponent>();
	}
};
static_assert(alignof(UContentBatchManagerComponent) == 0x000008, "Wrong alignment on UContentBatchManagerComponent");
static_assert(sizeof(UContentBatchManagerComponent) == 0x0000B0, "Wrong size on UContentBatchManagerComponent");
static_assert(offsetof(UContentBatchManagerComponent, EnabledContentBatchPersistIds) == 0x0000A0, "Member 'UContentBatchManagerComponent::EnabledContentBatchPersistIds' has a wrong offset!");

// Class Palia.VAL_PlayerControllerBase
// 0x01D0 (0x0A38 - 0x0868)
class AVAL_PlayerControllerBase : public APlayerController
{
public:
	TSubclassOf<class AHUD>                       HUDClass;                                          // 0x0868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253C[0x8];                                     // 0x0870(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnClientPreTravel;                                 // 0x0878(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_253D[0x18];                                    // 0x0888(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformEnvironment;                               // 0x08A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlatformEnvUpdated;                              // 0x08B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_253E[0x78];                                    // 0x08C0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMatchmakingStarted;                              // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchmakingResultObtained;                       // 0x0948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerIdUpdated;                                 // 0x0958(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerRegionUpdated;                             // 0x0968(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 ServerId;                                          // 0x0978(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerRegion;                                      // 0x0988(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotificationEvent;                               // 0x0998(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotificationDismissEvent;                        // 0x09A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bUseLowDrainBatteryMode;                           // 0x09B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackPlayerInactivity;                            // 0x09B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253F[0x2];                                     // 0x09BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InactivityTimeAccumulator;                         // 0x09BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InactivityHeartbeatTimeSeconds;                    // 0x09C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InactiveTimeToDisconnectSeconds;                   // 0x09C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2540[0x18];                                    // 0x09C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRunningExpPkgChanged;                            // 0x09E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerMaintenanceScheduled;                      // 0x09F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerMaintenanceCancelled;                      // 0x0A00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2541[0x10];                                    // 0x0A10(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UExperiencePackageConfig*               RunningExpPkg;                                     // 0x0A20(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVAL_ServerMaintenanceData             ServerMaintenanceData;                             // 0x0A28(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void Client_InactivityHeartbeat();
	void DismissNotification(const struct FNotification& Notification);
	class UExperiencePackageConfig* GetExperiencePackage();
	bool IsRunningExpPkg();
	void OnClientPreTravel__DelegateSignature(const class FString& PendingURL, ETravelType TravelType, bool bIsSeamlessTravel);
	void OnMatchmakingResultObtained__DelegateSignature(struct FOSSVAL_MatchmakingResult& Result);
	void OnMatchmakingStarted__DelegateSignature();
	void OnPlatformEnvUpdated__DelegateSignature(const class FString& Environment);
	void OnRep_OnServerIdUpdated();
	void OnRep_OnServerRegionUpdated();
	void OnRep_PlatformEnvironment();
	void OnRep_RunningExpPkgChanged();
	void OnRep_ServerMaintenanceDataUpdated();
	void OnRunningExpPkgChanged__DelegateSignature(class UExperiencePackageConfig* ExpPkg);
	void OnServerIdUpdated__DelegateSignature(const class FString& ID);
	void OnServerMaintenanceCancelled__DelegateSignature();
	void OnServerMaintenanceScheduled__DelegateSignature(struct FVAL_ServerMaintenanceData& Param_ServerMaintenanceData);
	void OnServerRegionUpdated__DelegateSignature(const class FString& Region);
	void RpcClient_DismissNotification(const struct FNotification& Notification);
	void RpcClient_Logout();
	void RpcClient_OnMatchmakingCreateJoinOrTravelResultReceived(struct FGuid& RequestID, struct FOSSVAL_MatchmakingJoinStatusResult& Result);
	void RpcClient_OnMatchmakingDeleteRequestReceived(struct FGuid& RequestID, struct FOSSVAL_MatchmakingResult& RequestContext);
	void RpcClient_OnMatchmakingFinalPersistComplete(struct FGuid& RequestID, bool bSuccess);
	void RpcClient_OnMatchmakingJoinOrTravelStatusReceived(struct FGuid& RequestID, struct FOSSVAL_MatchmakingJoinStatusResult& Result);
	void RpcClient_OnMatchmakingTravelTicketRequestCompleted(struct FGuid& RequestID, struct FOSSVAL_MatchmakingJoinStatusResult& Result);
	void RpcClient_RequestMatchmakingDeleteJoin_Internal(struct FGuid& RequestID, struct FOSSVAL_MatchmakingRequestContext& RequestContext);
	void RpcClient_RequestMatchmakingJoinStatus_Internal(struct FGuid& RequestID, struct FOSSVAL_MatchmakingRequestContext& RequestContext);
	void RpcClient_RequestMatchmakingJoinTicket_Internal(struct FGuid& RequestID, struct FOSSVAL_MatchmakingRequestContext& RequestContext);
	void RpcClient_RequestMatchmakingTravelTicket_Internal(struct FGuid& RequestID, struct FOSSVAL_MatchmakingRequestContext& RequestContext);
	void RpcClient_SendNotification(const struct FNotification& Notification);
	void RpcClient_StoreKickReason(class FText& Reason);
	void RpcServer_NotifyInactivityInterrupted();
	void RpcServer_RequestMatchmakingCreateJoinOrTravelRequest(struct FGuid& RequestID, struct FOSSVAL_MatchmakingRequestContext& RequestContext);
	void RpcServer_RequestMatchmakingDeleteRequest(struct FGuid& RequestID, struct FOSSVAL_MatchmakingRequestContext& RequestContext);
	void RpcServer_RequestMatchmakingFinalPersist(struct FGuid& RequestID);
	void RpcServer_RequestMatchmakingJoinOrTravelStatus(struct FGuid& RequestID, struct FOSSVAL_MatchmakingRequestContext& RequestContext);
	void RpcServer_RequestMatchmakingTravelTicket(struct FGuid& RequestID, struct FOSSVAL_MatchmakingRequestContext& RequestContext);
	void SendNotification(const struct FNotification& Notification);
	void Server_InactivityHeartbeat();
	void SetExperiencePackage(class UExperiencePackageConfig* InExpPkg);

	const struct FVAL_ServerMaintenanceData GetServerMaintenanceData() const;
	bool IsServerMaintenanceScheduled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerControllerBase">();
	}
	static class AVAL_PlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_PlayerControllerBase>();
	}
};
static_assert(alignof(AVAL_PlayerControllerBase) == 0x000008, "Wrong alignment on AVAL_PlayerControllerBase");
static_assert(sizeof(AVAL_PlayerControllerBase) == 0x000A38, "Wrong size on AVAL_PlayerControllerBase");
static_assert(offsetof(AVAL_PlayerControllerBase, HUDClass) == 0x000868, "Member 'AVAL_PlayerControllerBase::HUDClass' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnClientPreTravel) == 0x000878, "Member 'AVAL_PlayerControllerBase::OnClientPreTravel' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, PlatformEnvironment) == 0x0008A0, "Member 'AVAL_PlayerControllerBase::PlatformEnvironment' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnPlatformEnvUpdated) == 0x0008B0, "Member 'AVAL_PlayerControllerBase::OnPlatformEnvUpdated' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnMatchmakingStarted) == 0x000938, "Member 'AVAL_PlayerControllerBase::OnMatchmakingStarted' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnMatchmakingResultObtained) == 0x000948, "Member 'AVAL_PlayerControllerBase::OnMatchmakingResultObtained' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnServerIdUpdated) == 0x000958, "Member 'AVAL_PlayerControllerBase::OnServerIdUpdated' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnServerRegionUpdated) == 0x000968, "Member 'AVAL_PlayerControllerBase::OnServerRegionUpdated' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, ServerId) == 0x000978, "Member 'AVAL_PlayerControllerBase::ServerId' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, ServerRegion) == 0x000988, "Member 'AVAL_PlayerControllerBase::ServerRegion' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnNotificationEvent) == 0x000998, "Member 'AVAL_PlayerControllerBase::OnNotificationEvent' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnNotificationDismissEvent) == 0x0009A8, "Member 'AVAL_PlayerControllerBase::OnNotificationDismissEvent' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, bUseLowDrainBatteryMode) == 0x0009B8, "Member 'AVAL_PlayerControllerBase::bUseLowDrainBatteryMode' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, bTrackPlayerInactivity) == 0x0009B9, "Member 'AVAL_PlayerControllerBase::bTrackPlayerInactivity' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, InactivityTimeAccumulator) == 0x0009BC, "Member 'AVAL_PlayerControllerBase::InactivityTimeAccumulator' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, InactivityHeartbeatTimeSeconds) == 0x0009C0, "Member 'AVAL_PlayerControllerBase::InactivityHeartbeatTimeSeconds' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, InactiveTimeToDisconnectSeconds) == 0x0009C4, "Member 'AVAL_PlayerControllerBase::InactiveTimeToDisconnectSeconds' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnRunningExpPkgChanged) == 0x0009E0, "Member 'AVAL_PlayerControllerBase::OnRunningExpPkgChanged' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnServerMaintenanceScheduled) == 0x0009F0, "Member 'AVAL_PlayerControllerBase::OnServerMaintenanceScheduled' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, OnServerMaintenanceCancelled) == 0x000A00, "Member 'AVAL_PlayerControllerBase::OnServerMaintenanceCancelled' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, RunningExpPkg) == 0x000A20, "Member 'AVAL_PlayerControllerBase::RunningExpPkg' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerControllerBase, ServerMaintenanceData) == 0x000A28, "Member 'AVAL_PlayerControllerBase::ServerMaintenanceData' has a wrong offset!");

// Class Palia.ValeriaPlayerController
// 0x0598 (0x0FD0 - 0x0A38)
class AValeriaPlayerController : public AVAL_PlayerControllerBase
{
public:
	FMulticastInlineDelegateProperty_             OnErrorMessageReceived;                            // 0x0A38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnErrorMessageTextReceived;                        // 0x0A48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnErrorModalReceived;                              // 0x0A58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPremiumStoreEntitlementsChanged;                 // 0x0A68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPossessionChanged;                               // 0x0A78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterWasSpawnedEvent;                        // 0x0A88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFocusUpgradedEvent;                              // 0x0A98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHousingPlotVisited;                              // 0x0AA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSimpleFadeRequested;                             // 0x0AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCinematicSetup;                                  // 0x0AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCinematicTeardown;                               // 0x0AD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2544[0x10];                                    // 0x0AE8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharacterTeleported;                             // 0x0AF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         SyncTimeInterval;                                  // 0x0B08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSnapshotInterval;                            // 0x0B0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerTraversalSnapshotInterval;                   // 0x0B10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameTelemetrySnapshotInterval;                     // 0x0B14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           DisconnectWithMessageTimeoutHandle;                // 0x0B18(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           UnstuckCooldownTimerHandle;                        // 0x0B20(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UnstuckLastUsageTime;                              // 0x0B28(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnstuckCooldownSeconds;                            // 0x0B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnstuckUseFactorIncrease;                          // 0x0B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UnstuckOnCooldownText;                             // 0x0B38(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ReturnHomeCooldownTimerHandle;                     // 0x0B50(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnHomeLastUsageTime;                           // 0x0B58(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnHomeCooldownSeconds;                         // 0x0B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2545[0x4];                                     // 0x0B64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeleportTravelConfigAsset*             ReturnHomeDestinationAddress;                      // 0x0B68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2546[0x4];                                     // 0x0B70(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractableSearchRadius;                          // 0x0B74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractableSearchDistanceAhead;                   // 0x0B78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlacementModeWallpaperSearchDistance;              // 0x0B7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSingleTagFilter                       PlacementModeWallpaperLongRangeAllowedTags;        // 0x0B80(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurrentSubgameInputBindingHandles;                 // 0x0BA8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientLeaveHousingPlot;                          // 0x0BB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientArriveOnHousingPlot;                       // 0x0BC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientVisitorListUpdated;                        // 0x0BD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPlotPresence                          PlotPresence;                                      // 0x0BE8(0x0010)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPendingPersistenceFlush;                          // 0x0BF8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchmakingIsExpectedToSucceed;                   // 0x0BF9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2547[0x6];                                     // 0x0BFA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ActiveMatchmakingExpectedTimeoutHandle;            // 0x0C00(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2548[0x50];                                    // 0x0C08(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReticleNeedsUpdate;                              // 0x0C58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class AValeriaCharacter*                      ValeriaCharacter;                                  // 0x0C68(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBurstNetSpeedComponent*                BurstNetSpeed;                                     // 0x0C70(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugCheatComponent*                   Cheater;                                           // 0x0C78(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTrackingComponent*                     TrackingComponent;                                 // 0x0C80(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugServerActorsComponent*            DebugServerActors;                                 // 0x0C88(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReplicationTrackingComponent*          ReplicationTracking;                               // 0x0C90(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_EncyclopediaManagerComponent*      EncyclopediaManagerComponent;                      // 0x0C98(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_EntitlementComponent*              EntitlementComponent;                              // 0x0CA0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_DialogueRoomManagerComponent*      DialogueRoomManagerComponent;                      // 0x0CA8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCinematicManagerComponent*             CinematicManagerComponent;                         // 0x0CB0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugSpawningComponent*                DebugSpawning;                                     // 0x0CB8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2549[0x150];                                   // 0x0CC0(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class UValeriaGameInstance*                   GameInst;                                          // 0x0E10(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_254A[0x10];                                    // 0x0E18(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMusicState                            MusicState;                                        // 0x0E28(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_254B[0x68];                                    // 0x0E40(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnOnFoliageManager*                 SpawnOnFoliageManager;                             // 0x0EA8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnCinematicModeSet;                                // 0x0EB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_254C[0x18];                                    // 0x0EC0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemPurcahsedFrom3DStore;                        // 0x0ED8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRecipeCrafted;                                   // 0x0EE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_254D[0x8];                                     // 0x0EF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeleportTravelConfigAsset*             InitialTeleportAsset;                              // 0x0F00(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  InitialTeleportTargetAccountID;                    // 0x0F08(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UExperiencePackageConfig*               ServerExpPkg;                                      // 0x0F18(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_NewsInboxComponent*                NewsInbox;                                         // 0x0F20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ValeriaCharacterPlayerGuid;                        // 0x0F28(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ValeriaCharacterPrimaryHouseGuid;                  // 0x0F38(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254E[0x8];                                     // 0x0F48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             NearestPlayersUpdated;                             // 0x0F50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterFellOutOfWorld;                         // 0x0F60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterCompletedCourse;                        // 0x0F70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<int32, struct FVAL_CachedEffectActor>    CachedEffectActors;                                // 0x0F80(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	void AddItemToQuestGiver(class UQuestGiverComponent* QuestGiver, const struct FBagSlotLocation& Location, int32 Amount);
	void AssignEmoteToWheel(int32 WheelIndex, struct FGuid& EmoteId);
	void BrowsingRecipe(class UCrafterComponent* Crafter, int32 RecipeConfigId);
	void CancelCraftingForCrafter(class UCrafterComponent* Crafter);
	void ChangeCoinsCheat(int32 Amount);
	void ChangeDecorState(class AActor* Actor, int32 State, bool bLockDecor);
	void ChangeItemSlot(class UInventoryComponent* OldInventory, const struct FBagSlotLocation& OldSlotLocation, class UInventoryComponent* NewInventory, const struct FBagSlotLocation& NewSlotLocation, EInventoryAmount AmountOption);
	void ChangePlayerStateToPlayer();
	void ChangePlayerStateToSpectator();
	void Cheat_IgnoreRandomChanceForSpawns(bool bShouldIgnore);
	void ClearAssignedEmote(int32 WheelIndex);
	void ClearAssignedEmotes();
	void Client_Camera_AdvanceInspoSubState();
	void Client_Camera_TickInspoState(float DeltaTime);
	void Client_HandleMapAreaTransformationNotification(EMapAreaTransformationNotificationType NotificationType, struct FVector& Location);
	void Client_RequestEffectActors();
	void Client_RouteVAkEvent(class AActor* ActorHit, bool WasDamaged, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& HeldItemType, const struct FVector& Location, class AActor* ExtInstigator);
	class AActor* Client_SpawnEffectActor(struct FVAL_EffectActorSpawnParameters& SpawnParameters);
	void CollectItemSlotFrom(class UInventoryComponent* FromInventory, const struct FBagSlotLocation& FromSlotLocation, int32 Amount, class UInventoryComponent* ToInventory);
	bool ConsumeItem(const struct FBagSlotLocation& Location);
	void CustomizeItemVariant(class UItemVariantCustomizerComponent* Customizer, const struct FBagSlotLocation& Slot, int32 TintPersistID, const struct FValeriaItem& ItemFromStorage);
	void DebugCheat(const struct Palia::FDebugCheat& Cheat);
	void DebugRequestDialogue(class FName& DialogueName);
	void DiscardItem(const struct FBagSlotLocation& Location, int32 AmountToDiscard);
	void DiscardStorageItem(struct FValeriaItem& ItemToDiscard, EStoragePoolType StoragePool);
	bool DoesDecorHaveChildren(class AActor* DecorActor);
	void DumpPlayerTags();
	void EmoteCheat(const class FString& Command);
	class UInteractableComponent* FindBestInteractable();
	void GatherPlaceableActor(class AActor* Actor, bool GatherAllChildren);
	class FString GetConnectedServerAddressWithPort();
	void GodModeDisable();
	void GodModeEnable();
	void GotoPerfLocation(int32 Param_Index);
	void HandleEntitlementsSeenUpdated();
	void HandleGenericDisconnect(class UWorld* InWorld, class UNetDriver* NetDriver);
	void HandleOnPartyStateChanged(EVAL_PartyManagerState State);
	void HidePlayersInCinematicModeEvent(bool bHidePlayers);
	bool IsDecorLocked(class AActor* DecorActor, bool bIgnoreIfLockOwned);
	bool IsPawnInputLocked();
	void KickHousingVisitor(class AHousingOwnershipActor* HousingOwnershipActor, struct FGuid& VisitorPlayerId);
	struct FGuid LockPawnInput(class UObject* ObjectRequestingLock);
	void MarkAchievementRedeemed(const class FString& AchievementID, bool bWasSuccessful);
	void MarkAchievementUnlocked(const class FString& AchievementID);
	void MarkPageAsRead(int32 bookConfigId, int32 HighestPageRead);
	void MasterKeyDisable();
	void MasterKeyEnable();
	void MoveFromInventoryToPlayerStorage(class UInventoryComponent* OldInventory, struct FBagSlotLocation& OldSlotLocation, int32 Amount, EStoragePoolType StoragePool);
	void MoveFromOverflowToInventory(class UInventoryComponent* Inventory, struct FBagSlotLocation& OverflowSlotLocation, bool bMoveAll);
	void MoveFromPlayerStorageToInventory(struct FValeriaItem& Item, class UInventoryComponent* NewInventory, struct FBagSlotLocation& NewSlotLocation, EStoragePoolType StoragePool, struct FGameplayTag& BagType);
	void MoveItemSlotToInventory(class UInventoryComponent* OldInventory, const struct FBagSlotLocation& OldSlotLocation, class UInventoryComponent* NewInventory, const struct FBagSlotLocation& NewSlotLocation, int32 Amount);
	void MoveItemSlotToInventory_FallbackToStorage(class UInventoryComponent* OldInventory, const struct FBagSlotLocation& OldSlotLocation, class UInventoryComponent* NewInventory, const struct FBagSlotLocation& NewSlotLocation, int32 Amount, EStoragePoolType StoragePool);
	void MoveItemSlotToStorage(const struct FBagSlotLocation& SlotLocation, int32 Amount, EStoragePoolType StoragePoolType);
	void MoveStorageToItemSlot(struct FValeriaItem& Item, const struct FBagSlotLocation& SlotLocation, EStoragePoolType StoragePool);
	void MoveToNewStoragePool(struct FValeriaItem& Item, EStoragePoolType OriginalStoragePoolType, EStoragePoolType NewStoragePoolType);
	void NotifyReticleNeedsUpdate();
	void OnCharacterTeleported__DelegateSignature(class AValeriaPlayerController* PC);
	void OnCharacterWasSpawned();
	void OnErrorMessageReceived__DelegateSignature(class AValeriaPlayerController* PC, struct FErrorMessage& Error);
	void OnErrorMessageTextReceived__DelegateSignature(class AValeriaPlayerController* PC, class FText& Error);
	void OnHousingPlotChanged__DelegateSignature(class AHousingPlotActor* Plot);
	void OnHousingPlotVisitorListUpdated__DelegateSignature();
	void OnInputSettingsChanged(struct FValeriaInputSettings& InputSettings);
	void OnPremiumStoreEntitlementsChanged__DelegateSignature(class AValeriaPlayerController* PC);
	void OnRep_PlotPresence(struct FPlotPresence& OldPlotPresence);
	void OnReticleNeedsUpdate__DelegateSignature();
	void OnServerSettingsChanged();
	void OpenSesame();
	void PerformGardenAction(class UGardenComponent* Garden, const struct FGardenActionParams& Params_0);
	void PerformGardenAction_Unreliable(class UGardenComponent* Garden, const struct FGardenActionParams& Params_0);
	void PerformHousingSlotAction(class AHousingOwnershipActor* HousingOwnershipActor, struct FHousingSlotActionParams& ActionParams);
	void PushLocalStatUpdate(const class FString& StatName, const class FString& StatValue);
	bool ReadBook(const struct FBagSlotLocation& Location);
	void RedeemAccomplishment(const class FString& AccomplishmentName);
	void RedeemAchievement(const class FString& AchievementID);
	void ReplaceItemInInventory(class UInventoryComponent* Inventory, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemToBeReplaced, int32 AmountToReplace, struct FValeriaItem& NewItem);
	void ResetAssignedEmotes();
	void ResetCharacterRespecTime();
	void ReturnHome();
	void ReturnHomeStatus(bool bStatus);
	void RpcClient_BroadcastItemPurchasedFrom3DStore(struct FValeriaItem& ItemPurchased);
	void RpcClient_BroadcastRecipeCrafted(int32 RecipeIdCrafted);
	void RpcClient_CheckDataLayerStatusForTeleport(struct FPrimaryAssetId& ExpPkgId);
	void RpcClient_EffectActorsAdded(TArray<struct FVAL_CachedEffectActor>& EffectActors);
	void RpcClient_EffectActorsRemoved(TArray<int32>& RemovedIds);
	void RpcClient_HandleMapAreaTransformationNotification(EMapAreaTransformationNotificationType NotificationType, struct FVector& Location);
	void RpcClient_HousingDecorChangeInteractiveStateRejected(struct FSessionActorId& ID);
	void RpcClient_NotifyLoadingComplete();
	void RpcClient_NotifyOnHousingPlotVisited(struct FUniqueNetIdRepl& VisitorID);
	void RpcClient_PongClient(int64 ClientTimestampMs, int64 ServerValeriaTimeMs);
	void RpcClient_PushBatchedPlayerStats(struct FUniqueNetIdRepl& UniqueID, TArray<struct FVAL_StatKVPair>& Stats);
	void RpcClient_RejectGardenAction(class UGardenComponent* Garden, struct FGardenActionParams& Params_0, class FName& RejectReason_ErrorCode, bool HideErrorInShippingBuild);
	void RpcClient_RejectUnstuck(float CooldownSeconds);
	void RpcClient_RequestSimpleFade(bool bFadeIn);
	void RpcClient_SendErrorMessage(const struct FErrorMessage& Error);
	void RpcClient_SendErrorMessageText(class FText& Error);
	void RpcClient_SendErrorModal(const struct FErrorMessage& Error);
	void RpcClient_SendErrorStringToLog(const class FString& Error);
	void RpcClient_TeleportComplete(bool bHousingPlot, bool bAtHome);
	void RpcClient_TriggerFocusUpgradedEvent(EVAL_ShrineType ShrineType, float UpgradeAmount);
	void RpcClient_TryUnlockPlatformAchievements(TArray<int32>& AchievementIds);
	void RpcServer_AddItemToQuestGiver(class UQuestGiverComponent* QuestGiver, const struct FBagSlotLocation& Location, int32 Amount);
	void RpcServer_AssignEmoteToWheel(int32 WheelIndex, struct FGuid& EmoteId);
	void RpcServer_AttemptHousingLevelUp(class ULevelerComponent* Leveler, bool IgnoreCost, TArray<struct FValeriaItem>& Items);
	void RpcServer_BrowsingRecipe(class UCrafterComponent* Crafter, int32 RecipeConfigId);
	void RpcServer_CancelCraftingForCrafter(class UCrafterComponent* Crafter);
	void RpcServer_ChangeItemSlot(class UInventoryComponent* OldInventory, const struct FBagSlotLocation& OldSlotLocation, class UInventoryComponent* NewInventory, const struct FBagSlotLocation& NewSlotLocation, EInventoryAmount AmountOption);
	void RpcServer_Cheat_IgnoreRandomChanceForSpawns(bool bShouldIgnore);
	void RpcServer_ClearAssignedEmote(int32 WheelIndex);
	void RpcServer_ClearAssignedEmotes();
	void RpcServer_ClearReturnHomeCooldown();
	void RpcServer_CollectItemSlotFrom(class UInventoryComponent* FromInventory, const struct FBagSlotLocation& FromSlotLocation, int32 Amount, class UInventoryComponent* ToInventory);
	void RpcServer_ConsiderDisconnectCrafterEngagement();
	void RpcServer_ConsumeItem(const struct FBagSlotLocation& Location);
	void RpcServer_CustomizeItemVariant(class UItemVariantCustomizerComponent* Customizer, const struct FBagSlotLocation& Slot, int32 TintPersistID, const struct FValeriaItem& ItemFromStorage);
	void RpcServer_DebugDeliverMailEarly();
	void RpcServer_DebugRequestDialogue(class UDialogueComponent* DialogueSourceComponent, class FName& DialogueRowName);
	void RpcServer_DiscardItem(const struct FBagSlotLocation& Location, int32 AmountToDiscard);
	void RpcServer_DiscardStorageItem(struct FValeriaItem& ItemToDiscard, EStoragePoolType StoragePool);
	void RpcServer_GatherActorOrPlaceables(const struct FSessionActorId& ActorId, class AHousingOwnershipActor* HousingOwner, bool GatherAllChildren);
	void RpcServer_HandleInitialTeleport();
	void RpcServer_HousingDecorChangeInteractiveState(struct FSessionActorId& ID, int32 State, bool bLockDecor, bool bShouldPersist);
	void RpcServer_HousingTransitiveDecorInteract(struct FSessionActorId& ID, ETransitiveDecorStimulusType InteractionType, int32 InteractionState, int32 InteractionValue);
	void RpcServer_IgnoreFriendLvlReqsForDynamicGiftPrefs(bool Ignore);
	void RpcServer_InstrumentInput(int32 Pitch, bool bPressed);
	void RpcServer_MarkPageAsRead(int32 bookConfigId, int32 HighestPageRead);
	void RpcServer_MarkPremiumItemIdSeen(bool bSeen, struct FGuid& PremiumItemId);
	void RpcServer_MoveFromInventoryToPlayerStorage(class UInventoryComponent* OldInventory, struct FBagSlotLocation& OldSlotLocation, int32 Amount, EStoragePoolType StoragePool);
	void RpcServer_MoveFromOverflowToInventory(class UInventoryComponent* Inventory, struct FBagSlotLocation& OverflowSlotLocation, bool bMoveAll);
	void RpcServer_MoveFromPlayerStorageToInventory(struct FValeriaItem& Item, class UInventoryComponent* NewInventory, struct FBagSlotLocation& NewSlotLocation, EStoragePoolType StoragePool, struct FGameplayTag& BagType);
	void RpcServer_MoveItemSlotToInventory(class UInventoryComponent* OldInventory, const struct FBagSlotLocation& OldSlotLocation, class UInventoryComponent* NewInventory, const struct FBagSlotLocation& NewSlotLocation, int32 Amount);
	void RpcServer_MoveItemSlotToInventory_FallbackToStorage(class UInventoryComponent* OldInventory, const struct FBagSlotLocation& OldSlotLocation, class UInventoryComponent* NewInventory, const struct FBagSlotLocation& NewSlotLocation, int32 Amount, EStoragePoolType StoragePool);
	void RpcServer_MoveItemSlotToStorage(const struct FBagSlotLocation& SlotLocation, int32 Amount, EStoragePoolType StoragePool);
	void RpcServer_MoveStorageToItemSlot(struct FValeriaItem& Item, const struct FBagSlotLocation& SlotLocation, EStoragePoolType StoragePool);
	void RpcServer_MoveToNewStoragePool(struct FValeriaItem& Item, EStoragePoolType OriginalStoragePoolType, EStoragePoolType NewStoragePoolType);
	void RpcServer_OnCharacterSpawned();
	void RpcServer_PerformClientAuthoritativeHit(int32 ProjectileId, class AActor* HitActor, TArray<class AActor*>& AOEHitActors);
	void RpcServer_PerformGardenAction(class UGardenComponent* Garden, const struct FGardenActionParams& Params_0);
	void RpcServer_PerformGardenAction_Unreliable(class UGardenComponent* Garden, const struct FGardenActionParams& Params_0);
	void RpcServer_PingServer(int64 ClientTimestampMs);
	void RpcServer_RecordMapTravelTelemetry(struct FTelemetryClientDataForMapTravelLoadTime& TravelInfo);
	void RpcServer_RecordSessionStart(const class FString& OsVersion, const class FString& CpuVersion, const class FString& GpuVersion);
	void RpcServer_ReliableServerUpdateCamera(const struct FVector_NetQuantize& CamLoc, int32 CamPitchAndYaw);
	void RpcServer_RemoveWallpaper(const struct FWallpaperItem& Item, class UWallpaperComponent* Wall);
	void RpcServer_ReplaceItemInInventory(class UInventoryComponent* Inventory, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemToBeReplaced, int32 AmountToReplace, struct FValeriaItem& NewItem);
	void RpcServer_RequestHousingPermissionChange(class AHousingOwnershipActor* HousingOwnershipActor, struct FHouseOwnershipTitle& Permission);
	void RpcServer_RequestHousingSlotAction(class AHousingOwnershipActor* HousingOwnershipActor, struct FHousingSlotActionParams& ActionParams);
	void RpcServer_RequestKickHousingVisitor(class AHousingOwnershipActor* HousingOwnershipActor, struct FGuid& VisitorPlayerId);
	void RpcServer_RequestReturnHome();
	void RpcServer_RequestUnKickHousingVisitor(class AHousingOwnershipActor* HousingOwnershipActor, struct FGuid& VisitorPlayerId);
	void RpcServer_RequestUnstuck();
	void RpcServer_ResetAssignedEmotes();
	void RpcServer_SelectRecipeForCrafter(class UCrafterComponent* Crafter, int32 RecipeConfigId, struct FRecipePlayerOptions& RecipeOptions);
	void RpcServer_SetAllowEatingWhenFull(bool AllowEatingWhenFull);
	void RpcServer_SetIgnoreDialogueDailyLimit(bool Ignore);
	void RpcServer_SetIgnoreGiftTimer(bool Ignore);
	void RpcServer_SetNetworkProfiling(bool Status);
	void RpcServer_SetPartyState(EVAL_PartyManagerState NewState);
	void RpcServer_SetShowVillagerDebugInfo(bool Show);
	void RpcServer_SplitStackOfItemSlot(const struct FBagSlotLocation& Location);
	void RpcServer_SprayCosmetic(TSoftObjectPtr<class UVAL_SprayDataAsset>& Spray);
	void RpcServer_StartLocalLogin(const struct FUniqueNetIdRepl& UniqueID, const class FString& FakePIELogin);
	void RpcServer_TeleportToPlayerHouseKiosk();
	void RpcServer_ToggleReturnHomeCooldownEnabled();
	void RpcServer_UnlockHousingPlot(class AHousingOwnershipActor* HousingOwnershipActor, int32 PersistId);
	void RpcServer_UpdateAlterationOnPlaceable(class AActor* Actor, int32 PersistId);
	void RpcServer_UpdatePlayerPlatformName(const class FString& NewPlayerPlatformName);
	void RpcServer_UpgradeOrPurchaseHouse(int32 HouseConfigId);
	void RpcServerTeleportToPlayerHouse(struct FUniqueNetIdRepl& UserId);
	void SelectRecipeForCrafter(class UCrafterComponent* Crafter, int32 RecipeConfigId, struct FRecipePlayerOptions& RecipeOptions);
	void SellItem(const struct FBagSlotLocation& InventoryLocation, int32 Amount);
	void SendErrorMessage(class FName ErrorCode);
	void SendErrorMessageComplex(const struct FErrorMessage& Error);
	void SendErrorMessageText(class FText& Error);
	void SendErrorModal(class FName Error);
	void SendErrorStringToLog(const class FString& Error);
	void SendGameSettingsTelemetryEvent();
	void SendGraphicsSettingsTelemetryEvent(bool bNotChangedByUser);
	void Server_VAkEventLocation(class AActor* ActorHit, bool WasDamaged, int32 SearchRadius, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& HeldItemType, const struct FVector& Location, class APlayerController* ExceptionController, class AActor* ExtInstigator);
	void ServerNetworkProfile(bool State);
	void ServerOnly_DisconnectWithMessage(class FText& Message);
	void SetHousingPermission(class AHousingOwnershipActor* HousingOwnershipActor, struct FHouseOwnershipTitle& Permission);
	void SetIgnoreDialogueDailyLimit(bool Ignore);
	void SetIgnoreFriendLvlReqsForDynamicGiftPrefs(bool Ignore);
	void SetIgnoreGiftTimer(bool Ignore);
	void SetShowVillagerDebugInfo(bool Show);
	void SpeedCheat(float SpeedMultiplier);
	void SplitStackOfItemSlot(const struct FBagSlotLocation& Location);
	void StartMatchmaking(struct FOSSVAL_MatchmakingRequestContext& Context);
	void StartPerfCapture();
	void TeleportToLookAt();
	void TransitiveDecorInteract(class UTransitiveDecorComponent* TransComponent, ETransitiveDecorStimulusType InteractionType, int32 InteractionState, int32 InteractionValue);
	void TravelToMap(const class FString& Destination);
	void TriggerFocusUpgradedEvent(EVAL_ShrineType ShrineType, float UpgradeAmount);
	void UnKickHousingVisitor(class AHousingOwnershipActor* HousingOwnershipActor, struct FGuid& VisitorPlayerId);
	void UnlockHousingPlot(int32 PersistId);
	void UnlockPawnInput(const struct FGuid& IDRequestingUnlock);
	void UnstuckPlayerCharacter();
	void UpdateAlterationOnPlaceable(class AActor* Actor, int32 PersistId);
	void UpdateInputSettings();
	void UpdatePlayerStateMeshRelevancy();
	void UpgradeOrPurchaseHouse(int32 HouseConfigId);
	bool UseOrSelectItem(const struct FBagSlotLocation& Location);

	bool CanActivateSubgame() const;
	bool CanActorBeGathered(class AActor* Actor, class FText* Error) const;
	bool GatherActorHasChildrenAnchored(class AActor* Actor) const;
	class UCinematicManagerComponent* GetCinematicManager() const;
	class AHousingPlotActor* GetCurrentHousingPlot() const;
	class UDebugCheatComponent* GetDebugCheat() const;
	class UInputAction* GetDefaultInputActionForEventIndex(EInteractEventIndex InteractEventIndex) const;
	class UVAL_DialogueRoomManagerComponent* GetDialogueRoomManagerComponent() const;
	class UVAL_EncyclopediaManagerComponent* GetEncyclopediaManagerComponent() const;
	class UVAL_EntitlementComponent* GetEntitlementComponent() const;
	EInteractEventIndex GetInspectInteractEventIndex(EInputType InputType) const;
	EInteractEventIndex GetMovePlaceableInteractEventIndex(EInputType InputType) const;
	double GetNetLastReceivedDeltaSeconds() const;
	class AHousingPlotActor* GetOccupiedHousingPlot() const;
	class UReplicationTrackingComponent* GetReplicationTracking() const;
	int64 GetReturnHomeCooldownEndTime() const;
	float GetSecondsUntilReturnHomeIsAvailable() const;
	class UTrackingComponent* GetTrackingComponent() const;
	class AValeriaCharacter* GetValeriaCharacter() const;
	struct FGuid GetValeriaPlayerId() const;
	bool IsAtHome() const;
	bool IsInCinematicMode() const;
	bool IsOnHousingPlot() const;
	bool IsPlayerExpectedToLeaveViaMatchmaking() const;
	void RpcClient_NotifyCharacterCompletedCourse(class AValeriaCharacter* InCharacter, const struct FVector& InLocation, class UVAL_ScoreDefinition* ScoreDefinition) const;
	void RpcClient_NotifyCharacterFellOutOfWorld(class AValeriaCharacter* InCharacter, const struct FVector& InLocation) const;
	bool WasPremiumStoreEntitlementSeen(struct FGuid& ID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaPlayerController">();
	}
	static class AValeriaPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaPlayerController>();
	}
};
static_assert(alignof(AValeriaPlayerController) == 0x000008, "Wrong alignment on AValeriaPlayerController");
static_assert(sizeof(AValeriaPlayerController) == 0x000FD0, "Wrong size on AValeriaPlayerController");
static_assert(offsetof(AValeriaPlayerController, OnErrorMessageReceived) == 0x000A38, "Member 'AValeriaPlayerController::OnErrorMessageReceived' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnErrorMessageTextReceived) == 0x000A48, "Member 'AValeriaPlayerController::OnErrorMessageTextReceived' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnErrorModalReceived) == 0x000A58, "Member 'AValeriaPlayerController::OnErrorModalReceived' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnPremiumStoreEntitlementsChanged) == 0x000A68, "Member 'AValeriaPlayerController::OnPremiumStoreEntitlementsChanged' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnPossessionChanged) == 0x000A78, "Member 'AValeriaPlayerController::OnPossessionChanged' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnCharacterWasSpawnedEvent) == 0x000A88, "Member 'AValeriaPlayerController::OnCharacterWasSpawnedEvent' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnFocusUpgradedEvent) == 0x000A98, "Member 'AValeriaPlayerController::OnFocusUpgradedEvent' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnHousingPlotVisited) == 0x000AA8, "Member 'AValeriaPlayerController::OnHousingPlotVisited' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnSimpleFadeRequested) == 0x000AB8, "Member 'AValeriaPlayerController::OnSimpleFadeRequested' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnCinematicSetup) == 0x000AC8, "Member 'AValeriaPlayerController::OnCinematicSetup' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnCinematicTeardown) == 0x000AD8, "Member 'AValeriaPlayerController::OnCinematicTeardown' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnCharacterTeleported) == 0x000AF8, "Member 'AValeriaPlayerController::OnCharacterTeleported' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, SyncTimeInterval) == 0x000B08, "Member 'AValeriaPlayerController::SyncTimeInterval' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, PlayerSnapshotInterval) == 0x000B0C, "Member 'AValeriaPlayerController::PlayerSnapshotInterval' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, PlayerTraversalSnapshotInterval) == 0x000B10, "Member 'AValeriaPlayerController::PlayerTraversalSnapshotInterval' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, GameTelemetrySnapshotInterval) == 0x000B14, "Member 'AValeriaPlayerController::GameTelemetrySnapshotInterval' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, DisconnectWithMessageTimeoutHandle) == 0x000B18, "Member 'AValeriaPlayerController::DisconnectWithMessageTimeoutHandle' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, UnstuckCooldownTimerHandle) == 0x000B20, "Member 'AValeriaPlayerController::UnstuckCooldownTimerHandle' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, UnstuckLastUsageTime) == 0x000B28, "Member 'AValeriaPlayerController::UnstuckLastUsageTime' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, UnstuckCooldownSeconds) == 0x000B30, "Member 'AValeriaPlayerController::UnstuckCooldownSeconds' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, UnstuckUseFactorIncrease) == 0x000B34, "Member 'AValeriaPlayerController::UnstuckUseFactorIncrease' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, UnstuckOnCooldownText) == 0x000B38, "Member 'AValeriaPlayerController::UnstuckOnCooldownText' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ReturnHomeCooldownTimerHandle) == 0x000B50, "Member 'AValeriaPlayerController::ReturnHomeCooldownTimerHandle' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ReturnHomeLastUsageTime) == 0x000B58, "Member 'AValeriaPlayerController::ReturnHomeLastUsageTime' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ReturnHomeCooldownSeconds) == 0x000B60, "Member 'AValeriaPlayerController::ReturnHomeCooldownSeconds' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ReturnHomeDestinationAddress) == 0x000B68, "Member 'AValeriaPlayerController::ReturnHomeDestinationAddress' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, InteractableSearchRadius) == 0x000B74, "Member 'AValeriaPlayerController::InteractableSearchRadius' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, InteractableSearchDistanceAhead) == 0x000B78, "Member 'AValeriaPlayerController::InteractableSearchDistanceAhead' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, PlacementModeWallpaperSearchDistance) == 0x000B7C, "Member 'AValeriaPlayerController::PlacementModeWallpaperSearchDistance' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, PlacementModeWallpaperLongRangeAllowedTags) == 0x000B80, "Member 'AValeriaPlayerController::PlacementModeWallpaperLongRangeAllowedTags' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, CurrentSubgameInputBindingHandles) == 0x000BA8, "Member 'AValeriaPlayerController::CurrentSubgameInputBindingHandles' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnClientLeaveHousingPlot) == 0x000BB8, "Member 'AValeriaPlayerController::OnClientLeaveHousingPlot' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnClientArriveOnHousingPlot) == 0x000BC8, "Member 'AValeriaPlayerController::OnClientArriveOnHousingPlot' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnClientVisitorListUpdated) == 0x000BD8, "Member 'AValeriaPlayerController::OnClientVisitorListUpdated' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, PlotPresence) == 0x000BE8, "Member 'AValeriaPlayerController::PlotPresence' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, bPendingPersistenceFlush) == 0x000BF8, "Member 'AValeriaPlayerController::bPendingPersistenceFlush' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, bMatchmakingIsExpectedToSucceed) == 0x000BF9, "Member 'AValeriaPlayerController::bMatchmakingIsExpectedToSucceed' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ActiveMatchmakingExpectedTimeoutHandle) == 0x000C00, "Member 'AValeriaPlayerController::ActiveMatchmakingExpectedTimeoutHandle' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnReticleNeedsUpdate) == 0x000C58, "Member 'AValeriaPlayerController::OnReticleNeedsUpdate' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ValeriaCharacter) == 0x000C68, "Member 'AValeriaPlayerController::ValeriaCharacter' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, BurstNetSpeed) == 0x000C70, "Member 'AValeriaPlayerController::BurstNetSpeed' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, Cheater) == 0x000C78, "Member 'AValeriaPlayerController::Cheater' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, TrackingComponent) == 0x000C80, "Member 'AValeriaPlayerController::TrackingComponent' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, DebugServerActors) == 0x000C88, "Member 'AValeriaPlayerController::DebugServerActors' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ReplicationTracking) == 0x000C90, "Member 'AValeriaPlayerController::ReplicationTracking' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, EncyclopediaManagerComponent) == 0x000C98, "Member 'AValeriaPlayerController::EncyclopediaManagerComponent' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, EntitlementComponent) == 0x000CA0, "Member 'AValeriaPlayerController::EntitlementComponent' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, DialogueRoomManagerComponent) == 0x000CA8, "Member 'AValeriaPlayerController::DialogueRoomManagerComponent' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, CinematicManagerComponent) == 0x000CB0, "Member 'AValeriaPlayerController::CinematicManagerComponent' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, DebugSpawning) == 0x000CB8, "Member 'AValeriaPlayerController::DebugSpawning' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, GameInst) == 0x000E10, "Member 'AValeriaPlayerController::GameInst' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, MusicState) == 0x000E28, "Member 'AValeriaPlayerController::MusicState' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, SpawnOnFoliageManager) == 0x000EA8, "Member 'AValeriaPlayerController::SpawnOnFoliageManager' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnCinematicModeSet) == 0x000EB0, "Member 'AValeriaPlayerController::OnCinematicModeSet' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnItemPurcahsedFrom3DStore) == 0x000ED8, "Member 'AValeriaPlayerController::OnItemPurcahsedFrom3DStore' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnRecipeCrafted) == 0x000EE8, "Member 'AValeriaPlayerController::OnRecipeCrafted' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, InitialTeleportAsset) == 0x000F00, "Member 'AValeriaPlayerController::InitialTeleportAsset' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, InitialTeleportTargetAccountID) == 0x000F08, "Member 'AValeriaPlayerController::InitialTeleportTargetAccountID' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ServerExpPkg) == 0x000F18, "Member 'AValeriaPlayerController::ServerExpPkg' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, NewsInbox) == 0x000F20, "Member 'AValeriaPlayerController::NewsInbox' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ValeriaCharacterPlayerGuid) == 0x000F28, "Member 'AValeriaPlayerController::ValeriaCharacterPlayerGuid' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, ValeriaCharacterPrimaryHouseGuid) == 0x000F38, "Member 'AValeriaPlayerController::ValeriaCharacterPrimaryHouseGuid' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, NearestPlayersUpdated) == 0x000F50, "Member 'AValeriaPlayerController::NearestPlayersUpdated' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnCharacterFellOutOfWorld) == 0x000F60, "Member 'AValeriaPlayerController::OnCharacterFellOutOfWorld' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, OnCharacterCompletedCourse) == 0x000F70, "Member 'AValeriaPlayerController::OnCharacterCompletedCourse' has a wrong offset!");
static_assert(offsetof(AValeriaPlayerController, CachedEffectActors) == 0x000F80, "Member 'AValeriaPlayerController::CachedEffectActors' has a wrong offset!");

// Class Palia.ConvertibleActor
// 0x0000 (0x0028 - 0x0028)
class IConvertibleActor final : public IInterface
{
public:
	void ApplyConversion(EActorConversionType ConversionType);

	bool CanConvert(EActorConversionType ConversionType) const;
	class UClass* GetClassForConversion(EActorConversionType ConversionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvertibleActor">();
	}
	static class IConvertibleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<IConvertibleActor>();
	}
};
static_assert(alignof(IConvertibleActor) == 0x000008, "Wrong alignment on IConvertibleActor");
static_assert(sizeof(IConvertibleActor) == 0x000028, "Wrong size on IConvertibleActor");

// Class Palia.CookingSubsystem
// 0x00E0 (0x0110 - 0x0030)
class UCookingSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnComplexRecipeChanged;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRecipeBrowse;                                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSubRecipeChanged;                                // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShelfChanged;                                    // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCookingCameraChanged;                            // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIngredientOverrideChanged;                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUseStarQualityChanged;                           // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCraftMultiplierChanged;                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FRecipePlayerOptions                   RecipeOptions;                                     // 0x00B0(0x0018)(NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJoinComplexRecipe;                               // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnExitComplexRecipe;                               // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnComplexRecipeFinished;                           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TArray<class UCrafterComponent*>              ActivelyBrowsingCrafters;                          // 0x00F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2594[0x8];                                     // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRecipeOption_IngredientOverrideMapping(struct FRecipePlayerOptionMapping& MapPing);
	void ClearRecipeOption_IngredientOverrideMappings();
	void Client_UpdateLocalPlayerInCrafterCamera(bool NewIsLocalPlayerInCrafterCamera);
	void ComplexRecipeEvent__DelegateSignature(struct FComplexRecipeRecord& RecipeRecord);
	void ComplexRecipeStartEvent__DelegateSignature(struct FCrafterConfig& MainCrafterConfig, struct FComplexRecipeRecord& RecipeRecord);
	void CookingSubsystemEvent__DelegateSignature();
	void RecipeEvent__DelegateSignature(struct FComplexRecipeRecord& ComplexState, struct FComplexRecipeCrafter& CrafterState, int32 RecipeIndex);
	void RemoveRecipeOption_IngredientOverrideMappingForIndex(int32 SimpleIngredientIndex);
	void SetRecipeOption_CraftMultiplier(int32 Multiplier);
	void SetRecipeOption_UseStarQualityItems(bool UseStarQuality);

	bool Client_GetLocalPlayerInCrafterCamera() const;
	EComplexRecipeCueState GetCookingRecipeCueStateForCrafter(class UCrafterComponent* CrafterComponent, struct FRecipe_RequireItem& RequireItem) const;
	EComplexRecipeCueState GetCookingRecipeCueStateForHUD(int32 CrafterPersistId, struct FRecipe_RequireItem& RequireItem) const;
	EComplexRecipeCueState GetCookingRecipeCueStateForIngredient(class UCrafterComponent* CrafterComponent, struct FRecipe_RequireItem& RequireItem, int32 IngredientIndex) const;
	bool GetRecipeOption_IngredientOverrideMappingForIndex(int32 SimpleIngredientIndex, struct FRecipePlayerOptionMapping* OutMapping, EValeriaFuncResult* OutResult) const;
	bool GetRecipeOption_UseStarQualityItems() const;
	const struct FRecipePlayerOptions GetRecipeOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CookingSubsystem">();
	}
	static class UCookingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCookingSubsystem>();
	}
};
static_assert(alignof(UCookingSubsystem) == 0x000008, "Wrong alignment on UCookingSubsystem");
static_assert(sizeof(UCookingSubsystem) == 0x000110, "Wrong size on UCookingSubsystem");
static_assert(offsetof(UCookingSubsystem, OnComplexRecipeChanged) == 0x000030, "Member 'UCookingSubsystem::OnComplexRecipeChanged' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnRecipeBrowse) == 0x000040, "Member 'UCookingSubsystem::OnRecipeBrowse' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnSubRecipeChanged) == 0x000050, "Member 'UCookingSubsystem::OnSubRecipeChanged' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnShelfChanged) == 0x000060, "Member 'UCookingSubsystem::OnShelfChanged' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnCookingCameraChanged) == 0x000070, "Member 'UCookingSubsystem::OnCookingCameraChanged' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnIngredientOverrideChanged) == 0x000080, "Member 'UCookingSubsystem::OnIngredientOverrideChanged' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnUseStarQualityChanged) == 0x000090, "Member 'UCookingSubsystem::OnUseStarQualityChanged' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnCraftMultiplierChanged) == 0x0000A0, "Member 'UCookingSubsystem::OnCraftMultiplierChanged' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, RecipeOptions) == 0x0000B0, "Member 'UCookingSubsystem::RecipeOptions' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnJoinComplexRecipe) == 0x0000C8, "Member 'UCookingSubsystem::OnJoinComplexRecipe' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnExitComplexRecipe) == 0x0000D8, "Member 'UCookingSubsystem::OnExitComplexRecipe' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, OnComplexRecipeFinished) == 0x0000E8, "Member 'UCookingSubsystem::OnComplexRecipeFinished' has a wrong offset!");
static_assert(offsetof(UCookingSubsystem, ActivelyBrowsingCrafters) == 0x0000F8, "Member 'UCookingSubsystem::ActivelyBrowsingCrafters' has a wrong offset!");

// Class Palia.VAL_AsyncActionCreateRandomLoadoutFromItems
// 0x0068 (0x0098 - 0x0030)
class UVAL_AsyncActionCreateRandomLoadoutFromItems final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_259C[0x58];                                    // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_AsyncActionCreateRandomLoadoutFromItems* CreateRandomLoadoutFromItems(TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>>& Items, EVAL_CharacterBodyType BodyType);

	void OnCreateRandomLoadoutFromItemsCompleted__DelegateSignature(const struct FVAL_CharacterCustomizationLoadout& Loadout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AsyncActionCreateRandomLoadoutFromItems">();
	}
	static class UVAL_AsyncActionCreateRandomLoadoutFromItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AsyncActionCreateRandomLoadoutFromItems>();
	}
};
static_assert(alignof(UVAL_AsyncActionCreateRandomLoadoutFromItems) == 0x000008, "Wrong alignment on UVAL_AsyncActionCreateRandomLoadoutFromItems");
static_assert(sizeof(UVAL_AsyncActionCreateRandomLoadoutFromItems) == 0x000098, "Wrong size on UVAL_AsyncActionCreateRandomLoadoutFromItems");
static_assert(offsetof(UVAL_AsyncActionCreateRandomLoadoutFromItems, Completed) == 0x000030, "Member 'UVAL_AsyncActionCreateRandomLoadoutFromItems::Completed' has a wrong offset!");

// Class Palia.CrafterComponent
// 0x0280 (0x0320 - 0x00A0)
class UCrafterComponent : public UActorComponent
{
public:
	uint8                                         Pad_259E[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCrafterChanged;                                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCrafterChangedWithContext;                       // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCrafterStateChanged;                             // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCrafterBurned;                                   // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCrafterCharacterEngaged;                         // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPropChanged;                                     // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCrafterCancelled;                                // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMinigameSuccessfulInput;                         // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMinigameMistimedInput;                           // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComplexRecipeStarted;                            // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComplexRecipeFinished;                           // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    CrafterConfig;                                     // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCrafterRecipeState                    RecipeState;                                       // 0x0178(0x0038)(Net, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrafterStep>                   Steps;                                             // 0x01B0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAddedIngredient>               UsedItems;                                         // 0x01C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrafterIngredient>             Ingredients;                                       // 0x01D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FValeriaItem                           ItemCrafting;                                      // 0x01E0(0x0060)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCraftingPlayerReward>          PlayerRewards;                                     // 0x0240(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPersistGuid>                   PlayerIdsToReward;                                 // 0x0250(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	ERecipePropPhase                              CurrentPropPhase;                                  // 0x0260(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259F[0x7];                                     // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentProp;                                       // 0x0268(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               Particles;                                         // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 ActiveSteps;                                       // 0x0278(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FVAL_TimerHandle                       Server_CraftTimerHandle;                           // 0x0288(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVAL_TimerHandle                       Server_CraftBurnTimerHandle;                       // 0x0290(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           Server_RecipeRequest_RevealTimerHandle;            // 0x0298(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           Server_RecipeRequest_ExpireTimerHandle;            // 0x02A0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FStartingPlayerInfo                    StartingPlayerInfo;                                // 0x02A8(0x0020)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           UpdateHoldTimeTimerHandle;                         // 0x02C8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           UpdateItemDecayTimerHandle;                        // 0x02D0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProximityChecker*                      ProximityChecker;                                  // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int64                                         CurrentStateStartTimeMs;                           // 0x02E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int64                                         StartedCraftingAtMs;                               // 0x02F0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExpectedMeshEncroachment;                          // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A0[0x14];                                    // 0x02FC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           PropsToPreload;                                    // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void Client_TryDisengageCrafter(class AValeriaPlayerController* PlayerController);
	bool DoesBroadcastApply(class UCrafterComponent* Crafter);
	void HandleInteractableChanged(class UInteractableComponent* InInteractableComponent, class AActor* Actor);
	void HandleInteractableClaimedLocationChanged(struct FVAL_InteractorLockParams& LockParams, class UInteractorComponent* InteractorComponent, bool bLocationClaimed);
	void HandleMinigameMistimedInput(class UMinigameComponentMasterQTE* MinigameComponent);
	void HandleMinigameStateChanged(class UMinigameComponentBase* Comp, EMinigameState PrevState, EMinigameState NewState);
	void HandleMinigameSuccessfulInput(class UMinigameComponentMasterQTE* MinigameComponent);
	void HandlePropReleasedFromCharacter(class UInteractableComponent* InInteractableComponent, struct FVAL_ClientInteractableProp& InteractableProp);
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Vpc, const struct FInteractEventParams& EventParams);
	void OnPostCraftBurnTimer();
	void OnRep_ActiveSteps();
	void OnRep_CrafterState(struct FCrafterRecipeState& OldState);
	void OnRep_Steps();
	void OnReplicated_PropPhase(ERecipePropPhase OldPropPhase);
	void OnReplicatedAndShouldNotify();
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* VC, const struct FInteractEventParams& EventParams);
	void RpcMulticast_CraftingCancelled();
	void RpcMulticast_MistimedInput(class AValeriaCharacter* VC);
	void RpcMulticast_RecipeRequests_OnBurned();
	void RpcMulticast_SuccessfullInput(class AValeriaCharacter* VC);
	bool Server_Collect(class AActor* Actor);
	ECrafterEngageResult SetIsEngaging(bool bShouldEngage, class AValeriaPlayerController* Vpc, bool bForceUnlock);

	ERecipeAvailability CanSelectRecipe(class AActor* Actor, int32 RecipeConfigId, bool bCheckPlotFilter, bool bUseStarQualityItems, bool bAllowIntermixingRegularAndStarQualityIngredients, int32 Multiplier) const;
	bool CanShowCrafterPanel() const;
	bool ContainsAllIngredients(int32 Multiplier) const;
	bool DoesPlayerHaveRecipeOptionsIngredients(class AValeriaCharacter* VC, int32 RecipeId, bool bUseStarQualityItems, struct FRecipePlayerOptions& RecipeOptions) const;
	bool DoesPlayerHaveRootIngredients(class AValeriaCharacter* VC, int32 RecipeId, bool bUseStarQualityItems) const;
	void GatherIconsForIngredients(TArray<class UTexture2D*>* Icons, TArray<int32>* Amounts, int32 RecipeId) const;
	TArray<struct FValeriaItem> GetAddedIngredients() const;
	int64 GetCraftEndTimeMs() const;
	const struct FCrafterConfig GetCrafterConfig() const;
	ECrafterState GetCrafterState() const;
	bool GetCraftLimitTimes(int32* StartTime, int32* EndTime) const;
	bool GetCraftPhaseTimes(int32* StartTime, int32* EndTime) const;
	int64 GetCraftStartTimeMs() const;
	int32 GetCraftTimeMs(int32 RecipeId) const;
	int32 GetCraftTimeToHoldProgressMs() const;
	int32 GetCraftTimeToHoldRequiredSecs() const;
	bool GetEventIndexForInputAction(class AValeriaCharacter* Character, TSoftObjectPtr<class UInputAction>& InputAction, EInteractEventIndex* OutEventIndex) const;
	class FText GetIngredientRequestText(struct FCrafterIngredient& IngredientRequest) const;
	TSoftObjectPtr<class UInputAction> GetInputActionForEventIndex(class AValeriaCharacter* Character, EInteractEventIndex EventIndex) const;
	struct FValeriaItem GetItemCrafting(class AValeriaCharacter* VC) const;
	TArray<int32> GetManualIngredientSteps(int32 RecipeId) const;
	float GetNormalizedCraftingProgress() const;
	int32 GetNumberOfInteractions(int32 RecipeId) const;
	int32 GetNumberOfRequests() const;
	int32 GetNumPlayers() const;
	class AHousingPlotActor* GetOwningPlot() const;
	TArray<struct FPersistGuid> GetPlayers() const;
	const struct FRecipeConfig GetRecipeConfig(int32 RecipeId) const;
	int32 GetRecipeIdCrafting() const;
	struct FValeriaItem GetRecipeItemToProduce() const;
	void GetRecipeNeeds(class AValeriaCharacter* VC, int32 RecipeId, struct FRecipeNeeds* RecipeNeeds, bool bUseStarQualityItems) const;
	struct FRecipeStepConfig GetRecipeStepConfig(int32 RequestIndex, int32 RecipeId) const;
	float GetRequestCompletionNormalized(int32 RequestIndex) const;
	int32 GetRequestProgressTimeToHoldMs(int32 RequestIndex) const;
	float GetRequestRemainingNormalized(int32 RequestIndex) const;
	int32 GetRequestRequiredTimeToHoldMs(int32 RequestIndex) const;
	bool GetRequestTimes(int32* StartTime, int32* EndTime) const;
	int32 GetRequireItemAmount(class AValeriaCharacter* VC, struct FRecipe_RequireItem& RequireItem, bool UseStarQualityItem) const;
	TArray<struct FRecipe_RequireItem> GetStartingIngredients(int32 RecipeId) const;
	bool GetText(class AValeriaCharacter* VC, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 GetTimeRemainingTillBurntMs() const;
	int32 GetTimeSpentCraftingMs() const;
	bool GetUseableIMC(class AValeriaCharacter* Character, EInteractEventIndex InteractIndex, struct FInputMappingPriorityData* OutMappingData, struct FModifyContextOptions* OutOptions) const;
	bool HasIngredientsToProduceRecipe(int32 RecipeConfigId, class UInventoryComponent* InputInventory, struct FGameplayTag& InputInventoryBagType) const;
	bool HasIngredientTypesToProduceRecipe(int32 RecipeConfigId, class UInventoryComponent* InputInventory, struct FGameplayTag& InputInventoryBagType) const;
	bool HasInventorySpaceToProduceRecipe(int32 RecipeConfigId, class UInventoryComponent* InventoryComponent) const;
	bool HasPermissionsToCancelCrafting(class AValeriaCharacter* Character) const;
	bool HasRecipeFailed() const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsComplexRecipe(int32 RecipeId) const;
	bool IsIngredientActive(int32 Param_Index) const;
	bool IsIngredientExpired(int32 Param_Index) const;
	bool IsIngredientFullyAdded(int32 Param_Index) const;
	bool IsInteractable(class AValeriaCharacter* VC, const struct FInteractEventParams& EventParams) const;
	bool IsInteractingMode() const;
	bool IsPlateVisible(class AActor* InteractingActor) const;
	bool IsRequestStepActive(int32 RequestIndex) const;
	bool IsRequestStepDone(int32 RequestIndex) const;
	bool IsRequestStepExpired(int32 RequestIndex) const;
	bool K2_CanMakeRecipe(class AActor* Actor, int32 RecipeConfigId, bool bUseStarQualityItems, bool bAllowIntermixingRegularAndStarQualityIngredients, int32 CraftMultiplier) const;
	bool K2_GetComplexState(struct FComplexRecipeRecord* OutRecipeRecord) const;
	struct FNotification ShouldBlockGathering(class AValeriaCharacter* Character) const;
	int32 StarQualityItemsConsumedByRecipe(class AValeriaCharacter* VC, int32 RecipeConfigId) const;
	bool TryGetBurnTimes(int64* StartTime, int64* EndTime) const;
	bool WasRequestStepStarted(int32 RequestIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrafterComponent">();
	}
	static class UCrafterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrafterComponent>();
	}
};
static_assert(alignof(UCrafterComponent) == 0x000008, "Wrong alignment on UCrafterComponent");
static_assert(sizeof(UCrafterComponent) == 0x000320, "Wrong size on UCrafterComponent");
static_assert(offsetof(UCrafterComponent, OnCrafterChanged) == 0x0000B8, "Member 'UCrafterComponent::OnCrafterChanged' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnCrafterChangedWithContext) == 0x0000C8, "Member 'UCrafterComponent::OnCrafterChangedWithContext' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnCrafterStateChanged) == 0x0000D8, "Member 'UCrafterComponent::OnCrafterStateChanged' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnCrafterBurned) == 0x0000E8, "Member 'UCrafterComponent::OnCrafterBurned' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnCrafterCharacterEngaged) == 0x0000F8, "Member 'UCrafterComponent::OnCrafterCharacterEngaged' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnPropChanged) == 0x000108, "Member 'UCrafterComponent::OnPropChanged' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnCrafterCancelled) == 0x000118, "Member 'UCrafterComponent::OnCrafterCancelled' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnMinigameSuccessfulInput) == 0x000128, "Member 'UCrafterComponent::OnMinigameSuccessfulInput' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnMinigameMistimedInput) == 0x000138, "Member 'UCrafterComponent::OnMinigameMistimedInput' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnComplexRecipeStarted) == 0x000148, "Member 'UCrafterComponent::OnComplexRecipeStarted' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, OnComplexRecipeFinished) == 0x000158, "Member 'UCrafterComponent::OnComplexRecipeFinished' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, CrafterConfig) == 0x000168, "Member 'UCrafterComponent::CrafterConfig' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, RecipeState) == 0x000178, "Member 'UCrafterComponent::RecipeState' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, Steps) == 0x0001B0, "Member 'UCrafterComponent::Steps' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, UsedItems) == 0x0001C0, "Member 'UCrafterComponent::UsedItems' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, Ingredients) == 0x0001D0, "Member 'UCrafterComponent::Ingredients' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, ItemCrafting) == 0x0001E0, "Member 'UCrafterComponent::ItemCrafting' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, PlayerRewards) == 0x000240, "Member 'UCrafterComponent::PlayerRewards' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, PlayerIdsToReward) == 0x000250, "Member 'UCrafterComponent::PlayerIdsToReward' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, CurrentPropPhase) == 0x000260, "Member 'UCrafterComponent::CurrentPropPhase' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, CurrentProp) == 0x000268, "Member 'UCrafterComponent::CurrentProp' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, Particles) == 0x000270, "Member 'UCrafterComponent::Particles' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, ActiveSteps) == 0x000278, "Member 'UCrafterComponent::ActiveSteps' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, Server_CraftTimerHandle) == 0x000288, "Member 'UCrafterComponent::Server_CraftTimerHandle' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, Server_CraftBurnTimerHandle) == 0x000290, "Member 'UCrafterComponent::Server_CraftBurnTimerHandle' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, Server_RecipeRequest_RevealTimerHandle) == 0x000298, "Member 'UCrafterComponent::Server_RecipeRequest_RevealTimerHandle' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, Server_RecipeRequest_ExpireTimerHandle) == 0x0002A0, "Member 'UCrafterComponent::Server_RecipeRequest_ExpireTimerHandle' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, StartingPlayerInfo) == 0x0002A8, "Member 'UCrafterComponent::StartingPlayerInfo' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, UpdateHoldTimeTimerHandle) == 0x0002C8, "Member 'UCrafterComponent::UpdateHoldTimeTimerHandle' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, UpdateItemDecayTimerHandle) == 0x0002D0, "Member 'UCrafterComponent::UpdateItemDecayTimerHandle' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, InteractableComponent) == 0x0002D8, "Member 'UCrafterComponent::InteractableComponent' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, ProximityChecker) == 0x0002E0, "Member 'UCrafterComponent::ProximityChecker' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, CurrentStateStartTimeMs) == 0x0002E8, "Member 'UCrafterComponent::CurrentStateStartTimeMs' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, StartedCraftingAtMs) == 0x0002F0, "Member 'UCrafterComponent::StartedCraftingAtMs' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, ExpectedMeshEncroachment) == 0x0002F8, "Member 'UCrafterComponent::ExpectedMeshEncroachment' has a wrong offset!");
static_assert(offsetof(UCrafterComponent, PropsToPreload) == 0x000310, "Member 'UCrafterComponent::PropsToPreload' has a wrong offset!");

// Class Palia.CrafterComponent_Automatic
// 0x0040 (0x0360 - 0x0320)
class UCrafterComponent_Automatic final : public UCrafterComponent
{
public:
	FMulticastInlineDelegateProperty_             RecipesChanged;                                    // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<int32>                                 RecipeListUnlocked;                                // 0x0330(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 RecipeListAll;                                     // 0x0340(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UCrafterAutomaticInventoryComponent*    InventoryComponent;                                // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Server_HasBeenSetup;                               // 0x0358(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D4[0x7];                                     // 0x0359(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DevOnly_OnRecipesLocked(class URecipeInventoryComponent* Recipes);
	void OnAutoCrafterChanged(class UCrafterComponent* Crafter);
	void OnInventoryChanged(class UInventoryComponent* Inventory);
	void OnRecipeUnlocked(class URecipeInventoryComponent* Recipes, TArray<int32>& RecipeConfigId);
	void RpcServer_SwapIndices(int32 FirstIndex, int32 SecondIndex);
	void SwapIndices(int32 FirstIndex, int32 SecondIndex);

	bool CanIngredientBeUsedByAnyRecipe(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType) const;
	bool CanIngredientBeUsedByUnlockedRecipe(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType) const;
	class UInventoryComponent* GetInventoryComponent() const;
	const TArray<int32> GetRecipeList() const;
	const TArray<int32> GetRecipeListAll() const;
	bool IsIngredientUsedInRecipe(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 RecipeConfigId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrafterComponent_Automatic">();
	}
	static class UCrafterComponent_Automatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrafterComponent_Automatic>();
	}
};
static_assert(alignof(UCrafterComponent_Automatic) == 0x000008, "Wrong alignment on UCrafterComponent_Automatic");
static_assert(sizeof(UCrafterComponent_Automatic) == 0x000360, "Wrong size on UCrafterComponent_Automatic");
static_assert(offsetof(UCrafterComponent_Automatic, RecipesChanged) == 0x000320, "Member 'UCrafterComponent_Automatic::RecipesChanged' has a wrong offset!");
static_assert(offsetof(UCrafterComponent_Automatic, RecipeListUnlocked) == 0x000330, "Member 'UCrafterComponent_Automatic::RecipeListUnlocked' has a wrong offset!");
static_assert(offsetof(UCrafterComponent_Automatic, RecipeListAll) == 0x000340, "Member 'UCrafterComponent_Automatic::RecipeListAll' has a wrong offset!");
static_assert(offsetof(UCrafterComponent_Automatic, InventoryComponent) == 0x000350, "Member 'UCrafterComponent_Automatic::InventoryComponent' has a wrong offset!");
static_assert(offsetof(UCrafterComponent_Automatic, Server_HasBeenSetup) == 0x000358, "Member 'UCrafterComponent_Automatic::Server_HasBeenSetup' has a wrong offset!");

// Class Palia.ValeriaWaterBodyComponent
// 0x00D0 (0x0170 - 0x00A0)
class UValeriaWaterBodyComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDespawnedForLocalPlayer;                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFishMinigameWaterBodyConfig> FishSpawnPools;                                    // 0x00B0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WaterType;                                         // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanRefillWaterOn;                                  // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D8[0x7];                                     // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFishingFinished;                                 // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         SecondsToDestroyAfterFirstCatch;                   // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCoopSpawningEnabled;                              // 0x00FC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D9[0x3];                                     // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DestroyAfterSecsTimerHandle;                       // 0x0100(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<struct FGuid>                            PlayerIdsThatFishedHere;                           // 0x0108(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DA[0x10];                                    // 0x0158(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           WaitForWorldPartitionToLoadTimerHandle;            // 0x0168(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DestroyWaterBody();

	class UPhysicalMaterial* GetWaterPhysMat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaWaterBodyComponent">();
	}
	static class UValeriaWaterBodyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaWaterBodyComponent>();
	}
};
static_assert(alignof(UValeriaWaterBodyComponent) == 0x000008, "Wrong alignment on UValeriaWaterBodyComponent");
static_assert(sizeof(UValeriaWaterBodyComponent) == 0x000170, "Wrong size on UValeriaWaterBodyComponent");
static_assert(offsetof(UValeriaWaterBodyComponent, OnDespawnedForLocalPlayer) == 0x0000A0, "Member 'UValeriaWaterBodyComponent::OnDespawnedForLocalPlayer' has a wrong offset!");
static_assert(offsetof(UValeriaWaterBodyComponent, FishSpawnPools) == 0x0000B0, "Member 'UValeriaWaterBodyComponent::FishSpawnPools' has a wrong offset!");
static_assert(offsetof(UValeriaWaterBodyComponent, WaterType) == 0x0000D8, "Member 'UValeriaWaterBodyComponent::WaterType' has a wrong offset!");
static_assert(offsetof(UValeriaWaterBodyComponent, CanRefillWaterOn) == 0x0000E0, "Member 'UValeriaWaterBodyComponent::CanRefillWaterOn' has a wrong offset!");
static_assert(offsetof(UValeriaWaterBodyComponent, OnFishingFinished) == 0x0000E8, "Member 'UValeriaWaterBodyComponent::OnFishingFinished' has a wrong offset!");
static_assert(offsetof(UValeriaWaterBodyComponent, SecondsToDestroyAfterFirstCatch) == 0x0000F8, "Member 'UValeriaWaterBodyComponent::SecondsToDestroyAfterFirstCatch' has a wrong offset!");
static_assert(offsetof(UValeriaWaterBodyComponent, bCoopSpawningEnabled) == 0x0000FC, "Member 'UValeriaWaterBodyComponent::bCoopSpawningEnabled' has a wrong offset!");
static_assert(offsetof(UValeriaWaterBodyComponent, DestroyAfterSecsTimerHandle) == 0x000100, "Member 'UValeriaWaterBodyComponent::DestroyAfterSecsTimerHandle' has a wrong offset!");
static_assert(offsetof(UValeriaWaterBodyComponent, PlayerIdsThatFishedHere) == 0x000108, "Member 'UValeriaWaterBodyComponent::PlayerIdsThatFishedHere' has a wrong offset!");
static_assert(offsetof(UValeriaWaterBodyComponent, WaitForWorldPartitionToLoadTimerHandle) == 0x000168, "Member 'UValeriaWaterBodyComponent::WaitForWorldPartitionToLoadTimerHandle' has a wrong offset!");

// Class Palia.CraftingGlobalConfig
// 0x0250 (0x0280 - 0x0030)
class UCraftingGlobalConfig final : public UDataAsset
{
public:
	struct FCraftingGlobalConfig_CoopSettings     CoOp;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DB[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCraftingGlobalConfig_ItemUseSettings  ItemUse;                                           // 0x0038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECraftingRequestItemMode                      RequestItemMode;                                   // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DC[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNotification                          RecipeRuined;                                      // 0x0078(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UVAL_ItemTypeDefinitionAsset*           FailureRewardItemType;                             // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QualityBaseChance;                                 // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QualityChancePerSkillLevel;                        // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QualityChanceForIngredients;                       // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QualityChanceForMinigame;                          // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstTimeFurniturePercentBonus;                    // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DD[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCraftingGlobalConfig_ModificationBenchSettings ModificationBenchSettings;                         // 0x00C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCraftingGlobalConfig_CookingSettings  Cooking;                                           // 0x00E8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCraftingGlobalConfig_InputActions     Input;                                             // 0x0140(0x0140)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CraftingGlobalConfig">();
	}
	static class UCraftingGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCraftingGlobalConfig>();
	}
};
static_assert(alignof(UCraftingGlobalConfig) == 0x000008, "Wrong alignment on UCraftingGlobalConfig");
static_assert(sizeof(UCraftingGlobalConfig) == 0x000280, "Wrong size on UCraftingGlobalConfig");
static_assert(offsetof(UCraftingGlobalConfig, CoOp) == 0x000030, "Member 'UCraftingGlobalConfig::CoOp' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, ItemUse) == 0x000038, "Member 'UCraftingGlobalConfig::ItemUse' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, RequestItemMode) == 0x000070, "Member 'UCraftingGlobalConfig::RequestItemMode' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, RecipeRuined) == 0x000078, "Member 'UCraftingGlobalConfig::RecipeRuined' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, FailureRewardItemType) == 0x0000A8, "Member 'UCraftingGlobalConfig::FailureRewardItemType' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, QualityBaseChance) == 0x0000B0, "Member 'UCraftingGlobalConfig::QualityBaseChance' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, QualityChancePerSkillLevel) == 0x0000B4, "Member 'UCraftingGlobalConfig::QualityChancePerSkillLevel' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, QualityChanceForIngredients) == 0x0000B8, "Member 'UCraftingGlobalConfig::QualityChanceForIngredients' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, QualityChanceForMinigame) == 0x0000BC, "Member 'UCraftingGlobalConfig::QualityChanceForMinigame' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, FirstTimeFurniturePercentBonus) == 0x0000C0, "Member 'UCraftingGlobalConfig::FirstTimeFurniturePercentBonus' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, ModificationBenchSettings) == 0x0000C8, "Member 'UCraftingGlobalConfig::ModificationBenchSettings' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, Cooking) == 0x0000E8, "Member 'UCraftingGlobalConfig::Cooking' has a wrong offset!");
static_assert(offsetof(UCraftingGlobalConfig, Input) == 0x000140, "Member 'UCraftingGlobalConfig::Input' has a wrong offset!");

// Class Palia.CreatureAIController
// 0x0008 (0x03D8 - 0x03D0)
class ACreatureAIController final : public AAIController
{
public:
	class UBehaviorTreeComponent*                 BTComponent;                                       // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UBehaviorTreeComponent* GetBTComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatureAIController">();
	}
	static class ACreatureAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACreatureAIController>();
	}
};
static_assert(alignof(ACreatureAIController) == 0x000008, "Wrong alignment on ACreatureAIController");
static_assert(sizeof(ACreatureAIController) == 0x0003D8, "Wrong size on ACreatureAIController");
static_assert(offsetof(ACreatureAIController, BTComponent) == 0x0003D0, "Member 'ACreatureAIController::BTComponent' has a wrong offset!");

// Class Palia.ValeriaSplineBatchGenerator
// 0x0018 (0x02C0 - 0x02A8)
class AValeriaSplineBatchGenerator final : public AActor
{
public:
	class USplineComponent*                       Spline;                                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         GeneratedActors;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, DuplicateTransient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaSplineBatchGenerator">();
	}
	static class AValeriaSplineBatchGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaSplineBatchGenerator>();
	}
};
static_assert(alignof(AValeriaSplineBatchGenerator) == 0x000008, "Wrong alignment on AValeriaSplineBatchGenerator");
static_assert(sizeof(AValeriaSplineBatchGenerator) == 0x0002C0, "Wrong size on AValeriaSplineBatchGenerator");
static_assert(offsetof(AValeriaSplineBatchGenerator, Spline) == 0x0002A8, "Member 'AValeriaSplineBatchGenerator::Spline' has a wrong offset!");
static_assert(offsetof(AValeriaSplineBatchGenerator, GeneratedActors) == 0x0002B0, "Member 'AValeriaSplineBatchGenerator::GeneratedActors' has a wrong offset!");

// Class Palia.ValeriaBaseMovementComponent
// 0x0A28 (0x0B80 - 0x0158)
#pragma pack(push, 0x1)
class alignas(0x10) UValeriaBaseMovementComponent : public UPawnMovementComponent
{
public:
	class AValeriaMoveablePawn*                   MoveableOwner;                                     // 0x0158(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPathFollowingComponent*                FollowComponent;                                   // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravityScale;                                      // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZVelocity;                                     // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOffJumpZFactor;                                // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpCapsuleHalfHeight;                             // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpCapsuleRadius;                                 // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkCapsuleHalfHeight;                             // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkCapsuleRadius;                                 // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkableFloorAngle;                                // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkableFloorZ;                                    // 0x018C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMovementMode                                 MovementMode;                                      // 0x0190(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValeriaMoveSimulationFlag                    MoveSimFlags;                                      // 0x0191(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DE[0x6];                                     // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetFacing;                                      // 0x0198(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation1;                                   // 0x01B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation2;                                   // 0x01C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AValeriaMoveablePawn*                   TargetLocationLeader;                              // 0x01E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaderFollowDistance;                              // 0x01E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaderCloseEnoughRange;                            // 0x01EC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeaderLocationOffset;                              // 0x01F0(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaderInStep;                                     // 0x0208(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReachedTargetLocation1;                        // 0x0209(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DF[0x2];                                     // 0x020A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeleportDirectToThreshold;                         // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseFacingInsteadInSimFaceVelocityThreshold;        // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseForcedFacing;                            // 0x0214(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E0[0x3];                                     // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ForcedFacing;                                      // 0x0218(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              SimplePathTarget;                                  // 0x0230(0x0010)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SimplePathDirection;                               // 0x0240(0x0010)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimplePathDuration;                                // 0x0250(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimplePathGuaranteeFinalPosition;                 // 0x0254(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E1[0x3];                                     // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SimplePathGuaranteedFinalLocation;                 // 0x0258(0x0018)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               SimplePathGuaranteedFinalRotation;                 // 0x0270(0x0018)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         CustomMovementMode;                                // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENetworkSmoothingMode                         NetworkSmoothingMode;                              // 0x0289(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E2[0x2];                                     // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundFriction;                                    // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E3[0x38];                                    // 0x0290(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      SpeedScalarModifierMap;                            // 0x02C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	float                                         SpeedScalar;                                       // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeed;                                      // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimSpeedCatchUpScalar;                             // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFrictionFactor;                             // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFriction;                                   // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingSubStepTime;                                // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationWalking;                        // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationFalling;                        // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationSwimming;                       // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationFlying;                         // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControl;                                        // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControlBoostMultiplier;                         // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControlBoostVelocityThreshold;                  // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingLateralFriction;                            // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Buoyancy;                                          // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerchRadiusThreshold;                              // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerchAdditionalHeight;                             // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationRate;                                      // 0x0360(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               TempOverrideRotationRate;                          // 0x0378(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bUseSeparateBrakingFriction : 1;                   // 0x0390(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyGravityWhileJumping : 1;                     // 0x0390(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseControllerDesiredRotation : 1;                 // 0x0390(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOrientRotationToMovement : 1;                     // 0x0390(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSweepWhileNavWalking : 1;                         // 0x0390(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_5D : 1;                                     // 0x0390(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bMovementInProgress : 1;                           // 0x0390(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableScopedMovementUpdates : 1;                  // 0x0390(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceMaxAccel : 1;                                // 0x0391(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRunPhysicsWithNoController : 1;                   // 0x0391(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceNextFloorCheck : 1;                          // 0x0391(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShrinkProxyCapsule : 1;                           // 0x0391(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanWalkOffLedges : 1;                             // 0x0391(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_5E : 2;                                     // 0x0391(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bNetworkSkipProxyPredictionOnNetUpdate : 1;        // 0x0391(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNetworkSkipProxyPredictionAlways : 1;             // 0x0392(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDeferUpdateMoveComponent : 1;                     // 0x0392(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnablePhysicsInteraction : 1;                     // 0x0392(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTouchForceScaledToMass : 1;                       // 0x0392(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPushForceScaledToMass : 1;                        // 0x0392(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPushForceUsingZOffset : 1;                        // 0x0392(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScalePushForceToVelocity : 1;                     // 0x0392(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25E4[0x5];                                     // 0x0393(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DeferredUpdatedMoveComponent;                      // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOutOfWaterStepHeight;                           // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutofWaterZ;                                       // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandingDownwardForceScale;                        // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialPushForceFactor;                            // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushForceFactor;                                   // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushForcePointZOffsetFactor;                       // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TouchForceFactor;                                  // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTouchForce;                                     // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTouchForce;                                     // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepulsionForce;                                    // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E5[0x4];                                     // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Acceleration;                                      // 0x03D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E6[0x8];                                     // 0x03E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  LastUpdateRotation;                                // 0x03F0(0x0020)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastUpdateLocation;                                // 0x0410(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastUpdateVelocity;                                // 0x0428(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingImpulseToApply;                             // 0x0440(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingForceToApply;                               // 0x0458(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnalogInputModifier;                               // 0x0470(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E7[0xC];                                     // 0x0474(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bClientSimUseThrottleDistribution;                 // 0x0480(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E8[0x7];                                     // 0x0481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimMoveThrottleMappings               ThrottleMappings;                                  // 0x0488(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E9[0x1F8];                                   // 0x04E8(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSimulationTimeStep;                             // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimulationTimeStep_Constrained;                 // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSimulationIterations;                           // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxJumpApexAttemptsPerSimulation;                  // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationWithGeometry;                      // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationWithGeometryAsProxy;               // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationWithPawn;                          // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationWithPawnAsProxy;                   // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetProxyShrinkRadius;                              // 0x0700(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetProxyShrinkHalfHeight;                          // 0x0704(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LedgeCheckThreshold;                               // 0x0708(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOutOfWaterPitch;                               // 0x070C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloorInfo                             CurrentFloor;                                      // 0x0710(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_25EA[0xF8];                                    // 0x0800(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	EMovementMode                                 DefaultLandMovementMode;                           // 0x08F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 GroundMovementMode;                                // 0x08F9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25EB[0x2];                                     // 0x08FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReduceSimulationToTeleportsThreshold;              // 0x08FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReduceSimulationToTeleportsThreshold_ConstrainedPlatform; // 0x0900(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReduceSimulationToOneStepThreshold;                // 0x0904(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReduceSimulationToOneStepThreshold_Constrained;    // 0x0908(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CachedDistanceFromLocalPlayerSq;                   // 0x090C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bMovedBySimLodTele : 1;                            // 0x0910(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_25EC[0x3];                                     // 0x0911(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuickFloorAdjustTraceStartHeight;                  // 0x0914(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuickFloorAdjustTraceEndDepth;                     // 0x0918(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckFloorPeriod;                                  // 0x091C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckFloorTimer;                                   // 0x0920(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25ED[0x4];                                     // 0x0924(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, float>                    CosmeticAvoidanceActors;                           // 0x0928(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bMaintainHorizontalGroundVelocity : 1;             // 0x0978(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImpartBaseVelocityX : 1;                          // 0x0978(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImpartBaseVelocityY : 1;                          // 0x0978(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImpartBaseVelocityZ : 1;                          // 0x0978(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImpartBaseAngularVelocity : 1;                    // 0x0978(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bJustTeleported : 1;                               // 0x0978(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNetworkUpdateReceived : 1;                        // 0x0978(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNetworkMovementModeChanged : 1;                   // 0x0978(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNotifyApex : 1;                                   // 0x0979(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheatFlying : 1;                                  // 0x0979(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreBaseRotation : 1;                           // 0x0979(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFastAttachedMove : 1;                             // 0x0979(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysCheckFloor : 1;                             // 0x0979(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFlatBaseForFloorChecks : 1;                    // 0x0979(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPerformingJumpOff : 1;                            // 0x0979(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWantsToLeaveNavWalking : 1;                       // 0x0979(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequestedMoveUseAcceleration : 1;                 // 0x097A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_5F : 1;                                     // 0x097A(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bHasRequestedVelocity : 1;                         // 0x097A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRequestedMoveWithMaxSpeed : 1;                    // 0x097A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_60 : 1;                                     // 0x097A(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bProjectNavMeshWalking : 1;                        // 0x097A(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProjectNavMeshOnBothWorldChannels : 1;            // 0x097A(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_25EE[0x5];                                     // 0x097B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RequestedVelocity;                                 // 0x0980(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PendingLaunchVelocity;                             // 0x0998(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25EF[0x108];                                   // 0x09B0(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavMeshProjectionInterval;                         // 0x0AB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionTimer;                            // 0x0ABC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionInterpSpeed;                      // 0x0AC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionHeightScaleUp;                    // 0x0AC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionHeightScaleDown;                  // 0x0AC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavWalkingFloorDistTolerance;                      // 0x0ACC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeleportToResolvePath;                           // 0x0AD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FValeriaBaseMovementComponentPostPhysicsTickFunction PostPhysicsTickFunction;                           // 0x0AE0(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_25F0[0x48];                                    // 0x0B10(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        TargetLocations;                                   // 0x0B58(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F1[0x4];                                     // 0x0B68(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseTargetLocationArray;                           // 0x0B6C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F2[0x3];                                     // 0x0B6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnstuckTeleportAttempts;                           // 0x0B70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UnstuckTeleportDistance;                           // 0x0B74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddForce(const struct FVector& Force);
	void AddImpulse(const struct FVector& Impulse, bool bVelocityChange);
	bool AttemptServerTeleport(struct FVector& TeleportTarget, struct FRotator& TeleportRotation);
	void CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration);
	void CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void ClearAccumulatedForces();
	void ClearAllAvoidanceActors();
	void ClearAvoidanceActor(class AActor* MatchAvoidanceActor);
	void DisableMovement();
	void EnforceTargetLocationAndFacing();
	void OnRep_MoveSimFlags(EValeriaMoveSimulationFlag& OldFlags);
	void OnRep_TargetLocation1();
	void OnRep_TargetLocation2();
	void OnRep_TargetLocationLeader();
	void RpcClient_AddImpulse(const struct FVector& Impulse, bool bVelocityChange);
	void RpcClient_ApplyJump();
	void RpcClient_ApplyTeleport(const struct FVector& TeleportLocation, const struct FRotator& TeleportRotation);
	void RpcClient_UpdateTargetLocations(TArray<struct FVector>& TargetLocationsToRemove, TArray<struct FVector>& TargetLocationsToAdd, struct FVector& CurrentServerTarget, struct FVector& CurrentServerPosition);
	void RpcMulticast_SnapToDirection(const struct FRotator& Rotation);
	void Server_AddSpeedScalarModifier(class FName& InName, float& InSpeedScalarModifier);
	void Server_RemoveSpeedScalarModifier(class FName& InName);
	void Server_SnapToDirection(const struct FRotator& Rotation);
	void SetAvoidanceActor(class AActor* NewAvoidanceActor, float Radius);
	void SetMovementMode(EMovementMode NewMovementMode, uint8 NewCustomMode);
	void SetWalkableFloorAngle(float InWalkableFloorAngle);
	void SetWalkableFloorZ(float InWalkableFloorZ);
	bool StartFollowingLeader(class AValeriaMoveablePawn* NewLeader, float Distance, float CloseEnough);
	bool StopFollowingLeader();

	bool DetermineCurrentNavMeshLocation(struct FVector* NavFloorLocation) const;
	void DeterminePrimaryAvoidanceActor(class AActor** AvoidanceActor, float* Radius) const;
	float GetAnalogInputModifier() const;
	struct FVector GetCurrentAcceleration() const;
	class UPathFollowingComponent* GetFollowingComponent() const;
	struct FVector GetImpartedMovementBaseVelocity() const;
	struct FVector GetLastUpdateLocation() const;
	struct FRotator GetLastUpdateRotation() const;
	struct FVector GetLastUpdateVelocity() const;
	float GetMaxAcceleration() const;
	float GetMaxBrakingDeceleration() const;
	float GetMaxJumpHeight() const;
	float GetMaxJumpHeightWithJumpTime() const;
	float GetMinAnalogSpeed() const;
	class AValeriaMoveablePawn* GetMoveableOwner() const;
	class UPrimitiveComponent* GetMovementBase() const;
	float GetPerchRadiusThreshold() const;
	float GetValidPerchRadius() const;
	bool IsWalkable(struct FHitResult& Hit) const;
	bool IsWalking() const;
	void K2_ComputeFloorDist(const struct FVector& CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, struct FFloorInfo* FloorResult) const;
	void K2_FindFloor(const struct FVector& CapsuleLocation, struct FFloorInfo* FloorResult) const;
	float K2_GetWalkableFloorAngle() const;
	float K2_GetWalkableFloorZ() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaBaseMovementComponent">();
	}
	static class UValeriaBaseMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaBaseMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UValeriaBaseMovementComponent) == 0x000010, "Wrong alignment on UValeriaBaseMovementComponent");
static_assert(sizeof(UValeriaBaseMovementComponent) == 0x000B80, "Wrong size on UValeriaBaseMovementComponent");
static_assert(offsetof(UValeriaBaseMovementComponent, MoveableOwner) == 0x000158, "Member 'UValeriaBaseMovementComponent::MoveableOwner' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, FollowComponent) == 0x000160, "Member 'UValeriaBaseMovementComponent::FollowComponent' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, GravityScale) == 0x000168, "Member 'UValeriaBaseMovementComponent::GravityScale' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxStepHeight) == 0x00016C, "Member 'UValeriaBaseMovementComponent::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, JumpZVelocity) == 0x000170, "Member 'UValeriaBaseMovementComponent::JumpZVelocity' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, JumpOffJumpZFactor) == 0x000174, "Member 'UValeriaBaseMovementComponent::JumpOffJumpZFactor' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, JumpCapsuleHalfHeight) == 0x000178, "Member 'UValeriaBaseMovementComponent::JumpCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, JumpCapsuleRadius) == 0x00017C, "Member 'UValeriaBaseMovementComponent::JumpCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, WalkCapsuleHalfHeight) == 0x000180, "Member 'UValeriaBaseMovementComponent::WalkCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, WalkCapsuleRadius) == 0x000184, "Member 'UValeriaBaseMovementComponent::WalkCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, WalkableFloorAngle) == 0x000188, "Member 'UValeriaBaseMovementComponent::WalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, WalkableFloorZ) == 0x00018C, "Member 'UValeriaBaseMovementComponent::WalkableFloorZ' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MovementMode) == 0x000190, "Member 'UValeriaBaseMovementComponent::MovementMode' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MoveSimFlags) == 0x000191, "Member 'UValeriaBaseMovementComponent::MoveSimFlags' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, TargetFacing) == 0x000198, "Member 'UValeriaBaseMovementComponent::TargetFacing' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, TargetLocation1) == 0x0001B0, "Member 'UValeriaBaseMovementComponent::TargetLocation1' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, TargetLocation2) == 0x0001C8, "Member 'UValeriaBaseMovementComponent::TargetLocation2' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, TargetLocationLeader) == 0x0001E0, "Member 'UValeriaBaseMovementComponent::TargetLocationLeader' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, LeaderFollowDistance) == 0x0001E8, "Member 'UValeriaBaseMovementComponent::LeaderFollowDistance' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, LeaderCloseEnoughRange) == 0x0001EC, "Member 'UValeriaBaseMovementComponent::LeaderCloseEnoughRange' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, LeaderLocationOffset) == 0x0001F0, "Member 'UValeriaBaseMovementComponent::LeaderLocationOffset' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, bLeaderInStep) == 0x000208, "Member 'UValeriaBaseMovementComponent::bLeaderInStep' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, bHasReachedTargetLocation1) == 0x000209, "Member 'UValeriaBaseMovementComponent::bHasReachedTargetLocation1' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, TeleportDirectToThreshold) == 0x00020C, "Member 'UValeriaBaseMovementComponent::TeleportDirectToThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, UseFacingInsteadInSimFaceVelocityThreshold) == 0x000210, "Member 'UValeriaBaseMovementComponent::UseFacingInsteadInSimFaceVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, bShouldUseForcedFacing) == 0x000214, "Member 'UValeriaBaseMovementComponent::bShouldUseForcedFacing' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, ForcedFacing) == 0x000218, "Member 'UValeriaBaseMovementComponent::ForcedFacing' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, SimplePathTarget) == 0x000230, "Member 'UValeriaBaseMovementComponent::SimplePathTarget' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, SimplePathDirection) == 0x000240, "Member 'UValeriaBaseMovementComponent::SimplePathDirection' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, SimplePathDuration) == 0x000250, "Member 'UValeriaBaseMovementComponent::SimplePathDuration' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, bSimplePathGuaranteeFinalPosition) == 0x000254, "Member 'UValeriaBaseMovementComponent::bSimplePathGuaranteeFinalPosition' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, SimplePathGuaranteedFinalLocation) == 0x000258, "Member 'UValeriaBaseMovementComponent::SimplePathGuaranteedFinalLocation' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, SimplePathGuaranteedFinalRotation) == 0x000270, "Member 'UValeriaBaseMovementComponent::SimplePathGuaranteedFinalRotation' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, CustomMovementMode) == 0x000288, "Member 'UValeriaBaseMovementComponent::CustomMovementMode' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, NetworkSmoothingMode) == 0x000289, "Member 'UValeriaBaseMovementComponent::NetworkSmoothingMode' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, GroundFriction) == 0x00028C, "Member 'UValeriaBaseMovementComponent::GroundFriction' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, SpeedScalarModifierMap) == 0x0002C8, "Member 'UValeriaBaseMovementComponent::SpeedScalarModifierMap' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, SpeedScalar) == 0x000318, "Member 'UValeriaBaseMovementComponent::SpeedScalar' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxWalkSpeed) == 0x00031C, "Member 'UValeriaBaseMovementComponent::MaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxAcceleration) == 0x000320, "Member 'UValeriaBaseMovementComponent::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, SimSpeedCatchUpScalar) == 0x000324, "Member 'UValeriaBaseMovementComponent::SimSpeedCatchUpScalar' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, BrakingFrictionFactor) == 0x000328, "Member 'UValeriaBaseMovementComponent::BrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, BrakingFriction) == 0x00032C, "Member 'UValeriaBaseMovementComponent::BrakingFriction' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, BrakingSubStepTime) == 0x000330, "Member 'UValeriaBaseMovementComponent::BrakingSubStepTime' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, BrakingDecelerationWalking) == 0x000334, "Member 'UValeriaBaseMovementComponent::BrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, BrakingDecelerationFalling) == 0x000338, "Member 'UValeriaBaseMovementComponent::BrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, BrakingDecelerationSwimming) == 0x00033C, "Member 'UValeriaBaseMovementComponent::BrakingDecelerationSwimming' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, BrakingDecelerationFlying) == 0x000340, "Member 'UValeriaBaseMovementComponent::BrakingDecelerationFlying' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, AirControl) == 0x000344, "Member 'UValeriaBaseMovementComponent::AirControl' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, AirControlBoostMultiplier) == 0x000348, "Member 'UValeriaBaseMovementComponent::AirControlBoostMultiplier' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, AirControlBoostVelocityThreshold) == 0x00034C, "Member 'UValeriaBaseMovementComponent::AirControlBoostVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, FallingLateralFriction) == 0x000350, "Member 'UValeriaBaseMovementComponent::FallingLateralFriction' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, Buoyancy) == 0x000354, "Member 'UValeriaBaseMovementComponent::Buoyancy' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, PerchRadiusThreshold) == 0x000358, "Member 'UValeriaBaseMovementComponent::PerchRadiusThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, PerchAdditionalHeight) == 0x00035C, "Member 'UValeriaBaseMovementComponent::PerchAdditionalHeight' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, RotationRate) == 0x000360, "Member 'UValeriaBaseMovementComponent::RotationRate' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, TempOverrideRotationRate) == 0x000378, "Member 'UValeriaBaseMovementComponent::TempOverrideRotationRate' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, DeferredUpdatedMoveComponent) == 0x000398, "Member 'UValeriaBaseMovementComponent::DeferredUpdatedMoveComponent' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxOutOfWaterStepHeight) == 0x0003A0, "Member 'UValeriaBaseMovementComponent::MaxOutOfWaterStepHeight' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, OutofWaterZ) == 0x0003A4, "Member 'UValeriaBaseMovementComponent::OutofWaterZ' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, Mass) == 0x0003A8, "Member 'UValeriaBaseMovementComponent::Mass' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, StandingDownwardForceScale) == 0x0003AC, "Member 'UValeriaBaseMovementComponent::StandingDownwardForceScale' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, InitialPushForceFactor) == 0x0003B0, "Member 'UValeriaBaseMovementComponent::InitialPushForceFactor' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, PushForceFactor) == 0x0003B4, "Member 'UValeriaBaseMovementComponent::PushForceFactor' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, PushForcePointZOffsetFactor) == 0x0003B8, "Member 'UValeriaBaseMovementComponent::PushForcePointZOffsetFactor' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, TouchForceFactor) == 0x0003BC, "Member 'UValeriaBaseMovementComponent::TouchForceFactor' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MinTouchForce) == 0x0003C0, "Member 'UValeriaBaseMovementComponent::MinTouchForce' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxTouchForce) == 0x0003C4, "Member 'UValeriaBaseMovementComponent::MaxTouchForce' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, RepulsionForce) == 0x0003C8, "Member 'UValeriaBaseMovementComponent::RepulsionForce' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, Acceleration) == 0x0003D0, "Member 'UValeriaBaseMovementComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, LastUpdateRotation) == 0x0003F0, "Member 'UValeriaBaseMovementComponent::LastUpdateRotation' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, LastUpdateLocation) == 0x000410, "Member 'UValeriaBaseMovementComponent::LastUpdateLocation' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, LastUpdateVelocity) == 0x000428, "Member 'UValeriaBaseMovementComponent::LastUpdateVelocity' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, PendingImpulseToApply) == 0x000440, "Member 'UValeriaBaseMovementComponent::PendingImpulseToApply' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, PendingForceToApply) == 0x000458, "Member 'UValeriaBaseMovementComponent::PendingForceToApply' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, AnalogInputModifier) == 0x000470, "Member 'UValeriaBaseMovementComponent::AnalogInputModifier' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, bClientSimUseThrottleDistribution) == 0x000480, "Member 'UValeriaBaseMovementComponent::bClientSimUseThrottleDistribution' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, ThrottleMappings) == 0x000488, "Member 'UValeriaBaseMovementComponent::ThrottleMappings' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxSimulationTimeStep) == 0x0006E0, "Member 'UValeriaBaseMovementComponent::MaxSimulationTimeStep' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxSimulationTimeStep_Constrained) == 0x0006E4, "Member 'UValeriaBaseMovementComponent::MaxSimulationTimeStep_Constrained' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxSimulationIterations) == 0x0006E8, "Member 'UValeriaBaseMovementComponent::MaxSimulationIterations' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxJumpApexAttemptsPerSimulation) == 0x0006EC, "Member 'UValeriaBaseMovementComponent::MaxJumpApexAttemptsPerSimulation' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxDepenetrationWithGeometry) == 0x0006F0, "Member 'UValeriaBaseMovementComponent::MaxDepenetrationWithGeometry' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxDepenetrationWithGeometryAsProxy) == 0x0006F4, "Member 'UValeriaBaseMovementComponent::MaxDepenetrationWithGeometryAsProxy' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxDepenetrationWithPawn) == 0x0006F8, "Member 'UValeriaBaseMovementComponent::MaxDepenetrationWithPawn' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, MaxDepenetrationWithPawnAsProxy) == 0x0006FC, "Member 'UValeriaBaseMovementComponent::MaxDepenetrationWithPawnAsProxy' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, NetProxyShrinkRadius) == 0x000700, "Member 'UValeriaBaseMovementComponent::NetProxyShrinkRadius' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, NetProxyShrinkHalfHeight) == 0x000704, "Member 'UValeriaBaseMovementComponent::NetProxyShrinkHalfHeight' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, LedgeCheckThreshold) == 0x000708, "Member 'UValeriaBaseMovementComponent::LedgeCheckThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, JumpOutOfWaterPitch) == 0x00070C, "Member 'UValeriaBaseMovementComponent::JumpOutOfWaterPitch' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, CurrentFloor) == 0x000710, "Member 'UValeriaBaseMovementComponent::CurrentFloor' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, DefaultLandMovementMode) == 0x0008F8, "Member 'UValeriaBaseMovementComponent::DefaultLandMovementMode' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, GroundMovementMode) == 0x0008F9, "Member 'UValeriaBaseMovementComponent::GroundMovementMode' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, ReduceSimulationToTeleportsThreshold) == 0x0008FC, "Member 'UValeriaBaseMovementComponent::ReduceSimulationToTeleportsThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, ReduceSimulationToTeleportsThreshold_ConstrainedPlatform) == 0x000900, "Member 'UValeriaBaseMovementComponent::ReduceSimulationToTeleportsThreshold_ConstrainedPlatform' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, ReduceSimulationToOneStepThreshold) == 0x000904, "Member 'UValeriaBaseMovementComponent::ReduceSimulationToOneStepThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, ReduceSimulationToOneStepThreshold_Constrained) == 0x000908, "Member 'UValeriaBaseMovementComponent::ReduceSimulationToOneStepThreshold_Constrained' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, CachedDistanceFromLocalPlayerSq) == 0x00090C, "Member 'UValeriaBaseMovementComponent::CachedDistanceFromLocalPlayerSq' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, QuickFloorAdjustTraceStartHeight) == 0x000914, "Member 'UValeriaBaseMovementComponent::QuickFloorAdjustTraceStartHeight' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, QuickFloorAdjustTraceEndDepth) == 0x000918, "Member 'UValeriaBaseMovementComponent::QuickFloorAdjustTraceEndDepth' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, CheckFloorPeriod) == 0x00091C, "Member 'UValeriaBaseMovementComponent::CheckFloorPeriod' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, CheckFloorTimer) == 0x000920, "Member 'UValeriaBaseMovementComponent::CheckFloorTimer' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, CosmeticAvoidanceActors) == 0x000928, "Member 'UValeriaBaseMovementComponent::CosmeticAvoidanceActors' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, RequestedVelocity) == 0x000980, "Member 'UValeriaBaseMovementComponent::RequestedVelocity' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, PendingLaunchVelocity) == 0x000998, "Member 'UValeriaBaseMovementComponent::PendingLaunchVelocity' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, NavMeshProjectionInterval) == 0x000AB8, "Member 'UValeriaBaseMovementComponent::NavMeshProjectionInterval' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, NavMeshProjectionTimer) == 0x000ABC, "Member 'UValeriaBaseMovementComponent::NavMeshProjectionTimer' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, NavMeshProjectionInterpSpeed) == 0x000AC0, "Member 'UValeriaBaseMovementComponent::NavMeshProjectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, NavMeshProjectionHeightScaleUp) == 0x000AC4, "Member 'UValeriaBaseMovementComponent::NavMeshProjectionHeightScaleUp' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, NavMeshProjectionHeightScaleDown) == 0x000AC8, "Member 'UValeriaBaseMovementComponent::NavMeshProjectionHeightScaleDown' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, NavWalkingFloorDistTolerance) == 0x000ACC, "Member 'UValeriaBaseMovementComponent::NavWalkingFloorDistTolerance' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, OnTeleportToResolvePath) == 0x000AD0, "Member 'UValeriaBaseMovementComponent::OnTeleportToResolvePath' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, PostPhysicsTickFunction) == 0x000AE0, "Member 'UValeriaBaseMovementComponent::PostPhysicsTickFunction' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, TargetLocations) == 0x000B58, "Member 'UValeriaBaseMovementComponent::TargetLocations' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, bUseTargetLocationArray) == 0x000B6C, "Member 'UValeriaBaseMovementComponent::bUseTargetLocationArray' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, UnstuckTeleportAttempts) == 0x000B70, "Member 'UValeriaBaseMovementComponent::UnstuckTeleportAttempts' has a wrong offset!");
static_assert(offsetof(UValeriaBaseMovementComponent, UnstuckTeleportDistance) == 0x000B74, "Member 'UValeriaBaseMovementComponent::UnstuckTeleportDistance' has a wrong offset!");

// Class Palia.ValeriaNpcMovementComponent
// 0x0040 (0x0BC0 - 0x0B80)
#pragma pack(push, 0x1)
class alignas(0x10) UValeriaNpcMovementComponent : public UValeriaBaseMovementComponent
{
public:
	bool                                          bMovingOnPlacedPath;                               // 0x0B78(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25FE[0x7];                                     // 0x0B79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OldTargetLocation1;                                // 0x0B80(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                OldTargetLocation2;                                // 0x0B98(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 ForcedClientMovementMode;                          // 0x0BB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 ForcedServerMovementMode;                          // 0x0BB1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25FF[0x2];                                     // 0x0BB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ClientMovementModeChangedFromForcedCounter;        // 0x0BB4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaNpcMovementComponent">();
	}
	static class UValeriaNpcMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaNpcMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UValeriaNpcMovementComponent) == 0x000010, "Wrong alignment on UValeriaNpcMovementComponent");
static_assert(sizeof(UValeriaNpcMovementComponent) == 0x000BC0, "Wrong size on UValeriaNpcMovementComponent");
static_assert(offsetof(UValeriaNpcMovementComponent, bMovingOnPlacedPath) == 0x000B78, "Member 'UValeriaNpcMovementComponent::bMovingOnPlacedPath' has a wrong offset!");
static_assert(offsetof(UValeriaNpcMovementComponent, OldTargetLocation1) == 0x000B80, "Member 'UValeriaNpcMovementComponent::OldTargetLocation1' has a wrong offset!");
static_assert(offsetof(UValeriaNpcMovementComponent, OldTargetLocation2) == 0x000B98, "Member 'UValeriaNpcMovementComponent::OldTargetLocation2' has a wrong offset!");
static_assert(offsetof(UValeriaNpcMovementComponent, ForcedClientMovementMode) == 0x000BB0, "Member 'UValeriaNpcMovementComponent::ForcedClientMovementMode' has a wrong offset!");
static_assert(offsetof(UValeriaNpcMovementComponent, ForcedServerMovementMode) == 0x000BB1, "Member 'UValeriaNpcMovementComponent::ForcedServerMovementMode' has a wrong offset!");
static_assert(offsetof(UValeriaNpcMovementComponent, ClientMovementModeChangedFromForcedCounter) == 0x000BB4, "Member 'UValeriaNpcMovementComponent::ClientMovementModeChangedFromForcedCounter' has a wrong offset!");

// Class Palia.VAL_ApplyCustomizationsToActorProxy
// 0x0960 (0x0990 - 0x0030)
class UVAL_ApplyCustomizationsToActorProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Failed;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Interrupted;                                       // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Stubbed;                                           // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2600[0x920];                                   // 0x0070(0x0920)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_ApplyCustomizationsToActorProxy* ApplyCustomizationsToActor(class UVAL_CharacterCustomizationComponent* CharacterCustomizationComponent, bool ValidateLoadout, const struct FVAL_CharacterCustomizationLoadout& NewLoadout, EVAL_ApplyCustomizationToActorContext Context);

	void OnApplyCustomizationsToActorCompleted__DelegateSignature();
	void OnApplyCustomizationsToActorFailed__DelegateSignature();
	void OnApplyCustomizationsToActorInterrupted__DelegateSignature();
	void OnApplyCustomizationsToActorStubbed__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ApplyCustomizationsToActorProxy">();
	}
	static class UVAL_ApplyCustomizationsToActorProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ApplyCustomizationsToActorProxy>();
	}
};
static_assert(alignof(UVAL_ApplyCustomizationsToActorProxy) == 0x000008, "Wrong alignment on UVAL_ApplyCustomizationsToActorProxy");
static_assert(sizeof(UVAL_ApplyCustomizationsToActorProxy) == 0x000990, "Wrong size on UVAL_ApplyCustomizationsToActorProxy");
static_assert(offsetof(UVAL_ApplyCustomizationsToActorProxy, Completed) == 0x000030, "Member 'UVAL_ApplyCustomizationsToActorProxy::Completed' has a wrong offset!");
static_assert(offsetof(UVAL_ApplyCustomizationsToActorProxy, Failed) == 0x000040, "Member 'UVAL_ApplyCustomizationsToActorProxy::Failed' has a wrong offset!");
static_assert(offsetof(UVAL_ApplyCustomizationsToActorProxy, Interrupted) == 0x000050, "Member 'UVAL_ApplyCustomizationsToActorProxy::Interrupted' has a wrong offset!");
static_assert(offsetof(UVAL_ApplyCustomizationsToActorProxy, Stubbed) == 0x000060, "Member 'UVAL_ApplyCustomizationsToActorProxy::Stubbed' has a wrong offset!");

// Class Palia.CreatureMovementComponent
// 0x0010 (0x0BD0 - 0x0BC0)
class UCreatureMovementComponent final : public UValeriaNpcMovementComponent
{
public:
	float                                         SprintSpeedMultiplier;                             // 0x0BB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EscapeSprintSpeedMultiplier;                       // 0x0BBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2603[0x10];                                    // 0x0BC0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatureMovementComponent">();
	}
	static class UCreatureMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreatureMovementComponent>();
	}
};
static_assert(alignof(UCreatureMovementComponent) == 0x000010, "Wrong alignment on UCreatureMovementComponent");
static_assert(sizeof(UCreatureMovementComponent) == 0x000BD0, "Wrong size on UCreatureMovementComponent");
static_assert(offsetof(UCreatureMovementComponent, SprintSpeedMultiplier) == 0x000BB8, "Member 'UCreatureMovementComponent::SprintSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UCreatureMovementComponent, EscapeSprintSpeedMultiplier) == 0x000BBC, "Member 'UCreatureMovementComponent::EscapeSprintSpeedMultiplier' has a wrong offset!");

// Class Palia.CreatureSlimeTrailComponent
// 0x0018 (0x00B8 - 0x00A0)
class UCreatureSlimeTrailComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2604[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlimeSplatSpawnInterval;                           // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlimeSplatScale;                                   // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     SlimeSplatActor;                                   // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void StartSlimeTrailSpawn();
	void StopSlimeTrailSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatureSlimeTrailComponent">();
	}
	static class UCreatureSlimeTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreatureSlimeTrailComponent>();
	}
};
static_assert(alignof(UCreatureSlimeTrailComponent) == 0x000008, "Wrong alignment on UCreatureSlimeTrailComponent");
static_assert(sizeof(UCreatureSlimeTrailComponent) == 0x0000B8, "Wrong size on UCreatureSlimeTrailComponent");
static_assert(offsetof(UCreatureSlimeTrailComponent, SlimeSplatSpawnInterval) == 0x0000A8, "Member 'UCreatureSlimeTrailComponent::SlimeSplatSpawnInterval' has a wrong offset!");
static_assert(offsetof(UCreatureSlimeTrailComponent, SlimeSplatScale) == 0x0000AC, "Member 'UCreatureSlimeTrailComponent::SlimeSplatScale' has a wrong offset!");
static_assert(offsetof(UCreatureSlimeTrailComponent, SlimeSplatActor) == 0x0000B0, "Member 'UCreatureSlimeTrailComponent::SlimeSplatActor' has a wrong offset!");

// Class Palia.VAL_BreakableActor
// 0x00A8 (0x0350 - 0x02A8)
class AVAL_BreakableActor final : public AActor
{
public:
	class USceneComponent*                        BreakableRoot;                                     // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       DetectionSphere;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBreakableHit;                                    // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBreakableStageComplete;                          // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBreakableComplete;                               // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWrongBreaker;                                    // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRegenerationStarted;                             // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRegenerationComplete;                            // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FVAL_BreakableStages>           BreakableStages;                                   // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanRegenerate;                                    // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2605[0x3];                                     // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RegenerationDuration;                              // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2606[0x20];                                    // 0x0330(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnBreakableComplete_Client();
	void BP_OnBreakableComplete_Server();
	void BP_OnRegenerationComplete_Client();
	void BP_OnRegenerationComplete_Server();
	void BP_OnRegenerationStarted_Client();
	void BP_OnRegenerationStarted_Server();
	void BP_OnStageComplete_Client();
	void BP_OnStageComplete_Server();
	void BP_OnValidHit_Client();
	void BP_OnValidHit_Server();
	void BP_OnWrongBreaker_Client();
	void BP_OnWrongBreaker_Server();
	bool GetCanRegenerate();
	struct FVAL_BreakableStages GetCurrentStageData();
	int32 GetCurrentStageIndex();
	bool GetIsRegenerating();
	int32 GetMaxStageIndex();
	float GetNormalizedRegenerationTimeRemaining();
	float GetRegenerationDuration();
	float GetRegerenerationTimeRemaining();
	void OnSphereOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void ProgressToNextStage();
	void RegenerationComplete();
	void RpcClient_OnValidHit();
	void RpcClient_OnWrongBreaker();
	void SetAbleToBeBroken(bool bBreakable);
	void SetToBreakableComplete();
	void SetToStage(int32 StateIndex);
	void StartRegeneration();
	void TryRegisterHit(class AValeriaCharacter* Character);
	void VAL_OnBreakableComplete__DelegateSignature();
	void VAL_OnBreakableStageComplete__DelegateSignature();
	void VAL_OnBreakableValidHit__DelegateSignature();
	void VAL_OnRegenerationComplete__DelegateSignature();
	void VAL_OnRegenerationStarted__DelegateSignature();
	void VAL_OnWrongBreaker__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_BreakableActor">();
	}
	static class AVAL_BreakableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_BreakableActor>();
	}
};
static_assert(alignof(AVAL_BreakableActor) == 0x000008, "Wrong alignment on AVAL_BreakableActor");
static_assert(sizeof(AVAL_BreakableActor) == 0x000350, "Wrong size on AVAL_BreakableActor");
static_assert(offsetof(AVAL_BreakableActor, BreakableRoot) == 0x0002A8, "Member 'AVAL_BreakableActor::BreakableRoot' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, DetectionSphere) == 0x0002B0, "Member 'AVAL_BreakableActor::DetectionSphere' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, OnBreakableHit) == 0x0002B8, "Member 'AVAL_BreakableActor::OnBreakableHit' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, OnBreakableStageComplete) == 0x0002C8, "Member 'AVAL_BreakableActor::OnBreakableStageComplete' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, OnBreakableComplete) == 0x0002D8, "Member 'AVAL_BreakableActor::OnBreakableComplete' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, OnWrongBreaker) == 0x0002E8, "Member 'AVAL_BreakableActor::OnWrongBreaker' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, OnRegenerationStarted) == 0x0002F8, "Member 'AVAL_BreakableActor::OnRegenerationStarted' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, OnRegenerationComplete) == 0x000308, "Member 'AVAL_BreakableActor::OnRegenerationComplete' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, BreakableStages) == 0x000318, "Member 'AVAL_BreakableActor::BreakableStages' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, bCanRegenerate) == 0x000328, "Member 'AVAL_BreakableActor::bCanRegenerate' has a wrong offset!");
static_assert(offsetof(AVAL_BreakableActor, RegenerationDuration) == 0x00032C, "Member 'AVAL_BreakableActor::RegenerationDuration' has a wrong offset!");

// Class Palia.CurrencyConfig
// 0x0058 (0x00A0 - 0x0048)
class UCurrencyConfig final : public UGuidDataAsset
{
public:
	int32                                         MaxAmount;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2608[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_CurrencyConfig;                               // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 StatName;                                          // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ToolTipText;                                       // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsSkillMedal;                                     // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2609[0x7];                                     // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyConfig">();
	}
	static class UCurrencyConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrencyConfig>();
	}
};
static_assert(alignof(UCurrencyConfig) == 0x000008, "Wrong alignment on UCurrencyConfig");
static_assert(sizeof(UCurrencyConfig) == 0x0000A0, "Wrong size on UCurrencyConfig");
static_assert(offsetof(UCurrencyConfig, MaxAmount) == 0x000048, "Member 'UCurrencyConfig::MaxAmount' has a wrong offset!");
static_assert(offsetof(UCurrencyConfig, Icon) == 0x000050, "Member 'UCurrencyConfig::Icon' has a wrong offset!");
static_assert(offsetof(UCurrencyConfig, Name_CurrencyConfig) == 0x000058, "Member 'UCurrencyConfig::Name_CurrencyConfig' has a wrong offset!");
static_assert(offsetof(UCurrencyConfig, StatName) == 0x000070, "Member 'UCurrencyConfig::StatName' has a wrong offset!");
static_assert(offsetof(UCurrencyConfig, ToolTipText) == 0x000080, "Member 'UCurrencyConfig::ToolTipText' has a wrong offset!");
static_assert(offsetof(UCurrencyConfig, bIsSkillMedal) == 0x000098, "Member 'UCurrencyConfig::bIsSkillMedal' has a wrong offset!");

// Class Palia.DataLayerStatesConfig
// 0x0048 (0x0078 - 0x0030)
class UDataLayerStatesConfig final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UDataLayerAsset>> UnloadedLayers;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataLayerAsset>> ActivatedLayers;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataLayerAsset>> LoadedLayers;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                ActiveQueryLocation;                               // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataLayerStatesConfig">();
	}
	static class UDataLayerStatesConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataLayerStatesConfig>();
	}
};
static_assert(alignof(UDataLayerStatesConfig) == 0x000008, "Wrong alignment on UDataLayerStatesConfig");
static_assert(sizeof(UDataLayerStatesConfig) == 0x000078, "Wrong size on UDataLayerStatesConfig");
static_assert(offsetof(UDataLayerStatesConfig, UnloadedLayers) == 0x000030, "Member 'UDataLayerStatesConfig::UnloadedLayers' has a wrong offset!");
static_assert(offsetof(UDataLayerStatesConfig, ActivatedLayers) == 0x000040, "Member 'UDataLayerStatesConfig::ActivatedLayers' has a wrong offset!");
static_assert(offsetof(UDataLayerStatesConfig, LoadedLayers) == 0x000050, "Member 'UDataLayerStatesConfig::LoadedLayers' has a wrong offset!");
static_assert(offsetof(UDataLayerStatesConfig, ActiveQueryLocation) == 0x000060, "Member 'UDataLayerStatesConfig::ActiveQueryLocation' has a wrong offset!");

// Class Palia.VAL_AsyncActionRegisterCharacterAndCacheRequest
// 0x07B0 (0x07E0 - 0x0030)
class UVAL_AsyncActionRegisterCharacterAndCacheRequest final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Successful;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Failure;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             InFlight;                                          // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_260A[0x780];                                   // 0x0060(0x0780)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_AsyncActionRegisterCharacterAndCacheRequest* RegisterCharacterAndCacheRequest(class ULocalPlayer* LP, struct FVALDTOS_MetaCharacterFormat& CharacterData);

	void OnCharacterRegisteredFailure__DelegateSignature(const struct FOSSVAL_RegisterCharacterResponse& Response);
	void OnCharacterRegisteredInFlight__DelegateSignature(const struct FOSSVAL_RegisterCharacterResponse& Response);
	void OnCharacterRegisteredSuccess__DelegateSignature(const struct FOSSVAL_RegisterCharacterResponse& Response);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AsyncActionRegisterCharacterAndCacheRequest">();
	}
	static class UVAL_AsyncActionRegisterCharacterAndCacheRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AsyncActionRegisterCharacterAndCacheRequest>();
	}
};
static_assert(alignof(UVAL_AsyncActionRegisterCharacterAndCacheRequest) == 0x000008, "Wrong alignment on UVAL_AsyncActionRegisterCharacterAndCacheRequest");
static_assert(sizeof(UVAL_AsyncActionRegisterCharacterAndCacheRequest) == 0x0007E0, "Wrong size on UVAL_AsyncActionRegisterCharacterAndCacheRequest");
static_assert(offsetof(UVAL_AsyncActionRegisterCharacterAndCacheRequest, Successful) == 0x000030, "Member 'UVAL_AsyncActionRegisterCharacterAndCacheRequest::Successful' has a wrong offset!");
static_assert(offsetof(UVAL_AsyncActionRegisterCharacterAndCacheRequest, Failure) == 0x000040, "Member 'UVAL_AsyncActionRegisterCharacterAndCacheRequest::Failure' has a wrong offset!");
static_assert(offsetof(UVAL_AsyncActionRegisterCharacterAndCacheRequest, InFlight) == 0x000050, "Member 'UVAL_AsyncActionRegisterCharacterAndCacheRequest::InFlight' has a wrong offset!");

// Class Palia.DeathComponent
// 0x0028 (0x00C8 - 0x00A0)
class UDeathComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDeathServer;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeath;                                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 DeathInstigator;                                   // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RpcClient_DisplayDeath(class AActor* PassedDeathInstigator);

	class AActor* GetDeathInstigator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathComponent">();
	}
	static class UDeathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathComponent>();
	}
};
static_assert(alignof(UDeathComponent) == 0x000008, "Wrong alignment on UDeathComponent");
static_assert(sizeof(UDeathComponent) == 0x0000C8, "Wrong size on UDeathComponent");
static_assert(offsetof(UDeathComponent, OnDeathServer) == 0x0000A0, "Member 'UDeathComponent::OnDeathServer' has a wrong offset!");
static_assert(offsetof(UDeathComponent, OnDeath) == 0x0000B0, "Member 'UDeathComponent::OnDeath' has a wrong offset!");
static_assert(offsetof(UDeathComponent, DeathInstigator) == 0x0000C0, "Member 'UDeathComponent::DeathInstigator' has a wrong offset!");

// Class Palia.DebugCheatComponent
// 0x0020 (0x00C0 - 0x00A0)
class UDebugCheatComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDebugSaveStateCompleted;                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SpawnedActors;                                     // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void RpcClient_DebugSaveComplete();
	void RpcServer_SendCheat(const struct Palia::FDebugCheat& Cheat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugCheatComponent">();
	}
	static class UDebugCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugCheatComponent>();
	}
};
static_assert(alignof(UDebugCheatComponent) == 0x000008, "Wrong alignment on UDebugCheatComponent");
static_assert(sizeof(UDebugCheatComponent) == 0x0000C0, "Wrong size on UDebugCheatComponent");
static_assert(offsetof(UDebugCheatComponent, OnDebugSaveStateCompleted) == 0x0000A0, "Member 'UDebugCheatComponent::OnDebugSaveStateCompleted' has a wrong offset!");
static_assert(offsetof(UDebugCheatComponent, SpawnedActors) == 0x0000B0, "Member 'UDebugCheatComponent::SpawnedActors' has a wrong offset!");

// Class Palia.ValeriaWeather
// 0x01A0 (0x01E0 - 0x0040)
class UValeriaWeather final : public UTickableWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             WeatherChanged;                                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             WeatherPendingChange;                              // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_260B[0x178];                                   // 0x0060(0x0178)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsWeatherEnabled;                                 // 0x01D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260C[0x7];                                     // 0x01D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<int32> GetValerianDayPeriodWeatherDuration();
	static TArray<struct FWeatherStateDateTime> GetWeatherStateForecast(struct FWeatherPatternConfig& Config, int64 StartTime, int64 EndTime);

	void ClearWeatherStateOverride();
	void NotifyWorldWeatherChanged__DelegateSignature(struct FWeatherStateProperties& State);
	void NotifyWorldWeatherPendingChange__DelegateSignature(struct FWeatherStateProperties& PendingState, int32 CountdownTime);
	void SetWeatherStateOverride(class FName State);
	void SetWorldOverrideName(class FName WorldName);

	class AValEnvironmentManager* GetCurrentEnvManager() const;
	struct FWeatherPatternConfig GetCurrentWeatherData() const;
	struct FWeatherStateProperties GetCurrentWorldWeatherState(bool PeekPending) const;
	float GetRandomFromCurrentWeatherState(int32 Seed) const;
	float GetRandomFromCurrentWeatherStateSequence(int32 Seed, int32 SequenceIndex) const;
	class FName GetWeatherStateOverride() const;
	class FName GetWorldOverrideName() const;
	bool IsWeatherEnabled() const;
	struct FWeatherStateProperties LookupWorldWeatherStateAtTime(int64 Time) const;
	struct FWeatherStateProperties LookupWorldWeatherStateAtTimeAndPlace(class FName Place, int64 Time) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaWeather">();
	}
	static class UValeriaWeather* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaWeather>();
	}
};
static_assert(alignof(UValeriaWeather) == 0x000008, "Wrong alignment on UValeriaWeather");
static_assert(sizeof(UValeriaWeather) == 0x0001E0, "Wrong size on UValeriaWeather");
static_assert(offsetof(UValeriaWeather, WeatherChanged) == 0x000040, "Member 'UValeriaWeather::WeatherChanged' has a wrong offset!");
static_assert(offsetof(UValeriaWeather, WeatherPendingChange) == 0x000050, "Member 'UValeriaWeather::WeatherPendingChange' has a wrong offset!");
static_assert(offsetof(UValeriaWeather, bIsWeatherEnabled) == 0x0001D8, "Member 'UValeriaWeather::bIsWeatherEnabled' has a wrong offset!");

// Class Palia.DebugInfoComponent
// 0x0080 (0x0120 - 0x00A0)
class UDebugInfoComponent final : public UActorComponent
{
public:
	uint8                                         Pad_260F[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTitleAndRowsInfo>              ServerLoadedPrivateSpacesTitleAndRowsInfo;         // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FDebugInfoPersistBlock                 DebugInfoPersistBlock;                             // 0x00C8(0x0058)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	bool HasReceivedCheatSet(class UCheatSetConfig* InCheatSetConfig);
	bool HasReceivedCheatSetByGuid(struct FGuid& InGuid);
	void OnReplicatedAndShouldNotify(const struct FDebugInfoPersistBlock& OldDebugInfoPersistBlock);
	void OnServerLoadedPrivateSpacesTitleAndRowsInfoReplicatedAndShouldNotify();
	void RpcServer_RequestServerLoadedPrivateSpacesTitleAndRowsInfo(bool bRequestOnlyOwner);
	void RpcServer_SetCheats(bool CanCheat);
	void RpcServer_ToggleCheats();

	bool AreCheatsEnabled() const;
	bool GetIgnoreDailyDialogueLimit() const;
	bool GetIgnoreFriendshipLevelRequirementsForDynamicGiftPrefs() const;
	bool GetIgnoreGiftTimeRestriction() const;
	bool GetShowHiddenGearTypes() const;
	bool GetShowVillagerDebugInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugInfoComponent">();
	}
	static class UDebugInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugInfoComponent>();
	}
};
static_assert(alignof(UDebugInfoComponent) == 0x000008, "Wrong alignment on UDebugInfoComponent");
static_assert(sizeof(UDebugInfoComponent) == 0x000120, "Wrong size on UDebugInfoComponent");
static_assert(offsetof(UDebugInfoComponent, OnChanged) == 0x0000A8, "Member 'UDebugInfoComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UDebugInfoComponent, ServerLoadedPrivateSpacesTitleAndRowsInfo) == 0x0000B8, "Member 'UDebugInfoComponent::ServerLoadedPrivateSpacesTitleAndRowsInfo' has a wrong offset!");
static_assert(offsetof(UDebugInfoComponent, DebugInfoPersistBlock) == 0x0000C8, "Member 'UDebugInfoComponent::DebugInfoPersistBlock' has a wrong offset!");

// Class Palia.DebugServerActorsComponent
// 0x0190 (0x0230 - 0x00A0)
class UDebugServerActorsComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnReplicated;                                      // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDebugServerActorListToTrack           Targets;                                           // 0x00B0(0x0118)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         SelectedClasses;                                   // 0x01C8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           UpdateTargetsTimerHandle;                          // 0x01D8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UClass*, struct FLinearColor>      ClassColors;                                       // 0x01E0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void Client_OnReplicated();
	void Reset();
	void Server_OnActorDestroyed(class AActor* InActor);
	bool Server_SelectActorClass(class UClass* InClass);
	bool Server_TrackActor(class AActor* InActor);
	bool Server_UnselectActorClass(class UClass* InClass);
	void Server_UntrackActor(class AActor* InActor);
	void Server_UpdateActorProperties(struct FDebugServerActorListToTrackItem* TrackItem);
	void Server_UpdateAllProperties();
	void Server_UpdateTimer();

	const TArray<struct FDebugServerActorListToTrackItem> GetActorData() const;
	struct FLinearColor GetActorDebugColor(class UClass* InClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugServerActorsComponent">();
	}
	static class UDebugServerActorsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugServerActorsComponent>();
	}
};
static_assert(alignof(UDebugServerActorsComponent) == 0x000008, "Wrong alignment on UDebugServerActorsComponent");
static_assert(sizeof(UDebugServerActorsComponent) == 0x000230, "Wrong size on UDebugServerActorsComponent");
static_assert(offsetof(UDebugServerActorsComponent, OnReplicated) == 0x0000A0, "Member 'UDebugServerActorsComponent::OnReplicated' has a wrong offset!");
static_assert(offsetof(UDebugServerActorsComponent, Targets) == 0x0000B0, "Member 'UDebugServerActorsComponent::Targets' has a wrong offset!");
static_assert(offsetof(UDebugServerActorsComponent, SelectedClasses) == 0x0001C8, "Member 'UDebugServerActorsComponent::SelectedClasses' has a wrong offset!");
static_assert(offsetof(UDebugServerActorsComponent, UpdateTargetsTimerHandle) == 0x0001D8, "Member 'UDebugServerActorsComponent::UpdateTargetsTimerHandle' has a wrong offset!");
static_assert(offsetof(UDebugServerActorsComponent, ClassColors) == 0x0001E0, "Member 'UDebugServerActorsComponent::ClassColors' has a wrong offset!");

// Class Palia.VAL_BpAsyncAction_PlayClientLevelSequence
// 0x0058 (0x0088 - 0x0030)
class UVAL_BpAsyncAction_PlayClientLevelSequence final : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_2615[0x18];                                    // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlay;                                            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnPause;                                           // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnStop;                                            // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UVAL_BpAsyncAction_PlayClientLevelSequence* PlayClientLevelSequence(class ALevelSequenceActor* LevelSequenceActor, float PlayRate, class FName PlayerBindingTag, bool bHideUI);

	void HandleFinish();
	void HandlePause();
	void HandlePlay();
	void HandleStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_BpAsyncAction_PlayClientLevelSequence">();
	}
	static class UVAL_BpAsyncAction_PlayClientLevelSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_BpAsyncAction_PlayClientLevelSequence>();
	}
};
static_assert(alignof(UVAL_BpAsyncAction_PlayClientLevelSequence) == 0x000008, "Wrong alignment on UVAL_BpAsyncAction_PlayClientLevelSequence");
static_assert(sizeof(UVAL_BpAsyncAction_PlayClientLevelSequence) == 0x000088, "Wrong size on UVAL_BpAsyncAction_PlayClientLevelSequence");
static_assert(offsetof(UVAL_BpAsyncAction_PlayClientLevelSequence, OnPlay) == 0x000048, "Member 'UVAL_BpAsyncAction_PlayClientLevelSequence::OnPlay' has a wrong offset!");
static_assert(offsetof(UVAL_BpAsyncAction_PlayClientLevelSequence, OnPause) == 0x000058, "Member 'UVAL_BpAsyncAction_PlayClientLevelSequence::OnPause' has a wrong offset!");
static_assert(offsetof(UVAL_BpAsyncAction_PlayClientLevelSequence, OnStop) == 0x000068, "Member 'UVAL_BpAsyncAction_PlayClientLevelSequence::OnStop' has a wrong offset!");
static_assert(offsetof(UVAL_BpAsyncAction_PlayClientLevelSequence, OnFinish) == 0x000078, "Member 'UVAL_BpAsyncAction_PlayClientLevelSequence::OnFinish' has a wrong offset!");

// Class Palia.DebugSpawningComponent
// 0x00C0 (0x0160 - 0x00A0)
class UDebugSpawningComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSettingsChanged;                                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDebugSpawningSettings                 Settings;                                          // 0x00B0(0x0038)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     SpawnManagerClassToIterate;                        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         CurrentlyTrackingSpawnManagers;                    // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         CurrentlyTrackingSpawnees;                         // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FDebugSpawningReplicatedData           ReplicatedData;                                    // 0x0110(0x0030)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         Targets;                                           // 0x0140(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UDebugServerActorsComponent*            DebugServerActors;                                 // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2617[0x8];                                     // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_OnReplicatedData();
	void Client_OnReplicatedSettings();
	void Client_TrackSpawneeClass(class FName& SpawneeClassName);
	void Client_TrackSpawnManager(class FName& SpawnManagerName);
	void Client_UntrackAll();
	void Client_UntrackAllSpawnees();
	void Client_UntrackAllSpawnManagers();
	void Client_UntrackSpawneeClass(class FName& SpawneeClassName);
	void Client_UntrackSpawnManager(class FName& SpawnManagerName);
	void OnSpawnManagerActorSpawnChange(class AActor* InActor);
	void RpcServer_SetDebugSpawningSettings(struct FDebugSpawningSettings& InSettings);
	void RpcServer_SetEnabled(bool Enable);
	void RpcServer_TrackSpawneeClass(class FName& SpawneeClassName);
	void RpcServer_TrackSpawnManager(class FName& SpawnManagerName);
	void RpcServer_UntrackAll();
	void RpcServer_UntrackAllSpawnees();
	void RpcServer_UntrackAllSpawnManagers();
	void RpcServer_UntrackSpawneeClass(class FName& SpawneeClassName);
	void RpcServer_UntrackSpawnManager(class FName& SpawnManagerName);
	void Server_OnActorDespawned(class AActor* InActor);
	void Server_OnActorSpawned(class AActor* InActor);
	void SetDebugSpawningSettings(struct FDebugSpawningSettings& InSettings);
	void SetEnabled(bool Enable);

	const struct FDebugSpawningSettings GetDebugSpawningSettings() const;
	const TArray<class FName> GetSpawneeClassNames() const;
	const TArray<class FName> GetSpawnManagerNames() const;
	bool IsTrackingSpawnManager(class FName& SpawnManagerName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugSpawningComponent">();
	}
	static class UDebugSpawningComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugSpawningComponent>();
	}
};
static_assert(alignof(UDebugSpawningComponent) == 0x000008, "Wrong alignment on UDebugSpawningComponent");
static_assert(sizeof(UDebugSpawningComponent) == 0x000160, "Wrong size on UDebugSpawningComponent");
static_assert(offsetof(UDebugSpawningComponent, OnSettingsChanged) == 0x0000A0, "Member 'UDebugSpawningComponent::OnSettingsChanged' has a wrong offset!");
static_assert(offsetof(UDebugSpawningComponent, Settings) == 0x0000B0, "Member 'UDebugSpawningComponent::Settings' has a wrong offset!");
static_assert(offsetof(UDebugSpawningComponent, SpawnManagerClassToIterate) == 0x0000E8, "Member 'UDebugSpawningComponent::SpawnManagerClassToIterate' has a wrong offset!");
static_assert(offsetof(UDebugSpawningComponent, CurrentlyTrackingSpawnManagers) == 0x0000F0, "Member 'UDebugSpawningComponent::CurrentlyTrackingSpawnManagers' has a wrong offset!");
static_assert(offsetof(UDebugSpawningComponent, CurrentlyTrackingSpawnees) == 0x000100, "Member 'UDebugSpawningComponent::CurrentlyTrackingSpawnees' has a wrong offset!");
static_assert(offsetof(UDebugSpawningComponent, ReplicatedData) == 0x000110, "Member 'UDebugSpawningComponent::ReplicatedData' has a wrong offset!");
static_assert(offsetof(UDebugSpawningComponent, Targets) == 0x000140, "Member 'UDebugSpawningComponent::Targets' has a wrong offset!");
static_assert(offsetof(UDebugSpawningComponent, DebugServerActors) == 0x000150, "Member 'UDebugSpawningComponent::DebugServerActors' has a wrong offset!");

// Class Palia.DefaultDestinationsConfig
// 0x0170 (0x01A8 - 0x0038)
class UDefaultDestinationsConfig final : public UDeveloperSettings
{
public:
	struct FLevelToDestination                    HousingPlotDefault;                                // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FLevelToDestination                    VisitingPlotDefault;                               // 0x0068(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FLevelToDestination                    SpecificLocationDefault;                           // 0x0098(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FLevelToDestination                    ViewOnlyPlotDefault;                               // 0x00C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UWorld>, TSoftObjectPtr<class UTeleportTravelConfigAsset>> DefaultMapDestinations;                            // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTeleportTravelConfigAsset>> CrossServerDestinations;                           // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UWorld>, TSoftObjectPtr<class UTeleportTravelConfigAsset>> DefaultInitialMapPrivateSpaces;                    // 0x0158(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultDestinationsConfig">();
	}
	static class UDefaultDestinationsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultDestinationsConfig>();
	}
};
static_assert(alignof(UDefaultDestinationsConfig) == 0x000008, "Wrong alignment on UDefaultDestinationsConfig");
static_assert(sizeof(UDefaultDestinationsConfig) == 0x0001A8, "Wrong size on UDefaultDestinationsConfig");
static_assert(offsetof(UDefaultDestinationsConfig, HousingPlotDefault) == 0x000038, "Member 'UDefaultDestinationsConfig::HousingPlotDefault' has a wrong offset!");
static_assert(offsetof(UDefaultDestinationsConfig, VisitingPlotDefault) == 0x000068, "Member 'UDefaultDestinationsConfig::VisitingPlotDefault' has a wrong offset!");
static_assert(offsetof(UDefaultDestinationsConfig, SpecificLocationDefault) == 0x000098, "Member 'UDefaultDestinationsConfig::SpecificLocationDefault' has a wrong offset!");
static_assert(offsetof(UDefaultDestinationsConfig, ViewOnlyPlotDefault) == 0x0000C8, "Member 'UDefaultDestinationsConfig::ViewOnlyPlotDefault' has a wrong offset!");
static_assert(offsetof(UDefaultDestinationsConfig, DefaultMapDestinations) == 0x0000F8, "Member 'UDefaultDestinationsConfig::DefaultMapDestinations' has a wrong offset!");
static_assert(offsetof(UDefaultDestinationsConfig, CrossServerDestinations) == 0x000148, "Member 'UDefaultDestinationsConfig::CrossServerDestinations' has a wrong offset!");
static_assert(offsetof(UDefaultDestinationsConfig, DefaultInitialMapPrivateSpaces) == 0x000158, "Member 'UDefaultDestinationsConfig::DefaultInitialMapPrivateSpaces' has a wrong offset!");

// Class Palia.VAL_CharacterCustomization_PerSlotPreset_Base
// 0x0008 (0x0038 - 0x0030)
class UVAL_CharacterCustomization_PerSlotPreset_Base : public UDataAsset
{
public:
	int32                                         HideSlotFlagsBitmask;                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2619[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomization_PerSlotPreset_Base">();
	}
	static class UVAL_CharacterCustomization_PerSlotPreset_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomization_PerSlotPreset_Base>();
	}
};
static_assert(alignof(UVAL_CharacterCustomization_PerSlotPreset_Base) == 0x000008, "Wrong alignment on UVAL_CharacterCustomization_PerSlotPreset_Base");
static_assert(sizeof(UVAL_CharacterCustomization_PerSlotPreset_Base) == 0x000038, "Wrong size on UVAL_CharacterCustomization_PerSlotPreset_Base");
static_assert(offsetof(UVAL_CharacterCustomization_PerSlotPreset_Base, HideSlotFlagsBitmask) == 0x000030, "Member 'UVAL_CharacterCustomization_PerSlotPreset_Base::HideSlotFlagsBitmask' has a wrong offset!");

// Class Palia.VAL_CharacterCustomization_FacialHairTypePreset
// 0x0150 (0x0188 - 0x0038)
class UVAL_CharacterCustomization_FacialHairTypePreset final : public UVAL_CharacterCustomization_PerSlotPreset_Base
{
public:
	struct FVAL_CharacterCustomization_SkeletalMeshComponentConfig HeadReplacementMeshIfHidden;                       // 0x0038(0x0150)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomization_FacialHairTypePreset">();
	}
	static class UVAL_CharacterCustomization_FacialHairTypePreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomization_FacialHairTypePreset>();
	}
};
static_assert(alignof(UVAL_CharacterCustomization_FacialHairTypePreset) == 0x000008, "Wrong alignment on UVAL_CharacterCustomization_FacialHairTypePreset");
static_assert(sizeof(UVAL_CharacterCustomization_FacialHairTypePreset) == 0x000188, "Wrong size on UVAL_CharacterCustomization_FacialHairTypePreset");
static_assert(offsetof(UVAL_CharacterCustomization_FacialHairTypePreset, HeadReplacementMeshIfHidden) == 0x000038, "Member 'UVAL_CharacterCustomization_FacialHairTypePreset::HeadReplacementMeshIfHidden' has a wrong offset!");

// Class Palia.DespawnComponent
// 0x0038 (0x00D8 - 0x00A0)
class UDespawnComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDespawnStarted;                                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDespawnWasCancelled;                             // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_261A[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeStartedDespawnAt;                              // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalDespawnTime;                                  // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImmuneWhileDespawning;                          // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlterOpacityWhileDespawning;                      // 0x00D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_261B[0x6];                                     // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RpcNetMulticast_BeginDespawn(float DespawnDuration);
	void RpcNetMulticast_CancelDespawn();

	float GetDespawnProgress() const;
	float GetRemainingDespawnTime() const;
	float GetSpentDespawnTime() const;
	float GetTotalDespawnTime() const;
	bool IsDespawning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DespawnComponent">();
	}
	static class UDespawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDespawnComponent>();
	}
};
static_assert(alignof(UDespawnComponent) == 0x000008, "Wrong alignment on UDespawnComponent");
static_assert(sizeof(UDespawnComponent) == 0x0000D8, "Wrong size on UDespawnComponent");
static_assert(offsetof(UDespawnComponent, OnDespawnStarted) == 0x0000A0, "Member 'UDespawnComponent::OnDespawnStarted' has a wrong offset!");
static_assert(offsetof(UDespawnComponent, OnDespawnWasCancelled) == 0x0000B0, "Member 'UDespawnComponent::OnDespawnWasCancelled' has a wrong offset!");
static_assert(offsetof(UDespawnComponent, TimeStartedDespawnAt) == 0x0000C8, "Member 'UDespawnComponent::TimeStartedDespawnAt' has a wrong offset!");
static_assert(offsetof(UDespawnComponent, TotalDespawnTime) == 0x0000CC, "Member 'UDespawnComponent::TotalDespawnTime' has a wrong offset!");
static_assert(offsetof(UDespawnComponent, bIsImmuneWhileDespawning) == 0x0000D0, "Member 'UDespawnComponent::bIsImmuneWhileDespawning' has a wrong offset!");
static_assert(offsetof(UDespawnComponent, bAlterOpacityWhileDespawning) == 0x0000D1, "Member 'UDespawnComponent::bAlterOpacityWhileDespawning' has a wrong offset!");

// Class Palia.DespawnTimerComponent
// 0x0018 (0x00B8 - 0x00A0)
class UDespawnTimerComponent final : public UActorComponent
{
public:
	float                                         DefaultSecondsToDespawn;                           // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartTimerOnBeginPlay;                            // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261C[0x3];                                     // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DespawnTimestamp;                                  // 0x00A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_261D[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelDespawnTimer();
	void HandleDespawnTimerExpired();
	void StartDespawnTimer(float SecondsToDespawn);

	float GetSecondsUntilDespawn() const;
	bool IsDespawning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DespawnTimerComponent">();
	}
	static class UDespawnTimerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDespawnTimerComponent>();
	}
};
static_assert(alignof(UDespawnTimerComponent) == 0x000008, "Wrong alignment on UDespawnTimerComponent");
static_assert(sizeof(UDespawnTimerComponent) == 0x0000B8, "Wrong size on UDespawnTimerComponent");
static_assert(offsetof(UDespawnTimerComponent, DefaultSecondsToDespawn) == 0x0000A0, "Member 'UDespawnTimerComponent::DefaultSecondsToDespawn' has a wrong offset!");
static_assert(offsetof(UDespawnTimerComponent, bStartTimerOnBeginPlay) == 0x0000A4, "Member 'UDespawnTimerComponent::bStartTimerOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UDespawnTimerComponent, DespawnTimestamp) == 0x0000A8, "Member 'UDespawnTimerComponent::DespawnTimestamp' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationComponent
// 0x1810 (0x18B0 - 0x00A0)
class UVAL_CharacterCustomizationComponent : public UActorComponent
{
public:
	uint8                                         Pad_261E[0x70];                                    // 0x00A0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVAL_CharacterCustomizationLoadout_ReplDTO ReplicatedLoadoutDTO;                              // 0x0110(0x0274)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_261F[0x4];                                     // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           MeshReplacementWhenCulled;                         // 0x0388(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimInstanceClassReplacementWhenCulled;            // 0x03B0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterCustomizationPersistBlock    CharacterCustomizationPersistBlock;                // 0x03D8(0x0058)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2620[0x18];                                    // 0x0430(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSavedLoadoutsUpdated;                            // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCustomizationLoadoutApplied;                     // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2621[0x10];                                    // 0x0468(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGliderPropOverridden;                            // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGliderSpawned;                                   // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bTemporarilyAllowAllEntitlements;                  // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2622[0x7];                                     // 0x0499(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGliderRemoved;                                   // 0x04A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPetChanged;                                      // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnValidateLoadoutErrorDuringApply;                 // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2623[0x8];                                     // 0x04D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaMoveablePawn*                   CurrentlyActivePet;                                // 0x04D8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVAL_GliderBase*                        CachedGlider;                                      // 0x04E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EVAL_CharacterBodyType, TSoftObjectPtr<class USkeletalMesh>> BodyTypeToSkeletonMap;                             // 0x04E8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2624[0x18];                                    // 0x0538(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UVAL_CharacterCustomization_ScriptObject*> ScriptObjectMap;                                   // 0x0550(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2625[0x10];                                    // 0x05A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        LoadedAssets;                                      // 0x05B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2626[0x904];                                   // 0x05C0(0x0904)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MorphTargetName_GenderExpression;                  // 0x0EC4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MorphTargetName_MuscularExpression_TypeA;          // 0x0ECC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MorphTargetName_MuscularExpression_TypeB;          // 0x0ED4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MorphTargetName_Thickness_TypeA;                   // 0x0EDC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MorphTargetName_Thickness_TypeB;                   // 0x0EE4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2627[0x4];                                     // 0x0EEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVAL_CharacterCustomizationLoadout     Loadout;                                           // 0x0EF0(0x0900)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, struct FVAL_CharacterCustomizationLoadout> SavedLoadoutMap;                                   // 0x17F0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVAL_CharacterCustomizationLoadout_ReplDTO> SavedLoadoutArray_Rep;                             // 0x1840(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          AssignedSavedLoadouts;                             // 0x1850(0x0010)(Edit, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAssignedSavedLoadoutsUpdated;                    // 0x1860(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UVAL_VoiceSet*                          VoiceSet;                                          // 0x1870(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         GliderTrailNiagaraSystem;                          // 0x1878(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAkRtpc*>                        ActiveAudioProcessingRtpcs;                        // 0x1880(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         MinimumTransitionTime;                             // 0x1890(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2628[0xC];                                     // 0x1894(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         LastCharacterRespecTime;                           // 0x18A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2629[0x8];                                     // 0x18A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSavedLoadoutToServer(const struct FVAL_CharacterCustomizationLoadout& NewLoadoutToAdd);
	bool ApplyAdditionalGliderCustomizations(class AVAL_GliderBase* GliderBase);
	void ApplyBodyData();
	void ApplyCustomizationsToActorSync(struct FVAL_CharacterCustomizationLoadout& NewLoadout, bool bValidateLoadout, EVAL_ApplyCustomizationToActorContext Context);
	bool AssignSavedLoadoutToWheel(int32 WheelIndex, struct FGuid& SavedLoadoutId);
	bool ClearAllAssignedSavedLoadouts();
	bool ClearAssignedSavedLoadout(int32 WheelIndex);
	void CommitLoadoutToServer();
	void DeleteSavedLoadoutOnServer(const struct FGuid& LoadoutId);
	TSet<class FName> GetCoopEffectNames();
	class AVAL_GliderBase* GetGlider();
	struct FGuid GetLoadoutIdForAssignedSlot(int32 WheelIndex);
	void HandleApplyBodyDataToAnimInstance(float HeightScalar, float ThicknessScalar, float GenderScalar, float FitnessScalar);
	void HandleApplyIdleAnimWidthToAnimInstance(float WidthScaler);
	void HandleClearIdleAnimwidthFromAnimInstance();
	void HandleOnMeshRelevancyToLocalPlayerUpdated(bool bNewRelevancy);
	void HandlePropDestroyed(class AEquipViewActor* EquipViewActor);
	bool HasCustomFootprintEffects();
	void OnGliderPropOverridden__DelegateSignature(TSoftClassPtr<class UClass>& GliderPropOverride, class FName& AttachPointName);
	void OnLoadoutTransitionEnded(EVAL_ApplyCustomizationToActorContext& Context, struct FVAL_CharacterCustomizationLoadout& OldLoadout, struct FVAL_CharacterCustomizationLoadout& NewLoadout);
	void OnLoadoutTransitionStarted(EVAL_ApplyCustomizationToActorContext& Context, struct FVAL_CharacterCustomizationLoadout& OldLoadout, struct FVAL_CharacterCustomizationLoadout& NewLoadout);
	void OnPetChanged__DelegateSignature(class UVAL_CharacterCustomizationItem_Pet* NewPet);
	void OnRep_AssignedSavedLoadouts();
	void OnRep_LastCharacterRespecTime();
	void OnRep_LoadoutDTO();
	void OnRep_UpdateSavedLoadouts();
	void SanitizeLoadoutByEntitlements(struct FVAL_ValidateLoadoutErrorPayload* OutErrorPayload);
	void Server_AddSavedLoadout(const struct FVAL_CharacterCustomizationLoadout_ReplDTO& NewSavedLoadout);
	void Server_AssignSavedLoadoutToWheel(int32 WheelIndex, struct FGuid& SavedLoadoutId);
	void Server_ClearAllAssignedSavedLoadouts();
	void Server_ClearAssignedSavedLoadout(int32 WheelIndex);
	void Server_CommitLoadout(const struct FVAL_CharacterCustomizationLoadout_ReplDTO& NewReplicatedLoadout);
	void Server_DeleteSavedLoadout(const struct FGuid& LoadoutId);
	void Server_SetLastCharacterRespecTime();
	void Server_UpdatePetFromLoadout(EVAL_UpdateSpawnedPetContext& Context);
	void SetLastCharacterRespecTime();
	void SetPetVisibility(bool bIsVisible);
	bool ShouldPlayTransition(EVAL_ApplyCustomizationToActorContext& Context, struct FVAL_CharacterCustomizationLoadout& OldLoadout, struct FVAL_CharacterCustomizationLoadout& NewLoadout);
	void SimpleCustomizationEvent__DelegateSignature(class UVAL_CharacterCustomizationComponent* CustomizationComp);
	EVAL_FootprintEffectType SpawnCustomFootprintEffects(struct FVector& SpawnLocation, struct FRotator& SpawnRotation);
	void UpdateCooperativeVFX();
	void UpdatePetFromLoadoutOnServer(EVAL_UpdateSpawnedPetContext& Context);
	void UpdateSpawnedPet(struct FVAL_UpdateSpawnedPetPayload& Payload);

	TArray<class FName> GetDifferencesBetweenLoadouts(struct FVAL_CharacterCustomizationLoadout& LoadoutA, struct FVAL_CharacterCustomizationLoadout& LoadoutB) const;
	class UNiagaraSystem* GetGliderTrailNiagaraSystem() const;
	int64 GetLastCharacterRespecTime() const;
	const struct FVAL_CharacterCustomizationLoadout GetLoadout() const;
	class UVAL_VoiceSet* GetVoiceSet() const;
	bool HasRecievedReplicatedLoadout() const;
	bool HasValidLoadoutApplied() const;
	bool IsPendingLoadoutApplication() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationComponent">();
	}
	static class UVAL_CharacterCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationComponent>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationComponent) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationComponent");
static_assert(sizeof(UVAL_CharacterCustomizationComponent) == 0x0018B0, "Wrong size on UVAL_CharacterCustomizationComponent");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, ReplicatedLoadoutDTO) == 0x000110, "Member 'UVAL_CharacterCustomizationComponent::ReplicatedLoadoutDTO' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, MeshReplacementWhenCulled) == 0x000388, "Member 'UVAL_CharacterCustomizationComponent::MeshReplacementWhenCulled' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, AnimInstanceClassReplacementWhenCulled) == 0x0003B0, "Member 'UVAL_CharacterCustomizationComponent::AnimInstanceClassReplacementWhenCulled' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, CharacterCustomizationPersistBlock) == 0x0003D8, "Member 'UVAL_CharacterCustomizationComponent::CharacterCustomizationPersistBlock' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, OnSavedLoadoutsUpdated) == 0x000448, "Member 'UVAL_CharacterCustomizationComponent::OnSavedLoadoutsUpdated' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, OnCustomizationLoadoutApplied) == 0x000458, "Member 'UVAL_CharacterCustomizationComponent::OnCustomizationLoadoutApplied' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, OnGliderPropOverridden) == 0x000478, "Member 'UVAL_CharacterCustomizationComponent::OnGliderPropOverridden' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, OnGliderSpawned) == 0x000488, "Member 'UVAL_CharacterCustomizationComponent::OnGliderSpawned' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, bTemporarilyAllowAllEntitlements) == 0x000498, "Member 'UVAL_CharacterCustomizationComponent::bTemporarilyAllowAllEntitlements' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, OnGliderRemoved) == 0x0004A0, "Member 'UVAL_CharacterCustomizationComponent::OnGliderRemoved' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, OnPetChanged) == 0x0004B0, "Member 'UVAL_CharacterCustomizationComponent::OnPetChanged' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, OnValidateLoadoutErrorDuringApply) == 0x0004C0, "Member 'UVAL_CharacterCustomizationComponent::OnValidateLoadoutErrorDuringApply' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, CurrentlyActivePet) == 0x0004D8, "Member 'UVAL_CharacterCustomizationComponent::CurrentlyActivePet' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, CachedGlider) == 0x0004E0, "Member 'UVAL_CharacterCustomizationComponent::CachedGlider' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, BodyTypeToSkeletonMap) == 0x0004E8, "Member 'UVAL_CharacterCustomizationComponent::BodyTypeToSkeletonMap' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, ScriptObjectMap) == 0x000550, "Member 'UVAL_CharacterCustomizationComponent::ScriptObjectMap' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, LoadedAssets) == 0x0005B0, "Member 'UVAL_CharacterCustomizationComponent::LoadedAssets' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, MorphTargetName_GenderExpression) == 0x000EC4, "Member 'UVAL_CharacterCustomizationComponent::MorphTargetName_GenderExpression' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, MorphTargetName_MuscularExpression_TypeA) == 0x000ECC, "Member 'UVAL_CharacterCustomizationComponent::MorphTargetName_MuscularExpression_TypeA' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, MorphTargetName_MuscularExpression_TypeB) == 0x000ED4, "Member 'UVAL_CharacterCustomizationComponent::MorphTargetName_MuscularExpression_TypeB' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, MorphTargetName_Thickness_TypeA) == 0x000EDC, "Member 'UVAL_CharacterCustomizationComponent::MorphTargetName_Thickness_TypeA' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, MorphTargetName_Thickness_TypeB) == 0x000EE4, "Member 'UVAL_CharacterCustomizationComponent::MorphTargetName_Thickness_TypeB' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, Loadout) == 0x000EF0, "Member 'UVAL_CharacterCustomizationComponent::Loadout' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, SavedLoadoutMap) == 0x0017F0, "Member 'UVAL_CharacterCustomizationComponent::SavedLoadoutMap' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, SavedLoadoutArray_Rep) == 0x001840, "Member 'UVAL_CharacterCustomizationComponent::SavedLoadoutArray_Rep' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, AssignedSavedLoadouts) == 0x001850, "Member 'UVAL_CharacterCustomizationComponent::AssignedSavedLoadouts' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, OnAssignedSavedLoadoutsUpdated) == 0x001860, "Member 'UVAL_CharacterCustomizationComponent::OnAssignedSavedLoadoutsUpdated' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, VoiceSet) == 0x001870, "Member 'UVAL_CharacterCustomizationComponent::VoiceSet' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, GliderTrailNiagaraSystem) == 0x001878, "Member 'UVAL_CharacterCustomizationComponent::GliderTrailNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, ActiveAudioProcessingRtpcs) == 0x001880, "Member 'UVAL_CharacterCustomizationComponent::ActiveAudioProcessingRtpcs' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, MinimumTransitionTime) == 0x001890, "Member 'UVAL_CharacterCustomizationComponent::MinimumTransitionTime' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationComponent, LastCharacterRespecTime) == 0x0018A0, "Member 'UVAL_CharacterCustomizationComponent::LastCharacterRespecTime' has a wrong offset!");

// Class Palia.Dev_SpawnActorConfig
// 0x0010 (0x0040 - 0x0030)
class UDev_SpawnActorConfig final : public UDataAsset
{
public:
	TArray<class FName>                           WhiteListAssetPaths;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Dev_SpawnActorConfig">();
	}
	static class UDev_SpawnActorConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDev_SpawnActorConfig>();
	}
};
static_assert(alignof(UDev_SpawnActorConfig) == 0x000008, "Wrong alignment on UDev_SpawnActorConfig");
static_assert(sizeof(UDev_SpawnActorConfig) == 0x000040, "Wrong size on UDev_SpawnActorConfig");
static_assert(offsetof(UDev_SpawnActorConfig, WhiteListAssetPaths) == 0x000030, "Member 'UDev_SpawnActorConfig::WhiteListAssetPaths' has a wrong offset!");

// Class Palia.Dialogueable
// 0x0000 (0x0028 - 0x0028)
class IDialogueable final : public IInterface
{
public:
	void BPIE_PlayAudioMappingConfig(struct FAudioMappingConfig& AudioConfig);
	class UAkComponent* BPNE_GetOrCreateVoicePositionAkComponent();

	class UDialogueComponent* BPNE_GetDialogueSourceComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Dialogueable">();
	}
	static class IDialogueable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDialogueable>();
	}
};
static_assert(alignof(IDialogueable) == 0x000008, "Wrong alignment on IDialogueable");
static_assert(sizeof(IDialogueable) == 0x000028, "Wrong size on IDialogueable");

// Class Palia.VAL_BpAsyncAction_GetMetaCharacterData
// 0x0038 (0x0068 - 0x0030)
class UVAL_BpAsyncAction_GetMetaCharacterData final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2633[0x18];                                    // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_BpAsyncAction_GetMetaCharacterData* GetMetaCharacterData(class ULocalPlayer* LocalPlayer, struct FGuid& AccountId);

	void OnGetCharactersFailed__DelegateSignature();
	void OnGetCharactersObtained__DelegateSignature(TArray<struct FVALDTOS_MetaCharacterFormat>& CharactersFound);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_BpAsyncAction_GetMetaCharacterData">();
	}
	static class UVAL_BpAsyncAction_GetMetaCharacterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_BpAsyncAction_GetMetaCharacterData>();
	}
};
static_assert(alignof(UVAL_BpAsyncAction_GetMetaCharacterData) == 0x000008, "Wrong alignment on UVAL_BpAsyncAction_GetMetaCharacterData");
static_assert(sizeof(UVAL_BpAsyncAction_GetMetaCharacterData) == 0x000068, "Wrong size on UVAL_BpAsyncAction_GetMetaCharacterData");
static_assert(offsetof(UVAL_BpAsyncAction_GetMetaCharacterData, OnSuccess) == 0x000030, "Member 'UVAL_BpAsyncAction_GetMetaCharacterData::OnSuccess' has a wrong offset!");
static_assert(offsetof(UVAL_BpAsyncAction_GetMetaCharacterData, OnFailed) == 0x000040, "Member 'UVAL_BpAsyncAction_GetMetaCharacterData::OnFailed' has a wrong offset!");

// Class Palia.DialogueActor
// 0x0038 (0x02E0 - 0x02A8)
class ADialogueActor final : public AActor
{
public:
	uint8                                         Pad_2634[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DialogueRootComponent;                             // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractableCollider;                              // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       DialogueCamera;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkCulledComponent*                     AkCulledComponent;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDialogueComponent*                     DialogueSourceComponent;                           // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueActor">();
	}
	static class ADialogueActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADialogueActor>();
	}
};
static_assert(alignof(ADialogueActor) == 0x000008, "Wrong alignment on ADialogueActor");
static_assert(sizeof(ADialogueActor) == 0x0002E0, "Wrong size on ADialogueActor");
static_assert(offsetof(ADialogueActor, DialogueRootComponent) == 0x0002B0, "Member 'ADialogueActor::DialogueRootComponent' has a wrong offset!");
static_assert(offsetof(ADialogueActor, InteractableCollider) == 0x0002B8, "Member 'ADialogueActor::InteractableCollider' has a wrong offset!");
static_assert(offsetof(ADialogueActor, DialogueCamera) == 0x0002C0, "Member 'ADialogueActor::DialogueCamera' has a wrong offset!");
static_assert(offsetof(ADialogueActor, AkCulledComponent) == 0x0002C8, "Member 'ADialogueActor::AkCulledComponent' has a wrong offset!");
static_assert(offsetof(ADialogueActor, InteractableComponent) == 0x0002D0, "Member 'ADialogueActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ADialogueActor, DialogueSourceComponent) == 0x0002D8, "Member 'ADialogueActor::DialogueSourceComponent' has a wrong offset!");

// Class Palia.DialogueComponent
// 0x0158 (0x01F8 - 0x00A0)
class UDialogueComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2635[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDialogueEntered;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueExited;                                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueStarted;                                 // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueEnded;                                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueCameraInitialFadeOutComplete;            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueCameraInitialFadeInStart;                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueCameraEndingFadeOutComplete;             // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIgnoreDialogueTriggered;                         // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bVillager;                                         // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2636[0x7];                                     // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_DialogueSpeakerAsset*              DialogueSpeaker;                                   // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AudioMappings;                                     // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimaryDataAsset*                      DialogBookendConfig;                               // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       DialogueCamera;                                    // 0x0148(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyFindDialogueCamera;                  // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAvoidConversation;                          // 0x0151(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnRouteToDestination;                             // 0x0152(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2637[0x1];                                     // 0x0153(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeUntilRushOnTravelStart;                        // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushSpeedUp;                                       // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2638[0x4];                                     // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVAL_DialogueAsset*>             DialogueAssets;                                    // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UVAL_DialogueAsset*>             InitialDialogueAssets;                             // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UVAL_DialogueAsset*>             GiftHintDialogueAssets;                            // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasAnyGiftHintDialogues;                          // 0x0190(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2639[0x7];                                     // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AValeriaCharacter*>              EngagedCharacters;                                 // 0x0198(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bPlayersEngaged;                                   // 0x01A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263A[0x7];                                     // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           Server_CleanEngagedCharactersHandle;               // 0x01B0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           Server_RushHandle;                                 // 0x01B8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CachedSpeakerName;                                 // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CachedSpeakerPersistId;                            // 0x01C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_263B[0x2C];                                    // 0x01CC(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetAudioMappingConfigRefForName(class FName& MappingName, struct FAudioMappingConfig* OutAudioMappingConfig);
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Player, const struct FInteractEventParams& Params_0);
	void OnRep_bPlayersEngaged();
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void OpenVillagerStore(class UPersistentTagMapComponent* TagMap);
	void RegisterArrivedAtDestination();
	void RegisterEnRouteToDestination();
	void VillagerActivityStatusChanged(class AValeriaVillagerController* ChangedValeriaVillagerController, EVillagerActivityStatus NewActivityStatus);
	void VillagerConfigIdChanged(class AValeriaVillagerCharacter* Villager, int32 NewVillagerConfigId);

	bool DoesAcceptGifts() const;
	bool DoesHaveAnyGiftHintDialogues() const;
	TScriptInterface<class IDialogueable> GetDialogueableInterface() const;
	class UCameraComponent* GetDialogueCamera() const;
	struct FTransform GetDialogueCameraTransform() const;
	class UVAL_DialogueSpeakerAsset* GetDialogueSpeaker() const;
	class FName GetSpeakerName() const;
	int32 GetSpeakerPersistId() const;
	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	class AValeriaVillagerCharacter* GetVillager() const;
	class AValeriaVillagerController* GetVillagerController() const;
	class UVillagerGiftReceiverComponent* GetVillagerGiftReceiverComponent() const;
	int32 GetVillagerId() const;
	bool HasStore() const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsAnyoneEngagedForDialogue() const;
	bool IsAvoidingConversation() const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;
	bool IsLocallyEngagedForDialogue() const;
	bool IsVillager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueComponent">();
	}
	static class UDialogueComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueComponent>();
	}
};
static_assert(alignof(UDialogueComponent) == 0x000008, "Wrong alignment on UDialogueComponent");
static_assert(sizeof(UDialogueComponent) == 0x0001F8, "Wrong size on UDialogueComponent");
static_assert(offsetof(UDialogueComponent, OnDialogueEntered) == 0x0000A8, "Member 'UDialogueComponent::OnDialogueEntered' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, OnDialogueExited) == 0x0000B8, "Member 'UDialogueComponent::OnDialogueExited' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, OnDialogueStarted) == 0x0000C8, "Member 'UDialogueComponent::OnDialogueStarted' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, OnDialogueEnded) == 0x0000D8, "Member 'UDialogueComponent::OnDialogueEnded' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, OnDialogueCameraInitialFadeOutComplete) == 0x0000E8, "Member 'UDialogueComponent::OnDialogueCameraInitialFadeOutComplete' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, OnDialogueCameraInitialFadeInStart) == 0x0000F8, "Member 'UDialogueComponent::OnDialogueCameraInitialFadeInStart' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, OnDialogueCameraEndingFadeOutComplete) == 0x000108, "Member 'UDialogueComponent::OnDialogueCameraEndingFadeOutComplete' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, OnIgnoreDialogueTriggered) == 0x000118, "Member 'UDialogueComponent::OnIgnoreDialogueTriggered' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, bVillager) == 0x000128, "Member 'UDialogueComponent::bVillager' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, DialogueSpeaker) == 0x000130, "Member 'UDialogueComponent::DialogueSpeaker' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, AudioMappings) == 0x000138, "Member 'UDialogueComponent::AudioMappings' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, DialogBookendConfig) == 0x000140, "Member 'UDialogueComponent::DialogBookendConfig' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, DialogueCamera) == 0x000148, "Member 'UDialogueComponent::DialogueCamera' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, bAutomaticallyFindDialogueCamera) == 0x000150, "Member 'UDialogueComponent::bAutomaticallyFindDialogueCamera' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, bShouldAvoidConversation) == 0x000151, "Member 'UDialogueComponent::bShouldAvoidConversation' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, bOnRouteToDestination) == 0x000152, "Member 'UDialogueComponent::bOnRouteToDestination' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, TimeUntilRushOnTravelStart) == 0x000154, "Member 'UDialogueComponent::TimeUntilRushOnTravelStart' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, RushSpeedUp) == 0x000158, "Member 'UDialogueComponent::RushSpeedUp' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, DialogueAssets) == 0x000160, "Member 'UDialogueComponent::DialogueAssets' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, InitialDialogueAssets) == 0x000170, "Member 'UDialogueComponent::InitialDialogueAssets' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, GiftHintDialogueAssets) == 0x000180, "Member 'UDialogueComponent::GiftHintDialogueAssets' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, bHasAnyGiftHintDialogues) == 0x000190, "Member 'UDialogueComponent::bHasAnyGiftHintDialogues' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, EngagedCharacters) == 0x000198, "Member 'UDialogueComponent::EngagedCharacters' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, bPlayersEngaged) == 0x0001A8, "Member 'UDialogueComponent::bPlayersEngaged' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, Server_CleanEngagedCharactersHandle) == 0x0001B0, "Member 'UDialogueComponent::Server_CleanEngagedCharactersHandle' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, Server_RushHandle) == 0x0001B8, "Member 'UDialogueComponent::Server_RushHandle' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, CachedSpeakerName) == 0x0001C0, "Member 'UDialogueComponent::CachedSpeakerName' has a wrong offset!");
static_assert(offsetof(UDialogueComponent, CachedSpeakerPersistId) == 0x0001C8, "Member 'UDialogueComponent::CachedSpeakerPersistId' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItemBase
// 0x0138 (0x0168 - 0x0030)
class UVAL_CharacterCustomizationItemBase : public UPrimaryDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	struct FGuid                                  ItemId;                                            // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVAL_CharacterCustomizationItemType           ItemType;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2644[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FVAL_CharacterCustomization_CosmeticTagSelector> CosmeticTags;                                      // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAkRtpc*                                AudioProcessingRtpc;                               // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PrerenderedThumbnailImage_Female;                  // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PrerenderedThumbnailImage_Male;                    // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScriptStruct*                          BodyTypeSpecificStruct;                            // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TooltipDataRowName;                                // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2645[0x50];                                    // 0x0118(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAdditionalCustomizations(class UVAL_CharacterCustomizationComponent* Customizer, TMap<class FName, struct FGuid>& SelectedVariantOptions, struct FVAL_CharacterCustomization_SkinMaterialSet& SkinMaterials);
	bool TryGetAllVariantChannelNames(EVAL_CharacterBodyType BodyType, TSet<class FName>* OutVariantChannelNames);
	bool TryGetAllVariantOptionIds(EVAL_CharacterBodyType BodyType, class FName VariantChannelName, TSet<struct FGuid>* OutVariantOptionIds);
	bool TryGetBodyTypeSpecificConfig(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomization_PerBodyTypeConfig_Base* OutBodyTypeSpecificConfig);
	bool TryGetVariantChannelByName(EVAL_CharacterBodyType BodyType, class FName VariantChannelName, struct FVAL_CharacterCustomizationVariantChannel* OutVariantChannel);
	bool TryGetVariantOptionById(EVAL_CharacterBodyType BodyType, class FName VariantChannelName, struct FGuid& ID, struct FVAL_CharacterCustomizationVariantOptionBase* OutVariantOption);

	bool CanItemBeUsedOnBodyType(EVAL_CharacterBodyType BodyType) const;
	TSoftObjectPtr<class UTexture2D> GetPrerenderedThumbnailImage(EVAL_CharacterBodyType BodyType) const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItemBase">();
	}
	static class UVAL_CharacterCustomizationItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItemBase>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItemBase) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItemBase");
static_assert(sizeof(UVAL_CharacterCustomizationItemBase) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItemBase");
static_assert(offsetof(UVAL_CharacterCustomizationItemBase, DisplayName) == 0x000030, "Member 'UVAL_CharacterCustomizationItemBase::DisplayName' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationItemBase, ItemId) == 0x000048, "Member 'UVAL_CharacterCustomizationItemBase::ItemId' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationItemBase, ItemType) == 0x000058, "Member 'UVAL_CharacterCustomizationItemBase::ItemType' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationItemBase, CosmeticTags) == 0x000060, "Member 'UVAL_CharacterCustomizationItemBase::CosmeticTags' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationItemBase, AudioProcessingRtpc) == 0x0000B0, "Member 'UVAL_CharacterCustomizationItemBase::AudioProcessingRtpc' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationItemBase, PrerenderedThumbnailImage_Female) == 0x0000B8, "Member 'UVAL_CharacterCustomizationItemBase::PrerenderedThumbnailImage_Female' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationItemBase, PrerenderedThumbnailImage_Male) == 0x0000E0, "Member 'UVAL_CharacterCustomizationItemBase::PrerenderedThumbnailImage_Male' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationItemBase, BodyTypeSpecificStruct) == 0x000108, "Member 'UVAL_CharacterCustomizationItemBase::BodyTypeSpecificStruct' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationItemBase, TooltipDataRowName) == 0x000110, "Member 'UVAL_CharacterCustomizationItemBase::TooltipDataRowName' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItem_Eyes
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_Eyes final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_Eyes(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_Eyes_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_Eyes">();
	}
	static class UVAL_CharacterCustomizationItem_Eyes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_Eyes>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_Eyes) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_Eyes");
static_assert(sizeof(UVAL_CharacterCustomizationItem_Eyes) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_Eyes");

// Class Palia.DialogueManagerComponent
// 0x05E0 (0x0680 - 0x00A0)
class UDialogueManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2656[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      OwningCharacter;                                   // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AValeriaPlayerController*               OwningPlayerController;                            // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDialogueEntered;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueExited;                                  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueProgressed;                              // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueTextFullyDisplayed;                      // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueOptionListUpdated;                       // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueStarted;                                 // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueEnded;                                   // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueScriptedNotify;                          // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialoguePreloadStarted;                          // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialoguePreloadComplete;                         // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialoguePreloadTimedOut;                         // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVillagerStoreOpened;                             // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         AutomaticallyPlayAnimOutroDelay;                   // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2657[0x4];                                     // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVillagerDialogueGlobalConfig*          GlobalDialogueConfig;                              // 0x0180(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDialogueComponent*                     CurrentDialogueSourceComponent;                    // 0x0188(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2658[0x8];                                     // 0x0190(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRequestingStartDialogue;                          // 0x0198(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2659[0x7];                                     // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_DialogueAsset*                     CurrentDialogueAsset;                              // 0x01A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVAL_DialogueSpeakerAsset*              CurrentPrimaryDialogueSpeakerAsset;                // 0x01A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDialogueLine>                  CurrentDialogueLines;                              // 0x01B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentLineNumber;                                 // 0x01C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDialogueTextFullyDisplayed;                       // 0x01C4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265A[0x3];                                     // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogueListToShow                    LastShownDialogueList;                             // 0x01C8(0x0138)(Protected, NativeAccessSpecifierProtected)
	struct FVAL_DialogueOptionList                CurrentDialogueOptionList;                         // 0x0300(0x0048)(Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 CurrentDialogueOptionsSeenThatDidntContinueConversation; // 0x0348(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVAL_PostDialogueChainSupplementaryInfo PostDialogueChainSupplementaryInfo;                // 0x0358(0x0010)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FClientDialogueDisplayInfo             TextDisplayInfo;                                   // 0x0368(0x0048)(Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldStallDialogueAnimsForBehaviorOutro;         // 0x03B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDialoguePreloadPhase                         CurrentPreloadPhase;                               // 0x03B1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265B[0x6];                                     // 0x03B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeleportTravelConfigAsset*             ExitDialogueTeleportTravelConfigAsset;             // 0x03B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class ULevelSequence>          ExitDialogueLevelSequence;                         // 0x03C0(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCinematicSequenceConfig*               ExitDialogueCinSequenceConfig;                     // 0x03E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           Client_PreloadTimeoutHandle;                       // 0x03F0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           Client_DialogueTextHandle;                         // 0x03F8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           Client_AnimQueueRestartHandle;                     // 0x0400(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           Client_AnimQueueOutroHandle;                       // 0x0408(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTransitionedToSingleCharacterDialogueScene;      // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTransitionedToMultiCharacterDialogueScene;       // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVAL_DialogueCharacter                 PrimaryDialogueCharacter;                          // 0x0430(0x0030)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVAL_DialogueCharacter>         MultiVillagerDialogueCharacters;                   // 0x0460(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AValeriaVillagerCharacter*>      CharactersToFinishLoadingAnimations;               // 0x0470(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bMultiCharacterDialogueSceneActive;                // 0x0480(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265C[0x7];                                     // 0x0481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDialogueCameraInitialFadeOutComplete;            // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueCameraInitialFadeInStart;                // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueCameraEndingFadeOutComplete;             // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ACameraActor*                           MCDialogueCamera1;                                 // 0x04B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACameraActor*                           MCDialogueCamera2;                                 // 0x04C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMCDialogueCameraActive;                           // 0x04C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCamera1Active;                                    // 0x04C9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265D[0x6];                                     // 0x04CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OriginalDialogueSourceCameraTransform;             // 0x04D0(0x0060)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DialogueCameraActorClass;                          // 0x0530(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FViewTargetTransitionParams            DialogueCameraTransitionInfo;                      // 0x0558(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FViewTargetTransitionParams            MidDialogueCameraTransitionInfo;                   // 0x0568(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DefaultCameraHorizontalDistance;                   // 0x0578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultCameraDistanceFromCharacter;                // 0x057C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldHideOtherVillagersDuringDialogue;           // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldHidePlayerDuringDialogue;                   // 0x0581(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265E[0x2];                                     // 0x0582(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DialogueFadeInDuration;                            // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DialogueFadeHoldDuration;                          // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DialogueFadeOutDuration;                           // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DialoguePreloadTimeoutDuration;                    // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopBehaviorAnimsDuringFadeIn;                    // 0x0594(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestartDialogueAnimsDuringFadeIn;                 // 0x0595(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStallTextDuringCameraFade;                        // 0x0596(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265F[0x1];                                     // 0x0597(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RestartDialogueAnimsDuringFadeInTimingScalar;      // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutomaticallyFindDialogueCamera;                  // 0x059C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutomaticallySanitizeFocalDistance;               // 0x059D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCameraFadeInQueued;                               // 0x059E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipNextCameraFade;                               // 0x059F(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           Client_CameraFadeHandle;                           // 0x05A0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDialogueHistoryChanged;                          // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         DayGroupingOverlapHours;                           // 0x05B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2660[0x4];                                     // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDialogueChainEntry>            CurrentDialogueChain;                              // 0x05C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, struct FSpeakerDialogueHistory>   SpeakerDialogueHistories;                          // 0x05D0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, struct FSpeakerDialogueHistoryUpdate> SpeakerDialogueHistory_QueuedToSend;               // 0x0620(0x0050)(NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ProcessDialogueHistoryQueueHandle;                 // 0x0670(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2661[0x8];                                     // 0x0678(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AsyncLoadNeededAnimations(class UVAL_DialogueAsset* DialogueAsset);
	void AsyncLoadNeededVillagers(class UVAL_DialogueAsset* DialogueAsset);
	void Client_CompleteDialogue();
	void Client_RequestStartDialogue(int32 DialogueAssetId);
	void Client_SelectDialogueOption(int32 DialogueAssetId);
	void ControllerChangedForPawn(class APawn* Pawn, class AController* OldController, class AController* NewController);
	class FText CreateSubstitutedText(class FText& InputText);
	void DialogueSourceComponentOwnerDestroyed(class AActor* DestroyedActor);
	void ForceCompleteCurrentDialogueText();
	void GiveGiftTo(class UVillagerGiftReceiverComponent* GiftReceiver, const struct FBagSlotLocation& BagSlotLocation);
	void IncrementCurrentLineNumber();
	void LogSelectedDialogue(int32 PreviousDialogueID, int32 SelectedDialogueID);
	void OpenVillagerStore(class UPersistentTagMapComponent* TagMap);
	void PreloadComplete(class AValeriaVillagerCharacter* VillagerCharacter);
	void ProcessLongTermHistoryQueue();
	void ProgressDialogueText();
	void ResetCurrentLineNumber();
	void RpcClient_AssignExitCinSequenceConfig(class UCinematicSequenceConfig* InExitDialogueCinConfig);
	void RpcClient_AssignExitDialogueLevelSequence(TSoftObjectPtr<class ULevelSequence>& InExitDialogueLevelSequence);
	void RpcClient_AssignExitDialogueTeleportTravelConfigAsset(class UTeleportTravelConfigAsset* InExitDialogueTeleportTravelConfigAsset);
	void RpcClient_EnterDialogue(class UDialogueComponent* DialogueSourceComponent);
	void RpcClient_ExitDialogue();
	void RpcClient_InformDeterminedDialogueOptionList(const struct FVAL_DialogueOptionList& DeterminedDialogueOptionList);
	void RpcClient_ResetLongTermHistoryQueue();
	void RpcClient_SendLongTermSpeakerHistoryQueue(TArray<struct FSpeakerDialogueHistoryUpdate>& HistoryUpdates);
	void RpcClient_ShowIgnoreDialogue(class UDialogueComponent* AffectedDialogueSourceComponent);
	void RpcClient_StartDialogue(class UDialogueComponent* DialogueSourceComponent, class UVAL_DialogueAsset* InDialogueAsset, int32 InConditionalScriptIndex);
	void RpcServer_CompleteDialogue();
	void RpcServer_ConfirmEnteredDialogue(class UDialogueComponent* DialogueSourceComponent);
	void RpcServer_GiveGiftTo(class UVillagerGiftReceiverComponent* GiftReceiver, const struct FBagSlotLocation& BagSlotLocation);
	void RpcServer_RequestExitDialogue();
	void RpcServer_RequestStartDialogue(int32 DialogueAssetId);
	void SetCurrentDialogueAsset(class UVAL_DialogueAsset* InDialogueAsset, int32 InConditionalScriptIndex);
	void StartNewDialogueText(class FText& NewText, bool bPerformLocalSubsitutions);
	void StartProcessingLongTermHistoryQueue();
	void UpdateDialogueScene(class UDialogueComponent* InDialogueSourceComponent, class UVAL_DialogueAsset* InDialogueAsset);
	void VillagerAnimationLoadComplete(class AValeriaVillagerCharacter* VillagerCharacter);

	bool CanEnterDialogue() const;
	bool CanLeaveCurrentDialogue() const;
	TArray<class FName> GetAnimationsFromDialogueAsset(class UVAL_DialogueAsset* DialogueAsset) const;
	const class UVAL_DialogueAsset* GetCurrentDialogueAsset() const;
	bool GetCurrentDialogueLine(struct FDialogueLine* OutCurrentLine) const;
	class UDialogueComponent* GetCurrentDialogueSourceComponent() const;
	class UVAL_DialogueSpeakerAsset* GetCurrentDialogueSpeaker() const;
	int32 GetCurrentLineNumber() const;
	class UVAL_DialogueSpeakerAsset* GetCurrentPrimaryDialogueSpeakerAsset() const;
	const class FText GetDialogueDisplayString() const;
	TArray<struct FDialogueLine> GetSelectedScripts(class UVAL_DialogueAsset* DialogueAsset, int32 AlternativeScriptIndex) const;
	class AValeriaVillagerCharacter* GetVillagerByDialogueSpeaker(class UVAL_DialogueSpeakerAsset* InDialogueSpeakerAsset) const;
	bool HasPostDialogueAction() const;
	bool IsAtFinalLineOfDialogue() const;
	bool IsCurrentDialogueTerminal() const;
	bool IsDialogueTextFullyDisplayed() const;
	bool IsMultiCharacterDialogueSceneActive() const;
	bool IsRequestingStartDialogue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueManagerComponent">();
	}
	static class UDialogueManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueManagerComponent>();
	}
};
static_assert(alignof(UDialogueManagerComponent) == 0x000010, "Wrong alignment on UDialogueManagerComponent");
static_assert(sizeof(UDialogueManagerComponent) == 0x000680, "Wrong size on UDialogueManagerComponent");
static_assert(offsetof(UDialogueManagerComponent, OwningCharacter) == 0x0000A8, "Member 'UDialogueManagerComponent::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OwningPlayerController) == 0x0000B0, "Member 'UDialogueManagerComponent::OwningPlayerController' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueEntered) == 0x0000B8, "Member 'UDialogueManagerComponent::OnDialogueEntered' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueExited) == 0x0000C8, "Member 'UDialogueManagerComponent::OnDialogueExited' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueProgressed) == 0x0000D8, "Member 'UDialogueManagerComponent::OnDialogueProgressed' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueTextFullyDisplayed) == 0x0000E8, "Member 'UDialogueManagerComponent::OnDialogueTextFullyDisplayed' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueOptionListUpdated) == 0x0000F8, "Member 'UDialogueManagerComponent::OnDialogueOptionListUpdated' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueStarted) == 0x000108, "Member 'UDialogueManagerComponent::OnDialogueStarted' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueEnded) == 0x000118, "Member 'UDialogueManagerComponent::OnDialogueEnded' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueScriptedNotify) == 0x000128, "Member 'UDialogueManagerComponent::OnDialogueScriptedNotify' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialoguePreloadStarted) == 0x000138, "Member 'UDialogueManagerComponent::OnDialoguePreloadStarted' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialoguePreloadComplete) == 0x000148, "Member 'UDialogueManagerComponent::OnDialoguePreloadComplete' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialoguePreloadTimedOut) == 0x000158, "Member 'UDialogueManagerComponent::OnDialoguePreloadTimedOut' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnVillagerStoreOpened) == 0x000168, "Member 'UDialogueManagerComponent::OnVillagerStoreOpened' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, AutomaticallyPlayAnimOutroDelay) == 0x000178, "Member 'UDialogueManagerComponent::AutomaticallyPlayAnimOutroDelay' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, GlobalDialogueConfig) == 0x000180, "Member 'UDialogueManagerComponent::GlobalDialogueConfig' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CurrentDialogueSourceComponent) == 0x000188, "Member 'UDialogueManagerComponent::CurrentDialogueSourceComponent' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bRequestingStartDialogue) == 0x000198, "Member 'UDialogueManagerComponent::bRequestingStartDialogue' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CurrentDialogueAsset) == 0x0001A0, "Member 'UDialogueManagerComponent::CurrentDialogueAsset' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CurrentPrimaryDialogueSpeakerAsset) == 0x0001A8, "Member 'UDialogueManagerComponent::CurrentPrimaryDialogueSpeakerAsset' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CurrentDialogueLines) == 0x0001B0, "Member 'UDialogueManagerComponent::CurrentDialogueLines' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CurrentLineNumber) == 0x0001C0, "Member 'UDialogueManagerComponent::CurrentLineNumber' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bDialogueTextFullyDisplayed) == 0x0001C4, "Member 'UDialogueManagerComponent::bDialogueTextFullyDisplayed' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, LastShownDialogueList) == 0x0001C8, "Member 'UDialogueManagerComponent::LastShownDialogueList' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CurrentDialogueOptionList) == 0x000300, "Member 'UDialogueManagerComponent::CurrentDialogueOptionList' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CurrentDialogueOptionsSeenThatDidntContinueConversation) == 0x000348, "Member 'UDialogueManagerComponent::CurrentDialogueOptionsSeenThatDidntContinueConversation' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, PostDialogueChainSupplementaryInfo) == 0x000358, "Member 'UDialogueManagerComponent::PostDialogueChainSupplementaryInfo' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, TextDisplayInfo) == 0x000368, "Member 'UDialogueManagerComponent::TextDisplayInfo' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bShouldStallDialogueAnimsForBehaviorOutro) == 0x0003B0, "Member 'UDialogueManagerComponent::bShouldStallDialogueAnimsForBehaviorOutro' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CurrentPreloadPhase) == 0x0003B1, "Member 'UDialogueManagerComponent::CurrentPreloadPhase' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, ExitDialogueTeleportTravelConfigAsset) == 0x0003B8, "Member 'UDialogueManagerComponent::ExitDialogueTeleportTravelConfigAsset' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, ExitDialogueLevelSequence) == 0x0003C0, "Member 'UDialogueManagerComponent::ExitDialogueLevelSequence' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, ExitDialogueCinSequenceConfig) == 0x0003E8, "Member 'UDialogueManagerComponent::ExitDialogueCinSequenceConfig' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, Client_PreloadTimeoutHandle) == 0x0003F0, "Member 'UDialogueManagerComponent::Client_PreloadTimeoutHandle' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, Client_DialogueTextHandle) == 0x0003F8, "Member 'UDialogueManagerComponent::Client_DialogueTextHandle' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, Client_AnimQueueRestartHandle) == 0x000400, "Member 'UDialogueManagerComponent::Client_AnimQueueRestartHandle' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, Client_AnimQueueOutroHandle) == 0x000408, "Member 'UDialogueManagerComponent::Client_AnimQueueOutroHandle' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnTransitionedToSingleCharacterDialogueScene) == 0x000410, "Member 'UDialogueManagerComponent::OnTransitionedToSingleCharacterDialogueScene' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnTransitionedToMultiCharacterDialogueScene) == 0x000420, "Member 'UDialogueManagerComponent::OnTransitionedToMultiCharacterDialogueScene' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, PrimaryDialogueCharacter) == 0x000430, "Member 'UDialogueManagerComponent::PrimaryDialogueCharacter' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, MultiVillagerDialogueCharacters) == 0x000460, "Member 'UDialogueManagerComponent::MultiVillagerDialogueCharacters' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CharactersToFinishLoadingAnimations) == 0x000470, "Member 'UDialogueManagerComponent::CharactersToFinishLoadingAnimations' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bMultiCharacterDialogueSceneActive) == 0x000480, "Member 'UDialogueManagerComponent::bMultiCharacterDialogueSceneActive' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueCameraInitialFadeOutComplete) == 0x000488, "Member 'UDialogueManagerComponent::OnDialogueCameraInitialFadeOutComplete' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueCameraInitialFadeInStart) == 0x000498, "Member 'UDialogueManagerComponent::OnDialogueCameraInitialFadeInStart' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueCameraEndingFadeOutComplete) == 0x0004A8, "Member 'UDialogueManagerComponent::OnDialogueCameraEndingFadeOutComplete' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, MCDialogueCamera1) == 0x0004B8, "Member 'UDialogueManagerComponent::MCDialogueCamera1' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, MCDialogueCamera2) == 0x0004C0, "Member 'UDialogueManagerComponent::MCDialogueCamera2' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bMCDialogueCameraActive) == 0x0004C8, "Member 'UDialogueManagerComponent::bMCDialogueCameraActive' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bCamera1Active) == 0x0004C9, "Member 'UDialogueManagerComponent::bCamera1Active' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OriginalDialogueSourceCameraTransform) == 0x0004D0, "Member 'UDialogueManagerComponent::OriginalDialogueSourceCameraTransform' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, DialogueCameraActorClass) == 0x000530, "Member 'UDialogueManagerComponent::DialogueCameraActorClass' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, DialogueCameraTransitionInfo) == 0x000558, "Member 'UDialogueManagerComponent::DialogueCameraTransitionInfo' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, MidDialogueCameraTransitionInfo) == 0x000568, "Member 'UDialogueManagerComponent::MidDialogueCameraTransitionInfo' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, DefaultCameraHorizontalDistance) == 0x000578, "Member 'UDialogueManagerComponent::DefaultCameraHorizontalDistance' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, DefaultCameraDistanceFromCharacter) == 0x00057C, "Member 'UDialogueManagerComponent::DefaultCameraDistanceFromCharacter' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bShouldHideOtherVillagersDuringDialogue) == 0x000580, "Member 'UDialogueManagerComponent::bShouldHideOtherVillagersDuringDialogue' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bShouldHidePlayerDuringDialogue) == 0x000581, "Member 'UDialogueManagerComponent::bShouldHidePlayerDuringDialogue' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, DialogueFadeInDuration) == 0x000584, "Member 'UDialogueManagerComponent::DialogueFadeInDuration' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, DialogueFadeHoldDuration) == 0x000588, "Member 'UDialogueManagerComponent::DialogueFadeHoldDuration' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, DialogueFadeOutDuration) == 0x00058C, "Member 'UDialogueManagerComponent::DialogueFadeOutDuration' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, DialoguePreloadTimeoutDuration) == 0x000590, "Member 'UDialogueManagerComponent::DialoguePreloadTimeoutDuration' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bStopBehaviorAnimsDuringFadeIn) == 0x000594, "Member 'UDialogueManagerComponent::bStopBehaviorAnimsDuringFadeIn' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bRestartDialogueAnimsDuringFadeIn) == 0x000595, "Member 'UDialogueManagerComponent::bRestartDialogueAnimsDuringFadeIn' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bStallTextDuringCameraFade) == 0x000596, "Member 'UDialogueManagerComponent::bStallTextDuringCameraFade' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, RestartDialogueAnimsDuringFadeInTimingScalar) == 0x000598, "Member 'UDialogueManagerComponent::RestartDialogueAnimsDuringFadeInTimingScalar' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bAutomaticallyFindDialogueCamera) == 0x00059C, "Member 'UDialogueManagerComponent::bAutomaticallyFindDialogueCamera' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bAutomaticallySanitizeFocalDistance) == 0x00059D, "Member 'UDialogueManagerComponent::bAutomaticallySanitizeFocalDistance' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bCameraFadeInQueued) == 0x00059E, "Member 'UDialogueManagerComponent::bCameraFadeInQueued' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, bSkipNextCameraFade) == 0x00059F, "Member 'UDialogueManagerComponent::bSkipNextCameraFade' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, Client_CameraFadeHandle) == 0x0005A0, "Member 'UDialogueManagerComponent::Client_CameraFadeHandle' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, OnDialogueHistoryChanged) == 0x0005A8, "Member 'UDialogueManagerComponent::OnDialogueHistoryChanged' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, DayGroupingOverlapHours) == 0x0005B8, "Member 'UDialogueManagerComponent::DayGroupingOverlapHours' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, CurrentDialogueChain) == 0x0005C0, "Member 'UDialogueManagerComponent::CurrentDialogueChain' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, SpeakerDialogueHistories) == 0x0005D0, "Member 'UDialogueManagerComponent::SpeakerDialogueHistories' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, SpeakerDialogueHistory_QueuedToSend) == 0x000620, "Member 'UDialogueManagerComponent::SpeakerDialogueHistory_QueuedToSend' has a wrong offset!");
static_assert(offsetof(UDialogueManagerComponent, ProcessDialogueHistoryQueueHandle) == 0x000670, "Member 'UDialogueManagerComponent::ProcessDialogueHistoryQueueHandle' has a wrong offset!");

// Class Palia.DisplacerBeastComponent
// 0x0030 (0x00D0 - 0x00A0)
class UDisplacerBeastComponent final : public UActorComponent
{
public:
	TSubclassOf<class AActor>                     IllusionTemplate;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnedDecoy;                                      // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenActions;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecoySpawnRadius;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCombatTimeBeforeDespawnAttempt;                 // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2667[0x14];                                    // 0x00BC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeath(class UDeathComponent* Death);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplacerBeastComponent">();
	}
	static class UDisplacerBeastComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplacerBeastComponent>();
	}
};
static_assert(alignof(UDisplacerBeastComponent) == 0x000008, "Wrong alignment on UDisplacerBeastComponent");
static_assert(sizeof(UDisplacerBeastComponent) == 0x0000D0, "Wrong size on UDisplacerBeastComponent");
static_assert(offsetof(UDisplacerBeastComponent, IllusionTemplate) == 0x0000A0, "Member 'UDisplacerBeastComponent::IllusionTemplate' has a wrong offset!");
static_assert(offsetof(UDisplacerBeastComponent, SpawnedDecoy) == 0x0000A8, "Member 'UDisplacerBeastComponent::SpawnedDecoy' has a wrong offset!");
static_assert(offsetof(UDisplacerBeastComponent, TimeBetweenActions) == 0x0000B0, "Member 'UDisplacerBeastComponent::TimeBetweenActions' has a wrong offset!");
static_assert(offsetof(UDisplacerBeastComponent, DecoySpawnRadius) == 0x0000B4, "Member 'UDisplacerBeastComponent::DecoySpawnRadius' has a wrong offset!");
static_assert(offsetof(UDisplacerBeastComponent, MaxCombatTimeBeforeDespawnAttempt) == 0x0000B8, "Member 'UDisplacerBeastComponent::MaxCombatTimeBeforeDespawnAttempt' has a wrong offset!");

// Class Palia.DisplacerShadeComponent
// 0x0038 (0x00D8 - 0x00A0)
class UDisplacerShadeComponent final : public UActorComponent
{
public:
	class USphereComponent*                       CollisionComponent;                                // 0x00A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadeLifetime;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionPhysicsImpulsePower;                      // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitValidTargetClientSide;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2668[0x18];                                    // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void NotifyComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplacerShadeComponent">();
	}
	static class UDisplacerShadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplacerShadeComponent>();
	}
};
static_assert(alignof(UDisplacerShadeComponent) == 0x000008, "Wrong alignment on UDisplacerShadeComponent");
static_assert(sizeof(UDisplacerShadeComponent) == 0x0000D8, "Wrong size on UDisplacerShadeComponent");
static_assert(offsetof(UDisplacerShadeComponent, CollisionComponent) == 0x0000A0, "Member 'UDisplacerShadeComponent::CollisionComponent' has a wrong offset!");
static_assert(offsetof(UDisplacerShadeComponent, ShadeLifetime) == 0x0000A8, "Member 'UDisplacerShadeComponent::ShadeLifetime' has a wrong offset!");
static_assert(offsetof(UDisplacerShadeComponent, ExplosionPhysicsImpulsePower) == 0x0000AC, "Member 'UDisplacerShadeComponent::ExplosionPhysicsImpulsePower' has a wrong offset!");
static_assert(offsetof(UDisplacerShadeComponent, OnHitValidTargetClientSide) == 0x0000B0, "Member 'UDisplacerShadeComponent::OnHitValidTargetClientSide' has a wrong offset!");

// Class Palia.DummyObject
// 0x0008 (0x0030 - 0x0028)
class UDummyObject final : public UObject
{
public:
	class UDataTable*                             TableRef;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DummyObject">();
	}
	static class UDummyObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDummyObject>();
	}
};
static_assert(alignof(UDummyObject) == 0x000008, "Wrong alignment on UDummyObject");
static_assert(sizeof(UDummyObject) == 0x000030, "Wrong size on UDummyObject");
static_assert(offsetof(UDummyObject, TableRef) == 0x000028, "Member 'UDummyObject::TableRef' has a wrong offset!");

// Class Palia.ValeriaAnimInstance
// 0x0020 (0x0370 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) UValeriaAnimInstance : public UAnimInstance
{
public:
	float                                         IsMovingThreshold;                                 // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnedThreshold;                                   // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnedAroundThreshold;                             // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseYawOffset;                                     // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveSpeedCurve;                                    // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RootRotationCurve;                                 // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetDeltaYaw() const;
	float GetGroundSpeed() const;
	struct FVector2D GetGroundVelocity() const;
	float GetLinearMovementPlayRate(float Min, float Max) const;
	float GetOwnerYaw() const;
	float GetOwningMeshForwardAxisScale() const;
	class UAnimSequenceBase* GetRandomAnimSetSequence(struct FWeightedAnimSet& InAnimSet) const;
	struct FRotator GetRootRotation() const;
	bool IsMoving() const;
	bool IsTurnedAround() const;
	bool IsTurnedLeft() const;
	bool IsTurnedRight() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaAnimInstance">();
	}
	static class UValeriaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UValeriaAnimInstance) == 0x000010, "Wrong alignment on UValeriaAnimInstance");
static_assert(sizeof(UValeriaAnimInstance) == 0x000370, "Wrong size on UValeriaAnimInstance");
static_assert(offsetof(UValeriaAnimInstance, IsMovingThreshold) == 0x000348, "Member 'UValeriaAnimInstance::IsMovingThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaAnimInstance, TurnedThreshold) == 0x00034C, "Member 'UValeriaAnimInstance::TurnedThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaAnimInstance, TurnedAroundThreshold) == 0x000350, "Member 'UValeriaAnimInstance::TurnedAroundThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaAnimInstance, BaseYawOffset) == 0x000354, "Member 'UValeriaAnimInstance::BaseYawOffset' has a wrong offset!");
static_assert(offsetof(UValeriaAnimInstance, MoveSpeedCurve) == 0x000358, "Member 'UValeriaAnimInstance::MoveSpeedCurve' has a wrong offset!");
static_assert(offsetof(UValeriaAnimInstance, RootRotationCurve) == 0x000360, "Member 'UValeriaAnimInstance::RootRotationCurve' has a wrong offset!");

// Class Palia.ValeriaCreatureAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UValeriaCreatureAnimInstance final : public UValeriaAnimInstance
{
public:
	class ACreatureCharacter*                     CreatureOwner;                                     // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMeleeHitReact(class AActor* Instigator);
	void OnProjectileHitReact(class AActor* Instigator, class UVAL_ItemTypeDefinitionAsset* AmmoType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaCreatureAnimInstance">();
	}
	static class UValeriaCreatureAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaCreatureAnimInstance>();
	}
};
static_assert(alignof(UValeriaCreatureAnimInstance) == 0x000010, "Wrong alignment on UValeriaCreatureAnimInstance");
static_assert(sizeof(UValeriaCreatureAnimInstance) == 0x000370, "Wrong size on UValeriaCreatureAnimInstance");
static_assert(offsetof(UValeriaCreatureAnimInstance, CreatureOwner) == 0x000368, "Member 'UValeriaCreatureAnimInstance::CreatureOwner' has a wrong offset!");

// Class Palia.DynamicGiftPrefDataComponent
// 0x0038 (0x00D8 - 0x00A0)
class UDynamicGiftPrefDataComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDynamicGiftPreferencesChangedDel;                // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_266B[0x4];                                     // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeeklyEventConfig                     PreferenceResetTime;                               // 0x00B4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         PreferenceDataVersionNumber;                       // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_266C[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVillagerDynamicPreferenceData> CurrentPreferenceData;                             // 0x00C8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)

public:
	TArray<int32> GetPreferenceIdsForVillager(int32 VillagerCoreId);
	void OnRep_CurrentPreferenceData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicGiftPrefDataComponent">();
	}
	static class UDynamicGiftPrefDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicGiftPrefDataComponent>();
	}
};
static_assert(alignof(UDynamicGiftPrefDataComponent) == 0x000008, "Wrong alignment on UDynamicGiftPrefDataComponent");
static_assert(sizeof(UDynamicGiftPrefDataComponent) == 0x0000D8, "Wrong size on UDynamicGiftPrefDataComponent");
static_assert(offsetof(UDynamicGiftPrefDataComponent, OnDynamicGiftPreferencesChangedDel) == 0x0000A0, "Member 'UDynamicGiftPrefDataComponent::OnDynamicGiftPreferencesChangedDel' has a wrong offset!");
static_assert(offsetof(UDynamicGiftPrefDataComponent, PreferenceResetTime) == 0x0000B4, "Member 'UDynamicGiftPrefDataComponent::PreferenceResetTime' has a wrong offset!");
static_assert(offsetof(UDynamicGiftPrefDataComponent, PreferenceDataVersionNumber) == 0x0000C0, "Member 'UDynamicGiftPrefDataComponent::PreferenceDataVersionNumber' has a wrong offset!");
static_assert(offsetof(UDynamicGiftPrefDataComponent, CurrentPreferenceData) == 0x0000C8, "Member 'UDynamicGiftPrefDataComponent::CurrentPreferenceData' has a wrong offset!");

// Class Palia.EndlessRunnerArcadeMachine
// 0x0160 (0x0470 - 0x0310)
class AEndlessRunnerArcadeMachine final : public AArcadeMachineBase
{
public:
	struct FGuid                                  Server_CurrentReplayId;                            // 0x0310(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FArcadeReplicatedReplayFrameArray      Server_ReplicatedReplayFrames;                     // 0x0320(0x0128)(Net, Transient, NativeAccessSpecifierPrivate)
	struct FGuid                                  Client_CurrentReplayId;                            // 0x0448(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Client_CurrentFrameIndex;                          // 0x0458(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Client_ReplayInputsConsumed;                       // 0x045C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FArcadeInputState>              Client_CurrentReplayInputs;                        // 0x0460(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void AddReplayFrame(class AActor* FromActor, const struct FArcadeReplayFrame& InFrame);
	void BPIE_OnCurrentReplayInputsChanged();
	void Client_OnReplayInputReplicated();
	struct FArcadeInputState ConsumeReplayInput();
	int32 ConvertReplayGuidToSeed(const struct FGuid& Guid);
	struct FGuid GetCurrentReplayGuid();
	int32 GetNumberOfReplayInputsToConsume();

	bool ViewingOthersIsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndlessRunnerArcadeMachine">();
	}
	static class AEndlessRunnerArcadeMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndlessRunnerArcadeMachine>();
	}
};
static_assert(alignof(AEndlessRunnerArcadeMachine) == 0x000008, "Wrong alignment on AEndlessRunnerArcadeMachine");
static_assert(sizeof(AEndlessRunnerArcadeMachine) == 0x000470, "Wrong size on AEndlessRunnerArcadeMachine");
static_assert(offsetof(AEndlessRunnerArcadeMachine, Server_CurrentReplayId) == 0x000310, "Member 'AEndlessRunnerArcadeMachine::Server_CurrentReplayId' has a wrong offset!");
static_assert(offsetof(AEndlessRunnerArcadeMachine, Server_ReplicatedReplayFrames) == 0x000320, "Member 'AEndlessRunnerArcadeMachine::Server_ReplicatedReplayFrames' has a wrong offset!");
static_assert(offsetof(AEndlessRunnerArcadeMachine, Client_CurrentReplayId) == 0x000448, "Member 'AEndlessRunnerArcadeMachine::Client_CurrentReplayId' has a wrong offset!");
static_assert(offsetof(AEndlessRunnerArcadeMachine, Client_CurrentFrameIndex) == 0x000458, "Member 'AEndlessRunnerArcadeMachine::Client_CurrentFrameIndex' has a wrong offset!");
static_assert(offsetof(AEndlessRunnerArcadeMachine, Client_ReplayInputsConsumed) == 0x00045C, "Member 'AEndlessRunnerArcadeMachine::Client_ReplayInputsConsumed' has a wrong offset!");
static_assert(offsetof(AEndlessRunnerArcadeMachine, Client_CurrentReplayInputs) == 0x000460, "Member 'AEndlessRunnerArcadeMachine::Client_CurrentReplayInputs' has a wrong offset!");

// Class Palia.EnvEffectState
// 0x0038 (0x0060 - 0x0028)
class UEnvEffectState final : public UObject
{
public:
	ELightingModificationType                     LightModificationType;                             // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_266E[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   LightBaseState;                                    // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_266F[0x8];                                     // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnvEffectBegin();
	void EnvEffectEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvEffectState">();
	}
	static class UEnvEffectState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvEffectState>();
	}
};
static_assert(alignof(UEnvEffectState) == 0x000008, "Wrong alignment on UEnvEffectState");
static_assert(sizeof(UEnvEffectState) == 0x000060, "Wrong size on UEnvEffectState");
static_assert(offsetof(UEnvEffectState, LightModificationType) == 0x000028, "Member 'UEnvEffectState::LightModificationType' has a wrong offset!");
static_assert(offsetof(UEnvEffectState, LightBaseState) == 0x000030, "Member 'UEnvEffectState::LightBaseState' has a wrong offset!");

// Class Palia.EnvLightingOverrideVolume
// 0x00B8 (0x0360 - 0x02A8)
class AEnvLightingOverrideVolume final : public AActor
{
public:
	bool                                          bUseTimeBlend;                                     // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2670[0x3];                                     // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendTime;                                         // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightingModificationType                     OverrideType;                                      // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2671[0x7];                                     // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightingBaseState*                     OverrideState;                                     // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideStateStrength;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2672[0x4];                                     // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightingModState*                      ModificationState;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           EnvEffectClasses;                                  // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class AValEnvironmentManager>     EnvManagerClass;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          OuterBoundsBoxComp;                                // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InnerBoundsBoxComp;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentBlendPercentage;                            // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2673[0x4];                                     // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AValEnvironmentManager*                 EnvManager;                                        // 0x0308(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2674[0x50];                                    // 0x0310(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool RegisterOverrideState();
	bool UnregisterOverrideState();
	bool UpdateBlend();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvLightingOverrideVolume">();
	}
	static class AEnvLightingOverrideVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvLightingOverrideVolume>();
	}
};
static_assert(alignof(AEnvLightingOverrideVolume) == 0x000008, "Wrong alignment on AEnvLightingOverrideVolume");
static_assert(sizeof(AEnvLightingOverrideVolume) == 0x000360, "Wrong size on AEnvLightingOverrideVolume");
static_assert(offsetof(AEnvLightingOverrideVolume, bUseTimeBlend) == 0x0002A8, "Member 'AEnvLightingOverrideVolume::bUseTimeBlend' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, BlendTime) == 0x0002AC, "Member 'AEnvLightingOverrideVolume::BlendTime' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, OverrideType) == 0x0002B0, "Member 'AEnvLightingOverrideVolume::OverrideType' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, OverrideState) == 0x0002B8, "Member 'AEnvLightingOverrideVolume::OverrideState' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, OverrideStateStrength) == 0x0002C0, "Member 'AEnvLightingOverrideVolume::OverrideStateStrength' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, ModificationState) == 0x0002C8, "Member 'AEnvLightingOverrideVolume::ModificationState' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, EnvEffectClasses) == 0x0002D0, "Member 'AEnvLightingOverrideVolume::EnvEffectClasses' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, EnvManagerClass) == 0x0002E0, "Member 'AEnvLightingOverrideVolume::EnvManagerClass' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, Root) == 0x0002E8, "Member 'AEnvLightingOverrideVolume::Root' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, OuterBoundsBoxComp) == 0x0002F0, "Member 'AEnvLightingOverrideVolume::OuterBoundsBoxComp' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, InnerBoundsBoxComp) == 0x0002F8, "Member 'AEnvLightingOverrideVolume::InnerBoundsBoxComp' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, CurrentBlendPercentage) == 0x000300, "Member 'AEnvLightingOverrideVolume::CurrentBlendPercentage' has a wrong offset!");
static_assert(offsetof(AEnvLightingOverrideVolume, EnvManager) == 0x000308, "Member 'AEnvLightingOverrideVolume::EnvManager' has a wrong offset!");

// Class Palia.ValEnvironmentManager
// 0x0400 (0x06A8 - 0x02A8)
class AValEnvironmentManager : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnTimeOfDayChanged;                                // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DayNightChanged;                                   // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UPaliaTimeOfDaySequence>    TimeOfDaySequenceBlueprint;                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           EnvCollection;                                     // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VarHorizonHeight;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VarHorizonHardness;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VarZenithHeight;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VarZenithHardness;                                 // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VarHorizonColor;                                   // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VarZenithColor;                                    // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VarZenithColor2;                                   // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VarLowerHemisphereColor;                           // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VarWindIntensity;                                  // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPaliaTimeOfDaySequence*                TimeOfDaySequence;                                 // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      BlendTimes;                                        // 0x0328(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FPerPlatformFloat                      SunUpdateFrequency;                                // 0x0338(0x0004)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2675[0x4];                                     // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UValeriaTimeManager*                    TimeManager;                                       // 0x0340(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTime;                                       // 0x0348(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTimeIsFrozen;                                     // 0x034C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2676[0x193];                                   // 0x034D(0x0193)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVAL_StaticBoundaries                  StaticBoundaries;                                  // 0x04E0(0x0010)(NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnWindIntensityChange;                             // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UDirectionalLightComponent*             EnvDirectionalLight;                               // 0x0500(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkyLightComponent*                     EnvSkyLight;                                       // 0x0508(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UExponentialHeightFogComponent*         EnvHeightFog;                                      // 0x0510(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPostProcessComponent*                  EnvPostProcess;                                    // 0x0518(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_EnvironmentProfileSet*             DefaultProfileSet;                                 // 0x0520(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2677[0x8];                                     // 0x0528(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightingBaseState*                     BlendedLightingState;                              // 0x0530(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULightingBaseState*                     TODLightingState;                                  // 0x0538(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2678[0xB0];                                    // 0x0540(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	ETimeOfDayPeriod                              CurrentTimeOfDayState;                             // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsNightTime;                                      // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2679[0x6];                                     // 0x05F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVAL_EnvProfStackEntry>         EnvProfStack;                                      // 0x05F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class AVAL_EnvironmentBoundary*, class UVAL_EnvironmentProfileSet*> EnvProfSets;                                       // 0x0608(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class AVAL_EnvironmentBoundary*, class UVAL_EnvironmentProfile*> StaticEnvProfSets;                                 // 0x0658(0x0050)(NativeAccessSpecifierPrivate)

public:
	class ULightingBaseState* CreateNewLightingStateFromCurrentSettings(const class FString& AssetPath, const class FString& AssetName, class UDirectionalLightComponent* TempDirectionalLight);
	void FreezeLightingAtTime(float Time);
	struct FVAL_EnvProfStackEntry GetCurrentEnvProf();
	float GetDayPhaseAlpha();
	struct FVector GetSunForwardVector();
	bool IsDay();
	bool IsUsingEnvMgrV2();
	void NotifyDayNightChanged__DelegateSignature(bool bIsNight);
	void NotifyTimeOfDayChanged__DelegateSignature(ETimeOfDayPeriod Period);
	void OnDay();
	void OnEnterEnvBoundary(class AVAL_EnvironmentBoundary* EnvBoundary);
	void OnEvening();
	void OnExitEnvBoundary(class AVAL_EnvironmentBoundary* EnvBoundary);
	void OnMorning();
	void OnNight();
	void OnWindIntensityChange__DelegateSignature(float NewIntensity);
	bool RegisterLightingState(class FName OwnerName, class ULightingBaseState* ToAdd, float Percent, bool bIsCompleteOverride);
	void SetHeightFogOffset(float Offset);
	void UnfreezeLighting();
	bool UnregisterLightingState(class FName OwnerName);
	bool UpdateLightingStateInPool(class FName OwnerName, float NewBlendPercent);
	void UpdateLightingStateWithCurrentSettings(class ULightingBaseState* LightingState, class UDirectionalLightComponent* TempDirectionalLight);
	void UpdatePlanetRotation(class UArrowComponent* Arrow, const struct FVector& InitialForward, const struct FVector& Axis, float Time, float RiseTime, float SetTime);

	float GetCurrentTimeOfDayLerp() const;
	float GetEnvManagerTimeOfDay() const;
	bool GetIsNightTime() const;
	bool GetIsTimeFrozen() const;
	ETimeOfDayPeriod GetTimeOfDayPeriod() const;
	float GetWindIntensityAtPos(const struct FVector& Pos) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValEnvironmentManager">();
	}
	static class AValEnvironmentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValEnvironmentManager>();
	}
};
static_assert(alignof(AValEnvironmentManager) == 0x000008, "Wrong alignment on AValEnvironmentManager");
static_assert(sizeof(AValEnvironmentManager) == 0x0006A8, "Wrong size on AValEnvironmentManager");
static_assert(offsetof(AValEnvironmentManager, OnTimeOfDayChanged) == 0x0002A8, "Member 'AValEnvironmentManager::OnTimeOfDayChanged' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, DayNightChanged) == 0x0002B8, "Member 'AValEnvironmentManager::DayNightChanged' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, TimeOfDaySequenceBlueprint) == 0x0002C8, "Member 'AValEnvironmentManager::TimeOfDaySequenceBlueprint' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, EnvCollection) == 0x0002D0, "Member 'AValEnvironmentManager::EnvCollection' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, VarHorizonHeight) == 0x0002D8, "Member 'AValEnvironmentManager::VarHorizonHeight' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, VarHorizonHardness) == 0x0002E0, "Member 'AValEnvironmentManager::VarHorizonHardness' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, VarZenithHeight) == 0x0002E8, "Member 'AValEnvironmentManager::VarZenithHeight' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, VarZenithHardness) == 0x0002F0, "Member 'AValEnvironmentManager::VarZenithHardness' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, VarHorizonColor) == 0x0002F8, "Member 'AValEnvironmentManager::VarHorizonColor' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, VarZenithColor) == 0x000300, "Member 'AValEnvironmentManager::VarZenithColor' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, VarZenithColor2) == 0x000308, "Member 'AValEnvironmentManager::VarZenithColor2' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, VarLowerHemisphereColor) == 0x000310, "Member 'AValEnvironmentManager::VarLowerHemisphereColor' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, VarWindIntensity) == 0x000318, "Member 'AValEnvironmentManager::VarWindIntensity' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, TimeOfDaySequence) == 0x000320, "Member 'AValEnvironmentManager::TimeOfDaySequence' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, BlendTimes) == 0x000328, "Member 'AValEnvironmentManager::BlendTimes' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, SunUpdateFrequency) == 0x000338, "Member 'AValEnvironmentManager::SunUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, TimeManager) == 0x000340, "Member 'AValEnvironmentManager::TimeManager' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, CurrentTime) == 0x000348, "Member 'AValEnvironmentManager::CurrentTime' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, bTimeIsFrozen) == 0x00034C, "Member 'AValEnvironmentManager::bTimeIsFrozen' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, StaticBoundaries) == 0x0004E0, "Member 'AValEnvironmentManager::StaticBoundaries' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, OnWindIntensityChange) == 0x0004F0, "Member 'AValEnvironmentManager::OnWindIntensityChange' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, EnvDirectionalLight) == 0x000500, "Member 'AValEnvironmentManager::EnvDirectionalLight' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, EnvSkyLight) == 0x000508, "Member 'AValEnvironmentManager::EnvSkyLight' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, EnvHeightFog) == 0x000510, "Member 'AValEnvironmentManager::EnvHeightFog' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, EnvPostProcess) == 0x000518, "Member 'AValEnvironmentManager::EnvPostProcess' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, DefaultProfileSet) == 0x000520, "Member 'AValEnvironmentManager::DefaultProfileSet' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, BlendedLightingState) == 0x000530, "Member 'AValEnvironmentManager::BlendedLightingState' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, TODLightingState) == 0x000538, "Member 'AValEnvironmentManager::TODLightingState' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, CurrentTimeOfDayState) == 0x0005F0, "Member 'AValEnvironmentManager::CurrentTimeOfDayState' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, bIsNightTime) == 0x0005F1, "Member 'AValEnvironmentManager::bIsNightTime' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, EnvProfStack) == 0x0005F8, "Member 'AValEnvironmentManager::EnvProfStack' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, EnvProfSets) == 0x000608, "Member 'AValEnvironmentManager::EnvProfSets' has a wrong offset!");
static_assert(offsetof(AValEnvironmentManager, StaticEnvProfSets) == 0x000658, "Member 'AValEnvironmentManager::StaticEnvProfSets' has a wrong offset!");

// Class Palia.Env_CompVolume
// 0x0000 (0x02E0 - 0x02E0)
class AEnv_CompVolume final : public ATriggerVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Env_CompVolume">();
	}
	static class AEnv_CompVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnv_CompVolume>();
	}
};
static_assert(alignof(AEnv_CompVolume) == 0x000008, "Wrong alignment on AEnv_CompVolume");
static_assert(sizeof(AEnv_CompVolume) == 0x0002E0, "Wrong size on AEnv_CompVolume");

// Class Palia.Env_DistanceFadeVolume
// 0x0000 (0x02E0 - 0x02E0)
class AEnv_DistanceFadeVolume final : public AVolume
{
public:
	bool DoesEncompassPoint(const struct FVector& Point, float SphereRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Env_DistanceFadeVolume">();
	}
	static class AEnv_DistanceFadeVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnv_DistanceFadeVolume>();
	}
};
static_assert(alignof(AEnv_DistanceFadeVolume) == 0x000008, "Wrong alignment on AEnv_DistanceFadeVolume");
static_assert(sizeof(AEnv_DistanceFadeVolume) == 0x0002E0, "Wrong size on AEnv_DistanceFadeVolume");

// Class Palia.EquipmentComponent
// 0x01C0 (0x0260 - 0x00A0)
class UEquipmentComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnEquipmentChanged;                                // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReequipCurrentEquipped;                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectedEquipmentChanged;                        // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEquipmentUseAttempted;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCanChangeEquippedUpdated;                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEquipmentVisibilityChanged;                      // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPropsSpawned;                                    // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPropDestroyed;                                   // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FEquipmentItem                         EquippedTool;                                      // 0x0120(0x0050)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FEquipmentItem                         EquippedPrimary;                                   // 0x0170(0x0050)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FEquipmentItem                         SelectedEquipment;                                 // 0x01C0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2680[0x20];                                    // 0x0210(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPropInfo                              CurrentProps;                                      // 0x0230(0x0030)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void Client_ClearAnimationProps();
	void Client_HandleAbilityEnded(class UGameplayAbility* Ability);
	void Client_HandleAbilityStarted(class UGameplayAbility* Ability);
	void Client_HandleAnimInitialized();
	void Client_HandleCharacterStateChange(class UCharacterStateMachineComponent* CharacterStateMachine, const struct FCharacterStateChangeParams& StateChangeParams);
	void Client_HandleClimbingChanged(bool bIsClimbing);
	void Client_HandleEmoteEnded();
	void Client_HandleEmoteStarted(class UEmoteDataAsset* PlayingEmoteData);
	void Client_HandleGlidingChanged(bool bIsGliding);
	void Client_HandleInspirationSequenceChanged(class AValeriaCharacter* Character, bool bIsInInspirationSequence);
	void Client_HandleLongFallingChanged(bool bIsLongFalling);
	void Client_HandlePlacementModeChanged(class AValeriaCharacter* Character, bool bIsPlacementMode);
	void Client_HandleSeedPlantingStateChanged(bool bIsSeedPlantingActive);
	void Client_HandleWeedingEnded();
	void Client_HandleWeedingStarted();
	void Client_ShowAnimationProps(TMap<ECharacterAttachPoint, TSoftClassPtr<class UClass>>& Props, class FName& PropNotify, class FName& Qualifier, class FName& AttachNameExplicit);
	bool Client_TryEquipItemFromInventory(struct FBagSlotLocation& InventoryLocation);
	bool Client_TrySelectItemFromInventory(struct FBagSlotLocation& InventoryLocation, bool bAllowQuickUse);
	bool Client_TryUnequip();
	bool Client_TryUseEquipped(struct FUseEventParams& EventParams, bool bIsPrimaryAction);
	bool Client_TryUseTool(struct FUseEventParams& EventParams, bool bIsPrimaryAction);
	void Client_UnselectItem(bool bSendNotify);
	bool IsEquippedInUse();
	void K2_Server_EquipTemporaryItem(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& EquipItem, class AActor* Target);
	void OnRep_CurrentProps();
	void OnRep_EquippedPrimaryUpdated();
	void OnRep_EquippedToolUpdated();
	void PlayMontageOnEquippedActor(const struct FMontageInfo& MontageInfo, bool Multicast);
	void RpcClient_AcknowledgeEquipSucceeded();
	void RpcClient_ForceEquipItem(struct FEquipmentItem& EquipItem);
	void RpcClient_UpdateWaterLevel(int32 NewWaterLevel);
	void RpcNetMulticast_PlayMontageOnEquippedActor(const struct FMontageInfo& MontageInfo);
	void RpcServer_CHEAT_DecrementToolDurability(int32 Amount, class UGearSlotTypeConfig* GearSlot);
	void RpcServer_HiddenStateChange(bool bNewHidden);
	void RpcServer_UnequipCurrent(EEquipmentType UnequipType);
	void RpcServer_UpdateProps(struct FPropInfo& ShowProps);
	void RpcServer_ValidateEquippedItem(struct FEquipmentItem& EquipItem);
	void Server_DecrementToolDurability(int32 Amount);
	void Server_HandleInventoryChanged(class UInventoryComponent* Inventory);
	void Server_RepairToolDurability(int32 Amount);
	void Server_UnequipTemporaryItem();
	void Server_UpdateWaterLevel(int32 NewWaterLevel);

	struct FEquipmentItem GetEquippedItem() const;
	struct FValeriaItem GetValeriaItemFromEquipped() const;
	bool HasEquippedItem() const;
	bool HasSelectedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentComponent">();
	}
	static class UEquipmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentComponent>();
	}
};
static_assert(alignof(UEquipmentComponent) == 0x000008, "Wrong alignment on UEquipmentComponent");
static_assert(sizeof(UEquipmentComponent) == 0x000260, "Wrong size on UEquipmentComponent");
static_assert(offsetof(UEquipmentComponent, OnEquipmentChanged) == 0x0000A0, "Member 'UEquipmentComponent::OnEquipmentChanged' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, OnReequipCurrentEquipped) == 0x0000B0, "Member 'UEquipmentComponent::OnReequipCurrentEquipped' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, OnSelectedEquipmentChanged) == 0x0000C0, "Member 'UEquipmentComponent::OnSelectedEquipmentChanged' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, OnEquipmentUseAttempted) == 0x0000D0, "Member 'UEquipmentComponent::OnEquipmentUseAttempted' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, OnCanChangeEquippedUpdated) == 0x0000E0, "Member 'UEquipmentComponent::OnCanChangeEquippedUpdated' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, OnEquipmentVisibilityChanged) == 0x0000F0, "Member 'UEquipmentComponent::OnEquipmentVisibilityChanged' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, OnPropsSpawned) == 0x000100, "Member 'UEquipmentComponent::OnPropsSpawned' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, OnPropDestroyed) == 0x000110, "Member 'UEquipmentComponent::OnPropDestroyed' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, EquippedTool) == 0x000120, "Member 'UEquipmentComponent::EquippedTool' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, EquippedPrimary) == 0x000170, "Member 'UEquipmentComponent::EquippedPrimary' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, SelectedEquipment) == 0x0001C0, "Member 'UEquipmentComponent::SelectedEquipment' has a wrong offset!");
static_assert(offsetof(UEquipmentComponent, CurrentProps) == 0x000230, "Member 'UEquipmentComponent::CurrentProps' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItem_Makeup
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_Makeup final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_Makeup(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_Makeup_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_Makeup">();
	}
	static class UVAL_CharacterCustomizationItem_Makeup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_Makeup>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_Makeup) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_Makeup");
static_assert(sizeof(UVAL_CharacterCustomizationItem_Makeup) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_Makeup");

// Class Palia.ValeriaExecCmds
// 0x0010 (0x0038 - 0x0028)
class UValeriaExecCmds final : public UObject
{
public:
	TArray<class FString>                         Commands;                                          // 0x0028(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)

public:
	static class UValeriaExecCmds* GetExecCmds();

	void Execute(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaExecCmds">();
	}
	static class UValeriaExecCmds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaExecCmds>();
	}
};
static_assert(alignof(UValeriaExecCmds) == 0x000008, "Wrong alignment on UValeriaExecCmds");
static_assert(sizeof(UValeriaExecCmds) == 0x000038, "Wrong size on UValeriaExecCmds");
static_assert(offsetof(UValeriaExecCmds, Commands) == 0x000028, "Member 'UValeriaExecCmds::Commands' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItem_HairStyle
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_HairStyle final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_HairStyle(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_HairStyle_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_HairStyle">();
	}
	static class UVAL_CharacterCustomizationItem_HairStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_HairStyle>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_HairStyle) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_HairStyle");
static_assert(sizeof(UVAL_CharacterCustomizationItem_HairStyle) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_HairStyle");

// Class Palia.VAL_ExpPkgSelectionSettings
// 0x0010 (0x0048 - 0x0038)
class UVAL_ExpPkgSelectionSettings final : public UDeveloperSettings
{
public:
	class FString                                 SelectedExperiencePackage;                         // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ExpPkgSelectionSettings">();
	}
	static class UVAL_ExpPkgSelectionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ExpPkgSelectionSettings>();
	}
};
static_assert(alignof(UVAL_ExpPkgSelectionSettings) == 0x000008, "Wrong alignment on UVAL_ExpPkgSelectionSettings");
static_assert(sizeof(UVAL_ExpPkgSelectionSettings) == 0x000048, "Wrong size on UVAL_ExpPkgSelectionSettings");
static_assert(offsetof(UVAL_ExpPkgSelectionSettings, SelectedExperiencePackage) == 0x000038, "Member 'UVAL_ExpPkgSelectionSettings::SelectedExperiencePackage' has a wrong offset!");

// Class Palia.FenceComponent
// 0x0050 (0x05C0 - 0x0570)
class UFenceComponent final : public UPrimitiveComponent
{
public:
	struct FFenceConfig                           FenceConfig;                                       // 0x0570(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFenceState                            FenceState;                                        // 0x0590(0x0018)(Edit, Net, DisableEditOnInstance, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UFenceMeshComponent*                    StartPostMeshComp;                                 // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFenceMeshComponent*                    EndPostMeshComp;                                   // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFenceMeshComponent*                    SpanMeshComp;                                      // 0x05B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_FenceState();
	int32 TrySetFenceLength(int32 DesiredFenceLength, bool bHasStartPost, bool bHasEndPost);

	class UFenceMeshComponent* GetEndPostMeshComponent() const;
	int32 GetFenceLength() const;
	int32 GetMaxFenceLength(bool bWithEndPost) const;
	int32 GetMinFenceLength(bool bWithEndPost) const;
	class UFenceMeshComponent* GetSpanMeshComponent() const;
	class UFenceMeshComponent* GetStartPostMeshComponent() const;
	bool HasEndPost() const;
	bool HasStartPost() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FenceComponent">();
	}
	static class UFenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFenceComponent>();
	}
};
static_assert(alignof(UFenceComponent) == 0x000010, "Wrong alignment on UFenceComponent");
static_assert(sizeof(UFenceComponent) == 0x0005C0, "Wrong size on UFenceComponent");
static_assert(offsetof(UFenceComponent, FenceConfig) == 0x000570, "Member 'UFenceComponent::FenceConfig' has a wrong offset!");
static_assert(offsetof(UFenceComponent, FenceState) == 0x000590, "Member 'UFenceComponent::FenceState' has a wrong offset!");
static_assert(offsetof(UFenceComponent, StartPostMeshComp) == 0x0005A8, "Member 'UFenceComponent::StartPostMeshComp' has a wrong offset!");
static_assert(offsetof(UFenceComponent, EndPostMeshComp) == 0x0005B0, "Member 'UFenceComponent::EndPostMeshComp' has a wrong offset!");
static_assert(offsetof(UFenceComponent, SpanMeshComp) == 0x0005B8, "Member 'UFenceComponent::SpanMeshComp' has a wrong offset!");

// Class Palia.FenceMeshComponent
// 0x0010 (0x0640 - 0x0630)
class UFenceMeshComponent final : public UStaticMeshComponent
{
public:
	EFenceMeshType                                Type;                                              // 0x0630(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2690[0xF];                                     // 0x0631(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FenceMeshComponent">();
	}
	static class UFenceMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFenceMeshComponent>();
	}
};
static_assert(alignof(UFenceMeshComponent) == 0x000010, "Wrong alignment on UFenceMeshComponent");
static_assert(sizeof(UFenceMeshComponent) == 0x000640, "Wrong size on UFenceMeshComponent");
static_assert(offsetof(UFenceMeshComponent, Type) == 0x000630, "Member 'UFenceMeshComponent::Type' has a wrong offset!");

// Class Palia.FishMinigameBehaviorConfig
// 0x0018 (0x0048 - 0x0030)
class UFishMinigameBehaviorConfig final : public UDataAsset
{
public:
	TArray<struct FFishMinigameBehaviorChoice>    ActionsConfigPool;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bRandomlyFlipActionLocationSign;                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2691[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishMinigameBehaviorConfig">();
	}
	static class UFishMinigameBehaviorConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishMinigameBehaviorConfig>();
	}
};
static_assert(alignof(UFishMinigameBehaviorConfig) == 0x000008, "Wrong alignment on UFishMinigameBehaviorConfig");
static_assert(sizeof(UFishMinigameBehaviorConfig) == 0x000048, "Wrong size on UFishMinigameBehaviorConfig");
static_assert(offsetof(UFishMinigameBehaviorConfig, ActionsConfigPool) == 0x000030, "Member 'UFishMinigameBehaviorConfig::ActionsConfigPool' has a wrong offset!");
static_assert(offsetof(UFishMinigameBehaviorConfig, bRandomlyFlipActionLocationSign) == 0x000040, "Member 'UFishMinigameBehaviorConfig::bRandomlyFlipActionLocationSign' has a wrong offset!");

// Class Palia.FishMinigameSpawnPoolConfig
// 0x0038 (0x0068 - 0x0030)
class UFishMinigameSpawnPoolConfig final : public UDataAsset
{
public:
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> RequiredBait;                                      // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFishMinigameSpawnConfig>       SpawnPool;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishMinigameSpawnPoolConfig">();
	}
	static class UFishMinigameSpawnPoolConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishMinigameSpawnPoolConfig>();
	}
};
static_assert(alignof(UFishMinigameSpawnPoolConfig) == 0x000008, "Wrong alignment on UFishMinigameSpawnPoolConfig");
static_assert(sizeof(UFishMinigameSpawnPoolConfig) == 0x000068, "Wrong size on UFishMinigameSpawnPoolConfig");
static_assert(offsetof(UFishMinigameSpawnPoolConfig, RequiredBait) == 0x000030, "Member 'UFishMinigameSpawnPoolConfig::RequiredBait' has a wrong offset!");
static_assert(offsetof(UFishMinigameSpawnPoolConfig, SpawnPool) == 0x000058, "Member 'UFishMinigameSpawnPoolConfig::SpawnPool' has a wrong offset!");

// Class Palia.FishingCastIndicatorActor
// 0x0000 (0x02A8 - 0x02A8)
class AFishingCastIndicatorActor : public AActor
{
public:
	void OnCastIndicatorChanged(const struct FVector& Endpoint, EFishingCastIndicatorStatus Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishingCastIndicatorActor">();
	}
	static class AFishingCastIndicatorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFishingCastIndicatorActor>();
	}
};
static_assert(alignof(AFishingCastIndicatorActor) == 0x000008, "Wrong alignment on AFishingCastIndicatorActor");
static_assert(sizeof(AFishingCastIndicatorActor) == 0x0002A8, "Wrong size on AFishingCastIndicatorActor");

// Class Palia.FishingGlobalConfig
// 0x0340 (0x0370 - 0x0030)
class UFishingGlobalConfig final : public UDataAsset
{
public:
	struct FFishingSubclasses                     Subclasses;                                        // 0x0030(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UVAL_ItemTypeDefinitionAsset*           NoBaitSelectedItemType;                            // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurabilityLossStart;                               // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurabilityLossMidway;                              // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurabilityLossEnd;                                 // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2693[0x4];                                     // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              NoFishWaitTimeMinMax;                              // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFishingCameraSettings                 CameraSettings;                                    // 0x00A0(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFishingCastingSettings                CastSettings;                                      // 0x00D8(0x0050)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFishingGoalSettings                   GoalSettings;                                      // 0x0128(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFishingInputSettings                  Input;                                             // 0x0158(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFishingNotifications                  Notifications;                                     // 0x0198(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFishingSoundSettings                  SoundSettings;                                     // 0x0228(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FishingWorldScale;                                 // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishDepth;                                         // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishOffset;                                        // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewStateUpdatesPerSecond;                         // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RodOffset;                                         // 0x0240(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnBeginReelingInitialCooldown;                     // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelegraphMaxDistance;                              // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelegraphMaxSpeed;                                 // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTelegraphs;                                     // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTelegraphs;                                     // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelegraphMinPctg;                                  // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelegraphMaxPctg;                                  // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTelegraphCooldown;                              // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTelegraphCooldown;                              // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelegraphLerpExp;                                  // 0x027C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CelebrationSequenceSocketName;                     // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoofTimeFromWaterToHandOnCelebration;              // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalCelebrationDuration;                          // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CelebrationOnFirstCatchOnlyOverride;               // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2694[0x3];                                     // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FishingFinishReelInSpeed;                          // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterFinishDestroyBobberWhenAtDistanceToRod;       // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2695[0x4];                                     // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFishingEncouragementSettings          Encouragement;                                     // 0x02A0(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFishingSpawnSettings                  SpawnSettings;                                     // 0x02C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFishingNibbleSettings                 NibbleSettings;                                    // 0x0310(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FEndFishingSettings                    EndSettings;                                       // 0x0320(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFishingXpSettings                     XpSettings;                                        // 0x0330(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2696[0x4];                                     // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFishingCoopBuffSettings               CoopBuffSettings;                                  // 0x0340(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   GenericFishingErrorText;                           // 0x0358(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishingGlobalConfig">();
	}
	static class UFishingGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishingGlobalConfig>();
	}
};
static_assert(alignof(UFishingGlobalConfig) == 0x000008, "Wrong alignment on UFishingGlobalConfig");
static_assert(sizeof(UFishingGlobalConfig) == 0x000370, "Wrong size on UFishingGlobalConfig");
static_assert(offsetof(UFishingGlobalConfig, Subclasses) == 0x000030, "Member 'UFishingGlobalConfig::Subclasses' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, NoBaitSelectedItemType) == 0x000078, "Member 'UFishingGlobalConfig::NoBaitSelectedItemType' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, DurabilityLossStart) == 0x000080, "Member 'UFishingGlobalConfig::DurabilityLossStart' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, DurabilityLossMidway) == 0x000084, "Member 'UFishingGlobalConfig::DurabilityLossMidway' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, DurabilityLossEnd) == 0x000088, "Member 'UFishingGlobalConfig::DurabilityLossEnd' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, NoFishWaitTimeMinMax) == 0x000090, "Member 'UFishingGlobalConfig::NoFishWaitTimeMinMax' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, CameraSettings) == 0x0000A0, "Member 'UFishingGlobalConfig::CameraSettings' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, CastSettings) == 0x0000D8, "Member 'UFishingGlobalConfig::CastSettings' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, GoalSettings) == 0x000128, "Member 'UFishingGlobalConfig::GoalSettings' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, Input) == 0x000158, "Member 'UFishingGlobalConfig::Input' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, Notifications) == 0x000198, "Member 'UFishingGlobalConfig::Notifications' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, SoundSettings) == 0x000228, "Member 'UFishingGlobalConfig::SoundSettings' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, FishingWorldScale) == 0x000230, "Member 'UFishingGlobalConfig::FishingWorldScale' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, FishDepth) == 0x000234, "Member 'UFishingGlobalConfig::FishDepth' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, FishOffset) == 0x000238, "Member 'UFishingGlobalConfig::FishOffset' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, ViewStateUpdatesPerSecond) == 0x00023C, "Member 'UFishingGlobalConfig::ViewStateUpdatesPerSecond' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, RodOffset) == 0x000240, "Member 'UFishingGlobalConfig::RodOffset' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, OnBeginReelingInitialCooldown) == 0x000258, "Member 'UFishingGlobalConfig::OnBeginReelingInitialCooldown' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, TelegraphMaxDistance) == 0x00025C, "Member 'UFishingGlobalConfig::TelegraphMaxDistance' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, TelegraphMaxSpeed) == 0x000260, "Member 'UFishingGlobalConfig::TelegraphMaxSpeed' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, MinTelegraphs) == 0x000264, "Member 'UFishingGlobalConfig::MinTelegraphs' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, MaxTelegraphs) == 0x000268, "Member 'UFishingGlobalConfig::MaxTelegraphs' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, TelegraphMinPctg) == 0x00026C, "Member 'UFishingGlobalConfig::TelegraphMinPctg' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, TelegraphMaxPctg) == 0x000270, "Member 'UFishingGlobalConfig::TelegraphMaxPctg' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, MinTelegraphCooldown) == 0x000274, "Member 'UFishingGlobalConfig::MinTelegraphCooldown' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, MaxTelegraphCooldown) == 0x000278, "Member 'UFishingGlobalConfig::MaxTelegraphCooldown' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, TelegraphLerpExp) == 0x00027C, "Member 'UFishingGlobalConfig::TelegraphLerpExp' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, CelebrationSequenceSocketName) == 0x000280, "Member 'UFishingGlobalConfig::CelebrationSequenceSocketName' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, PoofTimeFromWaterToHandOnCelebration) == 0x000288, "Member 'UFishingGlobalConfig::PoofTimeFromWaterToHandOnCelebration' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, TotalCelebrationDuration) == 0x00028C, "Member 'UFishingGlobalConfig::TotalCelebrationDuration' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, CelebrationOnFirstCatchOnlyOverride) == 0x000290, "Member 'UFishingGlobalConfig::CelebrationOnFirstCatchOnlyOverride' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, FishingFinishReelInSpeed) == 0x000294, "Member 'UFishingGlobalConfig::FishingFinishReelInSpeed' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, AfterFinishDestroyBobberWhenAtDistanceToRod) == 0x000298, "Member 'UFishingGlobalConfig::AfterFinishDestroyBobberWhenAtDistanceToRod' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, Encouragement) == 0x0002A0, "Member 'UFishingGlobalConfig::Encouragement' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, SpawnSettings) == 0x0002C0, "Member 'UFishingGlobalConfig::SpawnSettings' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, NibbleSettings) == 0x000310, "Member 'UFishingGlobalConfig::NibbleSettings' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, EndSettings) == 0x000320, "Member 'UFishingGlobalConfig::EndSettings' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, XpSettings) == 0x000330, "Member 'UFishingGlobalConfig::XpSettings' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, CoopBuffSettings) == 0x000340, "Member 'UFishingGlobalConfig::CoopBuffSettings' has a wrong offset!");
static_assert(offsetof(UFishingGlobalConfig, GenericFishingErrorText) == 0x000358, "Member 'UFishingGlobalConfig::GenericFishingErrorText' has a wrong offset!");

// Class Palia.FishingLineComponent
// 0x00B0 (0x0660 - 0x05B0)
class UFishingLineComponent final : public UMeshComponent
{
public:
	bool                                          bAttachStart;                                      // 0x05A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachEnd;                                        // 0x05A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2697[0x6];                                     // 0x05AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    AttachEndTo;                                       // 0x05B0(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   AttachEndToSocketName;                             // 0x05D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x05E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFishingLineLengthToSnap;                        // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TensionFactor;                                     // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSegments;                                       // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubstepTime;                                       // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SolverIterations;                                  // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStiffness;                                  // 0x060C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSubstepping;                                   // 0x060D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipFishingLineUpdateWhenNotVisible;              // 0x060E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipFishingLineUpdateWhenNotOwnerRecentlyRendered; // 0x060F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollision;                                  // 0x0610(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2698[0x3];                                     // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionFriction;                                 // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FishingLineForce;                                  // 0x0618(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishingLineGravityScale;                           // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishingLineWidth;                                  // 0x0634(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0638(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileMaterial;                                      // 0x063C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2699[0x18];                                    // 0x0640(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FishingLineLength;                                 // 0x0658(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269A[0x4];                                     // 0x065C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetSimulation();
	void SetAttachEndTo(class AActor* Actor, class FName ComponentProperty, class FName SocketName);
	void SetAttachEndToComponent(class USceneComponent* Component, class FName SocketName);

	class AActor* GetAttachedActor() const;
	class USceneComponent* GetAttachedComponent() const;
	void GetFishingLineParticleLocations(TArray<struct FVector>* Locations) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishingLineComponent">();
	}
	static class UFishingLineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishingLineComponent>();
	}
};
static_assert(alignof(UFishingLineComponent) == 0x000010, "Wrong alignment on UFishingLineComponent");
static_assert(sizeof(UFishingLineComponent) == 0x000660, "Wrong size on UFishingLineComponent");
static_assert(offsetof(UFishingLineComponent, bAttachStart) == 0x0005A8, "Member 'UFishingLineComponent::bAttachStart' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, bAttachEnd) == 0x0005A9, "Member 'UFishingLineComponent::bAttachEnd' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, AttachEndTo) == 0x0005B0, "Member 'UFishingLineComponent::AttachEndTo' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, AttachEndToSocketName) == 0x0005D8, "Member 'UFishingLineComponent::AttachEndToSocketName' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, EndLocation) == 0x0005E0, "Member 'UFishingLineComponent::EndLocation' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, MinFishingLineLengthToSnap) == 0x0005F8, "Member 'UFishingLineComponent::MinFishingLineLengthToSnap' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, TensionFactor) == 0x0005FC, "Member 'UFishingLineComponent::TensionFactor' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, NumSegments) == 0x000600, "Member 'UFishingLineComponent::NumSegments' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, SubstepTime) == 0x000604, "Member 'UFishingLineComponent::SubstepTime' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, SolverIterations) == 0x000608, "Member 'UFishingLineComponent::SolverIterations' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, bEnableStiffness) == 0x00060C, "Member 'UFishingLineComponent::bEnableStiffness' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, bUseSubstepping) == 0x00060D, "Member 'UFishingLineComponent::bUseSubstepping' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, bSkipFishingLineUpdateWhenNotVisible) == 0x00060E, "Member 'UFishingLineComponent::bSkipFishingLineUpdateWhenNotVisible' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, bSkipFishingLineUpdateWhenNotOwnerRecentlyRendered) == 0x00060F, "Member 'UFishingLineComponent::bSkipFishingLineUpdateWhenNotOwnerRecentlyRendered' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, bEnableCollision) == 0x000610, "Member 'UFishingLineComponent::bEnableCollision' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, CollisionFriction) == 0x000614, "Member 'UFishingLineComponent::CollisionFriction' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, FishingLineForce) == 0x000618, "Member 'UFishingLineComponent::FishingLineForce' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, FishingLineGravityScale) == 0x000630, "Member 'UFishingLineComponent::FishingLineGravityScale' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, FishingLineWidth) == 0x000634, "Member 'UFishingLineComponent::FishingLineWidth' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, NumSides) == 0x000638, "Member 'UFishingLineComponent::NumSides' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, TileMaterial) == 0x00063C, "Member 'UFishingLineComponent::TileMaterial' has a wrong offset!");
static_assert(offsetof(UFishingLineComponent, FishingLineLength) == 0x000658, "Member 'UFishingLineComponent::FishingLineLength' has a wrong offset!");

// Class Palia.FishingViewComponent
// 0x0260 (0x0300 - 0x00A0)
class alignas(0x10) UFishingViewComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnFishingBobberWasCreated;                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFishIsBitingChanged;                             // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFishJumped;                                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNibbled;                                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnViewWasUpdated;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 Bobber;                                            // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 Rod;                                               // 0x00F8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 Fish;                                              // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFishingCastIndicatorActor*             CastIndicator;                                     // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFishViewComponent*                     FishView;                                          // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269B[0x68];                                    // 0x0118(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFishingNibbleActorData>        NibbleFish;                                        // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269C[0x18];                                    // 0x0190(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CelebrationFishHandSocketName;                     // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269D[0x148];                                   // 0x01B0(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	class US6Core_AssetLoader*                    FishingViewAssetLoader;                            // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBobberHitSomething(EFishingBobberHitSomethingResult Result, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& ImpactPoint, class UPhysicalMaterial* PhysMat);
	void OnCastingBobbleBeforeDestroyed(class AActor* bobble);
	void OnCastingBobbleWasCreated(class AActor* bobble);
	void OnFishingBobbleBeforeDestroyed(class AActor* bobble);
	void OnMiniGameStateChanged(EFishingMiniGameState PreviousState, EFishingMiniGameState NewState, class UFishingComponent* Source);
	void OnRodBeforeDestroyedEvent(class AActor* Param_Rod);
	void OnViewWasUpdatedEvent(const struct FFishingMiniGameViewState& ViewState, class UFishingComponent* Source);
	void RpcNetMulticast_BobberHitSomething(EFishingBobberHitSomethingResult Result, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& ImpactPoint, class UPhysicalMaterial* PhysMat);
	void RpcServer_BobberHitSomething(EFishingBobberHitSomethingResult Result, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& ImpactPoint, class UPhysicalMaterial* PhysMat);

	class AActor* GetActorBobber() const;
	class AActor* GetActorFish() const;
	class AActor* GetActorRod() const;
	struct FVector GetLineLocationBobber() const;
	struct FVector GetLineLocationRod() const;
	struct FVector GetSafeZoneCenter() const;
	struct FVector GetSafeZoneCenterAtOffset(struct FVector& Offset) const;
	float GetSafeZoneLength() const;
	struct FFishingMiniGameViewState GetViewState() const;
	bool IsInSafeZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishingViewComponent">();
	}
	static class UFishingViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFishingViewComponent>();
	}
};
static_assert(alignof(UFishingViewComponent) == 0x000010, "Wrong alignment on UFishingViewComponent");
static_assert(sizeof(UFishingViewComponent) == 0x000300, "Wrong size on UFishingViewComponent");
static_assert(offsetof(UFishingViewComponent, OnFishingBobberWasCreated) == 0x0000A0, "Member 'UFishingViewComponent::OnFishingBobberWasCreated' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, OnFishIsBitingChanged) == 0x0000B0, "Member 'UFishingViewComponent::OnFishIsBitingChanged' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, OnFishJumped) == 0x0000C0, "Member 'UFishingViewComponent::OnFishJumped' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, OnNibbled) == 0x0000D0, "Member 'UFishingViewComponent::OnNibbled' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, OnViewWasUpdated) == 0x0000E0, "Member 'UFishingViewComponent::OnViewWasUpdated' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, Bobber) == 0x0000F0, "Member 'UFishingViewComponent::Bobber' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, Rod) == 0x0000F8, "Member 'UFishingViewComponent::Rod' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, Fish) == 0x000100, "Member 'UFishingViewComponent::Fish' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, CastIndicator) == 0x000108, "Member 'UFishingViewComponent::CastIndicator' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, FishView) == 0x000110, "Member 'UFishingViewComponent::FishView' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, NibbleFish) == 0x000180, "Member 'UFishingViewComponent::NibbleFish' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, CelebrationFishHandSocketName) == 0x0001A8, "Member 'UFishingViewComponent::CelebrationFishHandSocketName' has a wrong offset!");
static_assert(offsetof(UFishingViewComponent, FishingViewAssetLoader) == 0x0002F8, "Member 'UFishingViewComponent::FishingViewAssetLoader' has a wrong offset!");

// Class Palia.FoliageRustleAudioComponent
// 0x0080 (0x0120 - 0x00A0)
class UFoliageRustleAudioComponent : public UActorComponent
{
public:
	class UAudioFoliageRustleDataAsset*           FoliageRustleData;                                 // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RustleOverlapTag;                                  // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StopTransitionDurationMs;                          // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkCurveInterpolation                         StopFadeCurve;                                     // 0x00B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A3[0x3];                                     // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRtpc*                                IsLocalMixRTPC;                                    // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                ActorSpeedRTPC;                                    // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActorSpeedRTPCInterpolationMs;                     // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A4[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UAkAudioEvent*, struct FFoliageRustleState> ActiveRustles;                                     // 0x00D0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddActiveRustle(class UPrimitiveComponent* ComponentToAdd);
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void RemoveActiveRustle(class UPrimitiveComponent* ComponentToRemove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageRustleAudioComponent">();
	}
	static class UFoliageRustleAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageRustleAudioComponent>();
	}
};
static_assert(alignof(UFoliageRustleAudioComponent) == 0x000008, "Wrong alignment on UFoliageRustleAudioComponent");
static_assert(sizeof(UFoliageRustleAudioComponent) == 0x000120, "Wrong size on UFoliageRustleAudioComponent");
static_assert(offsetof(UFoliageRustleAudioComponent, FoliageRustleData) == 0x0000A0, "Member 'UFoliageRustleAudioComponent::FoliageRustleData' has a wrong offset!");
static_assert(offsetof(UFoliageRustleAudioComponent, RustleOverlapTag) == 0x0000A8, "Member 'UFoliageRustleAudioComponent::RustleOverlapTag' has a wrong offset!");
static_assert(offsetof(UFoliageRustleAudioComponent, StopTransitionDurationMs) == 0x0000B0, "Member 'UFoliageRustleAudioComponent::StopTransitionDurationMs' has a wrong offset!");
static_assert(offsetof(UFoliageRustleAudioComponent, StopFadeCurve) == 0x0000B4, "Member 'UFoliageRustleAudioComponent::StopFadeCurve' has a wrong offset!");
static_assert(offsetof(UFoliageRustleAudioComponent, IsLocalMixRTPC) == 0x0000B8, "Member 'UFoliageRustleAudioComponent::IsLocalMixRTPC' has a wrong offset!");
static_assert(offsetof(UFoliageRustleAudioComponent, ActorSpeedRTPC) == 0x0000C0, "Member 'UFoliageRustleAudioComponent::ActorSpeedRTPC' has a wrong offset!");
static_assert(offsetof(UFoliageRustleAudioComponent, ActorSpeedRTPCInterpolationMs) == 0x0000C8, "Member 'UFoliageRustleAudioComponent::ActorSpeedRTPCInterpolationMs' has a wrong offset!");
static_assert(offsetof(UFoliageRustleAudioComponent, ActiveRustles) == 0x0000D0, "Member 'UFoliageRustleAudioComponent::ActiveRustles' has a wrong offset!");

// Class Palia.FollowCameraManagerComponent
// 0x01E0 (0x0280 - 0x00A0)
class UFollowCameraManagerComponent final : public UActorComponent
{
public:
	class UDataTable*                             Settings;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    CameraBoom;                                        // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FollowCamera;                                      // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterStateMachineComponent*        CharacterStateMachine;                             // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFollowCameraSettings                  PreviousSetting;                                   // 0x00C0(0x00B0)(NativeAccessSpecifierPrivate)
	struct FFollowCameraSettings                  CurrentSetting;                                    // 0x0170(0x00B0)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_26A7[0x60];                                    // 0x0220(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSetting(class FName SettingsName, class UObject* Instigator);
	void ApplyGraphicSettings(struct FValeriaGraphicSettings& GraphicSettings);
	void DeactivateSetting(class FName SettingsName, class UObject* Instigator, bool Force);
	void PlayDollyZoom();

	bool IsSettingActive(class FName& SettingsName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FollowCameraManagerComponent">();
	}
	static class UFollowCameraManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFollowCameraManagerComponent>();
	}
};
static_assert(alignof(UFollowCameraManagerComponent) == 0x000008, "Wrong alignment on UFollowCameraManagerComponent");
static_assert(sizeof(UFollowCameraManagerComponent) == 0x000280, "Wrong size on UFollowCameraManagerComponent");
static_assert(offsetof(UFollowCameraManagerComponent, Settings) == 0x0000A0, "Member 'UFollowCameraManagerComponent::Settings' has a wrong offset!");
static_assert(offsetof(UFollowCameraManagerComponent, CameraBoom) == 0x0000A8, "Member 'UFollowCameraManagerComponent::CameraBoom' has a wrong offset!");
static_assert(offsetof(UFollowCameraManagerComponent, FollowCamera) == 0x0000B0, "Member 'UFollowCameraManagerComponent::FollowCamera' has a wrong offset!");
static_assert(offsetof(UFollowCameraManagerComponent, CharacterStateMachine) == 0x0000B8, "Member 'UFollowCameraManagerComponent::CharacterStateMachine' has a wrong offset!");
static_assert(offsetof(UFollowCameraManagerComponent, PreviousSetting) == 0x0000C0, "Member 'UFollowCameraManagerComponent::PreviousSetting' has a wrong offset!");
static_assert(offsetof(UFollowCameraManagerComponent, CurrentSetting) == 0x000170, "Member 'UFollowCameraManagerComponent::CurrentSetting' has a wrong offset!");

// Class Palia.GameplayBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameplayBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool EqualEqual_ObjectObject(struct FDebugServerActorMapping& A, struct FDebugServerActorMapping& B);
	static bool IsSteamEnabled();
	static bool NotEqual_ObjectObject(struct FDebugServerActorMapping& A, struct FDebugServerActorMapping& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayBlueprintLibrary">();
	}
	static class UGameplayBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayBlueprintLibrary>();
	}
};
static_assert(alignof(UGameplayBlueprintLibrary) == 0x000008, "Wrong alignment on UGameplayBlueprintLibrary");
static_assert(sizeof(UGameplayBlueprintLibrary) == 0x000028, "Wrong size on UGameplayBlueprintLibrary");

// Class Palia.VAL_CompositeCondition
// 0x0010 (0x0040 - 0x0030)
class UVAL_CompositeCondition : public UVAL_GameplayConditionDef
{
public:
	TArray<class UVAL_GameplayConditionDef*>      SubConditions;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CompositeCondition">();
	}
	static class UVAL_CompositeCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CompositeCondition>();
	}
};
static_assert(alignof(UVAL_CompositeCondition) == 0x000008, "Wrong alignment on UVAL_CompositeCondition");
static_assert(sizeof(UVAL_CompositeCondition) == 0x000040, "Wrong size on UVAL_CompositeCondition");
static_assert(offsetof(UVAL_CompositeCondition, SubConditions) == 0x000030, "Member 'UVAL_CompositeCondition::SubConditions' has a wrong offset!");

// Class Palia.VAL_CompositeCondition_And
// 0x0000 (0x0040 - 0x0040)
class UVAL_CompositeCondition_And final : public UVAL_CompositeCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CompositeCondition_And">();
	}
	static class UVAL_CompositeCondition_And* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CompositeCondition_And>();
	}
};
static_assert(alignof(UVAL_CompositeCondition_And) == 0x000008, "Wrong alignment on UVAL_CompositeCondition_And");
static_assert(sizeof(UVAL_CompositeCondition_And) == 0x000040, "Wrong size on UVAL_CompositeCondition_And");

// Class Palia.VAL_CompositeCondition_Or
// 0x0000 (0x0040 - 0x0040)
class UVAL_CompositeCondition_Or final : public UVAL_CompositeCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CompositeCondition_Or">();
	}
	static class UVAL_CompositeCondition_Or* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CompositeCondition_Or>();
	}
};
static_assert(alignof(UVAL_CompositeCondition_Or) == 0x000008, "Wrong alignment on UVAL_CompositeCondition_Or");
static_assert(sizeof(UVAL_CompositeCondition_Or) == 0x000040, "Wrong size on UVAL_CompositeCondition_Or");

// Class Palia.VAL_GameplayCondition_Not
// 0x0008 (0x0038 - 0x0030)
class UVAL_GameplayCondition_Not final : public UVAL_GameplayConditionDef
{
public:
	class UVAL_GameplayConditionDef*              SubCondition;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayCondition_Not">();
	}
	static class UVAL_GameplayCondition_Not* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayCondition_Not>();
	}
};
static_assert(alignof(UVAL_GameplayCondition_Not) == 0x000008, "Wrong alignment on UVAL_GameplayCondition_Not");
static_assert(sizeof(UVAL_GameplayCondition_Not) == 0x000038, "Wrong size on UVAL_GameplayCondition_Not");
static_assert(offsetof(UVAL_GameplayCondition_Not, SubCondition) == 0x000030, "Member 'UVAL_GameplayCondition_Not::SubCondition' has a wrong offset!");

// Class Palia.VAL_HasItemTypeCondition
// 0x0030 (0x0078 - 0x0048)
class UVAL_HasItemTypeCondition final : public UVAL_DeductibleCondition
{
public:
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> ItemType;                                          // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlsoCheckStorage;                                 // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlsoCheckLockbox;                                 // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26AC[0x2];                                     // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumQualityStars;                               // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasItemTypeCondition">();
	}
	static class UVAL_HasItemTypeCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasItemTypeCondition>();
	}
};
static_assert(alignof(UVAL_HasItemTypeCondition) == 0x000008, "Wrong alignment on UVAL_HasItemTypeCondition");
static_assert(sizeof(UVAL_HasItemTypeCondition) == 0x000078, "Wrong size on UVAL_HasItemTypeCondition");
static_assert(offsetof(UVAL_HasItemTypeCondition, ItemType) == 0x000048, "Member 'UVAL_HasItemTypeCondition::ItemType' has a wrong offset!");
static_assert(offsetof(UVAL_HasItemTypeCondition, bAlsoCheckStorage) == 0x000070, "Member 'UVAL_HasItemTypeCondition::bAlsoCheckStorage' has a wrong offset!");
static_assert(offsetof(UVAL_HasItemTypeCondition, bAlsoCheckLockbox) == 0x000071, "Member 'UVAL_HasItemTypeCondition::bAlsoCheckLockbox' has a wrong offset!");
static_assert(offsetof(UVAL_HasItemTypeCondition, MinimumQualityStars) == 0x000074, "Member 'UVAL_HasItemTypeCondition::MinimumQualityStars' has a wrong offset!");

// Class Palia.VAL_HasPlayerTagCondition
// 0x0008 (0x0048 - 0x0040)
class UVAL_HasPlayerTagCondition final : public UVAL_QuantityCondition
{
public:
	struct FGameplayTag                           TagToCheck;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasPlayerTagCondition">();
	}
	static class UVAL_HasPlayerTagCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasPlayerTagCondition>();
	}
};
static_assert(alignof(UVAL_HasPlayerTagCondition) == 0x000008, "Wrong alignment on UVAL_HasPlayerTagCondition");
static_assert(sizeof(UVAL_HasPlayerTagCondition) == 0x000048, "Wrong size on UVAL_HasPlayerTagCondition");
static_assert(offsetof(UVAL_HasPlayerTagCondition, TagToCheck) == 0x000040, "Member 'UVAL_HasPlayerTagCondition::TagToCheck' has a wrong offset!");

// Class Palia.VAL_PlotValueCondition
// 0x0000 (0x0040 - 0x0040)
class UVAL_PlotValueCondition final : public UVAL_QuantityCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlotValueCondition">();
	}
	static class UVAL_PlotValueCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlotValueCondition>();
	}
};
static_assert(alignof(UVAL_PlotValueCondition) == 0x000008, "Wrong alignment on UVAL_PlotValueCondition");
static_assert(sizeof(UVAL_PlotValueCondition) == 0x000040, "Wrong size on UVAL_PlotValueCondition");

// Class Palia.VAL_PlotVisitorCountCondition
// 0x0000 (0x0040 - 0x0040)
class UVAL_PlotVisitorCountCondition final : public UVAL_QuantityCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlotVisitorCountCondition">();
	}
	static class UVAL_PlotVisitorCountCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlotVisitorCountCondition>();
	}
};
static_assert(alignof(UVAL_PlotVisitorCountCondition) == 0x000008, "Wrong alignment on UVAL_PlotVisitorCountCondition");
static_assert(sizeof(UVAL_PlotVisitorCountCondition) == 0x000040, "Wrong size on UVAL_PlotVisitorCountCondition");

// Class Palia.VAL_HasMetVillagerCondition
// 0x0010 (0x0040 - 0x0030)
class UVAL_HasMetVillagerCondition final : public UVAL_GameplayConditionDef
{
public:
	struct FDataTableRowHandle                    Villager;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasMetVillagerCondition">();
	}
	static class UVAL_HasMetVillagerCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasMetVillagerCondition>();
	}
};
static_assert(alignof(UVAL_HasMetVillagerCondition) == 0x000008, "Wrong alignment on UVAL_HasMetVillagerCondition");
static_assert(sizeof(UVAL_HasMetVillagerCondition) == 0x000040, "Wrong size on UVAL_HasMetVillagerCondition");
static_assert(offsetof(UVAL_HasMetVillagerCondition, Villager) == 0x000030, "Member 'UVAL_HasMetVillagerCondition::Villager' has a wrong offset!");

// Class Palia.VAL_HasMailCondition
// 0x0018 (0x0048 - 0x0030)
class UVAL_HasMailCondition final : public UVAL_GameplayConditionDef
{
public:
	struct FDataTableRowHandle                    MailMessage;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCheckUnread;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckRead;                                        // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckNotSent;                                     // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26AD[0x5];                                     // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasMailCondition">();
	}
	static class UVAL_HasMailCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasMailCondition>();
	}
};
static_assert(alignof(UVAL_HasMailCondition) == 0x000008, "Wrong alignment on UVAL_HasMailCondition");
static_assert(sizeof(UVAL_HasMailCondition) == 0x000048, "Wrong size on UVAL_HasMailCondition");
static_assert(offsetof(UVAL_HasMailCondition, MailMessage) == 0x000030, "Member 'UVAL_HasMailCondition::MailMessage' has a wrong offset!");
static_assert(offsetof(UVAL_HasMailCondition, bCheckUnread) == 0x000040, "Member 'UVAL_HasMailCondition::bCheckUnread' has a wrong offset!");
static_assert(offsetof(UVAL_HasMailCondition, bCheckRead) == 0x000041, "Member 'UVAL_HasMailCondition::bCheckRead' has a wrong offset!");
static_assert(offsetof(UVAL_HasMailCondition, bCheckNotSent) == 0x000042, "Member 'UVAL_HasMailCondition::bCheckNotSent' has a wrong offset!");

// Class Palia.VAL_HasSeenDialogueCondition
// 0x0028 (0x0058 - 0x0030)
class UVAL_HasSeenDialogueCondition final : public UVAL_GameplayConditionDef
{
public:
	TSoftObjectPtr<class UVAL_DialogueAsset>      DialogueAsset;                                     // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasSeenDialogueCondition">();
	}
	static class UVAL_HasSeenDialogueCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasSeenDialogueCondition>();
	}
};
static_assert(alignof(UVAL_HasSeenDialogueCondition) == 0x000008, "Wrong alignment on UVAL_HasSeenDialogueCondition");
static_assert(sizeof(UVAL_HasSeenDialogueCondition) == 0x000058, "Wrong size on UVAL_HasSeenDialogueCondition");
static_assert(offsetof(UVAL_HasSeenDialogueCondition, DialogueAsset) == 0x000030, "Member 'UVAL_HasSeenDialogueCondition::DialogueAsset' has a wrong offset!");

// Class Palia.VAL_HasUsedWorldPersistGatherableCondition
// 0x0008 (0x0038 - 0x0030)
class UVAL_HasUsedWorldPersistGatherableCondition final : public UVAL_GameplayConditionDef
{
public:
	struct FGameplayTag                           TagToCheck;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasUsedWorldPersistGatherableCondition">();
	}
	static class UVAL_HasUsedWorldPersistGatherableCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasUsedWorldPersistGatherableCondition>();
	}
};
static_assert(alignof(UVAL_HasUsedWorldPersistGatherableCondition) == 0x000008, "Wrong alignment on UVAL_HasUsedWorldPersistGatherableCondition");
static_assert(sizeof(UVAL_HasUsedWorldPersistGatherableCondition) == 0x000038, "Wrong size on UVAL_HasUsedWorldPersistGatherableCondition");
static_assert(offsetof(UVAL_HasUsedWorldPersistGatherableCondition, TagToCheck) == 0x000030, "Member 'UVAL_HasUsedWorldPersistGatherableCondition::TagToCheck' has a wrong offset!");

// Class Palia.VAL_HasVitalCondition
// 0x0008 (0x0050 - 0x0048)
class UVAL_HasVitalCondition final : public UVAL_DeductibleCondition
{
public:
	EVitalType                                    VitalType;                                         // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26AE[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasVitalCondition">();
	}
	static class UVAL_HasVitalCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasVitalCondition>();
	}
};
static_assert(alignof(UVAL_HasVitalCondition) == 0x000008, "Wrong alignment on UVAL_HasVitalCondition");
static_assert(sizeof(UVAL_HasVitalCondition) == 0x000050, "Wrong size on UVAL_HasVitalCondition");
static_assert(offsetof(UVAL_HasVitalCondition, VitalType) == 0x000048, "Member 'UVAL_HasVitalCondition::VitalType' has a wrong offset!");

// Class Palia.VAL_CompletedBundleCondition
// 0x0060 (0x0090 - 0x0030)
class UVAL_CompletedBundleCondition final : public UVAL_GameplayConditionDef
{
public:
	ECompletedBundleConditionStatus               Status;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26AF[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBundleShrineConfig>     BundleConfig;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVAL_BundleShrineConfigAsset> BundleShrineConfigAsset;                           // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubBundleId;                                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B0[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CompletedBundleCondition">();
	}
	static class UVAL_CompletedBundleCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CompletedBundleCondition>();
	}
};
static_assert(alignof(UVAL_CompletedBundleCondition) == 0x000008, "Wrong alignment on UVAL_CompletedBundleCondition");
static_assert(sizeof(UVAL_CompletedBundleCondition) == 0x000090, "Wrong size on UVAL_CompletedBundleCondition");
static_assert(offsetof(UVAL_CompletedBundleCondition, Status) == 0x000030, "Member 'UVAL_CompletedBundleCondition::Status' has a wrong offset!");
static_assert(offsetof(UVAL_CompletedBundleCondition, BundleConfig) == 0x000038, "Member 'UVAL_CompletedBundleCondition::BundleConfig' has a wrong offset!");
static_assert(offsetof(UVAL_CompletedBundleCondition, BundleShrineConfigAsset) == 0x000060, "Member 'UVAL_CompletedBundleCondition::BundleShrineConfigAsset' has a wrong offset!");
static_assert(offsetof(UVAL_CompletedBundleCondition, SubBundleId) == 0x000088, "Member 'UVAL_CompletedBundleCondition::SubBundleId' has a wrong offset!");

// Class Palia.VAL_KnowsGiftPrefCondition
// 0x0018 (0x0048 - 0x0030)
class UVAL_KnowsGiftPrefCondition final : public UVAL_GameplayConditionDef
{
public:
	struct FDataTableRowHandle                    Villager;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EVillagerGiftRewardLevel                      RewardLevel;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B1[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_KnowsGiftPrefCondition">();
	}
	static class UVAL_KnowsGiftPrefCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_KnowsGiftPrefCondition>();
	}
};
static_assert(alignof(UVAL_KnowsGiftPrefCondition) == 0x000008, "Wrong alignment on UVAL_KnowsGiftPrefCondition");
static_assert(sizeof(UVAL_KnowsGiftPrefCondition) == 0x000048, "Wrong size on UVAL_KnowsGiftPrefCondition");
static_assert(offsetof(UVAL_KnowsGiftPrefCondition, Villager) == 0x000030, "Member 'UVAL_KnowsGiftPrefCondition::Villager' has a wrong offset!");
static_assert(offsetof(UVAL_KnowsGiftPrefCondition, RewardLevel) == 0x000040, "Member 'UVAL_KnowsGiftPrefCondition::RewardLevel' has a wrong offset!");

// Class Palia.VAL_HasCompletedQuestCondition
// 0x0030 (0x0060 - 0x0030)
class UVAL_HasCompletedQuestCondition final : public UVAL_GameplayConditionDef
{
public:
	TSoftObjectPtr<class UVAL_QuestDef>           Quest;                                             // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestProgressConditionStatus                 Status;                                            // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B2[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Step;                                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasCompletedQuestCondition">();
	}
	static class UVAL_HasCompletedQuestCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasCompletedQuestCondition>();
	}
};
static_assert(alignof(UVAL_HasCompletedQuestCondition) == 0x000008, "Wrong alignment on UVAL_HasCompletedQuestCondition");
static_assert(sizeof(UVAL_HasCompletedQuestCondition) == 0x000060, "Wrong size on UVAL_HasCompletedQuestCondition");
static_assert(offsetof(UVAL_HasCompletedQuestCondition, Quest) == 0x000030, "Member 'UVAL_HasCompletedQuestCondition::Quest' has a wrong offset!");
static_assert(offsetof(UVAL_HasCompletedQuestCondition, Status) == 0x000058, "Member 'UVAL_HasCompletedQuestCondition::Status' has a wrong offset!");
static_assert(offsetof(UVAL_HasCompletedQuestCondition, Step) == 0x00005C, "Member 'UVAL_HasCompletedQuestCondition::Step' has a wrong offset!");

// Class Palia.VAL_HasVisitProgressCondition
// 0x0030 (0x0060 - 0x0030)
class UVAL_HasVisitProgressCondition final : public UVAL_GameplayConditionDef
{
public:
	TSoftObjectPtr<class UPrivateSpaceVillagerVisitConfig> Visit;                                             // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireActiveVisit;                               // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisitProgressConditionStatus                 VisitStatus;                                       // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B3[0x6];                                     // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasVisitProgressCondition">();
	}
	static class UVAL_HasVisitProgressCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasVisitProgressCondition>();
	}
};
static_assert(alignof(UVAL_HasVisitProgressCondition) == 0x000008, "Wrong alignment on UVAL_HasVisitProgressCondition");
static_assert(sizeof(UVAL_HasVisitProgressCondition) == 0x000060, "Wrong size on UVAL_HasVisitProgressCondition");
static_assert(offsetof(UVAL_HasVisitProgressCondition, Visit) == 0x000030, "Member 'UVAL_HasVisitProgressCondition::Visit' has a wrong offset!");
static_assert(offsetof(UVAL_HasVisitProgressCondition, bRequireActiveVisit) == 0x000058, "Member 'UVAL_HasVisitProgressCondition::bRequireActiveVisit' has a wrong offset!");
static_assert(offsetof(UVAL_HasVisitProgressCondition, VisitStatus) == 0x000059, "Member 'UVAL_HasVisitProgressCondition::VisitStatus' has a wrong offset!");

// Class Palia.VAL_IsLimitedEventActiveCondition
// 0x0030 (0x0060 - 0x0030)
class UVAL_IsLimitedEventActiveCondition final : public UVAL_GameplayConditionDef
{
public:
	TSoftObjectPtr<class ULimitedEventDataAsset>  Event;                                             // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInactive;                                       // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B4[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_IsLimitedEventActiveCondition">();
	}
	static class UVAL_IsLimitedEventActiveCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_IsLimitedEventActiveCondition>();
	}
};
static_assert(alignof(UVAL_IsLimitedEventActiveCondition) == 0x000008, "Wrong alignment on UVAL_IsLimitedEventActiveCondition");
static_assert(sizeof(UVAL_IsLimitedEventActiveCondition) == 0x000060, "Wrong size on UVAL_IsLimitedEventActiveCondition");
static_assert(offsetof(UVAL_IsLimitedEventActiveCondition, Event) == 0x000030, "Member 'UVAL_IsLimitedEventActiveCondition::Event' has a wrong offset!");
static_assert(offsetof(UVAL_IsLimitedEventActiveCondition, bIsInactive) == 0x000058, "Member 'UVAL_IsLimitedEventActiveCondition::bIsInactive' has a wrong offset!");

// Class Palia.VAL_HasBuff
// 0x0010 (0x0040 - 0x0030)
class UVAL_HasBuff final : public UVAL_GameplayConditionDef
{
public:
	struct FDataTableRowHandle                    Buff;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_HasBuff">();
	}
	static class UVAL_HasBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_HasBuff>();
	}
};
static_assert(alignof(UVAL_HasBuff) == 0x000008, "Wrong alignment on UVAL_HasBuff");
static_assert(sizeof(UVAL_HasBuff) == 0x000040, "Wrong size on UVAL_HasBuff");
static_assert(offsetof(UVAL_HasBuff, Buff) == 0x000030, "Member 'UVAL_HasBuff::Buff' has a wrong offset!");

// Class Palia.VAL_ContentBatchAvailableCondition
// 0x0028 (0x0058 - 0x0030)
class UVAL_ContentBatchAvailableCondition final : public UVAL_GameplayConditionDef
{
public:
	TSoftObjectPtr<class UVAL_ContentBatchAsset>  ContentBatch;                                      // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ContentBatchAvailableCondition">();
	}
	static class UVAL_ContentBatchAvailableCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ContentBatchAvailableCondition>();
	}
};
static_assert(alignof(UVAL_ContentBatchAvailableCondition) == 0x000008, "Wrong alignment on UVAL_ContentBatchAvailableCondition");
static_assert(sizeof(UVAL_ContentBatchAvailableCondition) == 0x000058, "Wrong size on UVAL_ContentBatchAvailableCondition");
static_assert(offsetof(UVAL_ContentBatchAvailableCondition, ContentBatch) == 0x000030, "Member 'UVAL_ContentBatchAvailableCondition::ContentBatch' has a wrong offset!");

// Class Palia.VAL_EventCondition
// 0x0010 (0x0050 - 0x0040)
class UVAL_EventCondition final : public UVAL_QuantityCondition
{
public:
	struct FVAL_GameplayEventFilter               EventFilter;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EventCondition">();
	}
	static class UVAL_EventCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_EventCondition>();
	}
};
static_assert(alignof(UVAL_EventCondition) == 0x000008, "Wrong alignment on UVAL_EventCondition");
static_assert(sizeof(UVAL_EventCondition) == 0x000050, "Wrong size on UVAL_EventCondition");
static_assert(offsetof(UVAL_EventCondition, EventFilter) == 0x000040, "Member 'UVAL_EventCondition::EventFilter' has a wrong offset!");

// Class Palia.VAL_GameplayConditionContext
// 0x0038 (0x0060 - 0x0028)
class UVAL_GameplayConditionContext final : public UObject
{
public:
	class AValeriaCharacter*                      ValeriaCharacter;                                  // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConditionMet;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B5[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoalAmount;                                        // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B6[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_GameplayEventConditionState*       EventState;                                        // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UVAL_GameplayConditionContext*>  SubContexts;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UVAL_GameplayConditionDef*              Condition;                                         // 0x0058(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayConditionContext">();
	}
	static class UVAL_GameplayConditionContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayConditionContext>();
	}
};
static_assert(alignof(UVAL_GameplayConditionContext) == 0x000008, "Wrong alignment on UVAL_GameplayConditionContext");
static_assert(sizeof(UVAL_GameplayConditionContext) == 0x000060, "Wrong size on UVAL_GameplayConditionContext");
static_assert(offsetof(UVAL_GameplayConditionContext, ValeriaCharacter) == 0x000028, "Member 'UVAL_GameplayConditionContext::ValeriaCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayConditionContext, bConditionMet) == 0x000030, "Member 'UVAL_GameplayConditionContext::bConditionMet' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayConditionContext, Count) == 0x000034, "Member 'UVAL_GameplayConditionContext::Count' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayConditionContext, GoalAmount) == 0x000038, "Member 'UVAL_GameplayConditionContext::GoalAmount' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayConditionContext, EventState) == 0x000040, "Member 'UVAL_GameplayConditionContext::EventState' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayConditionContext, SubContexts) == 0x000048, "Member 'UVAL_GameplayConditionContext::SubContexts' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayConditionContext, Condition) == 0x000058, "Member 'UVAL_GameplayConditionContext::Condition' has a wrong offset!");

// Class Palia.VAL_GameplayEventsSubsystem
// 0x0050 (0x0080 - 0x0030)
class UVAL_GameplayEventsSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class UClass*, struct FVAL_GameplayEventListenerArray> Listeners;                                         // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEventsSubsystem">();
	}
	static class UVAL_GameplayEventsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEventsSubsystem>();
	}
};
static_assert(alignof(UVAL_GameplayEventsSubsystem) == 0x000008, "Wrong alignment on UVAL_GameplayEventsSubsystem");
static_assert(sizeof(UVAL_GameplayEventsSubsystem) == 0x000080, "Wrong size on UVAL_GameplayEventsSubsystem");
static_assert(offsetof(UVAL_GameplayEventsSubsystem, Listeners) == 0x000030, "Member 'UVAL_GameplayEventsSubsystem::Listeners' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_KillCreature
// 0x0010 (0x0178 - 0x0168)
class UVAL_GameplayEvent_KillCreature final : public UVAL_GameplayEvent
{
public:
	struct FDataTableRowHandle                    CreatureType;                                      // 0x0168(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_KillCreature">();
	}
	static class UVAL_GameplayEvent_KillCreature* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_KillCreature>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_KillCreature) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_KillCreature");
static_assert(sizeof(UVAL_GameplayEvent_KillCreature) == 0x000178, "Wrong size on UVAL_GameplayEvent_KillCreature");
static_assert(offsetof(UVAL_GameplayEvent_KillCreature, CreatureType) == 0x000168, "Member 'UVAL_GameplayEvent_KillCreature::CreatureType' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_CatchFish
// 0x0030 (0x0198 - 0x0168)
class UVAL_GameplayEvent_CatchFish final : public UVAL_GameplayEvent
{
public:
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> FishItemType;                                      // 0x0168(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiplayer;                                      // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B7[0x7];                                     // 0x0191(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_CatchFish">();
	}
	static class UVAL_GameplayEvent_CatchFish* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_CatchFish>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_CatchFish) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_CatchFish");
static_assert(sizeof(UVAL_GameplayEvent_CatchFish) == 0x000198, "Wrong size on UVAL_GameplayEvent_CatchFish");
static_assert(offsetof(UVAL_GameplayEvent_CatchFish, FishItemType) == 0x000168, "Member 'UVAL_GameplayEvent_CatchFish::FishItemType' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_CatchFish, bMultiplayer) == 0x000190, "Member 'UVAL_GameplayEvent_CatchFish::bMultiplayer' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItem_Head
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_Head final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_Head(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_Head_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_Head">();
	}
	static class UVAL_CharacterCustomizationItem_Head* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_Head>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_Head) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_Head");
static_assert(sizeof(UVAL_CharacterCustomizationItem_Head) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_Head");

// Class Palia.VAL_GameplayEvent_TillSoil
// 0x0000 (0x0168 - 0x0168)
class UVAL_GameplayEvent_TillSoil final : public UVAL_GameplayEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_TillSoil">();
	}
	static class UVAL_GameplayEvent_TillSoil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_TillSoil>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_TillSoil) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_TillSoil");
static_assert(sizeof(UVAL_GameplayEvent_TillSoil) == 0x000168, "Wrong size on UVAL_GameplayEvent_TillSoil");

// Class Palia.VAL_GameplayEvent_DiscoverGiftPreference
// 0x0018 (0x0180 - 0x0168)
class UVAL_GameplayEvent_DiscoverGiftPreference final : public UVAL_GameplayEvent
{
public:
	struct FDataTableRowHandle                    Villager;                                          // 0x0168(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EVillagerGiftRewardLevel                      RewardLevel;                                       // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26BA[0x3];                                     // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VillagerCoreId;                                    // 0x017C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_DiscoverGiftPreference">();
	}
	static class UVAL_GameplayEvent_DiscoverGiftPreference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_DiscoverGiftPreference>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_DiscoverGiftPreference) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_DiscoverGiftPreference");
static_assert(sizeof(UVAL_GameplayEvent_DiscoverGiftPreference) == 0x000180, "Wrong size on UVAL_GameplayEvent_DiscoverGiftPreference");
static_assert(offsetof(UVAL_GameplayEvent_DiscoverGiftPreference, Villager) == 0x000168, "Member 'UVAL_GameplayEvent_DiscoverGiftPreference::Villager' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_DiscoverGiftPreference, RewardLevel) == 0x000178, "Member 'UVAL_GameplayEvent_DiscoverGiftPreference::RewardLevel' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_DiscoverGiftPreference, VillagerCoreId) == 0x00017C, "Member 'UVAL_GameplayEvent_DiscoverGiftPreference::VillagerCoreId' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItem_Glider
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_Glider final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_Glider(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_Glider_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_Glider">();
	}
	static class UVAL_CharacterCustomizationItem_Glider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_Glider>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_Glider) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_Glider");
static_assert(sizeof(UVAL_CharacterCustomizationItem_Glider) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_Glider");

// Class Palia.VAL_GameplayEvent_CompleteBillboard
// 0x0008 (0x0170 - 0x0168)
class UVAL_GameplayEvent_CompleteBillboard final : public UVAL_GameplayEvent
{
public:
	int32                                         QuestSelectorId;                                   // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26BD[0x4];                                     // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_CompleteBillboard">();
	}
	static class UVAL_GameplayEvent_CompleteBillboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_CompleteBillboard>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_CompleteBillboard) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_CompleteBillboard");
static_assert(sizeof(UVAL_GameplayEvent_CompleteBillboard) == 0x000170, "Wrong size on UVAL_GameplayEvent_CompleteBillboard");
static_assert(offsetof(UVAL_GameplayEvent_CompleteBillboard, QuestSelectorId) == 0x000168, "Member 'UVAL_GameplayEvent_CompleteBillboard::QuestSelectorId' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_AcquireItem
// 0x0008 (0x01E8 - 0x01E0)
class UVAL_GameplayEvent_AcquireItem final : public UVAL_GameplayEvent_ItemAbstract
{
public:
	int32                                         AcquireMethodFilter;                               // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVAL_GE_AcquireItem_Method                    AcquireMethod;                                     // 0x01E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26BE[0x3];                                     // 0x01E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_AcquireItem">();
	}
	static class UVAL_GameplayEvent_AcquireItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_AcquireItem>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_AcquireItem) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_AcquireItem");
static_assert(sizeof(UVAL_GameplayEvent_AcquireItem) == 0x0001E8, "Wrong size on UVAL_GameplayEvent_AcquireItem");
static_assert(offsetof(UVAL_GameplayEvent_AcquireItem, AcquireMethodFilter) == 0x0001E0, "Member 'UVAL_GameplayEvent_AcquireItem::AcquireMethodFilter' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_AcquireItem, AcquireMethod) == 0x0001E4, "Member 'UVAL_GameplayEvent_AcquireItem::AcquireMethod' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItem_Hat
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_Hat final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_Hat(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_Hat_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_Hat">();
	}
	static class UVAL_CharacterCustomizationItem_Hat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_Hat>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_Hat) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_Hat");
static_assert(sizeof(UVAL_CharacterCustomizationItem_Hat) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_Hat");

// Class Palia.VAL_GameplayEvent_ReleaseItem
// 0x0008 (0x01E8 - 0x01E0)
class UVAL_GameplayEvent_ReleaseItem final : public UVAL_GameplayEvent_ItemAbstract
{
public:
	int32                                         ReleaseMethodFilter;                               // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVAL_GE_ReleaseItem_Method                    ReleaseMethod;                                     // 0x01E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C1[0x3];                                     // 0x01E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_ReleaseItem">();
	}
	static class UVAL_GameplayEvent_ReleaseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_ReleaseItem>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_ReleaseItem) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_ReleaseItem");
static_assert(sizeof(UVAL_GameplayEvent_ReleaseItem) == 0x0001E8, "Wrong size on UVAL_GameplayEvent_ReleaseItem");
static_assert(offsetof(UVAL_GameplayEvent_ReleaseItem, ReleaseMethodFilter) == 0x0001E0, "Member 'UVAL_GameplayEvent_ReleaseItem::ReleaseMethodFilter' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_ReleaseItem, ReleaseMethod) == 0x0001E4, "Member 'UVAL_GameplayEvent_ReleaseItem::ReleaseMethod' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_VitalAbstract
// 0x0008 (0x0170 - 0x0168)
class UVAL_GameplayEvent_VitalAbstract : public UVAL_GameplayEvent
{
public:
	EVitalType                                    VitalType;                                         // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C2[0x7];                                     // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_VitalAbstract">();
	}
	static class UVAL_GameplayEvent_VitalAbstract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_VitalAbstract>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_VitalAbstract) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_VitalAbstract");
static_assert(sizeof(UVAL_GameplayEvent_VitalAbstract) == 0x000170, "Wrong size on UVAL_GameplayEvent_VitalAbstract");
static_assert(offsetof(UVAL_GameplayEvent_VitalAbstract, VitalType) == 0x000168, "Member 'UVAL_GameplayEvent_VitalAbstract::VitalType' has a wrong offset!");

// Class Palia.QuestIconConfig
// 0x0050 (0x0080 - 0x0030)
class UQuestIconConfig final : public UDataAsset
{
public:
	TMap<EDialogueType, TSoftObjectPtr<class UTexture2D>> DialogueTypeToTextureMap;                          // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	TSoftObjectPtr<class UTexture2D> GetTextureForDialogueType(EDialogueType InDialogueType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestIconConfig">();
	}
	static class UQuestIconConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestIconConfig>();
	}
};
static_assert(alignof(UQuestIconConfig) == 0x000008, "Wrong alignment on UQuestIconConfig");
static_assert(sizeof(UQuestIconConfig) == 0x000080, "Wrong size on UQuestIconConfig");
static_assert(offsetof(UQuestIconConfig, DialogueTypeToTextureMap) == 0x000030, "Member 'UQuestIconConfig::DialogueTypeToTextureMap' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_AcquireVital
// 0x0000 (0x0170 - 0x0170)
class UVAL_GameplayEvent_AcquireVital final : public UVAL_GameplayEvent_VitalAbstract
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_AcquireVital">();
	}
	static class UVAL_GameplayEvent_AcquireVital* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_AcquireVital>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_AcquireVital) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_AcquireVital");
static_assert(sizeof(UVAL_GameplayEvent_AcquireVital) == 0x000170, "Wrong size on UVAL_GameplayEvent_AcquireVital");

// Class Palia.VAL_GameplayEvent_SpendVital
// 0x0000 (0x0170 - 0x0170)
class UVAL_GameplayEvent_SpendVital final : public UVAL_GameplayEvent_VitalAbstract
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_SpendVital">();
	}
	static class UVAL_GameplayEvent_SpendVital* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_SpendVital>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_SpendVital) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_SpendVital");
static_assert(sizeof(UVAL_GameplayEvent_SpendVital) == 0x000170, "Wrong size on UVAL_GameplayEvent_SpendVital");

// Class Palia.MirrorImageSpawningComponent
// 0x0038 (0x00D8 - 0x00A0)
class UMirrorImageSpawningComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMirrorImageSpawn;                                // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         IllusionSpawnRadius;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredIllusionCount;                              // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     IllusionTemplate;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SpawnedImages;                                     // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C4[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACreatureCharacter* GetCreator();
	void NotifyEvadeStart();
	void RpcClient_DisplaySpawn(TArray<class AActor*>& InSpawnedImages);
	void SpawnMirrorImages(int32 CopiesToSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorImageSpawningComponent">();
	}
	static class UMirrorImageSpawningComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorImageSpawningComponent>();
	}
};
static_assert(alignof(UMirrorImageSpawningComponent) == 0x000008, "Wrong alignment on UMirrorImageSpawningComponent");
static_assert(sizeof(UMirrorImageSpawningComponent) == 0x0000D8, "Wrong size on UMirrorImageSpawningComponent");
static_assert(offsetof(UMirrorImageSpawningComponent, OnMirrorImageSpawn) == 0x0000A0, "Member 'UMirrorImageSpawningComponent::OnMirrorImageSpawn' has a wrong offset!");
static_assert(offsetof(UMirrorImageSpawningComponent, IllusionSpawnRadius) == 0x0000B0, "Member 'UMirrorImageSpawningComponent::IllusionSpawnRadius' has a wrong offset!");
static_assert(offsetof(UMirrorImageSpawningComponent, DesiredIllusionCount) == 0x0000B4, "Member 'UMirrorImageSpawningComponent::DesiredIllusionCount' has a wrong offset!");
static_assert(offsetof(UMirrorImageSpawningComponent, IllusionTemplate) == 0x0000B8, "Member 'UMirrorImageSpawningComponent::IllusionTemplate' has a wrong offset!");
static_assert(offsetof(UMirrorImageSpawningComponent, SpawnedImages) == 0x0000C0, "Member 'UMirrorImageSpawningComponent::SpawnedImages' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_AcquireCurrency
// 0x0000 (0x0190 - 0x0190)
class UVAL_GameplayEvent_AcquireCurrency final : public UVAL_GameplayEvent_CurrencyAbstract
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_AcquireCurrency">();
	}
	static class UVAL_GameplayEvent_AcquireCurrency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_AcquireCurrency>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_AcquireCurrency) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_AcquireCurrency");
static_assert(sizeof(UVAL_GameplayEvent_AcquireCurrency) == 0x000190, "Wrong size on UVAL_GameplayEvent_AcquireCurrency");

// Class Palia.VAL_GameplayEvent_FulfillPlayerRequest
// 0x0000 (0x0168 - 0x0168)
class UVAL_GameplayEvent_FulfillPlayerRequest final : public UVAL_GameplayEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_FulfillPlayerRequest">();
	}
	static class UVAL_GameplayEvent_FulfillPlayerRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_FulfillPlayerRequest>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_FulfillPlayerRequest) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_FulfillPlayerRequest");
static_assert(sizeof(UVAL_GameplayEvent_FulfillPlayerRequest) == 0x000168, "Wrong size on UVAL_GameplayEvent_FulfillPlayerRequest");

// Class Palia.VAL_QuestConfiguration
// 0x00E8 (0x0120 - 0x0038)
class UVAL_QuestConfiguration final : public UDeveloperSettings
{
public:
	int32                                         PinLimit;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C5[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuestCompassConfig                    Compass;                                           // 0x0040(0x0048)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   GoalCountDescriptionFormat;                        // 0x0088(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	class FText                                   StarQualityGoalDescriptionFormat;                  // 0x00A0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FNotification                          QuestResetNotification;                            // 0x00B8(0x0030)(Edit, Config, NativeAccessSpecifierPublic)
	struct FNotification                          MultipleQuestsResetNotification;                   // 0x00E8(0x0030)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bShowStepCompleteNotification;                     // 0x0118(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C6[0x7];                                     // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_QuestConfiguration">();
	}
	static class UVAL_QuestConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_QuestConfiguration>();
	}
};
static_assert(alignof(UVAL_QuestConfiguration) == 0x000008, "Wrong alignment on UVAL_QuestConfiguration");
static_assert(sizeof(UVAL_QuestConfiguration) == 0x000120, "Wrong size on UVAL_QuestConfiguration");
static_assert(offsetof(UVAL_QuestConfiguration, PinLimit) == 0x000038, "Member 'UVAL_QuestConfiguration::PinLimit' has a wrong offset!");
static_assert(offsetof(UVAL_QuestConfiguration, Compass) == 0x000040, "Member 'UVAL_QuestConfiguration::Compass' has a wrong offset!");
static_assert(offsetof(UVAL_QuestConfiguration, GoalCountDescriptionFormat) == 0x000088, "Member 'UVAL_QuestConfiguration::GoalCountDescriptionFormat' has a wrong offset!");
static_assert(offsetof(UVAL_QuestConfiguration, StarQualityGoalDescriptionFormat) == 0x0000A0, "Member 'UVAL_QuestConfiguration::StarQualityGoalDescriptionFormat' has a wrong offset!");
static_assert(offsetof(UVAL_QuestConfiguration, QuestResetNotification) == 0x0000B8, "Member 'UVAL_QuestConfiguration::QuestResetNotification' has a wrong offset!");
static_assert(offsetof(UVAL_QuestConfiguration, MultipleQuestsResetNotification) == 0x0000E8, "Member 'UVAL_QuestConfiguration::MultipleQuestsResetNotification' has a wrong offset!");
static_assert(offsetof(UVAL_QuestConfiguration, bShowStepCompleteNotification) == 0x000118, "Member 'UVAL_QuestConfiguration::bShowStepCompleteNotification' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_ConfirmWardrobe
// 0x0000 (0x0168 - 0x0168)
class UVAL_GameplayEvent_ConfirmWardrobe final : public UVAL_GameplayEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_ConfirmWardrobe">();
	}
	static class UVAL_GameplayEvent_ConfirmWardrobe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_ConfirmWardrobe>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_ConfirmWardrobe) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_ConfirmWardrobe");
static_assert(sizeof(UVAL_GameplayEvent_ConfirmWardrobe) == 0x000168, "Wrong size on UVAL_GameplayEvent_ConfirmWardrobe");

// Class Palia.VAL_GameplayEvent_EngageInteractable
// 0x0010 (0x0178 - 0x0168)
class UVAL_GameplayEvent_EngageInteractable final : public UVAL_GameplayEvent
{
public:
	TArray<class FName>                           TagListFilter;                                     // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_EngageInteractable">();
	}
	static class UVAL_GameplayEvent_EngageInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_EngageInteractable>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_EngageInteractable) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_EngageInteractable");
static_assert(sizeof(UVAL_GameplayEvent_EngageInteractable) == 0x000178, "Wrong size on UVAL_GameplayEvent_EngageInteractable");
static_assert(offsetof(UVAL_GameplayEvent_EngageInteractable, TagListFilter) == 0x000168, "Member 'UVAL_GameplayEvent_EngageInteractable::TagListFilter' has a wrong offset!");

// Class Palia.MinigameComponentBase
// 0x0030 (0x00D0 - 0x00A0)
class UMinigameComponentBase : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStateChanged;                                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AValeriaPlayerController*               CachedPlayer;                                      // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AValeriaCharacter*                      CachedCharacter;                                   // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CachedSourceActor;                                 // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMinigameState                                ServerMinigameState;                               // 0x00C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMinigameState                                ClientMinigameState;                               // 0x00C9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C7[0x6];                                     // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RpcClient_RejectStartMinigame();
	void RpcServer_ChangeState(EMinigameState NewState);
	void StartMinigame(class AActor* Source);
	bool StopMinigame(EMinigameState DesiredFinalState);

	bool IsInFinishedState() const;
	bool IsPaused() const;
	bool IsPlaying() const;
	bool IsReadyToPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinigameComponentBase">();
	}
	static class UMinigameComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinigameComponentBase>();
	}
};
static_assert(alignof(UMinigameComponentBase) == 0x000008, "Wrong alignment on UMinigameComponentBase");
static_assert(sizeof(UMinigameComponentBase) == 0x0000D0, "Wrong size on UMinigameComponentBase");
static_assert(offsetof(UMinigameComponentBase, OnStateChanged) == 0x0000A0, "Member 'UMinigameComponentBase::OnStateChanged' has a wrong offset!");
static_assert(offsetof(UMinigameComponentBase, CachedPlayer) == 0x0000B0, "Member 'UMinigameComponentBase::CachedPlayer' has a wrong offset!");
static_assert(offsetof(UMinigameComponentBase, CachedCharacter) == 0x0000B8, "Member 'UMinigameComponentBase::CachedCharacter' has a wrong offset!");
static_assert(offsetof(UMinigameComponentBase, CachedSourceActor) == 0x0000C0, "Member 'UMinigameComponentBase::CachedSourceActor' has a wrong offset!");
static_assert(offsetof(UMinigameComponentBase, ServerMinigameState) == 0x0000C8, "Member 'UMinigameComponentBase::ServerMinigameState' has a wrong offset!");
static_assert(offsetof(UMinigameComponentBase, ClientMinigameState) == 0x0000C9, "Member 'UMinigameComponentBase::ClientMinigameState' has a wrong offset!");

// Class Palia.MinigameComponentMasterQTE
// 0x0160 (0x0230 - 0x00D0)
class UMinigameComponentMasterQTE final : public UMinigameComponentBase
{
public:
	uint8                                         Pad_26C8[0x8];                                     // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSuccessfulInputReceived;                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExpectedInputMissed;                             // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMistimedInputReceived;                           // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMinigameEngaged;                                 // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMinigameDisengaged;                              // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         MinigameResultLingerTime;                          // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C9[0x4];                                     // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinigameConfig                        ActiveConfig;                                      // 0x0130(0x00B8)(BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	float                                         MinigameStartTime;                                 // 0x01E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastPressReceiveTime;                              // 0x01EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastReleaseReceiveTime;                            // 0x01F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26CA[0xC];                                     // 0x01F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SuccessCount;                                      // 0x0200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PartialCompletion;                                 // 0x0204(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26CB[0x4];                                     // 0x0208(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMinigameConfigSet;                                // 0x020C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToolAbilityShouldBeActive;                        // 0x020D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26CC[0x2];                                     // 0x020E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           InputTimeHandle;                                   // 0x0210(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimeUpHandle;                                      // 0x0218(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ResultLingerHandle;                                // 0x0220(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             ToolAbilityHandle;                                 // 0x0228(0x0004)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26CD[0x4];                                     // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearResults();
	void ClearToolAbility();
	bool IncrementSuccessCount();
	void NotifyExpectedInputMissed();
	void NotifyMistimedInputReceived();
	struct FSelfUseEventResult OnClientUseEquippedOutward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnInputPeriodTimeElapsed();
	void OnSuccessCountReplicated(int32 OldSuccessCount);
	void OnTimeUp();
	void ResumeFromPenalty();
	void RpcServer_NotifyMistimedInputReceived();
	void RpcServer_NotifyUpdatedSuccessCount(int32 NewSuccessCount);
	void StartMinigameWithConfig(class AActor* Source, struct FMinigameConfig& Config);
	void WaitToStartMinigameWithConfig(class AActor* Source, struct FMinigameConfig& Config);

	float GetAnimationNormalizedTime(int32 NumCyclesPerAnim) const;
	float GetCompletion() const;
	float GetCursorPosition() const;
	const struct FMinigameConfig GetMinigameConfig() const;
	float GetTargetPosition() const;
	float GetTimeElapsed() const;
	bool HasMinigameConfig() const;
	bool IsButtonHeld() const;
	bool IsToolAbilityValid() const;
	bool ShouldReceiveInput() const;
	bool WouldInputNowBeSuccess() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinigameComponentMasterQTE">();
	}
	static class UMinigameComponentMasterQTE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinigameComponentMasterQTE>();
	}
};
static_assert(alignof(UMinigameComponentMasterQTE) == 0x000008, "Wrong alignment on UMinigameComponentMasterQTE");
static_assert(sizeof(UMinigameComponentMasterQTE) == 0x000230, "Wrong size on UMinigameComponentMasterQTE");
static_assert(offsetof(UMinigameComponentMasterQTE, OnSuccessfulInputReceived) == 0x0000D8, "Member 'UMinigameComponentMasterQTE::OnSuccessfulInputReceived' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, OnExpectedInputMissed) == 0x0000E8, "Member 'UMinigameComponentMasterQTE::OnExpectedInputMissed' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, OnMistimedInputReceived) == 0x0000F8, "Member 'UMinigameComponentMasterQTE::OnMistimedInputReceived' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, OnMinigameEngaged) == 0x000108, "Member 'UMinigameComponentMasterQTE::OnMinigameEngaged' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, OnMinigameDisengaged) == 0x000118, "Member 'UMinigameComponentMasterQTE::OnMinigameDisengaged' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, MinigameResultLingerTime) == 0x000128, "Member 'UMinigameComponentMasterQTE::MinigameResultLingerTime' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, ActiveConfig) == 0x000130, "Member 'UMinigameComponentMasterQTE::ActiveConfig' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, MinigameStartTime) == 0x0001E8, "Member 'UMinigameComponentMasterQTE::MinigameStartTime' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, LastPressReceiveTime) == 0x0001EC, "Member 'UMinigameComponentMasterQTE::LastPressReceiveTime' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, LastReleaseReceiveTime) == 0x0001F0, "Member 'UMinigameComponentMasterQTE::LastReleaseReceiveTime' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, SuccessCount) == 0x000200, "Member 'UMinigameComponentMasterQTE::SuccessCount' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, PartialCompletion) == 0x000204, "Member 'UMinigameComponentMasterQTE::PartialCompletion' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, bMinigameConfigSet) == 0x00020C, "Member 'UMinigameComponentMasterQTE::bMinigameConfigSet' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, bToolAbilityShouldBeActive) == 0x00020D, "Member 'UMinigameComponentMasterQTE::bToolAbilityShouldBeActive' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, InputTimeHandle) == 0x000210, "Member 'UMinigameComponentMasterQTE::InputTimeHandle' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, TimeUpHandle) == 0x000218, "Member 'UMinigameComponentMasterQTE::TimeUpHandle' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, ResultLingerHandle) == 0x000220, "Member 'UMinigameComponentMasterQTE::ResultLingerHandle' has a wrong offset!");
static_assert(offsetof(UMinigameComponentMasterQTE, ToolAbilityHandle) == 0x000228, "Member 'UMinigameComponentMasterQTE::ToolAbilityHandle' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_SpinPrizeWheel
// 0x0030 (0x0198 - 0x0168)
class UVAL_GameplayEvent_SpinPrizeWheel final : public UVAL_GameplayEvent
{
public:
	TSoftObjectPtr<class UVAL_PrizeWheelDef>      PrizeWheelDef;                                     // 0x0168(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrizeWheelPersistId;                               // 0x0190(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26CF[0x4];                                     // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_SpinPrizeWheel">();
	}
	static class UVAL_GameplayEvent_SpinPrizeWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_SpinPrizeWheel>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_SpinPrizeWheel) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_SpinPrizeWheel");
static_assert(sizeof(UVAL_GameplayEvent_SpinPrizeWheel) == 0x000198, "Wrong size on UVAL_GameplayEvent_SpinPrizeWheel");
static_assert(offsetof(UVAL_GameplayEvent_SpinPrizeWheel, PrizeWheelDef) == 0x000168, "Member 'UVAL_GameplayEvent_SpinPrizeWheel::PrizeWheelDef' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_SpinPrizeWheel, PrizeWheelPersistId) == 0x000190, "Member 'UVAL_GameplayEvent_SpinPrizeWheel::PrizeWheelPersistId' has a wrong offset!");

// Class Palia.VAL_GameplayEvent_SpawnGatherableOnPlot
// 0x0010 (0x0178 - 0x0168)
class UVAL_GameplayEvent_SpawnGatherableOnPlot final : public UVAL_GameplayEvent
{
public:
	TSubclassOf<class AGatherableActor>           GatherableType;                                    // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGatherableActor*                       GatherableActor;                                   // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_SpawnGatherableOnPlot">();
	}
	static class UVAL_GameplayEvent_SpawnGatherableOnPlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_SpawnGatherableOnPlot>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_SpawnGatherableOnPlot) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_SpawnGatherableOnPlot");
static_assert(sizeof(UVAL_GameplayEvent_SpawnGatherableOnPlot) == 0x000178, "Wrong size on UVAL_GameplayEvent_SpawnGatherableOnPlot");
static_assert(offsetof(UVAL_GameplayEvent_SpawnGatherableOnPlot, GatherableType) == 0x000168, "Member 'UVAL_GameplayEvent_SpawnGatherableOnPlot::GatherableType' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_SpawnGatherableOnPlot, GatherableActor) == 0x000170, "Member 'UVAL_GameplayEvent_SpawnGatherableOnPlot::GatherableActor' has a wrong offset!");

// Class Palia.PaliaBinkFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPaliaBinkFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void InitializeBinkMediaPlayer(class UBinkMediaPlayer* bmp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaliaBinkFunctionLibrary">();
	}
	static class UPaliaBinkFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaliaBinkFunctionLibrary>();
	}
};
static_assert(alignof(UPaliaBinkFunctionLibrary) == 0x000008, "Wrong alignment on UPaliaBinkFunctionLibrary");
static_assert(sizeof(UPaliaBinkFunctionLibrary) == 0x000028, "Wrong size on UPaliaBinkFunctionLibrary");

// Class Palia.VAL_GameplayEvent_TimerTrigger
// 0x0020 (0x0188 - 0x0168)
class UVAL_GameplayEvent_TimerTrigger final : public UVAL_GameplayEvent
{
public:
	ETimerEventType                               TimerEventType;                                    // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D0[0x7];                                     // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_TimerDefinition*                   TimerDefinition;                                   // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MsElapsed;                                         // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MsRemaining;                                       // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameplayEvent_TimerTrigger">();
	}
	static class UVAL_GameplayEvent_TimerTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameplayEvent_TimerTrigger>();
	}
};
static_assert(alignof(UVAL_GameplayEvent_TimerTrigger) == 0x000008, "Wrong alignment on UVAL_GameplayEvent_TimerTrigger");
static_assert(sizeof(UVAL_GameplayEvent_TimerTrigger) == 0x000188, "Wrong size on UVAL_GameplayEvent_TimerTrigger");
static_assert(offsetof(UVAL_GameplayEvent_TimerTrigger, TimerEventType) == 0x000168, "Member 'UVAL_GameplayEvent_TimerTrigger::TimerEventType' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_TimerTrigger, TimerDefinition) == 0x000170, "Member 'UVAL_GameplayEvent_TimerTrigger::TimerDefinition' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_TimerTrigger, MsElapsed) == 0x000178, "Member 'UVAL_GameplayEvent_TimerTrigger::MsElapsed' has a wrong offset!");
static_assert(offsetof(UVAL_GameplayEvent_TimerTrigger, MsRemaining) == 0x000180, "Member 'UVAL_GameplayEvent_TimerTrigger::MsRemaining' has a wrong offset!");

// Class Palia.VAL_DismissConditionDef
// 0x0000 (0x0030 - 0x0030)
class UVAL_DismissConditionDef : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DismissConditionDef">();
	}
	static class UVAL_DismissConditionDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DismissConditionDef>();
	}
};
static_assert(alignof(UVAL_DismissConditionDef) == 0x000008, "Wrong alignment on UVAL_DismissConditionDef");
static_assert(sizeof(UVAL_DismissConditionDef) == 0x000030, "Wrong size on UVAL_DismissConditionDef");

// Class Palia.MusicSubsystem
// 0x0070 (0x00A0 - 0x0030)
class UMusicSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnNoteStart;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnNoteStop;                                        // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnNotePlayed;                                      // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnNotesCleared;                                    // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSongMatchChanged;                                // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSongStop;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSongPlayed;                                      // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	bool AddNote(class AValeriaPlayerController* Player, int32 NoteValue);
	void ClearNotes(class AValeriaPlayerController* Player);
	void DisableInputs(class AValeriaPlayerController* Player);
	void EnableInputs(class AValeriaPlayerController* Player);
	void GetDisplayInfo(class AValeriaPlayerController* Player, TArray<class UInstrumentSongConfig*>* Infos);
	void NoteEvent__DelegateSignature(class AValeriaPlayerController* Vpc, int32 NoteIdx);
	void NotePlayed__DelegateSignature(int32 NoteIdx, int32 NoteValue);
	void SimpleMusicNotify__DelegateSignature(struct FMusicState& MusicState);
	void SongPlayed__DelegateSignature(class AValeriaPlayerController* Vpc, const struct FGameplayTag& Tag);
	void UserDone(class AValeriaPlayerController* Player);

	bool MatchesSong(class AValeriaPlayerController* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicSubsystem">();
	}
	static class UMusicSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicSubsystem>();
	}
};
static_assert(alignof(UMusicSubsystem) == 0x000008, "Wrong alignment on UMusicSubsystem");
static_assert(sizeof(UMusicSubsystem) == 0x0000A0, "Wrong size on UMusicSubsystem");
static_assert(offsetof(UMusicSubsystem, OnNoteStart) == 0x000030, "Member 'UMusicSubsystem::OnNoteStart' has a wrong offset!");
static_assert(offsetof(UMusicSubsystem, OnNoteStop) == 0x000040, "Member 'UMusicSubsystem::OnNoteStop' has a wrong offset!");
static_assert(offsetof(UMusicSubsystem, OnNotePlayed) == 0x000050, "Member 'UMusicSubsystem::OnNotePlayed' has a wrong offset!");
static_assert(offsetof(UMusicSubsystem, OnNotesCleared) == 0x000060, "Member 'UMusicSubsystem::OnNotesCleared' has a wrong offset!");
static_assert(offsetof(UMusicSubsystem, OnSongMatchChanged) == 0x000070, "Member 'UMusicSubsystem::OnSongMatchChanged' has a wrong offset!");
static_assert(offsetof(UMusicSubsystem, OnSongStop) == 0x000080, "Member 'UMusicSubsystem::OnSongStop' has a wrong offset!");
static_assert(offsetof(UMusicSubsystem, OnSongPlayed) == 0x000090, "Member 'UMusicSubsystem::OnSongPlayed' has a wrong offset!");

// Class Palia.VAL_KeypressTimeoutDismiss
// 0x0008 (0x0038 - 0x0030)
class UVAL_KeypressTimeoutDismiss final : public UVAL_DismissConditionDef
{
public:
	bool                                          bAllowTimeoutDismiss;                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D4[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeoutDurationSeconds;                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_KeypressTimeoutDismiss">();
	}
	static class UVAL_KeypressTimeoutDismiss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_KeypressTimeoutDismiss>();
	}
};
static_assert(alignof(UVAL_KeypressTimeoutDismiss) == 0x000008, "Wrong alignment on UVAL_KeypressTimeoutDismiss");
static_assert(sizeof(UVAL_KeypressTimeoutDismiss) == 0x000038, "Wrong size on UVAL_KeypressTimeoutDismiss");
static_assert(offsetof(UVAL_KeypressTimeoutDismiss, bAllowTimeoutDismiss) == 0x000030, "Member 'UVAL_KeypressTimeoutDismiss::bAllowTimeoutDismiss' has a wrong offset!");
static_assert(offsetof(UVAL_KeypressTimeoutDismiss, TimeoutDurationSeconds) == 0x000034, "Member 'UVAL_KeypressTimeoutDismiss::TimeoutDurationSeconds' has a wrong offset!");

// Class Palia.VAL_DismissGameAction
// 0x0020 (0x0050 - 0x0030)
class UVAL_DismissGameAction final : public UVAL_DismissConditionDef
{
public:
	class FText                                   DismissText;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UVAL_GameplayConditionDef*              Condition;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DismissGameAction">();
	}
	static class UVAL_DismissGameAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DismissGameAction>();
	}
};
static_assert(alignof(UVAL_DismissGameAction) == 0x000008, "Wrong alignment on UVAL_DismissGameAction");
static_assert(sizeof(UVAL_DismissGameAction) == 0x000050, "Wrong size on UVAL_DismissGameAction");
static_assert(offsetof(UVAL_DismissGameAction, DismissText) == 0x000030, "Member 'UVAL_DismissGameAction::DismissText' has a wrong offset!");
static_assert(offsetof(UVAL_DismissGameAction, Condition) == 0x000048, "Member 'UVAL_DismissGameAction::Condition' has a wrong offset!");

// Class Palia.MetaConfigsManager
// 0x0030 (0x0068 - 0x0038)
class UMetaConfigsManager final : public UDeveloperSettings
{
public:
	class FString                                 MetaBaseURIDomain;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MetaCertURIDomain;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameVersionSuffix;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaConfigsManager">();
	}
	static class UMetaConfigsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaConfigsManager>();
	}
};
static_assert(alignof(UMetaConfigsManager) == 0x000008, "Wrong alignment on UMetaConfigsManager");
static_assert(sizeof(UMetaConfigsManager) == 0x000068, "Wrong size on UMetaConfigsManager");
static_assert(offsetof(UMetaConfigsManager, MetaBaseURIDomain) == 0x000038, "Member 'UMetaConfigsManager::MetaBaseURIDomain' has a wrong offset!");
static_assert(offsetof(UMetaConfigsManager, MetaCertURIDomain) == 0x000048, "Member 'UMetaConfigsManager::MetaCertURIDomain' has a wrong offset!");
static_assert(offsetof(UMetaConfigsManager, GameVersionSuffix) == 0x000058, "Member 'UMetaConfigsManager::GameVersionSuffix' has a wrong offset!");

// Class Palia.VAL_PopupBehaviorDef
// 0x0000 (0x0030 - 0x0030)
class UVAL_PopupBehaviorDef : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PopupBehaviorDef">();
	}
	static class UVAL_PopupBehaviorDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PopupBehaviorDef>();
	}
};
static_assert(alignof(UVAL_PopupBehaviorDef) == 0x000008, "Wrong alignment on UVAL_PopupBehaviorDef");
static_assert(sizeof(UVAL_PopupBehaviorDef) == 0x000030, "Wrong size on UVAL_PopupBehaviorDef");

// Class Palia.VAL_DescriptivePopupType
// 0x0018 (0x0048 - 0x0030)
class UVAL_DescriptivePopupType final : public UVAL_PopupBehaviorDef
{
public:
	TArray<struct FPopupPageInfo>                 PopupPages;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EModalHorizontalAlignment                     PopupAlignment;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D5[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DescriptivePopupType">();
	}
	static class UVAL_DescriptivePopupType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DescriptivePopupType>();
	}
};
static_assert(alignof(UVAL_DescriptivePopupType) == 0x000008, "Wrong alignment on UVAL_DescriptivePopupType");
static_assert(sizeof(UVAL_DescriptivePopupType) == 0x000048, "Wrong size on UVAL_DescriptivePopupType");
static_assert(offsetof(UVAL_DescriptivePopupType, PopupPages) == 0x000030, "Member 'UVAL_DescriptivePopupType::PopupPages' has a wrong offset!");
static_assert(offsetof(UVAL_DescriptivePopupType, PopupAlignment) == 0x000040, "Member 'UVAL_DescriptivePopupType::PopupAlignment' has a wrong offset!");

// Class Palia.OutOfBoundsHandler_Base
// 0x0008 (0x02B0 - 0x02A8)
class AOutOfBoundsHandler_Base : public AActor
{
public:
	float                                         GeometryCollisionHeight;                           // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D6[0x4];                                     // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Debug_HandleTestTeleportLocationValitity();
	void TestTeleportLocationsForValidity(TArray<class AActor*>& TeleportActors);
	bool TryTeleportPawn(class AValeriaMoveablePawn* MoveablePawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutOfBoundsHandler_Base">();
	}
	static class AOutOfBoundsHandler_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutOfBoundsHandler_Base>();
	}
};
static_assert(alignof(AOutOfBoundsHandler_Base) == 0x000008, "Wrong alignment on AOutOfBoundsHandler_Base");
static_assert(sizeof(AOutOfBoundsHandler_Base) == 0x0002B0, "Wrong size on AOutOfBoundsHandler_Base");
static_assert(offsetof(AOutOfBoundsHandler_Base, GeometryCollisionHeight) == 0x0002A8, "Member 'AOutOfBoundsHandler_Base::GeometryCollisionHeight' has a wrong offset!");

// Class Palia.OutOfBoundsHandler_Spline
// 0x0068 (0x0318 - 0x02B0)
class AOutOfBoundsHandler_Spline : public AOutOfBoundsHandler_Base
{
public:
	TArray<class AActor*>                         TeleportActors;                                    // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D8[0x50];                                    // 0x02C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Debug_HandleShowOOBTeleportLocations(bool bShow);
	void HandleSplineBeginOverlap(class AValeriaCharacter* CollidingCharacter, float CollisionStartTime);
	void HandleSplineBeginOverlap_Internal(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool FromSweep, struct FHitResult& SweepResult);
	void HandleSplineEndOverlap(class AValeriaCharacter* CollidingCharacter, float CollisionStartTime);
	void HandleSplineEndOverlap_Internal(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutOfBoundsHandler_Spline">();
	}
	static class AOutOfBoundsHandler_Spline* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutOfBoundsHandler_Spline>();
	}
};
static_assert(alignof(AOutOfBoundsHandler_Spline) == 0x000008, "Wrong alignment on AOutOfBoundsHandler_Spline");
static_assert(sizeof(AOutOfBoundsHandler_Spline) == 0x000318, "Wrong size on AOutOfBoundsHandler_Spline");
static_assert(offsetof(AOutOfBoundsHandler_Spline, TeleportActors) == 0x0002B0, "Member 'AOutOfBoundsHandler_Spline::TeleportActors' has a wrong offset!");
static_assert(offsetof(AOutOfBoundsHandler_Spline, SplineComponent) == 0x0002C0, "Member 'AOutOfBoundsHandler_Spline::SplineComponent' has a wrong offset!");

// Class Palia.VAL_AlignedPopupType
// 0x0070 (0x00A0 - 0x0030)
class UVAL_AlignedPopupType final : public UVAL_PopupBehaviorDef
{
public:
	EGameplayPopupType                            GameplayPopupType;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26DD[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPopupPageInfo                         PopupInfo;                                         // 0x0038(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EModalHorizontalAlignment                     PopupHorizontalAlignment;                          // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModalVerticalAlignment                       PopupVerticalAlignment;                            // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26DE[0x6];                                     // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_DismissConditionDef*               DismissType;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AlignedPopupType">();
	}
	static class UVAL_AlignedPopupType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AlignedPopupType>();
	}
};
static_assert(alignof(UVAL_AlignedPopupType) == 0x000008, "Wrong alignment on UVAL_AlignedPopupType");
static_assert(sizeof(UVAL_AlignedPopupType) == 0x0000A0, "Wrong size on UVAL_AlignedPopupType");
static_assert(offsetof(UVAL_AlignedPopupType, GameplayPopupType) == 0x000030, "Member 'UVAL_AlignedPopupType::GameplayPopupType' has a wrong offset!");
static_assert(offsetof(UVAL_AlignedPopupType, PopupInfo) == 0x000038, "Member 'UVAL_AlignedPopupType::PopupInfo' has a wrong offset!");
static_assert(offsetof(UVAL_AlignedPopupType, PopupHorizontalAlignment) == 0x000090, "Member 'UVAL_AlignedPopupType::PopupHorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UVAL_AlignedPopupType, PopupVerticalAlignment) == 0x000091, "Member 'UVAL_AlignedPopupType::PopupVerticalAlignment' has a wrong offset!");
static_assert(offsetof(UVAL_AlignedPopupType, DismissType) == 0x000098, "Member 'UVAL_AlignedPopupType::DismissType' has a wrong offset!");

// Class Palia.VAL_AnchoredPopupType
// 0x0078 (0x00A8 - 0x0030)
class UVAL_AnchoredPopupType final : public UVAL_PopupBehaviorDef
{
public:
	struct FPopupPageInfo                         PopupInfo;                                         // 0x0030(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                AnchorWidget;                                      // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PopupScreenPosition;                               // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAL_DismissConditionDef*               DismissType;                                       // 0x00A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AnchoredPopupType">();
	}
	static class UVAL_AnchoredPopupType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AnchoredPopupType>();
	}
};
static_assert(alignof(UVAL_AnchoredPopupType) == 0x000008, "Wrong alignment on UVAL_AnchoredPopupType");
static_assert(sizeof(UVAL_AnchoredPopupType) == 0x0000A8, "Wrong size on UVAL_AnchoredPopupType");
static_assert(offsetof(UVAL_AnchoredPopupType, PopupInfo) == 0x000030, "Member 'UVAL_AnchoredPopupType::PopupInfo' has a wrong offset!");
static_assert(offsetof(UVAL_AnchoredPopupType, AnchorWidget) == 0x000088, "Member 'UVAL_AnchoredPopupType::AnchorWidget' has a wrong offset!");
static_assert(offsetof(UVAL_AnchoredPopupType, PopupScreenPosition) == 0x000090, "Member 'UVAL_AnchoredPopupType::PopupScreenPosition' has a wrong offset!");
static_assert(offsetof(UVAL_AnchoredPopupType, DismissType) == 0x0000A0, "Member 'UVAL_AnchoredPopupType::DismissType' has a wrong offset!");

// Class Palia.ParticipationTrackingComponent
// 0x0050 (0x00F0 - 0x00A0)
class UParticipationTrackingComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnParticipantsReplicated;                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ValidParticipationTypes;                           // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           DefaultParticipationType;                          // 0x00C0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FParticipant>                   ParticipantList;                                   // 0x00C8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          bAlwaysAddHomeOwnerToParticipantList;              // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26DF[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticipationTrackingComponent*> LinkedParticipationComponents;                     // 0x00E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddParticipant(class AActor* Actor);
	void AddParticipantForType(class AActor* Actor, struct FGameplayTag& ParticipationType);
	void ClearParticipants();
	void ClearParticipantsForType(struct FGameplayTag& ParticipationType);
	void LinkParticipationTrackingComponent(class UParticipationTrackingComponent* ComponentToLink);
	void OnRep_ParticipantList();
	void RemoveParticipant(class AActor* Actor);
	void RemoveParticipantForType(class AActor* Actor, struct FGameplayTag& ParticipationType);

	void GetParticipantActors(TArray<class AActor*>* OutActorList) const;
	void GetParticipantActorsForType(struct FGameplayTag& ParticipationType, TArray<class AActor*>* OutActorList) const;
	void GetParticipantList(TArray<struct FParticipant>* OutParticipantList) const;
	void GetParticipantsForType(struct FGameplayTag& ParticipationType, TArray<struct FParticipant>* OutParticipantList) const;
	bool IsParticipant(class AActor* Actor) const;
	bool IsParticipantForType(class AActor* Actor, struct FGameplayTag& ParticipationType) const;
	bool IsParticipationTypeValid(struct FGameplayTag& ParticipationType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticipationTrackingComponent">();
	}
	static class UParticipationTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticipationTrackingComponent>();
	}
};
static_assert(alignof(UParticipationTrackingComponent) == 0x000008, "Wrong alignment on UParticipationTrackingComponent");
static_assert(sizeof(UParticipationTrackingComponent) == 0x0000F0, "Wrong size on UParticipationTrackingComponent");
static_assert(offsetof(UParticipationTrackingComponent, OnParticipantsReplicated) == 0x0000A0, "Member 'UParticipationTrackingComponent::OnParticipantsReplicated' has a wrong offset!");
static_assert(offsetof(UParticipationTrackingComponent, ValidParticipationTypes) == 0x0000B0, "Member 'UParticipationTrackingComponent::ValidParticipationTypes' has a wrong offset!");
static_assert(offsetof(UParticipationTrackingComponent, DefaultParticipationType) == 0x0000C0, "Member 'UParticipationTrackingComponent::DefaultParticipationType' has a wrong offset!");
static_assert(offsetof(UParticipationTrackingComponent, ParticipantList) == 0x0000C8, "Member 'UParticipationTrackingComponent::ParticipantList' has a wrong offset!");
static_assert(offsetof(UParticipationTrackingComponent, bAlwaysAddHomeOwnerToParticipantList) == 0x0000D8, "Member 'UParticipationTrackingComponent::bAlwaysAddHomeOwnerToParticipantList' has a wrong offset!");
static_assert(offsetof(UParticipationTrackingComponent, LinkedParticipationComponents) == 0x0000E0, "Member 'UParticipationTrackingComponent::LinkedParticipationComponents' has a wrong offset!");

// Class Palia.GameplayInteractivePopupDataAsset
// 0x0008 (0x0060 - 0x0058)
class UGameplayInteractivePopupDataAsset final : public UVAL_DataAsset
{
public:
	class UVAL_PopupBehaviorDef*                  GameplayPopupBehavoir;                             // 0x0058(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static TSoftObjectPtr<class UGameplayInteractivePopupDataAsset> GetAssetByName_Cast(class FName& AssetName);
	static TSoftObjectPtr<class UGameplayInteractivePopupDataAsset> GetAssetByPersistId_Cast(int32 PersistIdToGet);
	static TArray<TSoftObjectPtr<class UGameplayInteractivePopupDataAsset>> GetAssetsOfType_Cast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayInteractivePopupDataAsset">();
	}
	static class UGameplayInteractivePopupDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayInteractivePopupDataAsset>();
	}
};
static_assert(alignof(UGameplayInteractivePopupDataAsset) == 0x000008, "Wrong alignment on UGameplayInteractivePopupDataAsset");
static_assert(sizeof(UGameplayInteractivePopupDataAsset) == 0x000060, "Wrong size on UGameplayInteractivePopupDataAsset");
static_assert(offsetof(UGameplayInteractivePopupDataAsset, GameplayPopupBehavoir) == 0x000058, "Member 'UGameplayInteractivePopupDataAsset::GameplayPopupBehavoir' has a wrong offset!");

// Class Palia.GameServerGlobalConfig
// 0x0028 (0x0058 - 0x0030)
class UGameServerGlobalConfig final : public UDataAsset
{
public:
	struct FCreatureOptimizations                 CreatureOptimizations;                             // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SecondsBeforeServerConnectionError;                // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E4[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ServerConnectionLostErrorText;                     // 0x0040(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameServerGlobalConfig">();
	}
	static class UGameServerGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameServerGlobalConfig>();
	}
};
static_assert(alignof(UGameServerGlobalConfig) == 0x000008, "Wrong alignment on UGameServerGlobalConfig");
static_assert(sizeof(UGameServerGlobalConfig) == 0x000058, "Wrong size on UGameServerGlobalConfig");
static_assert(offsetof(UGameServerGlobalConfig, CreatureOptimizations) == 0x000030, "Member 'UGameServerGlobalConfig::CreatureOptimizations' has a wrong offset!");
static_assert(offsetof(UGameServerGlobalConfig, SecondsBeforeServerConnectionError) == 0x000038, "Member 'UGameServerGlobalConfig::SecondsBeforeServerConnectionError' has a wrong offset!");
static_assert(offsetof(UGameServerGlobalConfig, ServerConnectionLostErrorText) == 0x000040, "Member 'UGameServerGlobalConfig::ServerConnectionLostErrorText' has a wrong offset!");

// Class Palia.PaliaLightingGroup
// 0x0078 (0x0320 - 0x02A8)
class APaliaLightingGroup final : public AActor
{
public:
	class USceneComponent*                        LowRoot;                                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MedRoot;                                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        HighRoot;                                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FLightingGroupSettings>    QualitySettings;                                   // 0x02C0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_26E5[0x10];                                    // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyComponentRestrictions(const TArray<class USceneComponent*>& Components, int32 Quality);
	void OnDetailModeChanged(int32 NewDetailMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaliaLightingGroup">();
	}
	static class APaliaLightingGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<APaliaLightingGroup>();
	}
};
static_assert(alignof(APaliaLightingGroup) == 0x000008, "Wrong alignment on APaliaLightingGroup");
static_assert(sizeof(APaliaLightingGroup) == 0x000320, "Wrong size on APaliaLightingGroup");
static_assert(offsetof(APaliaLightingGroup, LowRoot) == 0x0002A8, "Member 'APaliaLightingGroup::LowRoot' has a wrong offset!");
static_assert(offsetof(APaliaLightingGroup, MedRoot) == 0x0002B0, "Member 'APaliaLightingGroup::MedRoot' has a wrong offset!");
static_assert(offsetof(APaliaLightingGroup, HighRoot) == 0x0002B8, "Member 'APaliaLightingGroup::HighRoot' has a wrong offset!");
static_assert(offsetof(APaliaLightingGroup, QualitySettings) == 0x0002C0, "Member 'APaliaLightingGroup::QualitySettings' has a wrong offset!");

// Class Palia.GardenComponent
// 0x01A0 (0x0440 - 0x02A0)
class UGardenComponent final : public USceneComponent
{
public:
	uint8                                         Pad_26E7[0x18];                                    // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFertilizerAdded;                                 // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHarvest;                                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLootGathered;                                    // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLootUncovered;                                   // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSeeded;                                          // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTilled;                                          // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTilledPartial;                                   // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWaterAdded;                                      // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWatered;                                         // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeedRemoved;                                     // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E8[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGatherableComponent*                   CachedParentGatherable;                            // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGardenTile>                GardenPlotBlueprint;                               // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    GardenConfigRowHandle;                             // 0x0370(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AGardenTile*>                    GardenTilesSpawned;                                // 0x0380(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGardenPlot>                    Plots;                                             // 0x0390(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_26E9[0x28];                                    // 0x03A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RowSize;                                           // 0x03C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ColSize;                                           // 0x03CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26EA[0x10];                                    // 0x03D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int8                                          FreshSpawn;                                        // 0x03E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26EB[0x5F];                                    // 0x03E1(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorMoved(class UPersistComponent* Persist);
	void OnRep_Plots(const TArray<struct FGardenPlot>& PreReplicatedPlots);
	void PrepareToBeGathered(class UGatherableComponent* GatherableComponent, class AValeriaCharacter* Character);
	void RpcClient_PlotMoved();
	void Server_TriggerDestroyCrop(class AValeriaCharacter* Character, int32 PlotIndex);
	void TriggerHarvest(class AValeriaCharacter* VC, int32 PlotIndex);

	bool CanPickupPlot(class AValeriaCharacter* Character) const;
	class AGardenTile* GetGardenTile(int32 TileIndex) const;
	class UGardenManagementComponent* GetManagement() const;
	struct FVector GetTileWorldLocation(int32 TileIndex) const;
	float GetWateredPercent(int32 TileIndex) const;
	bool HasOverlappingMultiTilePlants(class UVAL_ItemTypeDefinitionAsset** OutBlockingPlantItemType) const;
	bool IsAnySeedablePlot() const;
	bool IsNewlySpawned() const;
	bool IsPlanted(int32 TileIndex) const;
	bool IsWatered(int32 TileIndex) const;
	struct FNotification ShouldBlockGathering(class AValeriaCharacter* Character) const;
	struct FNotification ShouldBlockMovement(class AValeriaCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenComponent">();
	}
	static class UGardenComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenComponent>();
	}
};
static_assert(alignof(UGardenComponent) == 0x000010, "Wrong alignment on UGardenComponent");
static_assert(sizeof(UGardenComponent) == 0x000440, "Wrong size on UGardenComponent");
static_assert(offsetof(UGardenComponent, OnFertilizerAdded) == 0x0002B8, "Member 'UGardenComponent::OnFertilizerAdded' has a wrong offset!");
static_assert(offsetof(UGardenComponent, OnHarvest) == 0x0002C8, "Member 'UGardenComponent::OnHarvest' has a wrong offset!");
static_assert(offsetof(UGardenComponent, OnLootGathered) == 0x0002D8, "Member 'UGardenComponent::OnLootGathered' has a wrong offset!");
static_assert(offsetof(UGardenComponent, OnLootUncovered) == 0x0002E8, "Member 'UGardenComponent::OnLootUncovered' has a wrong offset!");
static_assert(offsetof(UGardenComponent, OnSeeded) == 0x0002F8, "Member 'UGardenComponent::OnSeeded' has a wrong offset!");
static_assert(offsetof(UGardenComponent, OnTilled) == 0x000308, "Member 'UGardenComponent::OnTilled' has a wrong offset!");
static_assert(offsetof(UGardenComponent, OnTilledPartial) == 0x000318, "Member 'UGardenComponent::OnTilledPartial' has a wrong offset!");
static_assert(offsetof(UGardenComponent, OnWaterAdded) == 0x000328, "Member 'UGardenComponent::OnWaterAdded' has a wrong offset!");
static_assert(offsetof(UGardenComponent, OnWatered) == 0x000338, "Member 'UGardenComponent::OnWatered' has a wrong offset!");
static_assert(offsetof(UGardenComponent, OnWeedRemoved) == 0x000348, "Member 'UGardenComponent::OnWeedRemoved' has a wrong offset!");
static_assert(offsetof(UGardenComponent, CachedParentGatherable) == 0x000360, "Member 'UGardenComponent::CachedParentGatherable' has a wrong offset!");
static_assert(offsetof(UGardenComponent, GardenPlotBlueprint) == 0x000368, "Member 'UGardenComponent::GardenPlotBlueprint' has a wrong offset!");
static_assert(offsetof(UGardenComponent, GardenConfigRowHandle) == 0x000370, "Member 'UGardenComponent::GardenConfigRowHandle' has a wrong offset!");
static_assert(offsetof(UGardenComponent, GardenTilesSpawned) == 0x000380, "Member 'UGardenComponent::GardenTilesSpawned' has a wrong offset!");
static_assert(offsetof(UGardenComponent, Plots) == 0x000390, "Member 'UGardenComponent::Plots' has a wrong offset!");
static_assert(offsetof(UGardenComponent, RowSize) == 0x0003C8, "Member 'UGardenComponent::RowSize' has a wrong offset!");
static_assert(offsetof(UGardenComponent, ColSize) == 0x0003CC, "Member 'UGardenComponent::ColSize' has a wrong offset!");
static_assert(offsetof(UGardenComponent, FreshSpawn) == 0x0003E0, "Member 'UGardenComponent::FreshSpawn' has a wrong offset!");

// Class Palia.GardeningGlobalConfig
// 0x0520 (0x0550 - 0x0030)
class UGardeningGlobalConfig final : public UDataAsset
{
public:
	struct FGardeningCompanionConfig              CompanionConfig;                                   // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGardeningFertilizingGlobalConfig      FertilizerConfig;                                  // 0x0080(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGardeningHarvestConfig                HarvestConfig;                                     // 0x00B8(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGardeningSeedingGlobalConfig          SeedingConfig;                                     // 0x00F0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGardeningTillingGlobalConfig          TillingConfig;                                     // 0x0150(0x01F8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGardeningWateringConfig               WateringConfig;                                    // 0x0348(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGardeningWeedingGlobalConfig          WeedingConfig;                                     // 0x0358(0x01E8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlantGrowthPlayerAutoTagRoot;                      // 0x0540(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGardeningDebugConfig                  DebugConfig;                                       // 0x0548(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardeningGlobalConfig">();
	}
	static class UGardeningGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardeningGlobalConfig>();
	}
};
static_assert(alignof(UGardeningGlobalConfig) == 0x000008, "Wrong alignment on UGardeningGlobalConfig");
static_assert(sizeof(UGardeningGlobalConfig) == 0x000550, "Wrong size on UGardeningGlobalConfig");
static_assert(offsetof(UGardeningGlobalConfig, CompanionConfig) == 0x000030, "Member 'UGardeningGlobalConfig::CompanionConfig' has a wrong offset!");
static_assert(offsetof(UGardeningGlobalConfig, FertilizerConfig) == 0x000080, "Member 'UGardeningGlobalConfig::FertilizerConfig' has a wrong offset!");
static_assert(offsetof(UGardeningGlobalConfig, HarvestConfig) == 0x0000B8, "Member 'UGardeningGlobalConfig::HarvestConfig' has a wrong offset!");
static_assert(offsetof(UGardeningGlobalConfig, SeedingConfig) == 0x0000F0, "Member 'UGardeningGlobalConfig::SeedingConfig' has a wrong offset!");
static_assert(offsetof(UGardeningGlobalConfig, TillingConfig) == 0x000150, "Member 'UGardeningGlobalConfig::TillingConfig' has a wrong offset!");
static_assert(offsetof(UGardeningGlobalConfig, WateringConfig) == 0x000348, "Member 'UGardeningGlobalConfig::WateringConfig' has a wrong offset!");
static_assert(offsetof(UGardeningGlobalConfig, WeedingConfig) == 0x000358, "Member 'UGardeningGlobalConfig::WeedingConfig' has a wrong offset!");
static_assert(offsetof(UGardeningGlobalConfig, PlantGrowthPlayerAutoTagRoot) == 0x000540, "Member 'UGardeningGlobalConfig::PlantGrowthPlayerAutoTagRoot' has a wrong offset!");
static_assert(offsetof(UGardeningGlobalConfig, DebugConfig) == 0x000548, "Member 'UGardeningGlobalConfig::DebugConfig' has a wrong offset!");

// Class Palia.NiagaraComponent_GPUAudioSupport
// 0x0020 (0x0830 - 0x0810)
class UNiagaraComponent_GPUAudioSupport final : public UNiagaraComponent
{
public:
	uint8                                         Pad_26F4[0x8];                                     // 0x0810(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAkAudioEvent*>                  AkEvents;                                          // 0x0818(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F5[0x8];                                     // 0x0828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraComponent_GPUAudioSupport">();
	}
	static class UNiagaraComponent_GPUAudioSupport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraComponent_GPUAudioSupport>();
	}
};
static_assert(alignof(UNiagaraComponent_GPUAudioSupport) == 0x000010, "Wrong alignment on UNiagaraComponent_GPUAudioSupport");
static_assert(sizeof(UNiagaraComponent_GPUAudioSupport) == 0x000830, "Wrong size on UNiagaraComponent_GPUAudioSupport");
static_assert(offsetof(UNiagaraComponent_GPUAudioSupport, AkEvents) == 0x000818, "Member 'UNiagaraComponent_GPUAudioSupport::AkEvents' has a wrong offset!");

// Class Palia.GardenManagementComponent
// 0x0188 (0x0228 - 0x00A0)
class UGardenManagementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_26F6[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHarvestReady;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHasWaterable;                                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F7[0x20];                                    // 0x00C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Persist_DebugDaysTimeWarped;                       // 0x00E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26F8[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlantSerializer                       PlantSerializer;                                   // 0x00F0(0x0120)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26F9[0x18];                                    // 0x0210(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Plants();
	void RpcClient_NotifyHealthChanged(int32 TileId, class AActor* InstigatingPlayer, int32 HealthChange, int32 NewHealth);
	void UpdateGardensBasedOnCurrentWeather();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenManagementComponent">();
	}
	static class UGardenManagementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenManagementComponent>();
	}
};
static_assert(alignof(UGardenManagementComponent) == 0x000008, "Wrong alignment on UGardenManagementComponent");
static_assert(sizeof(UGardenManagementComponent) == 0x000228, "Wrong size on UGardenManagementComponent");
static_assert(offsetof(UGardenManagementComponent, OnHarvestReady) == 0x0000A8, "Member 'UGardenManagementComponent::OnHarvestReady' has a wrong offset!");
static_assert(offsetof(UGardenManagementComponent, OnHasWaterable) == 0x0000B8, "Member 'UGardenManagementComponent::OnHasWaterable' has a wrong offset!");
static_assert(offsetof(UGardenManagementComponent, Persist_DebugDaysTimeWarped) == 0x0000E8, "Member 'UGardenManagementComponent::Persist_DebugDaysTimeWarped' has a wrong offset!");
static_assert(offsetof(UGardenManagementComponent, PlantSerializer) == 0x0000F0, "Member 'UGardenManagementComponent::PlantSerializer' has a wrong offset!");

// Class Palia.GardenPlantingComponent
// 0x0140 (0x01E0 - 0x00A0)
class UGardenPlantingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_26FB[0x58];                                    // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHasHarvestablePlant;                             // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHasUnwateredPlant;                               // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeedRemovalStarted;                              // 0x0118(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeedRemovalEnded;                                // 0x0128(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSeedPlantingStateChanged;                        // 0x0138(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<class AGardenTile*>                    GardenTiles;                                       // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AGardenTile*                            GardenTile;                                        // 0x0158(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26FC[0x20];                                    // 0x0160(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      CachedVC;                                          // 0x0180(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGardenTile*                            LastPlotUnderCursor;                               // 0x0188(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGardenTile*>                    MultiTileAdjacentActors;                           // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26FD[0x40];                                    // 0x01A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ChangeSeedPlantingState(bool bIsSeedPlantingActive);
	void Client_EndWeedRemoval();
	void Client_StartWeedRemoval();
	bool HasWaterInCan(struct FValeriaItem& Item, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 AmountToUse);
	struct FSelfUseEventResult OnClientUseEquippedInward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	struct FSelfUseEventResult OnClientUseEquippedOutward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnHarvestReady(class AGardenTile* PGardenTile);
	void OnHasWaterable(class AGardenTile* PGardenTile);
	void OnStateChanged(class UCharacterStateMachineComponent* Csm, const struct FCharacterStateChangeParams& Params_0);
	void OnTeleported(class AValeriaPlayerController* Vpc);
	void RegisterForOnHasHarvestablePlant();
	void RegisterForOnHasUnwateredPlant();
	void RpcClient_ChangeSeedPlantingState(bool bIsSeedPlantingActive);
	void RpcServer_ClearClientTargetSpot();
	void RpcServer_SetClientTargetSpot(const struct FVector& TargetLocation);
	void RpcServer_UseWaterFromCan(struct FBagSlotLocation& CanLocation, int32 Amount);
	void RpcServerCheat_GiveOwnerAllSeeds();
	void RpcServerCheat_PlantAllSeeds();
	void Server_RefillWateringCan(struct FBagSlotLocation& CanLocation);
	void UnregisterForOnHasHarvestablePlant();
	void UnregisterForOnHasUnwateredPlant();
	void UseWaterFromCan(struct FBagSlotLocation& InventoryLocation, int32 Amount);

	bool GetDesiredCharacterYaw(float* OutYaw) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenPlantingComponent">();
	}
	static class UGardenPlantingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenPlantingComponent>();
	}
};
static_assert(alignof(UGardenPlantingComponent) == 0x000008, "Wrong alignment on UGardenPlantingComponent");
static_assert(sizeof(UGardenPlantingComponent) == 0x0001E0, "Wrong size on UGardenPlantingComponent");
static_assert(offsetof(UGardenPlantingComponent, OnHasHarvestablePlant) == 0x0000F8, "Member 'UGardenPlantingComponent::OnHasHarvestablePlant' has a wrong offset!");
static_assert(offsetof(UGardenPlantingComponent, OnHasUnwateredPlant) == 0x000108, "Member 'UGardenPlantingComponent::OnHasUnwateredPlant' has a wrong offset!");
static_assert(offsetof(UGardenPlantingComponent, OnWeedRemovalStarted) == 0x000118, "Member 'UGardenPlantingComponent::OnWeedRemovalStarted' has a wrong offset!");
static_assert(offsetof(UGardenPlantingComponent, OnWeedRemovalEnded) == 0x000128, "Member 'UGardenPlantingComponent::OnWeedRemovalEnded' has a wrong offset!");
static_assert(offsetof(UGardenPlantingComponent, OnSeedPlantingStateChanged) == 0x000138, "Member 'UGardenPlantingComponent::OnSeedPlantingStateChanged' has a wrong offset!");
static_assert(offsetof(UGardenPlantingComponent, GardenTiles) == 0x000148, "Member 'UGardenPlantingComponent::GardenTiles' has a wrong offset!");
static_assert(offsetof(UGardenPlantingComponent, GardenTile) == 0x000158, "Member 'UGardenPlantingComponent::GardenTile' has a wrong offset!");
static_assert(offsetof(UGardenPlantingComponent, CachedVC) == 0x000180, "Member 'UGardenPlantingComponent::CachedVC' has a wrong offset!");
static_assert(offsetof(UGardenPlantingComponent, LastPlotUnderCursor) == 0x000188, "Member 'UGardenPlantingComponent::LastPlotUnderCursor' has a wrong offset!");
static_assert(offsetof(UGardenPlantingComponent, MultiTileAdjacentActors) == 0x000190, "Member 'UGardenPlantingComponent::MultiTileAdjacentActors' has a wrong offset!");

// Class Palia.PaliaTimeOfDaySequence
// 0x0028 (0x0050 - 0x0028)
class UPaliaTimeOfDaySequence : public UObject
{
public:
	TArray<struct FS6LightBlendSettings>          LightingStates;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLoopStartAndEndBlend;                             // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2702[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DayNightSequenceTimeMultiplier;                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULightingBaseState*                     BlendedLightingState;                              // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2703[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaliaTimeOfDaySequence">();
	}
	static class UPaliaTimeOfDaySequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaliaTimeOfDaySequence>();
	}
};
static_assert(alignof(UPaliaTimeOfDaySequence) == 0x000008, "Wrong alignment on UPaliaTimeOfDaySequence");
static_assert(sizeof(UPaliaTimeOfDaySequence) == 0x000050, "Wrong size on UPaliaTimeOfDaySequence");
static_assert(offsetof(UPaliaTimeOfDaySequence, LightingStates) == 0x000028, "Member 'UPaliaTimeOfDaySequence::LightingStates' has a wrong offset!");
static_assert(offsetof(UPaliaTimeOfDaySequence, bLoopStartAndEndBlend) == 0x000038, "Member 'UPaliaTimeOfDaySequence::bLoopStartAndEndBlend' has a wrong offset!");
static_assert(offsetof(UPaliaTimeOfDaySequence, DayNightSequenceTimeMultiplier) == 0x00003C, "Member 'UPaliaTimeOfDaySequence::DayNightSequenceTimeMultiplier' has a wrong offset!");
static_assert(offsetof(UPaliaTimeOfDaySequence, BlendedLightingState) == 0x000040, "Member 'UPaliaTimeOfDaySequence::BlendedLightingState' has a wrong offset!");

// Class Palia.GardenTile
// 0x0278 (0x0520 - 0x02A8)
class alignas(0x10) AGardenTile : public AActor
{
public:
	uint8                                         Pad_2704[0x10];                                    // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWaterChanged;                                    // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFullyWatered;                                    // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHarvested;                                       // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PlantingPreviewDelegate;                           // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             StateChanged;                                      // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PlotMeshUnplanted;                                 // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PlantMesh;                                         // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractableCollider;                              // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2705[0x68];                                    // 0x0328(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 Interactable;                                      // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2706[0x8];                                     // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGatherableComponent*                   CachedParentGatherable;                            // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2707[0x8];                                     // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               PlotMeshDynaMaterialInstance;                      // 0x03B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 PlotMeshTillingRenderTarget;                       // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGardenPlotActorInternal               Internal;                                          // 0x03C0(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2708[0x4];                                     // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGardenTileBuffInfo                    GardenTileBuffInfoCache;                           // 0x03D8(0x0040)(Protected, NativeAccessSpecifierProtected)
	struct FGardenTileBuffsCache                  GardenTileBuffsCached;                             // 0x0418(0x0028)(Protected, NativeAccessSpecifierProtected)
	float                                         PlotBoxSize;                                       // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2709[0x4];                                     // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   WeedInteractPromptText;                            // 0x0448(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   HarvestInteractPromptText;                         // 0x0460(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   InventoryFullInteractPromptText;                   // 0x0478(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ExamineInteractPromptText;                         // 0x0490(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_270A[0x60];                                    // 0x04A8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UValeriaGASComponent*                   ValeriaGAS;                                        // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVitalsComponent*                       Vitals;                                            // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaGASAttributeSet*                AttributeSet;                                      // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Client_HandleHealthChanged(class AActor* InstigatingPlayer, int32 HealthChange, int32 NewHealth);
	class UImage* GetMinigameImage();
	TSet<class UFoliageRustleAudioComponent*> GetOverlappingRustleComponents();
	class AGardenTile* GetOwningGardenTile();
	class UGatherableComponent* GetParentGatherable();
	class UVitalsComponent* GetVitals();
	bool HasOverlappingMultiTilePlants(class UVAL_ItemTypeDefinitionAsset** OutBlockingPlantItemType);
	void OnBeginFertilizing(class AValeriaCharacter* Actor, class UVAL_ItemTypeDefinitionAsset* FertilizedItemType);
	void OnBeginSeeding(class AValeriaCharacter* Actor, class UVAL_ItemTypeDefinitionAsset* SeedItemType);
	void OnBeginTilling();
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Param_Interactable, class AValeriaPlayerController* Player, const struct FInteractEventParams& Params_0);
	struct FUseEventResult OnClientUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnFertilized(class UVAL_ItemTypeDefinitionAsset* FertilizedItemType);
	void OnFullyTilled();
	void OnGardenPlotChanged();
	void OnHiddenLootPickedUp();
	void OnHiddenLootUncovered();
	void OnPlantChanged();
	void OnPreviewStateCleared();
	void OnPreviewStateStarted(class UVAL_ItemTypeDefinitionAsset* SeedItemType);
	void OnReadyToHarvest(class UVAL_ItemTypeDefinitionAsset* PlantItemType, bool RepeatHarvest);
	void OnSeeded(class UVAL_ItemTypeDefinitionAsset* SeedItemType);
	void OnSoilChanged();
	void OnUntilled();
	void OnWeedRemoved();
	void OnWeedSprouted(int32 WeedType);
	void Server_DestroyCrop(class AValeriaCharacter* Character);
	void Server_HandleVitalsChanged(class UVitalsComponent* VitalsComponent, const struct FVitalsChange& VitalsChange);
	void Server_NotifyClientsOfHealthChange(class AActor* InstigatingPlayer, int32 HealthChange, int32 NewHealth);
	void UpdateGardenPlotStatus();

	bool CanDestroyCrop(class AValeriaCharacter* Character) const;
	class UAbilitySystemComponent* GetAbilitySystemComponent() const;
	class UValeriaGASAttributeSet* GetAttributeSet() const;
	float GetClampedFertilizerPctgRemaining() const;
	class UGardenComponent* GetGardenParent() const;
	class AActor* GetGardenPatchOwner() const;
	const struct FGardenPlot GetGardenPlot() const;
	void GetPlantCenter(struct FVector2D* OutLocation) const;
	class UTexture2D* GetPlantIcon() const;
	int32 GetPlantSize() const;
	int32 GetPlotIndex() const;
	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	float GetWateredPercent() const;
	int32 GetWeedCount() const;
	bool HasAnyTilling() const;
	bool HasValidGardenData() const;
	bool HasWeeds() const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;
	bool IsPlanted() const;
	bool IsPlantMaster() const;
	bool IsReadyToHarvest() const;
	bool IsTilled() const;
	bool IsWatered() const;
	bool K2_TryGetGardenTileBuffInfo(struct FGardenTileBuffInfo* FertilizerInfo) const;
	bool TryGetReadOnlyGardenData(struct FGardenPlot* OutGardenData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenTile">();
	}
	static class AGardenTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGardenTile>();
	}
};
static_assert(alignof(AGardenTile) == 0x000010, "Wrong alignment on AGardenTile");
static_assert(sizeof(AGardenTile) == 0x000520, "Wrong size on AGardenTile");
static_assert(offsetof(AGardenTile, OnWaterChanged) == 0x0002B8, "Member 'AGardenTile::OnWaterChanged' has a wrong offset!");
static_assert(offsetof(AGardenTile, OnFullyWatered) == 0x0002C8, "Member 'AGardenTile::OnFullyWatered' has a wrong offset!");
static_assert(offsetof(AGardenTile, OnHarvested) == 0x0002D8, "Member 'AGardenTile::OnHarvested' has a wrong offset!");
static_assert(offsetof(AGardenTile, PlantingPreviewDelegate) == 0x0002E8, "Member 'AGardenTile::PlantingPreviewDelegate' has a wrong offset!");
static_assert(offsetof(AGardenTile, StateChanged) == 0x0002F8, "Member 'AGardenTile::StateChanged' has a wrong offset!");
static_assert(offsetof(AGardenTile, Root) == 0x000308, "Member 'AGardenTile::Root' has a wrong offset!");
static_assert(offsetof(AGardenTile, PlotMeshUnplanted) == 0x000310, "Member 'AGardenTile::PlotMeshUnplanted' has a wrong offset!");
static_assert(offsetof(AGardenTile, PlantMesh) == 0x000318, "Member 'AGardenTile::PlantMesh' has a wrong offset!");
static_assert(offsetof(AGardenTile, InteractableCollider) == 0x000320, "Member 'AGardenTile::InteractableCollider' has a wrong offset!");
static_assert(offsetof(AGardenTile, Interactable) == 0x000390, "Member 'AGardenTile::Interactable' has a wrong offset!");
static_assert(offsetof(AGardenTile, CachedParentGatherable) == 0x0003A0, "Member 'AGardenTile::CachedParentGatherable' has a wrong offset!");
static_assert(offsetof(AGardenTile, PlotMeshDynaMaterialInstance) == 0x0003B0, "Member 'AGardenTile::PlotMeshDynaMaterialInstance' has a wrong offset!");
static_assert(offsetof(AGardenTile, PlotMeshTillingRenderTarget) == 0x0003B8, "Member 'AGardenTile::PlotMeshTillingRenderTarget' has a wrong offset!");
static_assert(offsetof(AGardenTile, Internal) == 0x0003C0, "Member 'AGardenTile::Internal' has a wrong offset!");
static_assert(offsetof(AGardenTile, GardenTileBuffInfoCache) == 0x0003D8, "Member 'AGardenTile::GardenTileBuffInfoCache' has a wrong offset!");
static_assert(offsetof(AGardenTile, GardenTileBuffsCached) == 0x000418, "Member 'AGardenTile::GardenTileBuffsCached' has a wrong offset!");
static_assert(offsetof(AGardenTile, PlotBoxSize) == 0x000440, "Member 'AGardenTile::PlotBoxSize' has a wrong offset!");
static_assert(offsetof(AGardenTile, WeedInteractPromptText) == 0x000448, "Member 'AGardenTile::WeedInteractPromptText' has a wrong offset!");
static_assert(offsetof(AGardenTile, HarvestInteractPromptText) == 0x000460, "Member 'AGardenTile::HarvestInteractPromptText' has a wrong offset!");
static_assert(offsetof(AGardenTile, InventoryFullInteractPromptText) == 0x000478, "Member 'AGardenTile::InventoryFullInteractPromptText' has a wrong offset!");
static_assert(offsetof(AGardenTile, ExamineInteractPromptText) == 0x000490, "Member 'AGardenTile::ExamineInteractPromptText' has a wrong offset!");
static_assert(offsetof(AGardenTile, ValeriaGAS) == 0x000508, "Member 'AGardenTile::ValeriaGAS' has a wrong offset!");
static_assert(offsetof(AGardenTile, Vitals) == 0x000510, "Member 'AGardenTile::Vitals' has a wrong offset!");
static_assert(offsetof(AGardenTile, AttributeSet) == 0x000518, "Member 'AGardenTile::AttributeSet' has a wrong offset!");

// Class Palia.GatherableActor
// 0x0020 (0x02C8 - 0x02A8)
class AGatherableActor : public AActor
{
public:
	uint8                                         Pad_2714[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UValeriaGASComponent*                   ValeriaGAS;                                        // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGatherableLootVitalsComponent*         Vitals;                                            // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaGASAttributeSet*                AttributeSet;                                      // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UVitalsComponent* GetVitals();
	void Server_SendGatherablePlacedEvent();

	class UAbilitySystemComponent* GetAbilitySystemComponent() const;
	class UValeriaGASAttributeSet* GetAttributeSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GatherableActor">();
	}
	static class AGatherableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGatherableActor>();
	}
};
static_assert(alignof(AGatherableActor) == 0x000008, "Wrong alignment on AGatherableActor");
static_assert(sizeof(AGatherableActor) == 0x0002C8, "Wrong size on AGatherableActor");
static_assert(offsetof(AGatherableActor, ValeriaGAS) == 0x0002B0, "Member 'AGatherableActor::ValeriaGAS' has a wrong offset!");
static_assert(offsetof(AGatherableActor, Vitals) == 0x0002B8, "Member 'AGatherableActor::Vitals' has a wrong offset!");
static_assert(offsetof(AGatherableActor, AttributeSet) == 0x0002C0, "Member 'AGatherableActor::AttributeSet' has a wrong offset!");

// Class Palia.PlaceableVisibilityComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPlaceableVisibilityComponent final : public UActorComponent
{
public:
	class UDataTable*                             VisibilityConfig;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleAlterationsChanged(class UPlaceableAlterationsComponent* Comp);
	void HandleHousingSlotChanged(class UPersistComponent* Comp);
	void HandleLevelerChanged(class ULevelerComponent* Comp);
	void HandlePlugAndSocketStatusChanged(class UPlaceablePlugAndSocketsComponent* Comp);
	void InitialUpdateVisibility();
	void UpdateVisibility(bool bAllowRemovalOfPlaceables);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceableVisibilityComponent">();
	}
	static class UPlaceableVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceableVisibilityComponent>();
	}
};
static_assert(alignof(UPlaceableVisibilityComponent) == 0x000008, "Wrong alignment on UPlaceableVisibilityComponent");
static_assert(sizeof(UPlaceableVisibilityComponent) == 0x0000A8, "Wrong size on UPlaceableVisibilityComponent");
static_assert(offsetof(UPlaceableVisibilityComponent, VisibilityConfig) == 0x0000A0, "Member 'UPlaceableVisibilityComponent::VisibilityConfig' has a wrong offset!");

// Class Palia.GatherableBlocker
// 0x0000 (0x0028 - 0x0028)
class IGatherableBlocker final : public IInterface
{
public:
	struct FNotification ShouldBlockGathering(class AValeriaCharacter* Character) const;
	struct FNotification ShouldBlockMovement(class AValeriaCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GatherableBlocker">();
	}
	static class IGatherableBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGatherableBlocker>();
	}
};
static_assert(alignof(IGatherableBlocker) == 0x000008, "Wrong alignment on IGatherableBlocker");
static_assert(sizeof(IGatherableBlocker) == 0x000028, "Wrong size on IGatherableBlocker");

// Class Palia.GatherableComponent
// 0x0260 (0x0300 - 0x00A0)
class UGatherableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2715[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPreGather;                                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGathered;                                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerGather;                                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVAL_ItemTypeDefinitionAsset*           ItemType;                                          // 0x00D8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemAmount;                                        // 0x00E0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemLevel;                                         // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QualityStars;                                      // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisallowItemsGrantingAccomplishmentProgress;       // 0x00EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVitalType                                    VitalRequired;                                     // 0x00ED(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2716[0x2];                                     // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VitalAmountRequired;                               // 0x00F0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2717[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FShopCostScalingInfo                   VitalAmountScaling;                                // 0x00F8(0x0018)(Edit, BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	EVitalType                                    Vital2Required;                                    // 0x0110(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2718[0x3];                                     // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Vital2AmountRequired;                              // 0x0114(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShopCostScalingInfo                   Vital2AmountScaling;                               // 0x0118(0x0018)(Edit, BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FShopItemAdditionalCost>        AdditionalCost;                                    // 0x0130(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DontDestroyOnGather;                               // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrackLimitedStockOnPerPlayerBasis;                 // 0x0141(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2719[0x2];                                     // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LimitedStock;                                      // 0x0144(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyedAfterFirstGatherSecs;                     // 0x0148(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stage1SecondsUntilDespawn;                         // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stage2SecondsUntilDespawn;                         // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutSeconds;                                    // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DestroyTimestamp;                                  // 0x0158(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAdditionalGatherable>          AdditionalItems;                                   // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAdditionalReward>              AdditionalRewards;                                 // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEquipmentRequiredToGather;                        // 0x0180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271A[0x7];                                     // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           EquipmentRequiredItemTags;                         // 0x0188(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTagList                               EquipmentRequiredItemGameplayTags;                 // 0x0198(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAutoConsumeOnPickup;                              // 0x01B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271B[0x3];                                     // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OriginatesFromShopId;                              // 0x01BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDontUsePickupModeToGatherOnPlot;                  // 0x01C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271C[0x7];                                     // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             LocalHasBeenGatheredMesh;                          // 0x01C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMaterialInterface>> LocalHasBeenGatheredMaterials;                     // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         LocalHasBeenGatheredScale;                         // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271D[0x4];                                     // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TextOverride;                                      // 0x0208(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStage1CountdownStarted;                          // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStage2CountdownStarted;                          // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFadeOutStarted;                                  // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnErosionStarted;                                  // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPlayerGatherCount                     PlayerGatherCount;                                 // 0x0260(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         TotalGatherCount;                                  // 0x0280(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271E[0x4];                                     // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DestroyAfterSecsTimerHandle;                       // 0x0288(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           FadeOutTimerHandle;                                // 0x0290(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           UpdateVFXTimerHandle;                              // 0x0298(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseAbilityGather;                                  // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271F[0x7];                                     // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ActorToSpawnOnGather;                              // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FActorSpawnConditions                  ActorToSpawnOnGatherConditions;                    // 0x02B0(0x0040)(Transient, NativeAccessSpecifierPrivate)
	bool                                          bBlockGatherIfFullInventory;                       // 0x02F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2720[0x3];                                     // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AcceptableGatherDistance;                          // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2721[0x8];                                     // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_StartFadeOut();
	void Client_StartStage1Countdown();
	void Client_StartStage2Countdown();
	void Client_WaitForStage1Countdown();
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Vpc, const struct FInteractEventParams& EventParams);
	struct FUseEventResult OnClientUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnReplicatedDestroyTimestamp();
	void OnReplicatedPlayersGathered();
	void OnReplicatedTotalGatherCount();
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void OnServerUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FServerUseEventParams& Params_0);
	void RpcClient_NotifyGathered(class AValeriaCharacter* Character);
	void RpcNetMulticast_NotifyPlayerGather(class AValeriaCharacter* Character);
	void Server_TriggerGather(class AValeriaCharacter* Character);

	bool CanBeGatheredBy(class AValeriaCharacter* VC) const;
	bool CanBeMovedBy(class AValeriaCharacter* VC, bool bMassMove) const;
	TSoftObjectPtr<class UInputAction> GetInputActionForEventIndex(class AValeriaCharacter* Character, EInteractEventIndex EventIndex) const;
	float GetSecondsUntilDespawn() const;
	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	bool GetUseableIMC(class AValeriaCharacter* Character, EInteractEventIndex InteractIndex, struct FInputMappingPriorityData* OutMappingData, struct FModifyContextOptions* OutOptions) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GatherableComponent">();
	}
	static class UGatherableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGatherableComponent>();
	}
};
static_assert(alignof(UGatherableComponent) == 0x000008, "Wrong alignment on UGatherableComponent");
static_assert(sizeof(UGatherableComponent) == 0x000300, "Wrong size on UGatherableComponent");
static_assert(offsetof(UGatherableComponent, OnPreGather) == 0x0000A8, "Member 'UGatherableComponent::OnPreGather' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, OnGathered) == 0x0000B8, "Member 'UGatherableComponent::OnGathered' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, OnPlayerGather) == 0x0000C8, "Member 'UGatherableComponent::OnPlayerGather' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, ItemType) == 0x0000D8, "Member 'UGatherableComponent::ItemType' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, ItemAmount) == 0x0000E0, "Member 'UGatherableComponent::ItemAmount' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, ItemLevel) == 0x0000E4, "Member 'UGatherableComponent::ItemLevel' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, QualityStars) == 0x0000E8, "Member 'UGatherableComponent::QualityStars' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, DisallowItemsGrantingAccomplishmentProgress) == 0x0000EC, "Member 'UGatherableComponent::DisallowItemsGrantingAccomplishmentProgress' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, VitalRequired) == 0x0000ED, "Member 'UGatherableComponent::VitalRequired' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, VitalAmountRequired) == 0x0000F0, "Member 'UGatherableComponent::VitalAmountRequired' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, VitalAmountScaling) == 0x0000F8, "Member 'UGatherableComponent::VitalAmountScaling' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, Vital2Required) == 0x000110, "Member 'UGatherableComponent::Vital2Required' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, Vital2AmountRequired) == 0x000114, "Member 'UGatherableComponent::Vital2AmountRequired' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, Vital2AmountScaling) == 0x000118, "Member 'UGatherableComponent::Vital2AmountScaling' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, AdditionalCost) == 0x000130, "Member 'UGatherableComponent::AdditionalCost' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, DontDestroyOnGather) == 0x000140, "Member 'UGatherableComponent::DontDestroyOnGather' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, TrackLimitedStockOnPerPlayerBasis) == 0x000141, "Member 'UGatherableComponent::TrackLimitedStockOnPerPlayerBasis' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, LimitedStock) == 0x000144, "Member 'UGatherableComponent::LimitedStock' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, DestroyedAfterFirstGatherSecs) == 0x000148, "Member 'UGatherableComponent::DestroyedAfterFirstGatherSecs' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, Stage1SecondsUntilDespawn) == 0x00014C, "Member 'UGatherableComponent::Stage1SecondsUntilDespawn' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, Stage2SecondsUntilDespawn) == 0x000150, "Member 'UGatherableComponent::Stage2SecondsUntilDespawn' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, FadeOutSeconds) == 0x000154, "Member 'UGatherableComponent::FadeOutSeconds' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, DestroyTimestamp) == 0x000158, "Member 'UGatherableComponent::DestroyTimestamp' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, AdditionalItems) == 0x000160, "Member 'UGatherableComponent::AdditionalItems' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, AdditionalRewards) == 0x000170, "Member 'UGatherableComponent::AdditionalRewards' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, bEquipmentRequiredToGather) == 0x000180, "Member 'UGatherableComponent::bEquipmentRequiredToGather' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, EquipmentRequiredItemTags) == 0x000188, "Member 'UGatherableComponent::EquipmentRequiredItemTags' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, EquipmentRequiredItemGameplayTags) == 0x000198, "Member 'UGatherableComponent::EquipmentRequiredItemGameplayTags' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, bAutoConsumeOnPickup) == 0x0001B8, "Member 'UGatherableComponent::bAutoConsumeOnPickup' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, OriginatesFromShopId) == 0x0001BC, "Member 'UGatherableComponent::OriginatesFromShopId' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, bDontUsePickupModeToGatherOnPlot) == 0x0001C0, "Member 'UGatherableComponent::bDontUsePickupModeToGatherOnPlot' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, LocalHasBeenGatheredMesh) == 0x0001C8, "Member 'UGatherableComponent::LocalHasBeenGatheredMesh' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, LocalHasBeenGatheredMaterials) == 0x0001F0, "Member 'UGatherableComponent::LocalHasBeenGatheredMaterials' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, LocalHasBeenGatheredScale) == 0x000200, "Member 'UGatherableComponent::LocalHasBeenGatheredScale' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, TextOverride) == 0x000208, "Member 'UGatherableComponent::TextOverride' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, OnStage1CountdownStarted) == 0x000220, "Member 'UGatherableComponent::OnStage1CountdownStarted' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, OnStage2CountdownStarted) == 0x000230, "Member 'UGatherableComponent::OnStage2CountdownStarted' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, OnFadeOutStarted) == 0x000240, "Member 'UGatherableComponent::OnFadeOutStarted' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, OnErosionStarted) == 0x000250, "Member 'UGatherableComponent::OnErosionStarted' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, PlayerGatherCount) == 0x000260, "Member 'UGatherableComponent::PlayerGatherCount' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, TotalGatherCount) == 0x000280, "Member 'UGatherableComponent::TotalGatherCount' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, DestroyAfterSecsTimerHandle) == 0x000288, "Member 'UGatherableComponent::DestroyAfterSecsTimerHandle' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, FadeOutTimerHandle) == 0x000290, "Member 'UGatherableComponent::FadeOutTimerHandle' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, UpdateVFXTimerHandle) == 0x000298, "Member 'UGatherableComponent::UpdateVFXTimerHandle' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, UseAbilityGather) == 0x0002A0, "Member 'UGatherableComponent::UseAbilityGather' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, ActorToSpawnOnGather) == 0x0002A8, "Member 'UGatherableComponent::ActorToSpawnOnGather' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, ActorToSpawnOnGatherConditions) == 0x0002B0, "Member 'UGatherableComponent::ActorToSpawnOnGatherConditions' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, bBlockGatherIfFullInventory) == 0x0002F0, "Member 'UGatherableComponent::bBlockGatherIfFullInventory' has a wrong offset!");
static_assert(offsetof(UGatherableComponent, AcceptableGatherDistance) == 0x0002F4, "Member 'UGatherableComponent::AcceptableGatherDistance' has a wrong offset!");

// Class Palia.Persistable
// 0x0000 (0x0028 - 0x0028)
class IPersistable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Persistable">();
	}
	static class IPersistable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPersistable>();
	}
};
static_assert(alignof(IPersistable) == 0x000008, "Wrong alignment on IPersistable");
static_assert(sizeof(IPersistable) == 0x000028, "Wrong size on IPersistable");

// Class Palia.LootComponent
// 0x0370 (0x0410 - 0x00A0)
class ULootComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             LootPerVital;                                      // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FQuestRewardConfig                     RewardFinal;                                       // 0x00B0(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	ELootType                                     Type;                                              // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_272C[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ChestTemplate;                                     // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELootAchievementCreditType                    AchievementCreditType;                             // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_272D[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuestRewardConfig                     RewardPerVital;                                    // 0x0240(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         LootPerVitalAmount;                                // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          GrantLootToKillerImmediately;                      // 0x03BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_272E[0x3];                                     // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagList                               Tags;                                              // 0x03C0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          IsLootCommunal;                                    // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_272F[0x3];                                     // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DistanceToCheckForGround;                          // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2730[0x18];                                    // 0x03E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ParticipationTag;                                  // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           PastParticipationTag;                              // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	TArray<struct FQuestReward> Auto_SimulateLootActor(class AValeriaCharacter* PlayerCharacter);
	TArray<struct FQuestReward> Auto_SimulateLootPerVitalChanged(class AValeriaCharacter* PlayerCharacter);
	void OnVitalsChanged(class UVitalsComponent* Vitals, const struct FVitalsChange& Change);
	void OnVitalsInitialized(class UVitalsComponent* Vitals);
	void ResetLoot(class UVitalsComponent* Vitals);

	bool HasBeenGatheredByPlayer(class AValeriaCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootComponent">();
	}
	static class ULootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootComponent>();
	}
};
static_assert(alignof(ULootComponent) == 0x000008, "Wrong alignment on ULootComponent");
static_assert(sizeof(ULootComponent) == 0x000410, "Wrong size on ULootComponent");
static_assert(offsetof(ULootComponent, LootPerVital) == 0x0000A0, "Member 'ULootComponent::LootPerVital' has a wrong offset!");
static_assert(offsetof(ULootComponent, RewardFinal) == 0x0000B0, "Member 'ULootComponent::RewardFinal' has a wrong offset!");
static_assert(offsetof(ULootComponent, Type) == 0x000228, "Member 'ULootComponent::Type' has a wrong offset!");
static_assert(offsetof(ULootComponent, ChestTemplate) == 0x000230, "Member 'ULootComponent::ChestTemplate' has a wrong offset!");
static_assert(offsetof(ULootComponent, AchievementCreditType) == 0x000238, "Member 'ULootComponent::AchievementCreditType' has a wrong offset!");
static_assert(offsetof(ULootComponent, RewardPerVital) == 0x000240, "Member 'ULootComponent::RewardPerVital' has a wrong offset!");
static_assert(offsetof(ULootComponent, LootPerVitalAmount) == 0x0003B8, "Member 'ULootComponent::LootPerVitalAmount' has a wrong offset!");
static_assert(offsetof(ULootComponent, GrantLootToKillerImmediately) == 0x0003BC, "Member 'ULootComponent::GrantLootToKillerImmediately' has a wrong offset!");
static_assert(offsetof(ULootComponent, Tags) == 0x0003C0, "Member 'ULootComponent::Tags' has a wrong offset!");
static_assert(offsetof(ULootComponent, IsLootCommunal) == 0x0003E0, "Member 'ULootComponent::IsLootCommunal' has a wrong offset!");
static_assert(offsetof(ULootComponent, DistanceToCheckForGround) == 0x0003E4, "Member 'ULootComponent::DistanceToCheckForGround' has a wrong offset!");
static_assert(offsetof(ULootComponent, ParticipationTag) == 0x000400, "Member 'ULootComponent::ParticipationTag' has a wrong offset!");
static_assert(offsetof(ULootComponent, PastParticipationTag) == 0x000408, "Member 'ULootComponent::PastParticipationTag' has a wrong offset!");

// Class Palia.GatherableLootComponent
// 0x0098 (0x04A8 - 0x0410)
class UGatherableLootComponent final : public ULootComponent
{
public:
	uint8                                         Pad_2732[0x8];                                     // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRequirementConfig                     RequirementConfig;                                 // 0x0418(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	bool GetRequirement(struct FRequirement* Requirement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GatherableLootComponent">();
	}
	static class UGatherableLootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGatherableLootComponent>();
	}
};
static_assert(alignof(UGatherableLootComponent) == 0x000008, "Wrong alignment on UGatherableLootComponent");
static_assert(sizeof(UGatherableLootComponent) == 0x0004A8, "Wrong size on UGatherableLootComponent");
static_assert(offsetof(UGatherableLootComponent, RequirementConfig) == 0x000418, "Member 'UGatherableLootComponent::RequirementConfig' has a wrong offset!");

// Class Palia.PaliaScreenStateRequester
// 0x0020 (0x0048 - 0x0028)
class UPaliaScreenStateRequester : public UObject
{
public:
	uint8                                         Pad_2734[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaliaScreenStateRequester">();
	}
	static class UPaliaScreenStateRequester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaliaScreenStateRequester>();
	}
};
static_assert(alignof(UPaliaScreenStateRequester) == 0x000008, "Wrong alignment on UPaliaScreenStateRequester");
static_assert(sizeof(UPaliaScreenStateRequester) == 0x000048, "Wrong size on UPaliaScreenStateRequester");

// Class Palia.VitalsComponent
// 0x0120 (0x01C0 - 0x00A0)
class UVitalsComponent : public UActorComponent
{
public:
	TArray<struct FVital>                         Vitals;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	EVitalRelevance                               VitalPresenceRule;                                 // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUpgradeVitals;                                 // 0x00B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2735[0x6];                                     // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDowned;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VitalEmptyNotification;                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VitalFullNotification;                             // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStaminaPreUse;                                   // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangedContext;                                  // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangedContextPostReplicate;                     // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStunned;                                         // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2736[0x10];                                    // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UValeriaGASAttributeSet*                AttributeSet;                                      // 0x0148(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DoNotTick;                                         // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DoNotReplicate;                                    // 0x0151(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStunned;                                        // 0x0152(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInvulnerable;                                   // 0x0153(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2737[0x4];                                     // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVitalsChange>                  VitalChangesQueuedToBeSent;                        // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           SendVitalChangeMadeRpcTimerHandle;                 // 0x0168(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     ActorToSpawnOnDeath;                               // 0x0170(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FActorSpawnConditions                  ActorToSpawnOnDeathConditions;                     // 0x0178(0x0040)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2738[0x8];                                     // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddVital(const struct FVitalsChange& Change);
	int32 ChangeVitalBy(const struct FVitalsChange& Change, bool ShouldTestFilter);
	void FlushVitalChangeNotifs();
	void InvulnerableFor(float Seconds);
	void OnReplicatedAndNotify();
	void RemoveInvulnerabilityByTimer();
	void RemoveStunnedByTimer();
	int32 ResetVitalToMax(EVitalType Type);
	void RpcClient_ForceVitalExhaustion(EVitalType Type);
	void RpcClient_ManuallyReplicateVitalChange(const struct FVitalsChange& Change);
	void RpcClient_NotifyVitalEmpty(EVitalType Type);
	void RpcClient_NotifyVitalFull(EVitalType Type);
	void RpcClient_VitalChangeMade(const struct FVitalsChange& Change);
	void RpcNetMulticast_OnStunned(float Seconds);
	void SetInvulnerable(bool bEnabled);
	void StunFor(float Seconds);
	int32 SubtractVital(const struct FVitalsChange& Change);
	bool TryVitalChange(const struct FVitalsChange& Change);

	bool FilterChange(struct FVitalsChange& Change, bool ShouldSurfaceErrors) const;
	int32 GetVital(EVitalType Type) const;
	int32 GetVitalMax(EVitalType Type) const;
	int32 GetVitalStart(EVitalType Type) const;
	bool IsDowned() const;
	bool IsInvulnerable() const;
	bool IsStunned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VitalsComponent">();
	}
	static class UVitalsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVitalsComponent>();
	}
};
static_assert(alignof(UVitalsComponent) == 0x000008, "Wrong alignment on UVitalsComponent");
static_assert(sizeof(UVitalsComponent) == 0x0001C0, "Wrong size on UVitalsComponent");
static_assert(offsetof(UVitalsComponent, Vitals) == 0x0000A0, "Member 'UVitalsComponent::Vitals' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, VitalPresenceRule) == 0x0000B0, "Member 'UVitalsComponent::VitalPresenceRule' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, bCanUpgradeVitals) == 0x0000B1, "Member 'UVitalsComponent::bCanUpgradeVitals' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, OnChanged) == 0x0000B8, "Member 'UVitalsComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, OnDowned) == 0x0000C8, "Member 'UVitalsComponent::OnDowned' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, VitalEmptyNotification) == 0x0000D8, "Member 'UVitalsComponent::VitalEmptyNotification' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, VitalFullNotification) == 0x0000E8, "Member 'UVitalsComponent::VitalFullNotification' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, OnStaminaPreUse) == 0x0000F8, "Member 'UVitalsComponent::OnStaminaPreUse' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, OnChangedContext) == 0x000108, "Member 'UVitalsComponent::OnChangedContext' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, OnChangedContextPostReplicate) == 0x000118, "Member 'UVitalsComponent::OnChangedContextPostReplicate' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, OnStunned) == 0x000128, "Member 'UVitalsComponent::OnStunned' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, AttributeSet) == 0x000148, "Member 'UVitalsComponent::AttributeSet' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, DoNotTick) == 0x000150, "Member 'UVitalsComponent::DoNotTick' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, DoNotReplicate) == 0x000151, "Member 'UVitalsComponent::DoNotReplicate' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, bIsStunned) == 0x000152, "Member 'UVitalsComponent::bIsStunned' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, bIsInvulnerable) == 0x000153, "Member 'UVitalsComponent::bIsInvulnerable' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, VitalChangesQueuedToBeSent) == 0x000158, "Member 'UVitalsComponent::VitalChangesQueuedToBeSent' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, SendVitalChangeMadeRpcTimerHandle) == 0x000168, "Member 'UVitalsComponent::SendVitalChangeMadeRpcTimerHandle' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, ActorToSpawnOnDeath) == 0x000170, "Member 'UVitalsComponent::ActorToSpawnOnDeath' has a wrong offset!");
static_assert(offsetof(UVitalsComponent, ActorToSpawnOnDeathConditions) == 0x000178, "Member 'UVitalsComponent::ActorToSpawnOnDeathConditions' has a wrong offset!");

// Class Palia.GatherableLootVitalsComponent
// 0x0008 (0x01C8 - 0x01C0)
class UGatherableLootVitalsComponent final : public UVitalsComponent
{
public:
	uint8                                         Pad_2742[0x8];                                     // 0x01C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTimer();
	void OnVitalsChange(class UVitalsComponent* VitalsComponent, const struct FVitalsChange& Change);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GatherableLootVitalsComponent">();
	}
	static class UGatherableLootVitalsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGatherableLootVitalsComponent>();
	}
};
static_assert(alignof(UGatherableLootVitalsComponent) == 0x000008, "Wrong alignment on UGatherableLootVitalsComponent");
static_assert(sizeof(UGatherableLootVitalsComponent) == 0x0001C8, "Wrong size on UGatherableLootVitalsComponent");

// Class Palia.GatherablePiecemealComponent
// 0x0088 (0x0128 - 0x00A0)
class UGatherablePiecemealComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2743[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestRewardConfig>             Rewards;                                           // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         TimeTick;                                          // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartDelay;                                        // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimState                             AnimState;                                         // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	ECharacterState                               CharacterState;                                    // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2744[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractingText;                                   // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   NoninteractingText;                                // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class AValeriaCharacter*                      ValeriaCharacter;                                  // 0x0110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle;                                       // 0x0118(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Interacting;                                       // 0x0120(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2745[0x7];                                     // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void TickGather();

	bool CheckCanGather(class AValeriaCharacter* Character) const;
	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GatherablePiecemealComponent">();
	}
	static class UGatherablePiecemealComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGatherablePiecemealComponent>();
	}
};
static_assert(alignof(UGatherablePiecemealComponent) == 0x000008, "Wrong alignment on UGatherablePiecemealComponent");
static_assert(sizeof(UGatherablePiecemealComponent) == 0x000128, "Wrong size on UGatherablePiecemealComponent");
static_assert(offsetof(UGatherablePiecemealComponent, Rewards) == 0x0000A8, "Member 'UGatherablePiecemealComponent::Rewards' has a wrong offset!");
static_assert(offsetof(UGatherablePiecemealComponent, TimeTick) == 0x0000B8, "Member 'UGatherablePiecemealComponent::TimeTick' has a wrong offset!");
static_assert(offsetof(UGatherablePiecemealComponent, StartDelay) == 0x0000BC, "Member 'UGatherablePiecemealComponent::StartDelay' has a wrong offset!");
static_assert(offsetof(UGatherablePiecemealComponent, AnimState) == 0x0000C0, "Member 'UGatherablePiecemealComponent::AnimState' has a wrong offset!");
static_assert(offsetof(UGatherablePiecemealComponent, CharacterState) == 0x0000D8, "Member 'UGatherablePiecemealComponent::CharacterState' has a wrong offset!");
static_assert(offsetof(UGatherablePiecemealComponent, InteractingText) == 0x0000E0, "Member 'UGatherablePiecemealComponent::InteractingText' has a wrong offset!");
static_assert(offsetof(UGatherablePiecemealComponent, NoninteractingText) == 0x0000F8, "Member 'UGatherablePiecemealComponent::NoninteractingText' has a wrong offset!");
static_assert(offsetof(UGatherablePiecemealComponent, ValeriaCharacter) == 0x000110, "Member 'UGatherablePiecemealComponent::ValeriaCharacter' has a wrong offset!");
static_assert(offsetof(UGatherablePiecemealComponent, TimerHandle) == 0x000118, "Member 'UGatherablePiecemealComponent::TimerHandle' has a wrong offset!");
static_assert(offsetof(UGatherablePiecemealComponent, Interacting) == 0x000120, "Member 'UGatherablePiecemealComponent::Interacting' has a wrong offset!");

// Class Palia.GearComponent
// 0x00C8 (0x0168 - 0x00A0)
class UGearComponent final : public UActorComponent
{
public:
	uint8                                         Pad_274C[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGearAssetsWereLoaded;                            // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGearPersistBlock                      GearPersistBlock;                                  // 0x00C8(0x0070)(NativeAccessSpecifierPrivate)
	struct FGearTransientData                     GearTransientData;                                 // 0x0138(0x0028)(Net, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          bTransientDataIsValid;                             // 0x0160(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274D[0x7];                                     // 0x0161(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_RemoveGearBySlotType(class UGearSlotTypeConfig* SlotTypeConfig, const struct FBagSlotLocation& DesiredSlot, int32 IndexWithinType);
	void Client_SetGearFromInventory(class UInventoryComponent* Inventory, const struct FBagSlotLocation& SourceInventorySlot, int32 DestinationGearSlotIndex, bool ShouldSwapPin);
	int32 GetAvailableGearSlotForType(class UGearSlotTypeConfig* SlotTypeConfig);
	int32 GetGearSlotForType(class UGearSlotTypeConfig* SlotTypeConfig);
	bool HasRomancePinEquippedForVillager(int32 VillagerCoreId);
	void OnReplicated();
	void RpcServer_RemoveGearBySlotType(int32 PersistId, const struct FBagSlotLocation& DesiredSlot, int32 IndexWithinType);
	void RpcServer_SetGearFromInventory(class UInventoryComponent* Inventory, const struct FBagSlotLocation& SourceInventorySlot, int32 DestinationGearSlotIndex, bool ShouldSwapPin);

	EGearChangeResult CanRemoveGearBySlotType(class UInventoryComponent* Inventory, class UGearSlotTypeConfig* GearSlotTypeConfig, int32 SlotIndex) const;
	bool ContainsGameplayTag(struct FGameplayTag& GameplayTag) const;
	struct FValeriaItem GetGearByGameplayTag(struct FGameplayTag& GameplayTag) const;
	struct FValeriaItem GetGearBySlotType(class UGearSlotTypeConfig* SlotTypeConfig, int32 IndexWithinType) const;
	class UObject* GetLoadedAssetWithTag(class FName Tag) const;
	bool HasItemEquippedByPersistId(int32 PersistId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GearComponent">();
	}
	static class UGearComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGearComponent>();
	}
};
static_assert(alignof(UGearComponent) == 0x000008, "Wrong alignment on UGearComponent");
static_assert(sizeof(UGearComponent) == 0x000168, "Wrong size on UGearComponent");
static_assert(offsetof(UGearComponent, OnChanged) == 0x0000A8, "Member 'UGearComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UGearComponent, OnGearAssetsWereLoaded) == 0x0000B8, "Member 'UGearComponent::OnGearAssetsWereLoaded' has a wrong offset!");
static_assert(offsetof(UGearComponent, GearPersistBlock) == 0x0000C8, "Member 'UGearComponent::GearPersistBlock' has a wrong offset!");
static_assert(offsetof(UGearComponent, GearTransientData) == 0x000138, "Member 'UGearComponent::GearTransientData' has a wrong offset!");
static_assert(offsetof(UGearComponent, bTransientDataIsValid) == 0x000160, "Member 'UGearComponent::bTransientDataIsValid' has a wrong offset!");

// Class Palia.GearGlobalConfig
// 0x0030 (0x0060 - 0x0030)
class UGearGlobalConfig final : public UDataAsset
{
public:
	TArray<class UGearSlotTypeConfig*>            ActiveSlotTypes;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGearSlotTypeConfig*                    SlotTypeToReduceDurabilityWhenFishing;             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGearSlotTypeConfig*                    RomancePinSlotType;                                // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RomancePinRelationshipPointMultiplier;             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRomancePinResetTime                   RomancePinResetTime;                               // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	class UGearSlotTypeConfig* FindGearSlotTypeByPersistId(int32 GearSlotTypePersistId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GearGlobalConfig">();
	}
	static class UGearGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGearGlobalConfig>();
	}
};
static_assert(alignof(UGearGlobalConfig) == 0x000008, "Wrong alignment on UGearGlobalConfig");
static_assert(sizeof(UGearGlobalConfig) == 0x000060, "Wrong size on UGearGlobalConfig");
static_assert(offsetof(UGearGlobalConfig, ActiveSlotTypes) == 0x000030, "Member 'UGearGlobalConfig::ActiveSlotTypes' has a wrong offset!");
static_assert(offsetof(UGearGlobalConfig, SlotTypeToReduceDurabilityWhenFishing) == 0x000040, "Member 'UGearGlobalConfig::SlotTypeToReduceDurabilityWhenFishing' has a wrong offset!");
static_assert(offsetof(UGearGlobalConfig, RomancePinSlotType) == 0x000048, "Member 'UGearGlobalConfig::RomancePinSlotType' has a wrong offset!");
static_assert(offsetof(UGearGlobalConfig, RomancePinRelationshipPointMultiplier) == 0x000050, "Member 'UGearGlobalConfig::RomancePinRelationshipPointMultiplier' has a wrong offset!");
static_assert(offsetof(UGearGlobalConfig, RomancePinResetTime) == 0x000054, "Member 'UGearGlobalConfig::RomancePinResetTime' has a wrong offset!");

// Class Palia.GeneralHelpersBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGeneralHelpersBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CalculateZoomCenter(struct FVector2D* Center, struct FVector2D& OldCenter, struct FVector2D& ZoomAnchorPos, struct FVector2D& WorldCenter, struct FVector2D& WorldHalfExtents, struct FVector2D& PanelHalfExtents, float OldWorldToPanel, float NewWorldToPanel);
	static void ClampWorldToPanel(struct FVector2D* Center, struct FVector2D& OldCenter, struct FVector2D& WorldCenter, struct FVector2D& WorldHalfExtents, struct FVector2D& PanelHalfExtents, float WorldToPanel);
	static TScriptInterface<class IWaterable> FindWaterable(class UObject* WorldContextObject, class AValeriaCharacter* Instigator, TArray<EObjectTypeQuery>& LineTraceObjectTypes, const struct FVector& CheckPosition, const struct FVector& BoxExtent);
	static float NormalizeDegrees(float Degrees);
	static bool ProjectWorldLocationToWidgetPosition(class APlayerController* PlayerController, class UCameraComponent* Camera, const struct FVector& WorldLocation, struct FVector2D* ScreenPosition, bool bPlayerViewportRelative);
	static struct FServerUseEventResult ServerUseEventResult_Handled();
	static struct FServerUseEventResult ServerUseEventResult_HandledUnconsumed();
	static struct FServerUseEventResult ServerUseEventResult_Unhandled();
	static struct FUseEventResult UseEventResult_Handled();
	static struct FUseEventResult UseEventResult_HandledAndSentToServer();
	static struct FUseEventResult UseEventResult_HandledUnconsumed();
	static struct FUseEventResult UseEventResult_HandledUnconsumedAndSentToServer();
	static struct FUseEventResult UseEventResult_Unhandled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralHelpersBlueprintLibrary">();
	}
	static class UGeneralHelpersBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralHelpersBlueprintLibrary>();
	}
};
static_assert(alignof(UGeneralHelpersBlueprintLibrary) == 0x000008, "Wrong alignment on UGeneralHelpersBlueprintLibrary");
static_assert(sizeof(UGeneralHelpersBlueprintLibrary) == 0x000028, "Wrong size on UGeneralHelpersBlueprintLibrary");

// Class Palia.GiftPreferenceTrackingComponent
// 0x0060 (0x0100 - 0x00A0)
class UGiftPreferenceTrackingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_275B[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGiftPreferencesPersistBlock           GiftPreferencesPersistBlock;                       // 0x00A8(0x0058)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnReplicatedAndShouldNotify();

	bool CanLearnMoreForPreferenceLevel(int32 VillagerCoreId, EVillagerGiftRewardLevel PreferenceLevel) const;
	TArray<TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>> GetItemTypesToShowForPreferenceLevel(int32 VillagerCoreId, EVillagerGiftRewardLevel PreferenceLevel) const;
	bool IsAbleToGiftAtDifficulty(int32 VillagerCoreId, EVillagerGiftDifficultyGrouping Difficulty) const;
	bool IsAwareOfGiftingPreference(int32 VillagerCoreId, int32 PreferenceId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GiftPreferenceTrackingComponent">();
	}
	static class UGiftPreferenceTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGiftPreferenceTrackingComponent>();
	}
};
static_assert(alignof(UGiftPreferenceTrackingComponent) == 0x000008, "Wrong alignment on UGiftPreferenceTrackingComponent");
static_assert(sizeof(UGiftPreferenceTrackingComponent) == 0x000100, "Wrong size on UGiftPreferenceTrackingComponent");
static_assert(offsetof(UGiftPreferenceTrackingComponent, GiftPreferencesPersistBlock) == 0x0000A8, "Member 'UGiftPreferenceTrackingComponent::GiftPreferencesPersistBlock' has a wrong offset!");

// Class Palia.CharacterGlobalConfig
// 0x0020 (0x0050 - 0x0030)
class UCharacterGlobalConfig final : public UDataAsset
{
public:
	class FName                                   LeftHandSocket;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightHandSocket;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EquipSocketTag;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ANS_InteractableProp_Equip;                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterGlobalConfig">();
	}
	static class UCharacterGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterGlobalConfig>();
	}
};
static_assert(alignof(UCharacterGlobalConfig) == 0x000008, "Wrong alignment on UCharacterGlobalConfig");
static_assert(sizeof(UCharacterGlobalConfig) == 0x000050, "Wrong size on UCharacterGlobalConfig");
static_assert(offsetof(UCharacterGlobalConfig, LeftHandSocket) == 0x000030, "Member 'UCharacterGlobalConfig::LeftHandSocket' has a wrong offset!");
static_assert(offsetof(UCharacterGlobalConfig, RightHandSocket) == 0x000038, "Member 'UCharacterGlobalConfig::RightHandSocket' has a wrong offset!");
static_assert(offsetof(UCharacterGlobalConfig, EquipSocketTag) == 0x000040, "Member 'UCharacterGlobalConfig::EquipSocketTag' has a wrong offset!");
static_assert(offsetof(UCharacterGlobalConfig, ANS_InteractableProp_Equip) == 0x000048, "Member 'UCharacterGlobalConfig::ANS_InteractableProp_Equip' has a wrong offset!");

// Class Palia.PlayerCompassTargetConfigAsset
// 0x0068 (0x0098 - 0x0030)
class UPlayerCompassTargetConfigAsset final : public UDataAsset
{
public:
	struct FPlayerCompassTargetConfig             Config;                                            // 0x0030(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCompassTargetConfigAsset">();
	}
	static class UPlayerCompassTargetConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCompassTargetConfigAsset>();
	}
};
static_assert(alignof(UPlayerCompassTargetConfigAsset) == 0x000008, "Wrong alignment on UPlayerCompassTargetConfigAsset");
static_assert(sizeof(UPlayerCompassTargetConfigAsset) == 0x000098, "Wrong size on UPlayerCompassTargetConfigAsset");
static_assert(offsetof(UPlayerCompassTargetConfigAsset, Config) == 0x000030, "Member 'UPlayerCompassTargetConfigAsset::Config' has a wrong offset!");

// Class Palia.GatherableGlobalConfig
// 0x0268 (0x0298 - 0x0030)
class UGatherableGlobalConfig final : public UDataAsset
{
public:
	struct FGatherableGlobalConfig_Text           Text;                                              // 0x0030(0x01E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EInteractEventIndex, struct FInputMappingPriorityData> InputMappingPriorityDataForEventIndex;             // 0x0210(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FInputMappingPriorityData              InputMappingPriorityDataWhenMoveDisabled;          // 0x0260(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GatherableGlobalConfig">();
	}
	static class UGatherableGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGatherableGlobalConfig>();
	}
};
static_assert(alignof(UGatherableGlobalConfig) == 0x000008, "Wrong alignment on UGatherableGlobalConfig");
static_assert(sizeof(UGatherableGlobalConfig) == 0x000298, "Wrong size on UGatherableGlobalConfig");
static_assert(offsetof(UGatherableGlobalConfig, Text) == 0x000030, "Member 'UGatherableGlobalConfig::Text' has a wrong offset!");
static_assert(offsetof(UGatherableGlobalConfig, InputMappingPriorityDataForEventIndex) == 0x000210, "Member 'UGatherableGlobalConfig::InputMappingPriorityDataForEventIndex' has a wrong offset!");
static_assert(offsetof(UGatherableGlobalConfig, InputMappingPriorityDataWhenMoveDisabled) == 0x000260, "Member 'UGatherableGlobalConfig::InputMappingPriorityDataWhenMoveDisabled' has a wrong offset!");

// Class Palia.PlacementGlobalConfig
// 0x0060 (0x0090 - 0x0030)
class UPlacementGlobalConfig final : public UDataAsset
{
public:
	TSubclassOf<class APlacementRegionMatActor>   PlacementRegionMatActor;                           // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlacementLimitByGameplayTag>   LimitsByTag;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DefaultPlacementSound;                             // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DefaultPickupSound;                                // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNotification                          DecorOnWallsRemovedNotification;                   // 0x0058(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         BuildingClusterCostLimit;                          // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2760[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacementGlobalConfig">();
	}
	static class UPlacementGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlacementGlobalConfig>();
	}
};
static_assert(alignof(UPlacementGlobalConfig) == 0x000008, "Wrong alignment on UPlacementGlobalConfig");
static_assert(sizeof(UPlacementGlobalConfig) == 0x000090, "Wrong size on UPlacementGlobalConfig");
static_assert(offsetof(UPlacementGlobalConfig, PlacementRegionMatActor) == 0x000030, "Member 'UPlacementGlobalConfig::PlacementRegionMatActor' has a wrong offset!");
static_assert(offsetof(UPlacementGlobalConfig, LimitsByTag) == 0x000038, "Member 'UPlacementGlobalConfig::LimitsByTag' has a wrong offset!");
static_assert(offsetof(UPlacementGlobalConfig, DefaultPlacementSound) == 0x000048, "Member 'UPlacementGlobalConfig::DefaultPlacementSound' has a wrong offset!");
static_assert(offsetof(UPlacementGlobalConfig, DefaultPickupSound) == 0x000050, "Member 'UPlacementGlobalConfig::DefaultPickupSound' has a wrong offset!");
static_assert(offsetof(UPlacementGlobalConfig, DecorOnWallsRemovedNotification) == 0x000058, "Member 'UPlacementGlobalConfig::DecorOnWallsRemovedNotification' has a wrong offset!");
static_assert(offsetof(UPlacementGlobalConfig, BuildingClusterCostLimit) == 0x000088, "Member 'UPlacementGlobalConfig::BuildingClusterCostLimit' has a wrong offset!");

// Class Palia.FocusGlobalConfig
// 0x0008 (0x0038 - 0x0030)
class UFocusGlobalConfig final : public UDataAsset
{
public:
	int32                                         FocusPerHourBeforeSoftCap;                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RestedFocusPerHourAfterSoftCap;                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FocusGlobalConfig">();
	}
	static class UFocusGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFocusGlobalConfig>();
	}
};
static_assert(alignof(UFocusGlobalConfig) == 0x000008, "Wrong alignment on UFocusGlobalConfig");
static_assert(sizeof(UFocusGlobalConfig) == 0x000038, "Wrong size on UFocusGlobalConfig");
static_assert(offsetof(UFocusGlobalConfig, FocusPerHourBeforeSoftCap) == 0x000030, "Member 'UFocusGlobalConfig::FocusPerHourBeforeSoftCap' has a wrong offset!");
static_assert(offsetof(UFocusGlobalConfig, RestedFocusPerHourAfterSoftCap) == 0x000034, "Member 'UFocusGlobalConfig::RestedFocusPerHourAfterSoftCap' has a wrong offset!");

// Class Palia.PlayerInventoryComponent
// 0x00E0 (0x02A8 - 0x01C8)
class UPlayerInventoryComponent final : public UInventoryComponent
{
public:
	uint8                                         Pad_2761[0x8];                                     // 0x01C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FValeriaItem>                   CarriedItems;                                      // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FCarryVisualizationInfo>        PrioritizedCarryVisualization;                     // 0x01E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCarryChanged;                                    // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCurrencyChanged;                                 // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FCurrencyBag>                   Currencies;                                        // 0x0210(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2762[0x70];                                    // 0x0220(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class US6Core_AssetLoader*                    PlayerInventoryAssetLoader;                        // 0x0290(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           CleanupTimerHandle;                                // 0x0298(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2763[0x8];                                     // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FSelfUseEventResult OnClientUseEquippedInward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnInventorySettingsChanged(struct FValeriaGameplaySettings& InventorySettings);
	void OnRep_Carried();
	void RpcClient_ChangeCurrency(class UCurrencyConfig* CurrencyConfig, int32 Delta, int32 NewAmount);
	void RpcServer_PocketCarried();

	int32 GetCurrencyAmount(class UCurrencyConfig* CurrencyConfig) const;
	bool GetSellValue(const struct FBagSlotLocation& Location, class FText* OutText, class UTexture2D** OutIcon, int32* OutIntValue) const;
	bool GetSingleSellValue(const struct FBagSlotLocation& Location, class FText* OutText, class UTexture2D** OutIcon, int32* OutIntValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInventoryComponent">();
	}
	static class UPlayerInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInventoryComponent>();
	}
};
static_assert(alignof(UPlayerInventoryComponent) == 0x000008, "Wrong alignment on UPlayerInventoryComponent");
static_assert(sizeof(UPlayerInventoryComponent) == 0x0002A8, "Wrong size on UPlayerInventoryComponent");
static_assert(offsetof(UPlayerInventoryComponent, CarriedItems) == 0x0001D0, "Member 'UPlayerInventoryComponent::CarriedItems' has a wrong offset!");
static_assert(offsetof(UPlayerInventoryComponent, PrioritizedCarryVisualization) == 0x0001E0, "Member 'UPlayerInventoryComponent::PrioritizedCarryVisualization' has a wrong offset!");
static_assert(offsetof(UPlayerInventoryComponent, OnCarryChanged) == 0x0001F0, "Member 'UPlayerInventoryComponent::OnCarryChanged' has a wrong offset!");
static_assert(offsetof(UPlayerInventoryComponent, OnCurrencyChanged) == 0x000200, "Member 'UPlayerInventoryComponent::OnCurrencyChanged' has a wrong offset!");
static_assert(offsetof(UPlayerInventoryComponent, Currencies) == 0x000210, "Member 'UPlayerInventoryComponent::Currencies' has a wrong offset!");
static_assert(offsetof(UPlayerInventoryComponent, PlayerInventoryAssetLoader) == 0x000290, "Member 'UPlayerInventoryComponent::PlayerInventoryAssetLoader' has a wrong offset!");
static_assert(offsetof(UPlayerInventoryComponent, CleanupTimerHandle) == 0x000298, "Member 'UPlayerInventoryComponent::CleanupTimerHandle' has a wrong offset!");

// Class Palia.SkillLevelsGlobalConfig
// 0x0058 (0x0088 - 0x0030)
class USkillLevelsGlobalConfig final : public UDataAsset
{
public:
	class FText                                   MasterLevelDisplayName;                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FMasterLevelReward>             MasterLevelRewards;                                // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FScalingReward>                 MasterLevelScalingRewards;                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MasterLevelTag;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LevelRequirementDisplayFormat;                     // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillLevelsGlobalConfig">();
	}
	static class USkillLevelsGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillLevelsGlobalConfig>();
	}
};
static_assert(alignof(USkillLevelsGlobalConfig) == 0x000008, "Wrong alignment on USkillLevelsGlobalConfig");
static_assert(sizeof(USkillLevelsGlobalConfig) == 0x000088, "Wrong size on USkillLevelsGlobalConfig");
static_assert(offsetof(USkillLevelsGlobalConfig, MasterLevelDisplayName) == 0x000030, "Member 'USkillLevelsGlobalConfig::MasterLevelDisplayName' has a wrong offset!");
static_assert(offsetof(USkillLevelsGlobalConfig, MasterLevelRewards) == 0x000048, "Member 'USkillLevelsGlobalConfig::MasterLevelRewards' has a wrong offset!");
static_assert(offsetof(USkillLevelsGlobalConfig, MasterLevelScalingRewards) == 0x000058, "Member 'USkillLevelsGlobalConfig::MasterLevelScalingRewards' has a wrong offset!");
static_assert(offsetof(USkillLevelsGlobalConfig, MasterLevelTag) == 0x000068, "Member 'USkillLevelsGlobalConfig::MasterLevelTag' has a wrong offset!");
static_assert(offsetof(USkillLevelsGlobalConfig, LevelRequirementDisplayFormat) == 0x000070, "Member 'USkillLevelsGlobalConfig::LevelRequirementDisplayFormat' has a wrong offset!");

// Class Palia.PlayerTagGlobalConfig
// 0x0050 (0x0080 - 0x0030)
class UPlayerTagGlobalConfig final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, class FText>        PlayerTagRequirementTextMap;                       // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerTagGlobalConfig">();
	}
	static class UPlayerTagGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerTagGlobalConfig>();
	}
};
static_assert(alignof(UPlayerTagGlobalConfig) == 0x000008, "Wrong alignment on UPlayerTagGlobalConfig");
static_assert(sizeof(UPlayerTagGlobalConfig) == 0x000080, "Wrong size on UPlayerTagGlobalConfig");
static_assert(offsetof(UPlayerTagGlobalConfig, PlayerTagRequirementTextMap) == 0x000030, "Member 'UPlayerTagGlobalConfig::PlayerTagRequirementTextMap' has a wrong offset!");

// Class Palia.PlacementViewActor
// 0x0148 (0x03F0 - 0x02A8)
class APlacementViewActor : public AActor
{
public:
	class UMaterial*                              OverlayMaterialTemplate;                           // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpawnEffectCurve;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PlaceEffectCurve;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMeshComponent*>                 ViewMeshComponents;                                // 0x02C0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 CheckMeshComponents;                               // 0x02D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         CheckMeshToOriginalArrayIdx;                       // 0x02E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2768[0x4];                                     // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMeshComponent*>                 NeedSuccessCheckComponents;                        // 0x02E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         MovedConnectedActors;                              // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        Root;                                              // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   PlugMesh;                                          // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          PlaceableActorBoundsInstances;                     // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          PlaceableConnectionsBounds;                        // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   FloorToCeilingIndicator;                           // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      HighlightedMaterial;                               // 0x0330(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      UnhighlightedMaterial;                             // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHousingPlacementEffectComponent*       HousingPlacementEffectComp;                        // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               OverlayMaterialInstance;                           // 0x0348(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2769[0x68];                                    // 0x0350(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       ItemToPlaceMaterials;                              // 0x03B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         OriginalMovedActors;                               // 0x03C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFenceComponent*>                FenceComponents;                                   // 0x03D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         NumValidFenceComponents;                           // 0x03E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_276A[0x4];                                     // 0x03EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnPlacementUserRotationInput(int32 Amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacementViewActor">();
	}
	static class APlacementViewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlacementViewActor>();
	}
};
static_assert(alignof(APlacementViewActor) == 0x000008, "Wrong alignment on APlacementViewActor");
static_assert(sizeof(APlacementViewActor) == 0x0003F0, "Wrong size on APlacementViewActor");
static_assert(offsetof(APlacementViewActor, OverlayMaterialTemplate) == 0x0002A8, "Member 'APlacementViewActor::OverlayMaterialTemplate' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, SpawnEffectCurve) == 0x0002B0, "Member 'APlacementViewActor::SpawnEffectCurve' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, PlaceEffectCurve) == 0x0002B8, "Member 'APlacementViewActor::PlaceEffectCurve' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, ViewMeshComponents) == 0x0002C0, "Member 'APlacementViewActor::ViewMeshComponents' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, CheckMeshComponents) == 0x0002D0, "Member 'APlacementViewActor::CheckMeshComponents' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, CheckMeshToOriginalArrayIdx) == 0x0002E0, "Member 'APlacementViewActor::CheckMeshToOriginalArrayIdx' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, NeedSuccessCheckComponents) == 0x0002E8, "Member 'APlacementViewActor::NeedSuccessCheckComponents' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, MovedConnectedActors) == 0x0002F8, "Member 'APlacementViewActor::MovedConnectedActors' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, Root) == 0x000308, "Member 'APlacementViewActor::Root' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, PlugMesh) == 0x000310, "Member 'APlacementViewActor::PlugMesh' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, PlaceableActorBoundsInstances) == 0x000318, "Member 'APlacementViewActor::PlaceableActorBoundsInstances' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, PlaceableConnectionsBounds) == 0x000320, "Member 'APlacementViewActor::PlaceableConnectionsBounds' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, FloorToCeilingIndicator) == 0x000328, "Member 'APlacementViewActor::FloorToCeilingIndicator' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, HighlightedMaterial) == 0x000330, "Member 'APlacementViewActor::HighlightedMaterial' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, UnhighlightedMaterial) == 0x000338, "Member 'APlacementViewActor::UnhighlightedMaterial' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, HousingPlacementEffectComp) == 0x000340, "Member 'APlacementViewActor::HousingPlacementEffectComp' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, OverlayMaterialInstance) == 0x000348, "Member 'APlacementViewActor::OverlayMaterialInstance' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, ItemToPlaceMaterials) == 0x0003B8, "Member 'APlacementViewActor::ItemToPlaceMaterials' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, OriginalMovedActors) == 0x0003C8, "Member 'APlacementViewActor::OriginalMovedActors' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, FenceComponents) == 0x0003D8, "Member 'APlacementViewActor::FenceComponents' has a wrong offset!");
static_assert(offsetof(APlacementViewActor, NumValidFenceComponents) == 0x0003E8, "Member 'APlacementViewActor::NumValidFenceComponents' has a wrong offset!");

// Class Palia.GoalsBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGoalsBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetXOverYProgressText(class AValeriaCharacter* Character, struct FVillagerQuestRequirement& Requirement, int32 GoalProgress, class FText* OutText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoalsBlueprintLibrary">();
	}
	static class UGoalsBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoalsBlueprintLibrary>();
	}
};
static_assert(alignof(UGoalsBlueprintLibrary) == 0x000008, "Wrong alignment on UGoalsBlueprintLibrary");
static_assert(sizeof(UGoalsBlueprintLibrary) == 0x000028, "Wrong size on UGoalsBlueprintLibrary");

// Class Palia.HazardComponent
// 0x0018 (0x00B8 - 0x00A0)
class UHazardComponent final : public UActorComponent
{
public:
	uint8                                         Pad_276D[0x4];                                     // 0x00A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalLifetime;                                     // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DespawnDuration;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BuffIDToApplyOnContact;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HazardTier;                                        // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_276E[0x4];                                     // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartHazard();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HazardComponent">();
	}
	static class UHazardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHazardComponent>();
	}
};
static_assert(alignof(UHazardComponent) == 0x000008, "Wrong alignment on UHazardComponent");
static_assert(sizeof(UHazardComponent) == 0x0000B8, "Wrong size on UHazardComponent");
static_assert(offsetof(UHazardComponent, TotalLifetime) == 0x0000A4, "Member 'UHazardComponent::TotalLifetime' has a wrong offset!");
static_assert(offsetof(UHazardComponent, DespawnDuration) == 0x0000A8, "Member 'UHazardComponent::DespawnDuration' has a wrong offset!");
static_assert(offsetof(UHazardComponent, BuffIDToApplyOnContact) == 0x0000AC, "Member 'UHazardComponent::BuffIDToApplyOnContact' has a wrong offset!");
static_assert(offsetof(UHazardComponent, HazardTier) == 0x0000B0, "Member 'UHazardComponent::HazardTier' has a wrong offset!");

// Class Palia.PrivateSpaceSettings
// 0x0028 (0x0060 - 0x0038)
class UPrivateSpaceSettings final : public UDeveloperSettings
{
public:
	struct FVector                                BaseSpawnOffset;                                   // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnSeparation;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPrivateSpacesPerRow;                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPrivateSpaceSlots;                              // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276F[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrivateSpaceSettings">();
	}
	static class UPrivateSpaceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrivateSpaceSettings>();
	}
};
static_assert(alignof(UPrivateSpaceSettings) == 0x000008, "Wrong alignment on UPrivateSpaceSettings");
static_assert(sizeof(UPrivateSpaceSettings) == 0x000060, "Wrong size on UPrivateSpaceSettings");
static_assert(offsetof(UPrivateSpaceSettings, BaseSpawnOffset) == 0x000038, "Member 'UPrivateSpaceSettings::BaseSpawnOffset' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceSettings, SpawnSeparation) == 0x000050, "Member 'UPrivateSpaceSettings::SpawnSeparation' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceSettings, NumPrivateSpacesPerRow) == 0x000054, "Member 'UPrivateSpaceSettings::NumPrivateSpacesPerRow' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceSettings, MaxPrivateSpaceSlots) == 0x000058, "Member 'UPrivateSpaceSettings::MaxPrivateSpaceSlots' has a wrong offset!");

// Class Palia.HealthRegenComponent
// 0x0018 (0x00B8 - 0x00A0)
class UHealthRegenComponent final : public UActorComponent
{
public:
	float                                         HealthRegenPerSecond;                              // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2770[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVitalsComponent*                       CachedVitalsComponent;                             // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2771[0x8];                                     // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthRegenComponent">();
	}
	static class UHealthRegenComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthRegenComponent>();
	}
};
static_assert(alignof(UHealthRegenComponent) == 0x000008, "Wrong alignment on UHealthRegenComponent");
static_assert(sizeof(UHealthRegenComponent) == 0x0000B8, "Wrong size on UHealthRegenComponent");
static_assert(offsetof(UHealthRegenComponent, HealthRegenPerSecond) == 0x0000A0, "Member 'UHealthRegenComponent::HealthRegenPerSecond' has a wrong offset!");
static_assert(offsetof(UHealthRegenComponent, CachedVitalsComponent) == 0x0000A8, "Member 'UHealthRegenComponent::CachedVitalsComponent' has a wrong offset!");

// Class Palia.GeneratedHeatmap
// 0x0010 (0x0038 - 0x0028)
class UGeneratedHeatmap final : public UObject
{
public:
	TArray<struct FGeneratedHeatmapPoint>         Points;                                            // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	struct FGeneratedHeatmapPoint GetPoint(int32 Param_Index) const;
	int32 NumPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratedHeatmap">();
	}
	static class UGeneratedHeatmap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratedHeatmap>();
	}
};
static_assert(alignof(UGeneratedHeatmap) == 0x000008, "Wrong alignment on UGeneratedHeatmap");
static_assert(sizeof(UGeneratedHeatmap) == 0x000038, "Wrong size on UGeneratedHeatmap");
static_assert(offsetof(UGeneratedHeatmap, Points) == 0x000028, "Member 'UGeneratedHeatmap::Points' has a wrong offset!");

// Class Palia.QualityGlobalConfig
// 0x0020 (0x0050 - 0x0030)
class UQualityGlobalConfig final : public UDataAsset
{
public:
	float                                         SellRewardQualityMultiplier;                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConsumeRewardFocusQualityMultiplier;               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WormFarmFoodValueQualityModifier;                  // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2773[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ItemRarityWeights;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QualityGlobalConfig">();
	}
	static class UQualityGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQualityGlobalConfig>();
	}
};
static_assert(alignof(UQualityGlobalConfig) == 0x000008, "Wrong alignment on UQualityGlobalConfig");
static_assert(sizeof(UQualityGlobalConfig) == 0x000050, "Wrong size on UQualityGlobalConfig");
static_assert(offsetof(UQualityGlobalConfig, SellRewardQualityMultiplier) == 0x000030, "Member 'UQualityGlobalConfig::SellRewardQualityMultiplier' has a wrong offset!");
static_assert(offsetof(UQualityGlobalConfig, ConsumeRewardFocusQualityMultiplier) == 0x000034, "Member 'UQualityGlobalConfig::ConsumeRewardFocusQualityMultiplier' has a wrong offset!");
static_assert(offsetof(UQualityGlobalConfig, WormFarmFoodValueQualityModifier) == 0x000038, "Member 'UQualityGlobalConfig::WormFarmFoodValueQualityModifier' has a wrong offset!");
static_assert(offsetof(UQualityGlobalConfig, ItemRarityWeights) == 0x000040, "Member 'UQualityGlobalConfig::ItemRarityWeights' has a wrong offset!");

// Class Palia.HeatmapGenerator
// 0x0000 (0x0030 - 0x0030)
class UHeatmapGenerator final : public UGameInstanceSubsystem
{
public:
	class UGeneratedHeatmap* GenerateSpawnHeatmap(const class FString& LogFilePath, const class FString& SpawnClass, int32 MaxLines);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeatmapGenerator">();
	}
	static class UHeatmapGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeatmapGenerator>();
	}
};
static_assert(alignof(UHeatmapGenerator) == 0x000008, "Wrong alignment on UHeatmapGenerator");
static_assert(sizeof(UHeatmapGenerator) == 0x000030, "Wrong size on UHeatmapGenerator");

// Class Palia.HitReactComponent
// 0x0110 (0x01B0 - 0x00A0)
class UHitReactComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDispel;                                          // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectileHitReact;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeHitReact;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHitReactEnded;                                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInsectEscapedFromTrap;                           // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInsectTrapWasBoosted;                            // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2775[0x4];                                     // 0x0100(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllowedAngleForBlocking;                           // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLeftInCurrentReaction;                         // 0x0108(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBeKnockedBack;                              // 0x010C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2776[0x3];                                     // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_ItemTypeDefinitionAsset*           ToolUsedToHit;                                     // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeStunnedAtEndOfHitReaction;                     // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToSpendBeingKnockedBack;                       // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackDistance;                                 // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToSpendBeingTrapped;                           // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBeingKnockedBack;                                 // 0x0128(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTrapped;                                        // 0x0129(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2777[0xA];                                     // 0x012A(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIRequestID                           LastKnockbackPathRequestId;                        // 0x0134(0x0004)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bShouldSimulateKnockbackMovement;                  // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2778[0x1F];                                    // 0x0139(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<uint32>                                  AttackersHitDuringTrapped;                         // 0x0158(0x0050)(Transient, NativeAccessSpecifierPrivate)
	float                                         AdditionalCatchValue;                              // 0x01A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasInstantTrapped;                                // 0x01AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2779[0x3];                                     // 0x01AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttemptApplyAttack(class AActor* Attacker, EHitReactionType Type, class UAbilitySystemComponent* AttackerGAS, TSubclassOf<class UGameplayEffect> GameplayEffectClass, class UAbilitySystemComponent* TargetGAS, float Level, const struct FGameplayEffectContextHandle& Context);
	void BeginHitReaction(class AActor* Attacker, EHitReactionType Type);
	void NotifyHitByMelee(class AActor* Attacker, EHitReactionType Type);
	void NotifyHitByProjectile(class AActor* Instigator, class AActor* Projectile);
	void NotifyHitReactEnd();
	void OnMoveToPathComplete(const struct FAIRequestID& RequestID, EPathFollowingResult Result);
	void RpcClient_DisplayProjectileHitReact(class AActor* Instigator, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& AmmoType);
	void RpcClient_NotifyDispeled();
	void RpcClient_OnPlayerKnockbackStarted(class AActor* Attacker, const struct FVector& KnockBackDirection, const struct FVector& FinalDestination, float KnockbackDuration);
	void RpcNetMulticast_BeginHitReaction(bool IsFromMelee, class AActor* Attacker, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& AmmoItemType, EHitReactionType Type);
	void RpcNetMulticast_OnCreatureEscapedFromTrap(class AActor* Actor);
	void RpcNetMulticast_OnCreatureKnockbackEnded();
	void RpcNetMulticast_OnCreatureKnockbackStarted(class AActor* Attacker, const struct FVector& KnockBackDirection, const struct FVector& FinalDestination);

	class AActor* GetAttackerInstigator() const;
	bool IsBeingKnockedBack() const;
	bool IsReactingToHit() const;
	bool IsTrapped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactComponent">();
	}
	static class UHitReactComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactComponent>();
	}
};
static_assert(alignof(UHitReactComponent) == 0x000008, "Wrong alignment on UHitReactComponent");
static_assert(sizeof(UHitReactComponent) == 0x0001B0, "Wrong size on UHitReactComponent");
static_assert(offsetof(UHitReactComponent, OnDispel) == 0x0000A0, "Member 'UHitReactComponent::OnDispel' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, OnProjectileHitReact) == 0x0000B0, "Member 'UHitReactComponent::OnProjectileHitReact' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, OnMeleeHitReact) == 0x0000C0, "Member 'UHitReactComponent::OnMeleeHitReact' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, OnHitReactEnded) == 0x0000D0, "Member 'UHitReactComponent::OnHitReactEnded' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, OnInsectEscapedFromTrap) == 0x0000E0, "Member 'UHitReactComponent::OnInsectEscapedFromTrap' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, OnInsectTrapWasBoosted) == 0x0000F0, "Member 'UHitReactComponent::OnInsectTrapWasBoosted' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, AllowedAngleForBlocking) == 0x000104, "Member 'UHitReactComponent::AllowedAngleForBlocking' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, TimeLeftInCurrentReaction) == 0x000108, "Member 'UHitReactComponent::TimeLeftInCurrentReaction' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, bShouldBeKnockedBack) == 0x00010C, "Member 'UHitReactComponent::bShouldBeKnockedBack' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, ToolUsedToHit) == 0x000110, "Member 'UHitReactComponent::ToolUsedToHit' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, TimeStunnedAtEndOfHitReaction) == 0x000118, "Member 'UHitReactComponent::TimeStunnedAtEndOfHitReaction' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, TimeToSpendBeingKnockedBack) == 0x00011C, "Member 'UHitReactComponent::TimeToSpendBeingKnockedBack' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, KnockbackDistance) == 0x000120, "Member 'UHitReactComponent::KnockbackDistance' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, TimeToSpendBeingTrapped) == 0x000124, "Member 'UHitReactComponent::TimeToSpendBeingTrapped' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, bBeingKnockedBack) == 0x000128, "Member 'UHitReactComponent::bBeingKnockedBack' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, bIsTrapped) == 0x000129, "Member 'UHitReactComponent::bIsTrapped' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, LastKnockbackPathRequestId) == 0x000134, "Member 'UHitReactComponent::LastKnockbackPathRequestId' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, bShouldSimulateKnockbackMovement) == 0x000138, "Member 'UHitReactComponent::bShouldSimulateKnockbackMovement' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, AttackersHitDuringTrapped) == 0x000158, "Member 'UHitReactComponent::AttackersHitDuringTrapped' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, AdditionalCatchValue) == 0x0001A8, "Member 'UHitReactComponent::AdditionalCatchValue' has a wrong offset!");
static_assert(offsetof(UHitReactComponent, bWasInstantTrapped) == 0x0001AC, "Member 'UHitReactComponent::bWasInstantTrapped' has a wrong offset!");

// Class Palia.PrivateSpaceVillagerVisitConfig
// 0x0158 (0x01A0 - 0x0048)
class UPrivateSpaceVillagerVisitConfig final : public UGuidDataAsset
{
public:
	bool                                          bEnabled;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2782[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventPlayerFromLeaving;                         // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepVillagersUntilPlayerLeaves;                   // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDelayedVisit;                                     // 0x0052(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2783[0x1];                                     // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DelayedVisitGameHours;                             // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVillagerVisitOccurrence                      VillagerVisitOccurrence;                           // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2784[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVillagerActionPrereq                  Requirements;                                      // 0x0060(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UVAL_GameplayConditionDef*              StartCondition;                                    // 0x00D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVillagerActionPrereq                  FinishRequirements;                                // 0x00E0(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UVAL_GameplayConditionDef*              FinishCondition;                                   // 0x0158(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrivateSpaceVillagerSpawnInfo> VisitingVillagerSpawnInfos;                        // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         VisitingVillagerWalkOutDuration;                   // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2785[0x4];                                     // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVAL_ContentBatchAsset>  ContentBatch;                                      // 0x0178(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CanFinishPrivateSpaceVillagerVisit(class AValeriaCharacter* InValeriaCharacter) const;
	bool CanStartPrivateSpaceVillagerVisit(class AValeriaCharacter* InValeriaCharacter) const;
	TArray<class FName> GetVisitingVillagerCoreNames() const;
	TArray<int32> GetVisitingVillagerIds() const;
	TMap<int32, struct FPrivateSpaceVillagerSpawnInfo> GetVisitingVillagerIdsAndSpawnInfos() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrivateSpaceVillagerVisitConfig">();
	}
	static class UPrivateSpaceVillagerVisitConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrivateSpaceVillagerVisitConfig>();
	}
};
static_assert(alignof(UPrivateSpaceVillagerVisitConfig) == 0x000008, "Wrong alignment on UPrivateSpaceVillagerVisitConfig");
static_assert(sizeof(UPrivateSpaceVillagerVisitConfig) == 0x0001A0, "Wrong size on UPrivateSpaceVillagerVisitConfig");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, bEnabled) == 0x000048, "Member 'UPrivateSpaceVillagerVisitConfig::bEnabled' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, Priority) == 0x00004C, "Member 'UPrivateSpaceVillagerVisitConfig::Priority' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, bPreventPlayerFromLeaving) == 0x000050, "Member 'UPrivateSpaceVillagerVisitConfig::bPreventPlayerFromLeaving' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, bKeepVillagersUntilPlayerLeaves) == 0x000051, "Member 'UPrivateSpaceVillagerVisitConfig::bKeepVillagersUntilPlayerLeaves' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, bDelayedVisit) == 0x000052, "Member 'UPrivateSpaceVillagerVisitConfig::bDelayedVisit' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, DelayedVisitGameHours) == 0x000054, "Member 'UPrivateSpaceVillagerVisitConfig::DelayedVisitGameHours' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, VillagerVisitOccurrence) == 0x000058, "Member 'UPrivateSpaceVillagerVisitConfig::VillagerVisitOccurrence' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, Requirements) == 0x000060, "Member 'UPrivateSpaceVillagerVisitConfig::Requirements' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, StartCondition) == 0x0000D8, "Member 'UPrivateSpaceVillagerVisitConfig::StartCondition' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, FinishRequirements) == 0x0000E0, "Member 'UPrivateSpaceVillagerVisitConfig::FinishRequirements' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, FinishCondition) == 0x000158, "Member 'UPrivateSpaceVillagerVisitConfig::FinishCondition' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, VisitingVillagerSpawnInfos) == 0x000160, "Member 'UPrivateSpaceVillagerVisitConfig::VisitingVillagerSpawnInfos' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, VisitingVillagerWalkOutDuration) == 0x000170, "Member 'UPrivateSpaceVillagerVisitConfig::VisitingVillagerWalkOutDuration' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceVillagerVisitConfig, ContentBatch) == 0x000178, "Member 'UPrivateSpaceVillagerVisitConfig::ContentBatch' has a wrong offset!");

// Class Palia.HotpotConfig
// 0x0090 (0x0128 - 0x0098)
class UHotpotConfig final : public USubgameConfig
{
public:
	int32                                         ScorePerFoodGroup;                                 // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScorePerColorGroup;                                // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurrencyConfig*                        RewardCurrency;                                    // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoStartDelaySeconds;                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2788[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    QuitDebuff;                                        // 0x00B0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   StartGameText;                                     // 0x00C0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DebuffText;                                        // 0x00D8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   WaitingToStartText;                                // 0x00F0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   GameActiveText;                                    // 0x0108(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bAutoWin;                                          // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2789[0x7];                                     // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotpotConfig">();
	}
	static class UHotpotConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotpotConfig>();
	}
};
static_assert(alignof(UHotpotConfig) == 0x000008, "Wrong alignment on UHotpotConfig");
static_assert(sizeof(UHotpotConfig) == 0x000128, "Wrong size on UHotpotConfig");
static_assert(offsetof(UHotpotConfig, ScorePerFoodGroup) == 0x000098, "Member 'UHotpotConfig::ScorePerFoodGroup' has a wrong offset!");
static_assert(offsetof(UHotpotConfig, ScorePerColorGroup) == 0x00009C, "Member 'UHotpotConfig::ScorePerColorGroup' has a wrong offset!");
static_assert(offsetof(UHotpotConfig, RewardCurrency) == 0x0000A0, "Member 'UHotpotConfig::RewardCurrency' has a wrong offset!");
static_assert(offsetof(UHotpotConfig, AutoStartDelaySeconds) == 0x0000A8, "Member 'UHotpotConfig::AutoStartDelaySeconds' has a wrong offset!");
static_assert(offsetof(UHotpotConfig, QuitDebuff) == 0x0000B0, "Member 'UHotpotConfig::QuitDebuff' has a wrong offset!");
static_assert(offsetof(UHotpotConfig, StartGameText) == 0x0000C0, "Member 'UHotpotConfig::StartGameText' has a wrong offset!");
static_assert(offsetof(UHotpotConfig, DebuffText) == 0x0000D8, "Member 'UHotpotConfig::DebuffText' has a wrong offset!");
static_assert(offsetof(UHotpotConfig, WaitingToStartText) == 0x0000F0, "Member 'UHotpotConfig::WaitingToStartText' has a wrong offset!");
static_assert(offsetof(UHotpotConfig, GameActiveText) == 0x000108, "Member 'UHotpotConfig::GameActiveText' has a wrong offset!");
static_assert(offsetof(UHotpotConfig, bAutoWin) == 0x000120, "Member 'UHotpotConfig::bAutoWin' has a wrong offset!");

// Class Palia.SubgameInputHandlerComponent
// 0x0050 (0x00F0 - 0x00A0)
class USubgameInputHandlerComponent : public UActorComponent
{
public:
	class UInputMappingContext*                   SubgameInputMappingContext;                        // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputMappingContext*                   SubgameInputMappingContextGamepad;                 // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSubgameInputInfo>              SubgameInputInfos;                                 // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         SubgameInputPriority;                              // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278A[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaPlayerController*               OwningPlayerController;                            // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCommonInputSubsystem>   CommonInputSubsystem;                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USubgameManagerComponent> SubgameManagerRef;                                 // 0x00D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                SubgameMixRtpc;                                    // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278B[0x8];                                     // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSubgameInputs();
	void BPIE_PlayerExitedSubgame(ESubgameResult SubgameResult);
	void BPNE_AssignSubgameManagerReference(class USubgameManagerComponent* InSubgameManagerRef);
	void ClearSubgameInputs();
	void ExitSubgame(ESubgameResult SubgameResult);
	void HandleInputTypeChanged(ECommonInputType NewInputType);
	void RpcClient_InitializeSubgameInputHandlerComponent(struct FSubgameInputHandlerInitializationParams& InSubgameInputHandlerInitializationParams);
	void RpcClient_UninitializeSubgameInputHandlerComponent(ESubgameResult SubgameResult);
	void RpcServer_ExitSubgame(ESubgameResult SubgameResult);

	bool IsSubgameActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubgameInputHandlerComponent">();
	}
	static class USubgameInputHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubgameInputHandlerComponent>();
	}
};
static_assert(alignof(USubgameInputHandlerComponent) == 0x000008, "Wrong alignment on USubgameInputHandlerComponent");
static_assert(sizeof(USubgameInputHandlerComponent) == 0x0000F0, "Wrong size on USubgameInputHandlerComponent");
static_assert(offsetof(USubgameInputHandlerComponent, SubgameInputMappingContext) == 0x0000A0, "Member 'USubgameInputHandlerComponent::SubgameInputMappingContext' has a wrong offset!");
static_assert(offsetof(USubgameInputHandlerComponent, SubgameInputMappingContextGamepad) == 0x0000A8, "Member 'USubgameInputHandlerComponent::SubgameInputMappingContextGamepad' has a wrong offset!");
static_assert(offsetof(USubgameInputHandlerComponent, SubgameInputInfos) == 0x0000B0, "Member 'USubgameInputHandlerComponent::SubgameInputInfos' has a wrong offset!");
static_assert(offsetof(USubgameInputHandlerComponent, SubgameInputPriority) == 0x0000C0, "Member 'USubgameInputHandlerComponent::SubgameInputPriority' has a wrong offset!");
static_assert(offsetof(USubgameInputHandlerComponent, OwningPlayerController) == 0x0000C8, "Member 'USubgameInputHandlerComponent::OwningPlayerController' has a wrong offset!");
static_assert(offsetof(USubgameInputHandlerComponent, CommonInputSubsystem) == 0x0000D0, "Member 'USubgameInputHandlerComponent::CommonInputSubsystem' has a wrong offset!");
static_assert(offsetof(USubgameInputHandlerComponent, SubgameManagerRef) == 0x0000D8, "Member 'USubgameInputHandlerComponent::SubgameManagerRef' has a wrong offset!");
static_assert(offsetof(USubgameInputHandlerComponent, SubgameMixRtpc) == 0x0000E0, "Member 'USubgameInputHandlerComponent::SubgameMixRtpc' has a wrong offset!");

// Class Palia.PresenceManager
// 0x00F0 (0x0120 - 0x0030)
class UPresenceManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPresenceChange;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExpPkgChanged;                                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowDebugPresences;                              // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerIdChanged;                                 // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_278C[0xB0];                                    // 0x0070(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetDebugPresenceFlag();

	void HandleExpPkgChanged(class UExperiencePackageConfig* NewExpPkg);
	void HandleOnPawnChanged(class APawn* Pawn);
	void HandleOnSelectedCharacterChanged(struct FOSSVAL_SelectedCharacter& SelectedCharacter);
	void HandleOnServerIdUpdated(const class FString& ID);
	void OnSearchForCharacterResult__DelegateSignature(bool bWasSuccessful, const class FString& OriginalSearchTerm, struct FUniqueNetIdRepl& OutUserId, struct FVALDTOS_MetaCharacterFormat& OutCharacterInfo);
	void OnServerIdChanged__DelegateSignature(const class FString& ID);
	void SetPresence(EVAL_PresenceStatus Status, const class FString& StatusStr);
	bool TrySearchForCharacter(const class FString& CharacterName, TDelegate<void(bool bWasSuccessful, const class FString& OriginalSearchTerm, struct FUniqueNetIdRepl& OutUserId, struct FVALDTOS_MetaCharacterFormat& OutCharacterInfo)>& OnSearchForCharacterResult);
	void ValShowDebugPresences__DelegateSignature(bool bDisplayDebugPresences);

	TArray<struct FUniqueNetIdRepl> GetCachedPresencesUserIdList() const;
	class FString GetCharacterName(struct FUniqueNetIdRepl& UserId) const;
	const class FString GetOurCurrentServer() const;
	struct FPresence GetPresenceForUserId(struct FUniqueNetIdRepl& UserId) const;
	class FString GetServerId() const;
	struct FUniqueNetIdRepl GetUserIdForCharacterName(const class FString& CharacterName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresenceManager">();
	}
	static class UPresenceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresenceManager>();
	}
};
static_assert(alignof(UPresenceManager) == 0x000008, "Wrong alignment on UPresenceManager");
static_assert(sizeof(UPresenceManager) == 0x000120, "Wrong size on UPresenceManager");
static_assert(offsetof(UPresenceManager, OnPresenceChange) == 0x000030, "Member 'UPresenceManager::OnPresenceChange' has a wrong offset!");
static_assert(offsetof(UPresenceManager, OnExpPkgChanged) == 0x000040, "Member 'UPresenceManager::OnExpPkgChanged' has a wrong offset!");
static_assert(offsetof(UPresenceManager, OnShowDebugPresences) == 0x000050, "Member 'UPresenceManager::OnShowDebugPresences' has a wrong offset!");
static_assert(offsetof(UPresenceManager, OnServerIdChanged) == 0x000060, "Member 'UPresenceManager::OnServerIdChanged' has a wrong offset!");

// Class Palia.HotPotInputHandlerComponent
// 0x0088 (0x0178 - 0x00F0)
class UHotPotInputHandlerComponent final : public USubgameInputHandlerComponent
{
public:
	FMulticastInlineDelegateProperty_             OnHotPotStateUpdated;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHotPotGameEnd;                                   // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bGameStateValid;                                   // 0x0110(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2790[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHotPotGameState                       LatestHotPotState;                                 // 0x0118(0x0030)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_2791[0x1];                                     // 0x0148(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLastHoveredByCursor;                              // 0x0149(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2792[0x16];                                    // 0x014A(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      MouseQueryObjectTypes;                             // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHotPotTileRepresentation> HoveredTile;                                       // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleOnHotPotGameEnd(class UHotPotSubgameManager* HotPotManager, struct FHotPotGameEndState& GameEndState);
	void HandleOnHotPotStateUpdated(class UHotPotSubgameManager* HotPotManager, class AValeriaPlayerController* Player, struct FHotPotGameState& HotPotGameState);
	void HandleTileSelectionDirection(EHotPotNavigationDirection Direction);
	void HoverDefaultTile();
	void OnHotPotGameEnd__DelegateSignature(struct FHotPotGameEndState& GameEndState);
	void OnHotPotStateUpdated__DelegateSignature(class UHotPotInputHandlerComponent* InputHandler, struct FHotPotGameState& LatestGameState);
	void RequestUpdateHotPotInfo();
	void RpcClient_EndGameNotify(const struct FHotPotGameEndState& HotPotEndState);
	void RpcClient_UpdateHotPotState(const struct FHotPotGameState& CurrentHotPotState);
	void RpcServer_GetHotPotState();
	void RpcServer_PlayerRequestAction(EHotPotActionType Action, int32 ActionTarget);
	void SetCanHover(bool bNewCanHover);
	void UpdateHoveredTile(class AHotPotTileRepresentation* InTile, bool bByCursor);

	bool CanHoverTiles() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotPotInputHandlerComponent">();
	}
	static class UHotPotInputHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotPotInputHandlerComponent>();
	}
};
static_assert(alignof(UHotPotInputHandlerComponent) == 0x000008, "Wrong alignment on UHotPotInputHandlerComponent");
static_assert(sizeof(UHotPotInputHandlerComponent) == 0x000178, "Wrong size on UHotPotInputHandlerComponent");
static_assert(offsetof(UHotPotInputHandlerComponent, OnHotPotStateUpdated) == 0x0000F0, "Member 'UHotPotInputHandlerComponent::OnHotPotStateUpdated' has a wrong offset!");
static_assert(offsetof(UHotPotInputHandlerComponent, OnHotPotGameEnd) == 0x000100, "Member 'UHotPotInputHandlerComponent::OnHotPotGameEnd' has a wrong offset!");
static_assert(offsetof(UHotPotInputHandlerComponent, bGameStateValid) == 0x000110, "Member 'UHotPotInputHandlerComponent::bGameStateValid' has a wrong offset!");
static_assert(offsetof(UHotPotInputHandlerComponent, LatestHotPotState) == 0x000118, "Member 'UHotPotInputHandlerComponent::LatestHotPotState' has a wrong offset!");
static_assert(offsetof(UHotPotInputHandlerComponent, bLastHoveredByCursor) == 0x000149, "Member 'UHotPotInputHandlerComponent::bLastHoveredByCursor' has a wrong offset!");
static_assert(offsetof(UHotPotInputHandlerComponent, MouseQueryObjectTypes) == 0x000160, "Member 'UHotPotInputHandlerComponent::MouseQueryObjectTypes' has a wrong offset!");
static_assert(offsetof(UHotPotInputHandlerComponent, HoveredTile) == 0x000170, "Member 'UHotPotInputHandlerComponent::HoveredTile' has a wrong offset!");

// Class Palia.SubgameActivatorComponent
// 0x00A8 (0x0148 - 0x00A0)
class USubgameActivatorComponent : public UActorComponent
{
public:
	uint8                                         Pad_2795[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USubgameConfig>          SubgameConfig;                                     // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   InteractText;                                      // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         InteractionPriority;                               // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2796[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharacterEnteredSubgame;                         // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterExitedSubgame;                          // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSubgameManagerChanged;                           // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USubgameManagerComponent*               SubgameManager;                                    // 0x0120(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AValeriaCharacter*>              CharactersPendingJoin;                             // 0x0128(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bFadeToBlackOnCameraChange;                        // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2797[0xF];                                     // 0x0139(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginSubgame(class AValeriaCharacter* PlayingCharacter);
	void ExitSubgame(class USubgameManagerComponent* ExitedSubgameManager, class AValeriaCharacter* PlayingCharacter, ESubgameResult SubgameResult);
	void FallbackTransitionBackToMainCamera(class AValeriaPlayerController* ValeriaPlayerController);
	void FinishBeginSubgame(class AValeriaCharacter* PlayingCharacter);
	void FinishExitSubgame(class AValeriaCharacter* PlayingCharacter, ESubgameResult SubgameResult);
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Vpc, const struct FInteractEventParams& EventParams);
	struct FUseEventResult OnClientUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnRep_SubgameManager();
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void OnServerUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FServerUseEventParams& Params_0);
	void PostFinishBeginSubgame(class AValeriaCharacter* PlayingCharacter);
	void PostFinishExitSubgame(class AValeriaCharacter* PlayingCharacter, ESubgameResult SubgameResult);
	void RpcNetMulticast_NotifyCharacterEnteredSubgame(class AValeriaCharacter* PlayingCharacter);
	void RpcNetMulticast_NotifyCharacterExitedSubgame(class AValeriaCharacter* PlayingCharacter, ESubgameResult SubgameResult);
	void SubgameManagerComponentDeactivated(class UActorComponent* DeactivatedComponent);

	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsAtMaxPlayers() const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubgameActivatorComponent">();
	}
	static class USubgameActivatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubgameActivatorComponent>();
	}
};
static_assert(alignof(USubgameActivatorComponent) == 0x000008, "Wrong alignment on USubgameActivatorComponent");
static_assert(sizeof(USubgameActivatorComponent) == 0x000148, "Wrong size on USubgameActivatorComponent");
static_assert(offsetof(USubgameActivatorComponent, SubgameConfig) == 0x0000A8, "Member 'USubgameActivatorComponent::SubgameConfig' has a wrong offset!");
static_assert(offsetof(USubgameActivatorComponent, InteractText) == 0x0000D0, "Member 'USubgameActivatorComponent::InteractText' has a wrong offset!");
static_assert(offsetof(USubgameActivatorComponent, InteractionPriority) == 0x0000E8, "Member 'USubgameActivatorComponent::InteractionPriority' has a wrong offset!");
static_assert(offsetof(USubgameActivatorComponent, OnCharacterEnteredSubgame) == 0x0000F0, "Member 'USubgameActivatorComponent::OnCharacterEnteredSubgame' has a wrong offset!");
static_assert(offsetof(USubgameActivatorComponent, OnCharacterExitedSubgame) == 0x000100, "Member 'USubgameActivatorComponent::OnCharacterExitedSubgame' has a wrong offset!");
static_assert(offsetof(USubgameActivatorComponent, OnSubgameManagerChanged) == 0x000110, "Member 'USubgameActivatorComponent::OnSubgameManagerChanged' has a wrong offset!");
static_assert(offsetof(USubgameActivatorComponent, SubgameManager) == 0x000120, "Member 'USubgameActivatorComponent::SubgameManager' has a wrong offset!");
static_assert(offsetof(USubgameActivatorComponent, CharactersPendingJoin) == 0x000128, "Member 'USubgameActivatorComponent::CharactersPendingJoin' has a wrong offset!");
static_assert(offsetof(USubgameActivatorComponent, bFadeToBlackOnCameraChange) == 0x000138, "Member 'USubgameActivatorComponent::bFadeToBlackOnCameraChange' has a wrong offset!");

// Class Palia.VAL_Prototype_BubbleSpawnManagerComponent
// 0x0080 (0x0120 - 0x00A0)
class UVAL_Prototype_BubbleSpawnManagerComponent final : public UActorComponent
{
public:
	float                                         TotalDuration;                                     // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveAlongSpline;                                  // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A1[0x3];                                     // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MovementSplineActor;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVAL_Prototype_BubbleSpawnRoundInstance> RoundStarts;                                       // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBubbleGameBegin;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBubbleGameEnd;                                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRoundBegin;                                      // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRoundEnd;                                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A2[0x3];                                     // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentTime;                                       // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVAL_Prototype_BubbleSpawnRound> ActiveRounds;                                      // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class USplineComponent*                       MovementSpline;                                    // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BeginBubbleSpawning();
	void BeginRound(const struct FVAL_Prototype_BubbleSpawnRound& RoundDefinition);
	void EndBubbleSpawning();
	TArray<struct FVAL_Prototype_BubbleSpawnRound> GetActiveRoundsByID(const class FString& RoundID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_Prototype_BubbleSpawnManagerComponent">();
	}
	static class UVAL_Prototype_BubbleSpawnManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_Prototype_BubbleSpawnManagerComponent>();
	}
};
static_assert(alignof(UVAL_Prototype_BubbleSpawnManagerComponent) == 0x000008, "Wrong alignment on UVAL_Prototype_BubbleSpawnManagerComponent");
static_assert(sizeof(UVAL_Prototype_BubbleSpawnManagerComponent) == 0x000120, "Wrong size on UVAL_Prototype_BubbleSpawnManagerComponent");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, TotalDuration) == 0x0000A0, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::TotalDuration' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, bMoveAlongSpline) == 0x0000A4, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::bMoveAlongSpline' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, MovementSplineActor) == 0x0000A8, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::MovementSplineActor' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, RoundStarts) == 0x0000B0, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::RoundStarts' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, OnBubbleGameBegin) == 0x0000C0, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::OnBubbleGameBegin' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, OnBubbleGameEnd) == 0x0000D0, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::OnBubbleGameEnd' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, OnRoundBegin) == 0x0000E0, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::OnRoundBegin' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, OnRoundEnd) == 0x0000F0, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::OnRoundEnd' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, bActive) == 0x000100, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::bActive' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, CurrentTime) == 0x000104, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::CurrentTime' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, ActiveRounds) == 0x000108, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::ActiveRounds' has a wrong offset!");
static_assert(offsetof(UVAL_Prototype_BubbleSpawnManagerComponent, MovementSpline) == 0x000118, "Member 'UVAL_Prototype_BubbleSpawnManagerComponent::MovementSpline' has a wrong offset!");

// Class Palia.HotPotSubgameActivator
// 0x0008 (0x0150 - 0x0148)
class UHotPotSubgameActivator final : public USubgameActivatorComponent
{
public:
	class UHotpotConfig*                          HotpotConfig;                                      // 0x0148(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotPotSubgameActivator">();
	}
	static class UHotPotSubgameActivator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotPotSubgameActivator>();
	}
};
static_assert(alignof(UHotPotSubgameActivator) == 0x000008, "Wrong alignment on UHotPotSubgameActivator");
static_assert(sizeof(UHotPotSubgameActivator) == 0x000150, "Wrong size on UHotPotSubgameActivator");
static_assert(offsetof(UHotPotSubgameActivator, HotpotConfig) == 0x000148, "Member 'UHotPotSubgameActivator::HotpotConfig' has a wrong offset!");

// Class Palia.VAL_PlayingCard
// 0x0000 (0x0028 - 0x0028)
class UVAL_PlayingCard : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayingCard">();
	}
	static class UVAL_PlayingCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayingCard>();
	}
};
static_assert(alignof(UVAL_PlayingCard) == 0x000008, "Wrong alignment on UVAL_PlayingCard");
static_assert(sizeof(UVAL_PlayingCard) == 0x000028, "Wrong size on UVAL_PlayingCard");

// Class Palia.ReadableBookComponent
// 0x0030 (0x00D0 - 0x00A0)
class UReadableBookComponent final : public UActorComponent
{
public:
	uint8                                         Pad_27A3[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    BookConfig;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   InteractText;                                      // 0x00B8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Player, const struct FInteractEventParams& EventParams);

	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadableBookComponent">();
	}
	static class UReadableBookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadableBookComponent>();
	}
};
static_assert(alignof(UReadableBookComponent) == 0x000008, "Wrong alignment on UReadableBookComponent");
static_assert(sizeof(UReadableBookComponent) == 0x0000D0, "Wrong size on UReadableBookComponent");
static_assert(offsetof(UReadableBookComponent, BookConfig) == 0x0000A8, "Member 'UReadableBookComponent::BookConfig' has a wrong offset!");
static_assert(offsetof(UReadableBookComponent, InteractText) == 0x0000B8, "Member 'UReadableBookComponent::InteractText' has a wrong offset!");

// Class Palia.HotPotTile
// 0x0008 (0x0030 - 0x0028)
class UHotPotTile final : public UVAL_PlayingCard
{
public:
	EHotPotTileColor                              TileColor;                                         // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHotPotTileFood                               TileFood;                                          // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A8[0x6];                                     // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotPotTile">();
	}
	static class UHotPotTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotPotTile>();
	}
};
static_assert(alignof(UHotPotTile) == 0x000008, "Wrong alignment on UHotPotTile");
static_assert(sizeof(UHotPotTile) == 0x000030, "Wrong size on UHotPotTile");
static_assert(offsetof(UHotPotTile, TileColor) == 0x000028, "Member 'UHotPotTile::TileColor' has a wrong offset!");
static_assert(offsetof(UHotPotTile, TileFood) == 0x000029, "Member 'UHotPotTile::TileFood' has a wrong offset!");

// Class Palia.HotPotPlayerInfo
// 0x0058 (0x0300 - 0x02A8)
class AHotPotPlayerInfo final : public AInfo
{
public:
	class UHotPotTileStack*                       Hand;                                              // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHotPotTileStack*                       DiscardPile;                                       // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHotPotTile*                            PendingTile;                                       // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A9[0x28];                                    // 0x02C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaPlayerController*               OwningPlayer;                                      // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AA[0x8];                                     // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHotpotConfig*                          HotpotConfig;                                      // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotPotPlayerInfo">();
	}
	static class AHotPotPlayerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHotPotPlayerInfo>();
	}
};
static_assert(alignof(AHotPotPlayerInfo) == 0x000008, "Wrong alignment on AHotPotPlayerInfo");
static_assert(sizeof(AHotPotPlayerInfo) == 0x000300, "Wrong size on AHotPotPlayerInfo");
static_assert(offsetof(AHotPotPlayerInfo, Hand) == 0x0002A8, "Member 'AHotPotPlayerInfo::Hand' has a wrong offset!");
static_assert(offsetof(AHotPotPlayerInfo, DiscardPile) == 0x0002B0, "Member 'AHotPotPlayerInfo::DiscardPile' has a wrong offset!");
static_assert(offsetof(AHotPotPlayerInfo, PendingTile) == 0x0002B8, "Member 'AHotPotPlayerInfo::PendingTile' has a wrong offset!");
static_assert(offsetof(AHotPotPlayerInfo, OwningPlayer) == 0x0002E8, "Member 'AHotPotPlayerInfo::OwningPlayer' has a wrong offset!");
static_assert(offsetof(AHotPotPlayerInfo, HotpotConfig) == 0x0002F8, "Member 'AHotPotPlayerInfo::HotpotConfig' has a wrong offset!");

// Class Palia.VAL_PrizeWheelComponent
// 0x0068 (0x0108 - 0x00A0)
class UVAL_PrizeWheelComponent final : public UActorComponent
{
public:
	uint8                                         Pad_27AB[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_PrizeWheelDef*                     PrizeWheelDefinition;                              // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InteractText;                                      // 0x00B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         PrizeDelay;                                        // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpinning;                                       // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AC[0x3];                                     // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWheelSpun;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRewardGranted;                                   // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentPrizeSlot;                                  // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AD[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      SpinningPlayer;                                    // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           FinishSpinningTimerHandle;                         // 0x0100(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Player, const struct FInteractEventParams& EventParams);
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void RpcNetMulticast_SpinTheWheel(int32 Slot);
	void Server_FinishSpinning();

	bool GetText(class AValeriaCharacter* VC, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PrizeWheelComponent">();
	}
	static class UVAL_PrizeWheelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PrizeWheelComponent>();
	}
};
static_assert(alignof(UVAL_PrizeWheelComponent) == 0x000008, "Wrong alignment on UVAL_PrizeWheelComponent");
static_assert(sizeof(UVAL_PrizeWheelComponent) == 0x000108, "Wrong size on UVAL_PrizeWheelComponent");
static_assert(offsetof(UVAL_PrizeWheelComponent, PrizeWheelDefinition) == 0x0000A8, "Member 'UVAL_PrizeWheelComponent::PrizeWheelDefinition' has a wrong offset!");
static_assert(offsetof(UVAL_PrizeWheelComponent, InteractText) == 0x0000B0, "Member 'UVAL_PrizeWheelComponent::InteractText' has a wrong offset!");
static_assert(offsetof(UVAL_PrizeWheelComponent, PrizeDelay) == 0x0000C8, "Member 'UVAL_PrizeWheelComponent::PrizeDelay' has a wrong offset!");
static_assert(offsetof(UVAL_PrizeWheelComponent, bIsSpinning) == 0x0000CC, "Member 'UVAL_PrizeWheelComponent::bIsSpinning' has a wrong offset!");
static_assert(offsetof(UVAL_PrizeWheelComponent, OnWheelSpun) == 0x0000D0, "Member 'UVAL_PrizeWheelComponent::OnWheelSpun' has a wrong offset!");
static_assert(offsetof(UVAL_PrizeWheelComponent, OnRewardGranted) == 0x0000E0, "Member 'UVAL_PrizeWheelComponent::OnRewardGranted' has a wrong offset!");
static_assert(offsetof(UVAL_PrizeWheelComponent, CurrentPrizeSlot) == 0x0000F0, "Member 'UVAL_PrizeWheelComponent::CurrentPrizeSlot' has a wrong offset!");
static_assert(offsetof(UVAL_PrizeWheelComponent, SpinningPlayer) == 0x0000F8, "Member 'UVAL_PrizeWheelComponent::SpinningPlayer' has a wrong offset!");
static_assert(offsetof(UVAL_PrizeWheelComponent, FinishSpinningTimerHandle) == 0x000100, "Member 'UVAL_PrizeWheelComponent::FinishSpinningTimerHandle' has a wrong offset!");

// Class Palia.HotPotSubgameManager
// 0x0090 (0x0198 - 0x0108)
class UHotPotSubgameManager final : public USubgameManagerComponent
{
public:
	class UHotpotConfig*                          HotpotConfig;                                      // 0x0108(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHotPotPlayerStateUpdated;                        // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHotPotGameEnd;                                   // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AHotPotPlayerInfo*>              CurrentPlayerInfo;                                 // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UHotPotTileStack*                       DrawPile;                                          // 0x0140(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentTurnIndex;                                  // 0x014C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPassTurnDelayTimeSeconds;                      // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B2[0x4];                                     // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AutoPassTurnTimerHandle;                           // 0x0158(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeoutPassTurnTimeSeconds;                        // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B3[0x4];                                     // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimeoutPassTurnTimerHandle;                        // 0x0168(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           AutoStartGameTimerHandle;                          // 0x0170(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B4[0x20];                                    // 0x0178(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAutoStart();
	void OnHotPotGameEnd__DelegateSignature(class UHotPotSubgameManager* HotPotManager, struct FHotPotGameEndState& GameEndState);
	void OnHotPotPlayerStateUpdated__DelegateSignature(class UHotPotSubgameManager* HotPotManager, class AValeriaPlayerController* Player, struct FHotPotGameState& GameState);

	int32 GetPlayerIndex(class AValeriaPlayerController* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotPotSubgameManager">();
	}
	static class UHotPotSubgameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotPotSubgameManager>();
	}
};
static_assert(alignof(UHotPotSubgameManager) == 0x000008, "Wrong alignment on UHotPotSubgameManager");
static_assert(sizeof(UHotPotSubgameManager) == 0x000198, "Wrong size on UHotPotSubgameManager");
static_assert(offsetof(UHotPotSubgameManager, HotpotConfig) == 0x000108, "Member 'UHotPotSubgameManager::HotpotConfig' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, OnHotPotPlayerStateUpdated) == 0x000110, "Member 'UHotPotSubgameManager::OnHotPotPlayerStateUpdated' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, OnHotPotGameEnd) == 0x000120, "Member 'UHotPotSubgameManager::OnHotPotGameEnd' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, CurrentPlayerInfo) == 0x000130, "Member 'UHotPotSubgameManager::CurrentPlayerInfo' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, DrawPile) == 0x000140, "Member 'UHotPotSubgameManager::DrawPile' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, MaxPlayers) == 0x000148, "Member 'UHotPotSubgameManager::MaxPlayers' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, CurrentTurnIndex) == 0x00014C, "Member 'UHotPotSubgameManager::CurrentTurnIndex' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, AutoPassTurnDelayTimeSeconds) == 0x000150, "Member 'UHotPotSubgameManager::AutoPassTurnDelayTimeSeconds' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, AutoPassTurnTimerHandle) == 0x000158, "Member 'UHotPotSubgameManager::AutoPassTurnTimerHandle' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, TimeoutPassTurnTimeSeconds) == 0x000160, "Member 'UHotPotSubgameManager::TimeoutPassTurnTimeSeconds' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, TimeoutPassTurnTimerHandle) == 0x000168, "Member 'UHotPotSubgameManager::TimeoutPassTurnTimerHandle' has a wrong offset!");
static_assert(offsetof(UHotPotSubgameManager, AutoStartGameTimerHandle) == 0x000170, "Member 'UHotPotSubgameManager::AutoStartGameTimerHandle' has a wrong offset!");

// Class Palia.HotPotTileRepresentation
// 0x0028 (0x02D0 - 0x02A8)
class AHotPotTileRepresentation final : public AActor
{
public:
	int32                                         Index_HotPotTileRepresentation;                    // 0x02A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHotPotTileZoneType                           ZoneType;                                          // 0x02AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B6[0x3];                                     // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTileAdjacencyRule>             TileAdjacency;                                     // 0x02B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AHotPotTileRepresentation> PreviousTile;                                      // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B7[0x8];                                     // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPNE_EndHover();
	void BPNE_StartHover();
	void Initialize(bool bInHoverable, int32 InIndex, EHotPotTileZoneType InZoneType);
	void SetAdjacency(TArray<struct FTileAdjacencyRule>& NewTileAdjacency);
	void SetHoverable(bool bInHoverable);
	void SetIsHovered(bool bNewHovered, class AHotPotTileRepresentation* InPreviousTile);

	bool CanBeHovered() const;
	bool IsHovered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotPotTileRepresentation">();
	}
	static class AHotPotTileRepresentation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHotPotTileRepresentation>();
	}
};
static_assert(alignof(AHotPotTileRepresentation) == 0x000008, "Wrong alignment on AHotPotTileRepresentation");
static_assert(sizeof(AHotPotTileRepresentation) == 0x0002D0, "Wrong size on AHotPotTileRepresentation");
static_assert(offsetof(AHotPotTileRepresentation, Index_HotPotTileRepresentation) == 0x0002A8, "Member 'AHotPotTileRepresentation::Index_HotPotTileRepresentation' has a wrong offset!");
static_assert(offsetof(AHotPotTileRepresentation, ZoneType) == 0x0002AC, "Member 'AHotPotTileRepresentation::ZoneType' has a wrong offset!");
static_assert(offsetof(AHotPotTileRepresentation, TileAdjacency) == 0x0002B0, "Member 'AHotPotTileRepresentation::TileAdjacency' has a wrong offset!");
static_assert(offsetof(AHotPotTileRepresentation, PreviousTile) == 0x0002C0, "Member 'AHotPotTileRepresentation::PreviousTile' has a wrong offset!");

// Class Palia.ValeriaBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UValeriaBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FInt64Split AddInt64(const struct FInt64Split& A, const struct FInt64Split& B);
	static void AddRowItemConfig(class UDataTable* DataTable, class FName RowName, const struct FDEPRECATED_ItemConfig& ItemConfig);
	static void AddRowLootBundleConfig(class UDataTable* DataTable, class FName RowName, const struct FLootBundleConfig& LootBundleConfig);
	static void AddRowLootPoolConfig(class UDataTable* DataTable, class FName RowName, const struct FLootPoolConfig& LootPoolConfig);
	static void AddRowRecipeConfig(class UDataTable* DataTable, class FName RowName, const struct FRecipeConfig& RecipeConfig);
	static void AddRowVillagerQuestConfig(class UDataTable* DataTable, class FName RowName, const struct FVillagerQuestConfig& VillagerQuestConfig);
	static float AngleBetween(struct FVector& VectorA, struct FVector& VectorB);
	static bool AreBagSlotsEqual(struct FBagSlotLocation& Lhs, struct FBagSlotLocation& Rhs);
	static bool BuildContainsDebugCheatCode();
	static bool BuildContainsServerOnlyCode();
	static bool BuildIsShipping();
	static struct FBox CalculateBounds(TArray<struct FVector>& Arr);
	static struct FBox2D CalculateBounds2D(TArray<struct FVector2D>& Arr);
	static bool CanFertilizerBeUsed(class ULocalPlayer* LP, class UVAL_ItemTypeDefinitionAsset* Item);
	static bool CanItemBePlacedInWorld(class ULocalPlayer* LP, class UVAL_ItemTypeDefinitionAsset* Item);
	static bool CanItemBeSold(class UObject* Context, const struct FValeriaItem& Item);
	static bool CanItemInstanceBePlacedInWorld(class ULocalPlayer* LP, struct FValeriaItem& Item);
	static bool CanSaveConfigFile();
	static bool CanSeedBePlanted(class ULocalPlayer* LP, class UVAL_ItemTypeDefinitionAsset* Item);
	static struct FInt64Split CastInt32ToInt64(int32 A);
	static int32 CastInt64ToInt32(const struct FInt64Split& A);
	static struct FInt64Split CastInt64ToInt64Split(int64 TimeMs);
	static bool ClearItemTaggedMetadata(struct FValeriaItem& Item, struct FGameplayTag& Tag);
	static class AValeriaPlayerController* Client_GetFirstPlayerController(class UObject* Context, EValeriaFuncResult* OutResult);
	static struct FValeriaItem Combine(class UObject* Context, const struct FValeriaItem& ExistingItem, const struct FValeriaItem& NewItem);
	static int32 CompareInt64(const struct FInt64Split& A, const struct FInt64Split& B);
	static void ComputeSaleValuePerItem(class UObject* Context, const struct FValeriaItem& Item, int32* VitalAmountPerItem, EVitalType* VitalType);
	static bool ContainsOneTag(struct FTagList& DesiredTagList, const struct FGameplayTag& TagParam);
	static bool ContainsOtherContainer(struct FTagList& DesiredTagList, struct FGameplayTagContainer& Other, bool MatchAll);
	static bool ContainsOtherTagList(struct FTagList& DesiredTagList, struct FTagList& Other, bool MatchAll);
	static class FText ConvertErrorMessageToText(class UObject* Context, const struct FErrorMessage& Error);
	static int32 ConvertToSecs(const struct FInt64Split& Timestamp);
	static int32 ConvertToSecs64(int64 Timestamp);
	static void ConvertToSingleRewards(TArray<struct FQuestRewardConfig>& Rewards, TArray<struct FSingleQuestReward>& SingleRewards);
	static void CopyItemTaggedMetadata(struct FValeriaItem& Item, struct FValeriaItem& ItemToCopy);
	static void CopyRenderTargetToRenderTarget(class UTextureRenderTarget2D* SourceRenderTarget, class UTextureRenderTarget2D* DestinationRenderTarget);
	static float CosineAngle2DBetween(struct FVector& VectorA, struct FVector& VectorB);
	static struct FValeriaItem CreateItem(class UObject* Context, class UVAL_ItemTypeDefinitionAsset* ItemType, int32 Amount, int32 QualityStars);
	static struct FValeriaItem CreateWithAmount(const struct FValeriaItem& ExistingItem, int32 Amount);
	static bool CSM_IsOnStack(class UObject* Context, ECharacterState CharacterState);
	static void DebugLog(class UObject* WorldContextObject, const class FString& InString);
	static void DebugLogError(class UObject* WorldContextObject, const class FString& InString);
	static void DebugLogWarn(class UObject* WorldContextObject, const class FString& InString);
	static void DestroyAndRemovePersist(class AActor* Actor);
	static bool DestroyIfServer(class AActor* Actor);
	static void DisableAnimationsOnSkelMesh(class USkeletalMeshComponent* Mesh);
	static bool DisableIfServer(class UObject* Obj);
	static bool DoesCharacterSatisfyQuestActivityPrereq(class AValeriaCharacter* Character, struct FQuestActivityPrereq& Requirement);
	static bool DoesItemHaveNonConsumableHotbarAction(class ULocalPlayer* LP, class UVAL_ItemTypeDefinitionAsset* Item);
	static bool DoesItemInstanceHaveNonConsumableHotbarAction(class ULocalPlayer* LP, struct FValeriaItem& Item);
	static bool DoesVillagerActionInfoHaveAnimationMapping(struct FVillagerActionInfo& InActionInfo);
	static void DrawMaskMesh(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const TArray<class UStaticMeshComponent*>& StaticMeshComp, const struct FVector& OffsetAndExtent);
	static void EnsureWidgetsCreatedOnPanel(class UUserWidget* Owner, class UPanelWidget* ParentPanel, TSubclassOf<class UUserWidget> WidgetToCreate, int32 NumberOfWidgets, const struct FAdditionalEnsureWidgetsOptions& Options);
	static bool ExpandCameraRangeForTopDownHousingMenu();
	static TArray<TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>> FindAllItemsByTag(class UObject* Context, const struct FGameplayTag& IngredientTag);
	static struct FBuffConfig FindBuffConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static class AActor* FindClosestActor(TArray<class AActor*>& Actors, const struct FVector& Center);
	static struct FCrafterConfig FindCrafterConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static class UVAL_DialogueAsset* FindDialogueByID(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static class UVAL_DialogueAsset* FindDialogueByName(class UObject* Context, class FString& Param_Name, EValeriaFuncResult* OutResult);
	static bool FindErrorModalConfig(class UObject* Context, const struct FErrorMessage& Error, struct FErrorModalConfig* OutModalConfig);
	static class AActor* FindFacingActor(TArray<class AActor*>& Actors, const struct FVector& PlayerLocation, const struct FVector& CameraForwardVector);
	static struct FInventoryBagConfig FindInventoryBagConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static struct FDEPRECATED_ItemConfig FindItemConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static const class UVAL_ItemTypeDefinitionAsset* FindItemTypeByActor(class AActor* Actor, EValeriaFuncResult* OutResult);
	static const class UVAL_ItemTypeDefinitionAsset* FindItemTypeBySimpleDecorActor(class AActor* Actor, EValeriaFuncResult* OutResult);
	static const class UVAL_ItemTypeDefinitionAsset* FindItemTypeByTag(class UObject* Context, const struct FGameplayTag& IngredientTag, EValeriaFuncResult* OutResult, int32* OutResultsFound);
	static int32 FindNeedsIndexForRecipeID(class UObject* Context, int32 RecipeId, TArray<struct FRecipe_RequireItem>& NeededItems);
	static class UPersistComponent* FindPersistComponentInParent(class AActor* Actor);
	static struct FRecipeConfig FindRecipeConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static struct FShopConfig FindShopConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static struct FSkillLevelConfig FindSkillLevelConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static struct FSkillLevelConfig FindSkillLevelConfigByType(class UObject* Context, ESkillType Typ, EValeriaFuncResult* OutResult);
	static struct FToolConfig FindToolConfig(class UObject* Context, class FName Param_Name);
	static struct FVillagerConfig FindVillagerConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static struct FVillagerCoreConfig FindVillagerCoreConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static struct FVillagerGiftPreferenceConfig FindVillagerGiftPreferenceConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static struct FVillagerRelationshipLevelConfig FindVillagerRelationshipLevelByValueByVillagerCoreId(class UObject* Context, int32 Value, ERelationshipType Type, int32 VillagerCoreId);
	static struct FVillagerRelationshipLevelConfig FindVillagerRelationshipLevelByVillagerCoreId(class UObject* Context, int32 Level, ERelationshipType Type, int32 VillagerCoreId, EValeriaFuncResult* OutResult);
	static struct FVitalConfig FindVitalConfigById(class UObject* Context, int32 ID, EValeriaFuncResult* OutResult);
	static struct FVitalConfig FindVitalConfigByType(class UObject* Context, EVitalType Typ, EValeriaFuncResult* OutResult);
	static TArray<struct FSingleQuestReward> FlattenScalingRewardsForLevel(TArray<struct FScalingReward>& ScalingRewards, int32 Level);
	static bool FloatRangeContains(const struct FFloatRange& Range, float Value);
	static bool FlushTextureAsyncLoad();
	static bool FNameIsNone(class FName& Param_Name);
	static class FString FormatDuration(int32 Seconds);
	static void GatherPlayerPersonalityInfo(class AValeriaCharacter* Character, EValeriaPersonalityElement* OutResult, int32* Air, int32* Earth, int32* Fire, int32* Water);
	static class FString GetAchievementNameForInsect(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType);
	static TArray<struct FAssetData> GetActorAssetsInPath(TArray<class FName>& Path);
	static void GetAllGameplayTagsAsFNameArray(TArray<class FName>* OutArray);
	static TArray<TSubclassOf<class AActor>> GetAllSpawnableActorClasses();
	static struct FAnimationMappingConfig GetAnimationMappingConfigFromVillagerActionInfo(struct FVillagerActionInfo& InActionInfo);
	static int32 GetAroundIndexFromRemoveIndex(class UListView* ListView, int32 FocusIndex);
	static class UClass* GetBlueprintClass(const class FString& FullPath);
	static struct FBuffConfig GetBuffConfigById(class UObject* Context, int32 ID);
	static struct FBuffConfig GetBuffDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static bool GetConfigString_GameUserSettings(const class FString& Section, const class FString& Key, class FString* Output);
	static TArray<class FString> GetConsoleObjectNamesThatStartWith(const class FString& StartWith);
	static struct FCrafterConfig GetCrafterConfigById(class UObject* Context, int32 ID);
	static struct FCrafterConfig GetCrafterDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static const class UCraftingGlobalConfig* GetCraftingGlobalConfig(class UObject* Context);
	static int32 GetCraftTimeMs(class UObject* Context, int32 RecipeId, int32 CrafterId);
	static struct FCreatureConfig GetCreatureDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static const class UDev_SpawnActorConfig* GetDevSpawnActorConfig(class UObject* Context);
	static class FString GetDisplayNameAndUniqueId(class UObject* Object);
	static class FString GetExperienceOrMapName(class UObject* WorldContextObject);
	static struct FFishConfig GetFishDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static TArray<class FName> GetFishMinigameConfigAssetNames();
	static TArray<struct FValeriaItem> GetGearItemsInInventory(class ULocalPlayer* Player, struct FValeriaItem& ItemToExclude, class UGearSlotTypeConfig* GearSlotTypeConfig);
	static const class UHousingGlobalConfig* GetHousingGlobalConfig(class UObject* Context);
	static class UTexture2D* GetIconForIngredient(class UObject* Context, struct FRecipe_RequireItem& Ingredient);
	static class UInputAction* GetInputActionForAnyTagFromItem(class UObject* Context, class UVAL_ItemTypeDefinitionAsset* ItemType);
	static const class UVAL_InputGlobalConfig* GetInputGlobalConfig(class UObject* Context);
	static const class UInstrumentGlobalConfig* GetInstrumentGlobalConfig(class UObject* Context);
	static class UInteractableComponent* GetInteractableComponent(class UObject* Context);
	static class UInventoryComponent* GetInteractor_OtherInventory(class UObject* Context);
	static int32 GetIntValueFromLevelArray(TArray<int32>& LevelArray, int32 Level);
	static struct FInventoryBagConfig GetInventoryBagConfigById(class UObject* Context, int32 ID);
	static void GetInventoryGlobalConfig(class UObject* Context, struct FInventoryGlobalConfig* InventoryConfig);
	static int32 GetItemAmountInX_ByTag(class AValeriaCharacter* ValeriaCharacter, struct FGameplayTag& ItemTag, struct FStarQualityConstraint& StarQualityConstraint, int32 StorageTypes);
	static int32 GetItemAmountInX_ByType(class AValeriaCharacter* ValeriaCharacter, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, struct FStarQualityConstraint& StarQualityConstraint, int32 StorageTypes, bool bAlsoCheckLockbox);
	static struct FDEPRECATED_ItemConfig GetItemConfigById(class UObject* Context, int32 ID);
	static struct FDEPRECATED_ItemConfig GetItemDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static class FText GetItemDescription(class UObject* Context, struct FValeriaItem& Item);
	static class FText GetItemDisplayNameFromId(int32 ItemId);
	static bool GetItemGrowthLevelInfo(struct FValeriaItem& Item, int32* OutTransitiveState, struct FTransitiveDecorProgressStep* OutProgressStepInfo);
	static struct FItemSellValueConfig GetItemSellValueDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static bool GetItemTaggedMetadataInt(struct FValeriaItem& Item, struct FGameplayTag& Tag, int32* OutMetadataInt);
	static bool GetItemTaggedMetadataString(struct FValeriaItem& Item, struct FGameplayTag& Tag, class FString* OutMetadataString);
	static struct FLauncherConfig GetLauncherDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static int32 GetMaxNumBagsAllowedForBagTypes(class UObject* Context, TArray<struct FGameplayTag>& InBagTypes);
	static class FName GetMontageCurrentSectionName(class AValeriaCharacter* PlayerCharacter, class UAnimMontage* Montage);
	static float GetMontageSectionLength(class UAnimMontage* Montage, class FName SectionName);
	static void GetMostNotableDialogueTypes(class UObject* Context, class AValeriaCharacter* PlayerCharacter, class AValeriaVillagerCharacter* VillagerCharacter, int32 VillagerId, EDialogueType* OutMostNotableGenericDialogueType, EDialogueType* OutMostNotableNonChatDialogueType, bool* bOutPinnedQuest);
	static void GetMostNotableDialogueTypesForVillagerId(class UObject* Context, class AValeriaCharacter* PlayerCharacter, int32 VillagerId, EDialogueType* OutMostNotableGenericDialogueType, EDialogueType* OutMostNotableNonChatDialogueType, bool* bOutPinnedQuest);
	static void GetMostNotableDialogueTypesForWorldVillager(class UObject* Context, class AValeriaCharacter* PlayerCharacter, class AValeriaVillagerCharacter* VillagerCharacter, EDialogueType* OutMostNotableGenericDialogueType, EDialogueType* OutMostNotableNonChatDialogueType, bool* bOutPinnedQuest);
	static class UPathStepComponent* GetPathStepComponentAt(class AActor* Owner, int32 StepIndex);
	static int32 GetPathStepIndexAfter(class AActor* Owner, int32 CurrIndex);
	static double GetPlatformTimeSeconds();
	static int32 GetPrimaryVillagerIdByVillagerCoreId(class UObject* Context, int32 VillagerCoreId);
	static bool GetPureConsoleVariableBoolValue(const class FString& VariableName);
	static float GetPureConsoleVariableFloatValue(const class FString& VariableName);
	static int32 GetPureConsoleVariableIntValue(const class FString& VariableName);
	static const class UQualityGlobalConfig* GetQualityGlobalConfig(class UObject* Context);
	static struct FQuestConfig GetQuestDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static TSoftObjectPtr<class UTexture2D> GetQuestIconForDialogueType(class UObject* Context, EDialogueType InDialogueType);
	static bool GetQuestRequirementDescription(class UObject* Context, struct FVillagerQuestRequirement& Requirement, class FText* OutText);
	static struct FQuestSelectorConfig GetQuestSelectorDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static int32 GetRandomIndexByWeight(TArray<int32>& WeightArray);
	static struct FRecipeConfig GetRecipeConfigById(class UObject* Context, int32 ID);
	static const class UDataTable* GetRecipeConfigDataTable(class UObject* Context);
	static struct FRecipeConfig GetRecipeDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static class FText GetRecipeItemDisplayNameFromId(class UObject* Context, int32 RecipeId);
	static int32 GetRecipeNumberOfExtraSteps(class UObject* Context, int32 RecipeConfigId);
	static EQuestRewardType GetRewardType(struct FSingleQuestReward& Reward);
	static TSoftObjectPtr<class AActor> GetRuntimeISMActor(class UObject* Context);
	static struct FDateTime GetS6WeeklyResetTime(class UObject* Context);
	static class UTexture2D* GetSellIconForItem(class UObject* Context, const struct FValeriaItem& Item);
	static void GetSellTextForItem(class UObject* Context, const struct FValeriaItem& Item, class FText* OutSellText);
	static const struct FVillagerCoreConfig GetSheppCoreConfigForPlayer(class AValeriaCharacter* PlayerCharacter);
	static struct FShopConfig GetShopConfigById(class UObject* Context, int32 ID);
	static struct FSkillLevelConfig GetSkillLevelConfigById(class UObject* Context, int32 ID);
	static struct FSkillLevelConfig GetSkillLevelConfigByType(class UObject* Context, ESkillType Typ);
	static float GetSlotMontageGlobalWeight(class UAnimInstance* AnimInstance, class FName SlotNodeName);
	static TArray<class UVAL_ItemTypeDefinitionAsset*> GetSortedItemTypesFromCategories(class UObject* Context, TArray<EItemStorageCategory>& StorageCategories, EItemSortType SortType);
	static TArray<class UVAL_ItemTypeDefinitionAsset*> GetSortedItemTypesFromCategory(class UObject* Context, EItemStorageCategory StorageCategory, EItemSortType SortType);
	static struct FTimespan GetTimeUntilS6WeeklyReset(class UObject* Context);
	static class FText GetTooltipForCurrency(class UCurrencyConfig* CurrencyConfig);
	static class FText GetTooltipForVital(class UObject* Context, EVitalType VitalType);
	static TArray<int32> GetTrackableVillagerConfigIds(class UObject* Context);
	static struct FTransform GetTransformFromValeriaSpawnTransform(struct FValeriaSpawnTransform& InValeriaSpawnTransform);
	static class FString GetValeriaBuildInfoString();
	static class AValeriaCharacter* GetValeriaCharacter(class UObject* Context, EValeriaFuncResult* OutResult);
	static class AValeriaCharacter* GetValeriaCharacterByPlayerId(class UObject* Context, const struct FPersistGuid& PlayerId, EValeriaFuncResult* OutResult);
	static class AValeriaCharacter* GetValeriaCharacterOwnerOfPlaceable(class AActor* Placeable);
	static class AValeriaPlayerController* GetValeriaPlayerController(class UObject* Context, EValeriaFuncResult* OutResult);
	static struct FDateTime GetValeriaTimestampDateTime(class UObject* Context);
	static struct FInt64Split GetValeriaTimestampMs(class UObject* Context);
	static int64 GetValeriaTimestampMs64(class UObject* Context);
	static int32 GetValeriaTimestampSecs(class UObject* Context);
	static const class AVAL_WorldSettings* GetValeriaWorldSettings(class UObject* Context);
	static uint8 GetValueFromFlattened2DArray(const TArray<uint8>& ValueArray, int32 X, int32 Y, int32 SizeX);
	static TArray<uint8> GetValuesFromGrayscaleTexture(class UTexture2D* Texture);
	static struct FVillagerConfig GetVillagerConfigById(class UObject* Context, int32 ID);
	static struct FVillagerCoreConfig GetVillagerCoreConfigById(class UObject* Context, int32 ID);
	static const class UDataTable* GetVillagerCoreConfigDataTable(class UObject* Context);
	static struct FVillagerCoreConfig GetVillagerCoreDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static int32 GetVillagerCoreIdByVillagerId(class UObject* Context, int32 VillagerId);
	static struct FVillagerConfig GetVillagerDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static struct FVillagerGiftPreferenceConfig GetVillagerGiftPreferenceConfigById(class UObject* Context, int32 ID);
	static const class UDataTable* GetVillagerGiftPreferenceConfigDataTable(class UObject* Context);
	static TArray<int32> GetVillagerIdsByVillagerCoreId(class UObject* Context, int32 VillagerCoreId);
	static class AValeriaVillagerCharacter* GetVillagerInWorldById(class UObject* Context, int32 InVillagerId);
	static const class UDataTable* GetVillagerMailMessageConfigDataTable(class UObject* Context);
	static struct FVillagerMailMessageConfig GetVillagerMailMessageDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static struct FVillagerQuestConfig GetVillagerQuestDataTableRow(class UObject* Context, const struct FDataTableRowHandle& Handle, EValeriaFuncResult* OutResult);
	static float GetVillagerRelationshipLevelPercentageByVillagerCoreId(class UObject* Context, int32 Value, ERelationshipType Type, int32 VillagerCoreId, bool* bOutMaxLevel);
	static void GetVillagerRelationshipXpProgressForCurrentLevel(class UObject* Context, int32 Value, ERelationshipType Type, int32 VillagerCoreId, int32* OutXpProgressForCurrentLevel, int32* OutXpMaxForCurrentLevel, bool* bOutMaxLevel);
	static class FName GetVillagerRowNameByConfigId(class UObject* Context, int32 VillagerId);
	static class FName GetVillagerRowNameByCoreConfigId(class UObject* Context, int32 VillagerCoreId);
	static TArray<int32> GetVisibleVillagerCoreConfigIds(class UObject* Context, bool bSortAlphabetically);
	static struct FVitalConfig GetVitalConfigById(class UObject* Context, int32 ID);
	static struct FVitalConfig GetVitalConfigByType(class UObject* Context, EVitalType Typ);
	static bool GetWaterPercent(class UObject* Context, struct FValeriaItem& Item, float* Percent);
	static const class UWorldMapGlobalConfig* GetWorldMapGlobalConfig(class UObject* Context);
	static bool InsectsAreTrappedInsteadOfDamaged();
	static bool IntLevelArrayHasLevel(TArray<int32>& LevelArray, int32 Level);
	static bool IsBagSlotLocationValid(const struct FBagSlotLocation& Location);
	static bool IsDialogueRequirementMetForVillagerId(class UObject* Context, struct FDialogueRequirements& Requirement, class AValeriaCharacter* PlayerCharacter, int32 VillagerId);
	static bool IsDialogueRequirementMetForWorldVillager(class UObject* Context, struct FDialogueRequirements& Requirement, class AValeriaCharacter* PlayerCharacter, class AValeriaVillagerCharacter* VillagerCharacter);
	static bool IsDialogueTypeImportantDialogue(EDialogueType InDialogueType);
	static bool IsDialogueTypeQuestDialogue(EDialogueType InDialogueType);
	static bool IsDialogueTypeQuestOrImportantDialogue(EDialogueType InDialogueType);
	static bool IsFTUEComplete(class AValeriaCharacter* Character);
	static bool IsFTUEMapOrExperience(const class FString& MapOrExperienceName);
	static bool IsItemOwned(class UObject* Context, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, bool bAlsoCheckLockbox);
	static bool IsItemTypeInCategory(class UObject* Context, class UVAL_ItemTypeDefinitionAsset* ItemType, EItemStorageCategory Category);
	static bool IsLoadTestClient();
	static bool IsMinigameWorld(class UObject* Context);
	static bool IsMobilePlatform(class UObject* Context);
	static bool IsMouseHiddenOnToolWheel();
	static bool IsOnHousingPlot(class UObject* Context);
	static bool IsOtherInventoryOpen(class UObject* Context);
	static bool IsPlayInEditor(class UObject* WorldContextObject);
	static bool IsReturnHomeEnabled(class AValeriaCharacter* Character);
	static bool IsReturnHomeMapButtonVisible(class UObject* Context);
	static bool IsSelfOrParentHidden(class UUserWidget* ChildWidget);
	static bool ItemCanBePlaced(struct FValeriaItem& Item);
	static bool ItemEquals(const struct FValeriaItem& Item1, const struct FValeriaItem& Item2);
	static bool ItemHasTaggedMetadata(struct FValeriaItem& Item, struct FGameplayTag& Tag);
	static bool ItemIsEmpty(const struct FValeriaItem& Item);
	static void LoadFileToText(class FText* OutputText, const class FString& Filename);
	static class FString MakePartOfTextInvisible(class FText InputText, float AccumulatedTime, class UObject* Context, bool* IsTextFullyDisplayed);
	static bool MontageHasSection(class UAnimMontage* Montage, class FName& SectionName);
	static float MoveTowards(float Value, float Target, float Delta);
	static class UHierarchicalInstancedStaticMeshComponent* NativeFindISMComponent(class AActor* ISMActor, class UStaticMesh* StaticMesh, struct FVector& Location, float GridSize);
	static void OpenTutorialWidget(class UObject* Context, class APlayerController* OwningPlayer, const TArray<TSoftClassPtr<class UClass>>& TutorialWidgetClasses, TSoftClassPtr<class UClass> TutorialModalClass, TDelegate<void(class UUserWidget* ModalWidget, TArray<class UUserWidget*>& TutorialWidgets)> OpenModalDelegate);
	static class FText PerformTextSubstitutions(class FText& InputText, class UObject* Context);
	static class FText PerformTextSubstitutionsForCharacter(class FText& InputText, class AValeriaCharacter* Character);
	static class FText PerformTextSubstitutionsForDialogue(class FText& InputText, struct FVAL_DialogueContext& Context);
	static bool PlacementHoverInfoEquals(struct FPlacementHoverInfo& Info1, struct FPlacementHoverInfo& Info2);
	static void RemoveRowRecipeConfig(class UDataTable* DataTable, class FName RowName, const struct FRecipeConfig& RecipeConfig);
	static struct FGameplayTag RequestGameplayTag(class FName DesiredTagName);
	static void RunBuildVerification();
	static bool SameItemTypeVariantAndQuality(const struct FValeriaItem& Item1, const struct FValeriaItem& Item2);
	static void SaveStringToFile(const class FString& InputText, const class FString& Filename);
	static bool SetBlueprintGatherableItemRow(class FName Path, class FName RowName);
	static bool SetBlueprintStaticMesh(class FName Path, class FName ComponentName, class UStaticMesh* Mesh);
	static void SetItemTaggedMetadataInt(struct FValeriaItem& Item, struct FGameplayTag& Tag, int32 MetadataInt);
	static void SetItemTaggedMetadataString(struct FValeriaItem& Item, struct FGameplayTag& Tag, const class FString& MetadataString);
	static void SetMapTravelReason(class UObject* Context, EMapTravelReason TravelReason);
	static bool ShouldVillagerDisappearDuringActivity(struct FVillagerScheduleActivity& InVillagerScheduleActivity);
	static TArray<class FString> Sort(TArray<class FString>& Array);
	static TArray<class AActor*> SortActorsByClosest(TArray<class AActor*>& Actors, struct FVector& Center);
	static TArray<class FName> SortFNameArray(TArray<class FName>& Arr);
	static void SortItemTypes(TArray<class UVAL_ItemTypeDefinitionAsset*>* Items, EItemSortType SortType);
	static TArray<class FName> SortRecipeArray(class UObject* Context, TArray<class FName>& Arr);
	static void SortStoreItemsArrayByRecipeAndSkillLevel(TArray<struct FStoreItem>& OutStoreItems);
	static void SortStoreItemsArrayByRequirements(TArray<struct FStoreItem>& OutStoreItems);
	static void SortStoreItemsArrayBySkillLevel(TArray<struct FStoreItem>& OutStoreItems);
	static class AActor* SpawnActorOnGround(class UObject* Context, TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingMethod, float UnitsToTraceDown);
	static class FText StripTextTags(class FText& InputText);
	static struct FInt64Split SubtractInt64(const struct FInt64Split& A, const struct FInt64Split& B);
	static void SyncWidgetsTest1(class UUserWidget* Owner, class UPanelWidget* ParentPanel, TSubclassOf<class UUserWidget> WidgetToCreate, TArray<class UObject*>& ObjectsToSync);
	static bool TryGetObjectPathFromPackageName(const class FString& InPackageName, class FString* OutObjectPath);
	static bool VitalEquals(const struct FVital& Vital1, const struct FVital& Vital2);
	static void WaitForLimitedEventManager(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class ULimitedEventDataAsset* LimitedEventDataAsset, class ALimitedEventManagerBase** EventManager);
	static void WaitForValeriaCharacter(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AValeriaCharacter** ValeriaCharacter);
	static int32 Wrap(int32 Number, int32 Max);

	void OnOpenModalWidget__DelegateSignature(class UUserWidget* ModalWidget, TArray<class UUserWidget*>& TutorialWidgets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaBlueprintFunctionLibrary">();
	}
	static class UValeriaBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UValeriaBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UValeriaBlueprintFunctionLibrary");
static_assert(sizeof(UValeriaBlueprintFunctionLibrary) == 0x000028, "Wrong size on UValeriaBlueprintFunctionLibrary");

// Class Palia.HouseInventoryComponent
// 0x0078 (0x0118 - 0x00A0)
class UHouseInventoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_285B[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHouseInventoryData                    Data;                                              // 0x00B8(0x0010)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285C[0x50];                                    // 0x00C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReplicatedData();

	bool ContainsHouse(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType) const;
	bool ContainsInventoryIndex(int32 Param_Index) const;
	struct FHouseInventoryItem GetHouseAtInventoryIndex(int32 Param_Index) const;
	int32 NumHousesInInventory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HouseInventoryComponent">();
	}
	static class UHouseInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHouseInventoryComponent>();
	}
};
static_assert(alignof(UHouseInventoryComponent) == 0x000008, "Wrong alignment on UHouseInventoryComponent");
static_assert(sizeof(UHouseInventoryComponent) == 0x000118, "Wrong size on UHouseInventoryComponent");
static_assert(offsetof(UHouseInventoryComponent, OnChanged) == 0x0000A8, "Member 'UHouseInventoryComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UHouseInventoryComponent, Data) == 0x0000B8, "Member 'UHouseInventoryComponent::Data' has a wrong offset!");

// Class Palia.HousingGlobalConfig
// 0x0020 (0x0050 - 0x0030)
class UHousingGlobalConfig final : public UDataAsset
{
public:
	int32                                         MaxPurchaseableSlotCount;                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_285F[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHouseSlotPurchaseCost>         PurchaseSlotCosts;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MaxSlotNameLength;                                 // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2860[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingGlobalConfig">();
	}
	static class UHousingGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHousingGlobalConfig>();
	}
};
static_assert(alignof(UHousingGlobalConfig) == 0x000008, "Wrong alignment on UHousingGlobalConfig");
static_assert(sizeof(UHousingGlobalConfig) == 0x000050, "Wrong size on UHousingGlobalConfig");
static_assert(offsetof(UHousingGlobalConfig, MaxPurchaseableSlotCount) == 0x000030, "Member 'UHousingGlobalConfig::MaxPurchaseableSlotCount' has a wrong offset!");
static_assert(offsetof(UHousingGlobalConfig, PurchaseSlotCosts) == 0x000038, "Member 'UHousingGlobalConfig::PurchaseSlotCosts' has a wrong offset!");
static_assert(offsetof(UHousingGlobalConfig, MaxSlotNameLength) == 0x000048, "Member 'UHousingGlobalConfig::MaxSlotNameLength' has a wrong offset!");

// Class Palia.AttachmentGenerator
// 0x00B8 (0x0360 - 0x02A8)
class AAttachmentGenerator final : public AActor
{
public:
	int32                                         SceneLimit;                                        // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SearchLimit;                                       // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Seed;                                              // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StepCount;                                         // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          RandomSeed;                                        // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AutoIncrementSeed;                                 // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DontLeaveEmptySocket;                              // 0x02BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DebugPauseAtStart;                                 // 0x02BB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2861[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoundsOffset;                                      // 0x02C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Bounds;                                            // 0x02D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2862[0x10];                                    // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class USceneGenData*>             Scenes;                                            // 0x0300(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2863[0x10];                                    // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChooseFirstAttachmentData(TSoftObjectPtr<class UWorld>* Attachment);
	bool ChooseNextAttachmentData(TSoftObjectPtr<class UWorld>* Attachment, class AActorSocket* Socket);
	void Clear();
	void Generate();
	void GenerateStep();
	bool GenerateStep_Internal();
	void GenerationInit();
	int32 NextSeed();
	void OnAttachmentAdded();
	void PostGeneration();
	void PreGeneration();
	void StateChanged(class USceneGenData* Data);

	bool ContinueAddingAttachment() const;
	bool IsGeneratedValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachmentGenerator">();
	}
	static class AAttachmentGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAttachmentGenerator>();
	}
};
static_assert(alignof(AAttachmentGenerator) == 0x000008, "Wrong alignment on AAttachmentGenerator");
static_assert(sizeof(AAttachmentGenerator) == 0x000360, "Wrong size on AAttachmentGenerator");
static_assert(offsetof(AAttachmentGenerator, SceneLimit) == 0x0002A8, "Member 'AAttachmentGenerator::SceneLimit' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, SearchLimit) == 0x0002AC, "Member 'AAttachmentGenerator::SearchLimit' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, Seed) == 0x0002B0, "Member 'AAttachmentGenerator::Seed' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, StepCount) == 0x0002B4, "Member 'AAttachmentGenerator::StepCount' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, RandomSeed) == 0x0002B8, "Member 'AAttachmentGenerator::RandomSeed' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, AutoIncrementSeed) == 0x0002B9, "Member 'AAttachmentGenerator::AutoIncrementSeed' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, DontLeaveEmptySocket) == 0x0002BA, "Member 'AAttachmentGenerator::DontLeaveEmptySocket' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, DebugPauseAtStart) == 0x0002BB, "Member 'AAttachmentGenerator::DebugPauseAtStart' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, BoundsOffset) == 0x0002C0, "Member 'AAttachmentGenerator::BoundsOffset' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, Bounds) == 0x0002D8, "Member 'AAttachmentGenerator::Bounds' has a wrong offset!");
static_assert(offsetof(AAttachmentGenerator, Scenes) == 0x000300, "Member 'AAttachmentGenerator::Scenes' has a wrong offset!");

// Class Palia.HousingOwnershipActor
// 0x0158 (0x0400 - 0x02A8)
class AHousingOwnershipActor : public AActor
{
public:
	uint8                                         Pad_2866[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHousingSlotChanged;                              // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveHousingSlotChanged;                        // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOwnershipTitleChanged;                           // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlacementAlterationOptionsChanged;               // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               PendingPlaceableMaterial;                          // 0x02F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  PendingPlaceableViewActor;                         // 0x0318(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBuildingLimitsChanged;                           // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FHousingBuildingLimits                 BuildingLimits;                                    // 0x0350(0x000C)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGuid                                  HousingGuid;                                       // 0x035C(0x0010)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2867[0x4];                                     // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHousingSlotData                       SlotData;                                          // 0x0370(0x0018)(Net, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         ActiveHousingSlotId;                               // 0x0388(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2868[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHouseOwnershipTitle>           OwnershipList;                                     // 0x0390(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	class UPersistComponent*                      PersistComponent;                                  // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHousingPlaceablesComponent*            HousingPlaceablesComponent;                        // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHousingPlotUnlocksComponent*           HousingPlotUnlocks;                                // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  LoadedByCharacterGuid;                             // 0x03B8(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsViewOnly;                                       // 0x03C8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2869[0x7];                                     // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AValeriaCharacter*>              VisitorsList;                                      // 0x03D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FKickedTicket>                  KickVisitorsList;                                  // 0x03E0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_286A[0x10];                                    // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_PlaceableActorVisibilityUpdate(class UPersistComponent* PersistComp);
	void OnRep_ActiveSlotId();
	void OnRep_BuildingLimits();
	void OnRep_HousingSlotData();
	void OnRep_KickedVisitorList();
	void OnRep_OwnershipList();
	void OnRep_VisitorList();
	void Server_PerformHousingSlotAction(class AValeriaPlayerController* Vpc, struct FHousingSlotActionParams& Action);

	int32 GetActiveHousingSlot() const;
	int32 GetCurrentBuildingClusterCostForActor(class AActor* Actor, int32* CurrentBuildingClusterLimitCost, class AActor* IgnoreActor) const;
	int32 GetCurrentBuildingCount(int32* CurrentHousingLimit, int32* TotalHousingLimit) const;
	struct FPersistGuid GetHousingGuid() const;
	TArray<struct FHouseOwnershipTitle> GetHousingOwnershipInfo() const;
	EHousingPermissionLevel GetHousingOwnershipInfoForCharacter(class AValeriaCharacter* VC) const;
	EHousingPermissionLevel GetHousingOwnershipInfoForCharacterId(struct FGuid& CharacterId) const;
	struct FPersistActorId GetHousingPersistId() const;
	class AHousingPlotActor* GetHousingPlotActor() const;
	class UHousingPlotUnlocksComponent* GetHousingPlotUnlocks() const;
	struct FSessionActorId GetHousingSessionId() const;
	TArray<struct FHouseOwnershipTitle> GetHousingSlotOwnershipInfo(int32 Slot) const;
	struct FPersistGuid GetLoadedByCharacterGuid() const;
	int32 GetNextSlotID() const;
	int32 GetNumPurchasedSlots() const;
	int32 GetPlotValue() const;
	bool GetSlotById(int32 SlotId, struct FHousingSlot* HousingSlot) const;
	void GetSlots(TArray<struct FHousingSlot>* Slots) const;
	TArray<class AValeriaCharacter*> GetVisitorList() const;
	bool IsActorVisibleOnCurrentHousingSlot(class AActor* Actor) const;
	bool IsAtMaxPurchasedSlots() const;
	bool IsOnKickedList(struct FGuid& PlayerId) const;
	bool IsOnVisitorList(struct FGuid& PlayerId) const;
	bool IsViewOnly() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingOwnershipActor">();
	}
	static class AHousingOwnershipActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHousingOwnershipActor>();
	}
};
static_assert(alignof(AHousingOwnershipActor) == 0x000008, "Wrong alignment on AHousingOwnershipActor");
static_assert(sizeof(AHousingOwnershipActor) == 0x000400, "Wrong size on AHousingOwnershipActor");
static_assert(offsetof(AHousingOwnershipActor, OnHousingSlotChanged) == 0x0002B0, "Member 'AHousingOwnershipActor::OnHousingSlotChanged' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, OnActiveHousingSlotChanged) == 0x0002C0, "Member 'AHousingOwnershipActor::OnActiveHousingSlotChanged' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, OnOwnershipTitleChanged) == 0x0002D0, "Member 'AHousingOwnershipActor::OnOwnershipTitleChanged' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, OnPlacementAlterationOptionsChanged) == 0x0002E0, "Member 'AHousingOwnershipActor::OnPlacementAlterationOptionsChanged' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, PendingPlaceableMaterial) == 0x0002F0, "Member 'AHousingOwnershipActor::PendingPlaceableMaterial' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, PendingPlaceableViewActor) == 0x000318, "Member 'AHousingOwnershipActor::PendingPlaceableViewActor' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, OnBuildingLimitsChanged) == 0x000340, "Member 'AHousingOwnershipActor::OnBuildingLimitsChanged' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, BuildingLimits) == 0x000350, "Member 'AHousingOwnershipActor::BuildingLimits' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, HousingGuid) == 0x00035C, "Member 'AHousingOwnershipActor::HousingGuid' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, SlotData) == 0x000370, "Member 'AHousingOwnershipActor::SlotData' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, ActiveHousingSlotId) == 0x000388, "Member 'AHousingOwnershipActor::ActiveHousingSlotId' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, OwnershipList) == 0x000390, "Member 'AHousingOwnershipActor::OwnershipList' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, PersistComponent) == 0x0003A0, "Member 'AHousingOwnershipActor::PersistComponent' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, HousingPlaceablesComponent) == 0x0003A8, "Member 'AHousingOwnershipActor::HousingPlaceablesComponent' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, HousingPlotUnlocks) == 0x0003B0, "Member 'AHousingOwnershipActor::HousingPlotUnlocks' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, LoadedByCharacterGuid) == 0x0003B8, "Member 'AHousingOwnershipActor::LoadedByCharacterGuid' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, bIsViewOnly) == 0x0003C8, "Member 'AHousingOwnershipActor::bIsViewOnly' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, VisitorsList) == 0x0003D0, "Member 'AHousingOwnershipActor::VisitorsList' has a wrong offset!");
static_assert(offsetof(AHousingOwnershipActor, KickVisitorsList) == 0x0003E0, "Member 'AHousingOwnershipActor::KickVisitorsList' has a wrong offset!");

// Class Palia.HousingChunkingDecorReplicationActor
// 0x0158 (0x0400 - 0x02A8)
class AHousingChunkingDecorReplicationActor final : public AActor
{
public:
	struct FSimpleDecorPlaceablesArray            DecorList;                                         // 0x02A8(0x0128)(Net, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSimpleDecorPlaceable>          Client_PendingAdds;                                // 0x03D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSimpleDecorPlaceable>          Client_PendingRemoves;                             // 0x03E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSimpleDecorPlaceable>          Client_PendingChanges;                             // 0x03F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingChunkingDecorReplicationActor">();
	}
	static class AHousingChunkingDecorReplicationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHousingChunkingDecorReplicationActor>();
	}
};
static_assert(alignof(AHousingChunkingDecorReplicationActor) == 0x000008, "Wrong alignment on AHousingChunkingDecorReplicationActor");
static_assert(sizeof(AHousingChunkingDecorReplicationActor) == 0x000400, "Wrong size on AHousingChunkingDecorReplicationActor");
static_assert(offsetof(AHousingChunkingDecorReplicationActor, DecorList) == 0x0002A8, "Member 'AHousingChunkingDecorReplicationActor::DecorList' has a wrong offset!");
static_assert(offsetof(AHousingChunkingDecorReplicationActor, Client_PendingAdds) == 0x0003D0, "Member 'AHousingChunkingDecorReplicationActor::Client_PendingAdds' has a wrong offset!");
static_assert(offsetof(AHousingChunkingDecorReplicationActor, Client_PendingRemoves) == 0x0003E0, "Member 'AHousingChunkingDecorReplicationActor::Client_PendingRemoves' has a wrong offset!");
static_assert(offsetof(AHousingChunkingDecorReplicationActor, Client_PendingChanges) == 0x0003F0, "Member 'AHousingChunkingDecorReplicationActor::Client_PendingChanges' has a wrong offset!");

// Class Palia.TeleportScreenStateRequester
// 0x0000 (0x0048 - 0x0048)
class UTeleportScreenStateRequester final : public UPaliaScreenStateRequester
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportScreenStateRequester">();
	}
	static class UTeleportScreenStateRequester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportScreenStateRequester>();
	}
};
static_assert(alignof(UTeleportScreenStateRequester) == 0x000008, "Wrong alignment on UTeleportScreenStateRequester");
static_assert(sizeof(UTeleportScreenStateRequester) == 0x000048, "Wrong size on UTeleportScreenStateRequester");

// Class Palia.HousingPlaceablesComponent
// 0x0220 (0x02C0 - 0x00A0)
class alignas(0x10) UHousingPlaceablesComponent final : public UActorComponent
{
public:
	int32                                         ActiveSlotDecorPlacementLimitCost;                 // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveSlotPlaceablePlacementLimitCost;             // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveSlotDecorPlotValue;                          // 0x00A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveSlotPlaceablePlotValue;                      // 0x00AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveSlotWallpaperPlotValue;                      // 0x00B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2875[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHousingChunkingDecorReplicationActor*> ChunkingDecorReplicators;                          // 0x00B8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FBlobIdSerializer                      PlaceableBlobIds;                                  // 0x00C8(0x0118)(Net, NativeAccessSpecifierPrivate)
	int32                                         ReplicatedActiveSlotId;                            // 0x01E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2876[0x4];                                     // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMultiplayerDecorLocking>       ActiveLockedPlaceablesPerCharacter;                // 0x01E8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	class AValeriaCharacter*                      ActiveMultilockInstigator;                         // 0x01F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2877[0x48];                                    // 0x0200(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMultiplayerDecorLocking>       ClientSide_ActiveLockedPlaceablesPerCharacter;     // 0x0248(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FSessionActorId, struct FSimpleDecorClientInfo> ClientSide_SimpleDecorActors;                      // 0x0258(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ClientSide_CachedList_OutdoorActors;               // 0x02A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2878[0x8];                                     // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LockedPlaceablesUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingPlaceablesComponent">();
	}
	static class UHousingPlaceablesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHousingPlaceablesComponent>();
	}
};
static_assert(alignof(UHousingPlaceablesComponent) == 0x000010, "Wrong alignment on UHousingPlaceablesComponent");
static_assert(sizeof(UHousingPlaceablesComponent) == 0x0002C0, "Wrong size on UHousingPlaceablesComponent");
static_assert(offsetof(UHousingPlaceablesComponent, ActiveSlotDecorPlacementLimitCost) == 0x0000A0, "Member 'UHousingPlaceablesComponent::ActiveSlotDecorPlacementLimitCost' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ActiveSlotPlaceablePlacementLimitCost) == 0x0000A4, "Member 'UHousingPlaceablesComponent::ActiveSlotPlaceablePlacementLimitCost' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ActiveSlotDecorPlotValue) == 0x0000A8, "Member 'UHousingPlaceablesComponent::ActiveSlotDecorPlotValue' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ActiveSlotPlaceablePlotValue) == 0x0000AC, "Member 'UHousingPlaceablesComponent::ActiveSlotPlaceablePlotValue' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ActiveSlotWallpaperPlotValue) == 0x0000B0, "Member 'UHousingPlaceablesComponent::ActiveSlotWallpaperPlotValue' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ChunkingDecorReplicators) == 0x0000B8, "Member 'UHousingPlaceablesComponent::ChunkingDecorReplicators' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, PlaceableBlobIds) == 0x0000C8, "Member 'UHousingPlaceablesComponent::PlaceableBlobIds' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ReplicatedActiveSlotId) == 0x0001E0, "Member 'UHousingPlaceablesComponent::ReplicatedActiveSlotId' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ActiveLockedPlaceablesPerCharacter) == 0x0001E8, "Member 'UHousingPlaceablesComponent::ActiveLockedPlaceablesPerCharacter' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ActiveMultilockInstigator) == 0x0001F8, "Member 'UHousingPlaceablesComponent::ActiveMultilockInstigator' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ClientSide_ActiveLockedPlaceablesPerCharacter) == 0x000248, "Member 'UHousingPlaceablesComponent::ClientSide_ActiveLockedPlaceablesPerCharacter' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ClientSide_SimpleDecorActors) == 0x000258, "Member 'UHousingPlaceablesComponent::ClientSide_SimpleDecorActors' has a wrong offset!");
static_assert(offsetof(UHousingPlaceablesComponent, ClientSide_CachedList_OutdoorActors) == 0x0002A8, "Member 'UHousingPlaceablesComponent::ClientSide_CachedList_OutdoorActors' has a wrong offset!");

// Class Palia.HousingPlacementEffectComponent
// 0x0040 (0x00E0 - 0x00A0)
class UHousingPlacementEffectComponent final : public UActorComponent
{
public:
	class UCurveFloat*                            TimingCurve;                                       // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              OverlayMaterialHighlightTemplate;                  // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2879[0x28];                                    // 0x00B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               OverlayMaterialHighlightInstance;                  // 0x00D8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetPlacementEffectState(bool IsEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingPlacementEffectComponent">();
	}
	static class UHousingPlacementEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHousingPlacementEffectComponent>();
	}
};
static_assert(alignof(UHousingPlacementEffectComponent) == 0x000008, "Wrong alignment on UHousingPlacementEffectComponent");
static_assert(sizeof(UHousingPlacementEffectComponent) == 0x0000E0, "Wrong size on UHousingPlacementEffectComponent");
static_assert(offsetof(UHousingPlacementEffectComponent, TimingCurve) == 0x0000A0, "Member 'UHousingPlacementEffectComponent::TimingCurve' has a wrong offset!");
static_assert(offsetof(UHousingPlacementEffectComponent, OverlayMaterialHighlightTemplate) == 0x0000A8, "Member 'UHousingPlacementEffectComponent::OverlayMaterialHighlightTemplate' has a wrong offset!");
static_assert(offsetof(UHousingPlacementEffectComponent, OverlayMaterialHighlightInstance) == 0x0000D8, "Member 'UHousingPlacementEffectComponent::OverlayMaterialHighlightInstance' has a wrong offset!");

// Class Palia.ValeriaAutomationBpFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UValeriaAutomationBpFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void VALTEST_FinishMapTest(class UObject* Context);
	static bool VALTEST_IsInAutomationWorld(class UObject* Context);
	static void VALTEST_TestTrue(class UObject* Context, const class FString& Result, bool WasSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaAutomationBpFunctionLibrary">();
	}
	static class UValeriaAutomationBpFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaAutomationBpFunctionLibrary>();
	}
};
static_assert(alignof(UValeriaAutomationBpFunctionLibrary) == 0x000008, "Wrong alignment on UValeriaAutomationBpFunctionLibrary");
static_assert(sizeof(UValeriaAutomationBpFunctionLibrary) == 0x000028, "Wrong size on UValeriaAutomationBpFunctionLibrary");

// Class Palia.HousingPlotActor
// 0x01B0 (0x0458 - 0x02A8)
class AHousingPlotActor : public AActor
{
public:
	uint8                                         Pad_287C[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoundaryRadiusSquared;                             // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287D[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnOrigin;                                       // 0x02B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnOffset;                                       // 0x02D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntitiesOnPlotCostLimit;                           // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287E[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> PlotHOAItemType;                                   // 0x02F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UHousingPlotSpawnConfig> HousingPlotConfig;                                 // 0x0318(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_ItemTypeDefinitionAsset*           DefaultSpawnedFenceItemType;                       // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DefaultSpawnedFenceGapSize;                        // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDefaultSpawnedFenceIrregular;                     // 0x034C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_287F[0x3];                                     // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        PlayerStart;                                       // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    Billboard;                                         // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextRenderComponent*                   HouseName;                                         // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlacementRegionComponent*              PlacementRegion;                                   // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        UpgradeLocation;                                   // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTeleportDestinationComponent*          TeleportDestination;                               // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          PlayerKillVolumeXNeg;                              // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          PlayerKillVolumeXPos;                              // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          PlayerKillVolumeYNeg;                              // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          PlayerKillVolumeYPos;                              // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          PlayerKillVolumeZNeg;                              // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          PlayerKillVolumeZPos;                              // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         KillVolumeExtent;                                  // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillVolumeThickness;                               // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlotDisplayName;                                   // 0x03C0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FComplexRecipeRecord>           ComplexRecipes;                                    // 0x03D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FRecipeIdToOtherRecipeIds>      ComplexRecipeReqs;                                 // 0x03E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FPersistGuid                           OccupiedHousingGuid;                               // 0x03F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHousingOwnershipActor*                 OccupiedHousingOwnershipActor;                     // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AHousingPlotDebrisActor*>        WritsDebrisActors;                                 // 0x0408(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2880[0x40];                                    // 0x0418(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsHousingMenuCameraRotationEnabled();

	TArray<class AActor*> ClientGetAllOutdoorDecorActors();
	int32 ClientGetAllOutdoorDecorActorsDirtyId();
	void CreateDebrisActors();
	void DestroyDebrisActors();
	class UTeleportDestinationComponent* GetTeleportDestination();
	void HandlePlayerReachedKillVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnForwardStickChanged(float Axis);
	void OnHousingPlotUnlocksChanged(class UHousingPlotUnlocksComponent* Component);
	void OnHousingVisitorListChanged(class AHousingOwnershipActor* HOA);
	void OnLocalPlayerPlacementStateChanged(class AValeriaCharacter* VC, bool PlacementMode);
	void OnOccupiedHousingOwnershipChanged(class AHousingOwnershipActor* HOA);
	void OnRep_ComplexRecipes(TArray<struct FComplexRecipeRecord>& OldRecipes);
	void OnRep_OccupiedByHousingOwnershipActor();
	void OnRightLeftStickChanged(float Axis);
	void OnZoomWheelChanged(float Rate);
	void SetDebrisActorsHighlightState(int32 PersistId, bool bHighlight);
	void ToggleCamera(class AValeriaCharacter* VC, bool IsAttached);
	void UpdateHouseName();

	bool GetComplexRecipe(ESkillType SkillType, class UCrafterComponent** Crafter, int32* RecipeId) const;
	TArray<struct FRecipeIdToOtherRecipeIds> GetComplexRecipesReqs() const;
	class UHousingPlotSpawnConfig* GetHousingPlotConfig() const;
	struct FPersistGuid GetOccupiedHousingGuid() const;
	struct FPersistActorId GetOccupiedHousingPersistActorId() const;
	struct FGuid GetOccupiedHousingPrimaryOwnerGuid() const;
	class FString GetOccupiedHousingPrimaryOwnerName() const;
	struct FTransform GetWritTransform(struct FHousingPlotWritRegion& Writ, class UPlacementRegionComponent* Region) const;
	bool IsCharacterOnHousePlot(class AValeriaCharacter* Character) const;
	bool IsComplexRecipeRunning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingPlotActor">();
	}
	static class AHousingPlotActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHousingPlotActor>();
	}
};
static_assert(alignof(AHousingPlotActor) == 0x000008, "Wrong alignment on AHousingPlotActor");
static_assert(sizeof(AHousingPlotActor) == 0x000458, "Wrong size on AHousingPlotActor");
static_assert(offsetof(AHousingPlotActor, BoundaryRadiusSquared) == 0x0002B0, "Member 'AHousingPlotActor::BoundaryRadiusSquared' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, SpawnOrigin) == 0x0002B8, "Member 'AHousingPlotActor::SpawnOrigin' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, SpawnOffset) == 0x0002D0, "Member 'AHousingPlotActor::SpawnOffset' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, EntitiesOnPlotCostLimit) == 0x0002E8, "Member 'AHousingPlotActor::EntitiesOnPlotCostLimit' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlotHOAItemType) == 0x0002F0, "Member 'AHousingPlotActor::PlotHOAItemType' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, HousingPlotConfig) == 0x000318, "Member 'AHousingPlotActor::HousingPlotConfig' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, DefaultSpawnedFenceItemType) == 0x000340, "Member 'AHousingPlotActor::DefaultSpawnedFenceItemType' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, DefaultSpawnedFenceGapSize) == 0x000348, "Member 'AHousingPlotActor::DefaultSpawnedFenceGapSize' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, bDefaultSpawnedFenceIrregular) == 0x00034C, "Member 'AHousingPlotActor::bDefaultSpawnedFenceIrregular' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, Root) == 0x000350, "Member 'AHousingPlotActor::Root' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlayerStart) == 0x000358, "Member 'AHousingPlotActor::PlayerStart' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, Billboard) == 0x000360, "Member 'AHousingPlotActor::Billboard' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, HouseName) == 0x000368, "Member 'AHousingPlotActor::HouseName' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlacementRegion) == 0x000370, "Member 'AHousingPlotActor::PlacementRegion' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, UpgradeLocation) == 0x000378, "Member 'AHousingPlotActor::UpgradeLocation' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, TeleportDestination) == 0x000380, "Member 'AHousingPlotActor::TeleportDestination' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlayerKillVolumeXNeg) == 0x000388, "Member 'AHousingPlotActor::PlayerKillVolumeXNeg' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlayerKillVolumeXPos) == 0x000390, "Member 'AHousingPlotActor::PlayerKillVolumeXPos' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlayerKillVolumeYNeg) == 0x000398, "Member 'AHousingPlotActor::PlayerKillVolumeYNeg' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlayerKillVolumeYPos) == 0x0003A0, "Member 'AHousingPlotActor::PlayerKillVolumeYPos' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlayerKillVolumeZNeg) == 0x0003A8, "Member 'AHousingPlotActor::PlayerKillVolumeZNeg' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlayerKillVolumeZPos) == 0x0003B0, "Member 'AHousingPlotActor::PlayerKillVolumeZPos' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, KillVolumeExtent) == 0x0003B8, "Member 'AHousingPlotActor::KillVolumeExtent' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, KillVolumeThickness) == 0x0003BC, "Member 'AHousingPlotActor::KillVolumeThickness' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, PlotDisplayName) == 0x0003C0, "Member 'AHousingPlotActor::PlotDisplayName' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, ComplexRecipes) == 0x0003D0, "Member 'AHousingPlotActor::ComplexRecipes' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, ComplexRecipeReqs) == 0x0003E0, "Member 'AHousingPlotActor::ComplexRecipeReqs' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, OccupiedHousingGuid) == 0x0003F0, "Member 'AHousingPlotActor::OccupiedHousingGuid' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, OccupiedHousingOwnershipActor) == 0x000400, "Member 'AHousingPlotActor::OccupiedHousingOwnershipActor' has a wrong offset!");
static_assert(offsetof(AHousingPlotActor, WritsDebrisActors) == 0x000408, "Member 'AHousingPlotActor::WritsDebrisActors' has a wrong offset!");

// Class Palia.HousingPlotSpawnConfig
// 0x0068 (0x0098 - 0x0030)
class UHousingPlotSpawnConfig final : public UDataAsset
{
public:
	TArray<struct FHousingPlotSpawningItem>       StartingSpawnItems;                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHousingPlotWritRegion>         WritRegions;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WritDebrisActorTemplate;                           // 0x0050(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHousingWritToBuildingUnlockLimit> BuildingLimit;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FConditionalHousingPlotSpawnItemList> ConditionalSpawnItemLists;                         // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingPlotSpawnConfig">();
	}
	static class UHousingPlotSpawnConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHousingPlotSpawnConfig>();
	}
};
static_assert(alignof(UHousingPlotSpawnConfig) == 0x000008, "Wrong alignment on UHousingPlotSpawnConfig");
static_assert(sizeof(UHousingPlotSpawnConfig) == 0x000098, "Wrong size on UHousingPlotSpawnConfig");
static_assert(offsetof(UHousingPlotSpawnConfig, StartingSpawnItems) == 0x000030, "Member 'UHousingPlotSpawnConfig::StartingSpawnItems' has a wrong offset!");
static_assert(offsetof(UHousingPlotSpawnConfig, WritRegions) == 0x000040, "Member 'UHousingPlotSpawnConfig::WritRegions' has a wrong offset!");
static_assert(offsetof(UHousingPlotSpawnConfig, WritDebrisActorTemplate) == 0x000050, "Member 'UHousingPlotSpawnConfig::WritDebrisActorTemplate' has a wrong offset!");
static_assert(offsetof(UHousingPlotSpawnConfig, BuildingLimit) == 0x000078, "Member 'UHousingPlotSpawnConfig::BuildingLimit' has a wrong offset!");
static_assert(offsetof(UHousingPlotSpawnConfig, ConditionalSpawnItemLists) == 0x000088, "Member 'UHousingPlotSpawnConfig::ConditionalSpawnItemLists' has a wrong offset!");

// Class Palia.RtpcTrackerComponent
// 0x00B0 (0x0150 - 0x00A0)
class URtpcTrackerComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnRtpcChanged;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UAkRtpc*, float>                   RtpcMap;                                           // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPrivate)
	TSet<class UAkComponent*>                     TrackedAkComponents;                               // 0x0100(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void GetRtpcs(TMap<class UAkRtpc*, float>* Rtpc_Map);
	void GetRTPCValue(class UAkRtpc* Rtpc, float* Value, bool* bFound);
	void PropagateRtpcs(class UAkComponent* AkComponent);
	void UpdateRTPCValue(class UAkRtpc* Rtpc, float Value, int32 Interpolation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RtpcTrackerComponent">();
	}
	static class URtpcTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URtpcTrackerComponent>();
	}
};
static_assert(alignof(URtpcTrackerComponent) == 0x000008, "Wrong alignment on URtpcTrackerComponent");
static_assert(sizeof(URtpcTrackerComponent) == 0x000150, "Wrong size on URtpcTrackerComponent");
static_assert(offsetof(URtpcTrackerComponent, OnRtpcChanged) == 0x0000A0, "Member 'URtpcTrackerComponent::OnRtpcChanged' has a wrong offset!");
static_assert(offsetof(URtpcTrackerComponent, RtpcMap) == 0x0000B0, "Member 'URtpcTrackerComponent::RtpcMap' has a wrong offset!");
static_assert(offsetof(URtpcTrackerComponent, TrackedAkComponents) == 0x000100, "Member 'URtpcTrackerComponent::TrackedAkComponents' has a wrong offset!");

// Class Palia.HousingPlotUnlocksComponent
// 0x0020 (0x00C0 - 0x00A0)
class UHousingPlotUnlocksComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHousingPlotUnlocksData                Data;                                              // 0x00B0(0x0010)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnReplicatedData();

	struct FVector4 GetNeighborVisualValue(int32 PersistId) const;
	bool HasRequirementsToUnlockPlot(class AValeriaCharacter* VC, int32 PersistId) const;
	bool IsNeighboringUnlockedPlot(int32 PersistId) const;
	bool IsPlotUnlocked(int32 PersistId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingPlotUnlocksComponent">();
	}
	static class UHousingPlotUnlocksComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHousingPlotUnlocksComponent>();
	}
};
static_assert(alignof(UHousingPlotUnlocksComponent) == 0x000008, "Wrong alignment on UHousingPlotUnlocksComponent");
static_assert(sizeof(UHousingPlotUnlocksComponent) == 0x0000C0, "Wrong size on UHousingPlotUnlocksComponent");
static_assert(offsetof(UHousingPlotUnlocksComponent, OnChanged) == 0x0000A0, "Member 'UHousingPlotUnlocksComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UHousingPlotUnlocksComponent, Data) == 0x0000B0, "Member 'UHousingPlotUnlocksComponent::Data' has a wrong offset!");

// Class Palia.HousingPlotDebrisActor
// 0x0008 (0x02B0 - 0x02A8)
class AHousingPlotDebrisActor : public AActor
{
public:
	int32                                         PersistId;                                         // 0x02A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlocked;                                         // 0x02AC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288D[0x3];                                     // 0x02AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHightlightState(bool Highlight);
	void UpdateCharacterState(class AValeriaCharacter* VC, bool IsPlacementMode);
	void UpdateWritPlotUnlockState(class UHousingPlotUnlocksComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingPlotDebrisActor">();
	}
	static class AHousingPlotDebrisActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHousingPlotDebrisActor>();
	}
};
static_assert(alignof(AHousingPlotDebrisActor) == 0x000008, "Wrong alignment on AHousingPlotDebrisActor");
static_assert(sizeof(AHousingPlotDebrisActor) == 0x0002B0, "Wrong size on AHousingPlotDebrisActor");
static_assert(offsetof(AHousingPlotDebrisActor, PersistId) == 0x0002A8, "Member 'AHousingPlotDebrisActor::PersistId' has a wrong offset!");
static_assert(offsetof(AHousingPlotDebrisActor, bUnlocked) == 0x0002AC, "Member 'AHousingPlotDebrisActor::bUnlocked' has a wrong offset!");

// Class Palia.SkillLevelsComponent
// 0x00E8 (0x0188 - 0x00A0)
class USkillLevelsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_288F[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SkillPointsAllowedTag;                             // 0x00A8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseFocusBonusMult;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2890[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagScoreRubric                        FocusBonusUpgradeBonusCalculator;                  // 0x00B8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LevelChanged;                                      // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2891[0x18];                                    // 0x00F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillsPersistBlock                    SkillsPersistBlock;                                // 0x0110(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NativeAccessSpecifierPublic)
	class FString                                 StatSkillAccomplishmentPrefix;                     // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSkillXpAggregationGroup>       batchedSkillXp;                                    // 0x0178(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CorrectSkillStatAccuracy();
	void OnRep_SkillLevels();

	float GetFocusBonusBuffXpMult() const;
	float GetFocusBonusUpgradeXpMult() const;
	float GetFocusBonusXpMult() const;
	int32 GetMasterLevel() const;
	int32 GetMaxSkillPoints() const;
	int32 GetNumberOfSkillPoints() const;
	struct FSkillPersist GetSkillLevel(ESkillType SkillType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillLevelsComponent">();
	}
	static class USkillLevelsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillLevelsComponent>();
	}
};
static_assert(alignof(USkillLevelsComponent) == 0x000008, "Wrong alignment on USkillLevelsComponent");
static_assert(sizeof(USkillLevelsComponent) == 0x000188, "Wrong size on USkillLevelsComponent");
static_assert(offsetof(USkillLevelsComponent, SkillPointsAllowedTag) == 0x0000A8, "Member 'USkillLevelsComponent::SkillPointsAllowedTag' has a wrong offset!");
static_assert(offsetof(USkillLevelsComponent, BaseFocusBonusMult) == 0x0000B0, "Member 'USkillLevelsComponent::BaseFocusBonusMult' has a wrong offset!");
static_assert(offsetof(USkillLevelsComponent, FocusBonusUpgradeBonusCalculator) == 0x0000B8, "Member 'USkillLevelsComponent::FocusBonusUpgradeBonusCalculator' has a wrong offset!");
static_assert(offsetof(USkillLevelsComponent, OnChanged) == 0x0000D8, "Member 'USkillLevelsComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(USkillLevelsComponent, LevelChanged) == 0x0000E8, "Member 'USkillLevelsComponent::LevelChanged' has a wrong offset!");
static_assert(offsetof(USkillLevelsComponent, SkillsPersistBlock) == 0x000110, "Member 'USkillLevelsComponent::SkillsPersistBlock' has a wrong offset!");
static_assert(offsetof(USkillLevelsComponent, StatSkillAccomplishmentPrefix) == 0x000168, "Member 'USkillLevelsComponent::StatSkillAccomplishmentPrefix' has a wrong offset!");
static_assert(offsetof(USkillLevelsComponent, batchedSkillXp) == 0x000178, "Member 'USkillLevelsComponent::batchedSkillXp' has a wrong offset!");

// Class Palia.HousingSlotOverride
// 0x0000 (0x0028 - 0x0028)
class IHousingSlotOverride final : public IInterface
{
public:
	int32 GetOverriddenHousingSlotId() const;
	bool ShouldOverrideHousingSlotId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingSlotOverride">();
	}
	static class IHousingSlotOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHousingSlotOverride>();
	}
};
static_assert(alignof(IHousingSlotOverride) == 0x000008, "Wrong alignment on IHousingSlotOverride");
static_assert(sizeof(IHousingSlotOverride) == 0x000028, "Wrong size on IHousingSlotOverride");

// Class Palia.HousingToursSpotlightAccountConfig
// 0x00C8 (0x00F8 - 0x0030)
class UHousingToursSpotlightAccountConfig final : public UDataAsset
{
public:
	class FText                                   PlotName;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AuthorName;                                        // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 CharacterIdDev;                                    // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterIdProd;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Screenshot1;                                       // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Screenshot2;                                       // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Screenshot3;                                       // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GetCharacterId(struct FGuid* OutGuid, bool* Success) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingToursSpotlightAccountConfig">();
	}
	static class UHousingToursSpotlightAccountConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHousingToursSpotlightAccountConfig>();
	}
};
static_assert(alignof(UHousingToursSpotlightAccountConfig) == 0x000008, "Wrong alignment on UHousingToursSpotlightAccountConfig");
static_assert(sizeof(UHousingToursSpotlightAccountConfig) == 0x0000F8, "Wrong size on UHousingToursSpotlightAccountConfig");
static_assert(offsetof(UHousingToursSpotlightAccountConfig, PlotName) == 0x000030, "Member 'UHousingToursSpotlightAccountConfig::PlotName' has a wrong offset!");
static_assert(offsetof(UHousingToursSpotlightAccountConfig, AuthorName) == 0x000048, "Member 'UHousingToursSpotlightAccountConfig::AuthorName' has a wrong offset!");
static_assert(offsetof(UHousingToursSpotlightAccountConfig, CharacterIdDev) == 0x000060, "Member 'UHousingToursSpotlightAccountConfig::CharacterIdDev' has a wrong offset!");
static_assert(offsetof(UHousingToursSpotlightAccountConfig, CharacterIdProd) == 0x000070, "Member 'UHousingToursSpotlightAccountConfig::CharacterIdProd' has a wrong offset!");
static_assert(offsetof(UHousingToursSpotlightAccountConfig, Screenshot1) == 0x000080, "Member 'UHousingToursSpotlightAccountConfig::Screenshot1' has a wrong offset!");
static_assert(offsetof(UHousingToursSpotlightAccountConfig, Screenshot2) == 0x0000A8, "Member 'UHousingToursSpotlightAccountConfig::Screenshot2' has a wrong offset!");
static_assert(offsetof(UHousingToursSpotlightAccountConfig, Screenshot3) == 0x0000D0, "Member 'UHousingToursSpotlightAccountConfig::Screenshot3' has a wrong offset!");

// Class Palia.VAL_SessionManager
// 0x0030 (0x0060 - 0x0030)
class UVAL_SessionManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPlayersRegistered;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2894[0x20];                                    // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ValSessionOnPlayersRegistered__DelegateSignature(bool bRegistered, class FName SessionName, TArray<struct FUniqueNetIdRepl>& Players);

	TArray<struct FUniqueNetIdRepl> GetRegisteredPlayers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_SessionManager">();
	}
	static class UVAL_SessionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_SessionManager>();
	}
};
static_assert(alignof(UVAL_SessionManager) == 0x000008, "Wrong alignment on UVAL_SessionManager");
static_assert(sizeof(UVAL_SessionManager) == 0x000060, "Wrong size on UVAL_SessionManager");
static_assert(offsetof(UVAL_SessionManager, OnPlayersRegistered) == 0x000030, "Member 'UVAL_SessionManager::OnPlayersRegistered' has a wrong offset!");

// Class Palia.HousingUpgradeKioskComponent
// 0x0010 (0x00B0 - 0x00A0)
class UHousingUpgradeKioskComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2897[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     EmptyActorBlueprint;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Player, const struct FInteractEventParams& EventParams);

	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousingUpgradeKioskComponent">();
	}
	static class UHousingUpgradeKioskComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHousingUpgradeKioskComponent>();
	}
};
static_assert(alignof(UHousingUpgradeKioskComponent) == 0x000008, "Wrong alignment on UHousingUpgradeKioskComponent");
static_assert(sizeof(UHousingUpgradeKioskComponent) == 0x0000B0, "Wrong size on UHousingUpgradeKioskComponent");
static_assert(offsetof(UHousingUpgradeKioskComponent, EmptyActorBlueprint) == 0x0000A8, "Member 'UHousingUpgradeKioskComponent::EmptyActorBlueprint' has a wrong offset!");

// Class Palia.HuntingCreatureTeleportComponent
// 0x0068 (0x0108 - 0x00A0)
class UHuntingCreatureTeleportComponent final : public UActorComponent
{
public:
	uint8                                         Pad_289C[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDisruptedStart;                                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPreparingStart;                                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeleport;                                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_289D[0x4];                                     // 0x00D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialTeleportDelay;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportCooldown;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportCastTime;                                  // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportDistance;                                  // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportDirectionNoise;                            // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispelDuration;                                    // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289E[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitReactComponent*                     CachedHitReactComponent;                           // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACreatureCharacter*                     CachedCreature;                                    // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	ETeleportState GetCurrentTeleportState();
	float GetRemainingDisruptedTime();
	void NotifyEvadeEnd();
	void NotifyEvadeStart();
	void RpcClient_DisplayDisruptedStart(float VisualDisruptDuration);
	void RpcClient_DisplayPreparingStart();
	void RpcClient_DisplayTeleport(const struct FVector& TeleportDestination);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HuntingCreatureTeleportComponent">();
	}
	static class UHuntingCreatureTeleportComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHuntingCreatureTeleportComponent>();
	}
};
static_assert(alignof(UHuntingCreatureTeleportComponent) == 0x000008, "Wrong alignment on UHuntingCreatureTeleportComponent");
static_assert(sizeof(UHuntingCreatureTeleportComponent) == 0x000108, "Wrong size on UHuntingCreatureTeleportComponent");
static_assert(offsetof(UHuntingCreatureTeleportComponent, OnDisruptedStart) == 0x0000A8, "Member 'UHuntingCreatureTeleportComponent::OnDisruptedStart' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, OnPreparingStart) == 0x0000B8, "Member 'UHuntingCreatureTeleportComponent::OnPreparingStart' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, OnTeleport) == 0x0000C8, "Member 'UHuntingCreatureTeleportComponent::OnTeleport' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, InitialTeleportDelay) == 0x0000DC, "Member 'UHuntingCreatureTeleportComponent::InitialTeleportDelay' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, TeleportCooldown) == 0x0000E0, "Member 'UHuntingCreatureTeleportComponent::TeleportCooldown' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, TeleportCastTime) == 0x0000E4, "Member 'UHuntingCreatureTeleportComponent::TeleportCastTime' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, TeleportDistance) == 0x0000E8, "Member 'UHuntingCreatureTeleportComponent::TeleportDistance' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, TeleportDirectionNoise) == 0x0000EC, "Member 'UHuntingCreatureTeleportComponent::TeleportDirectionNoise' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, DispelDuration) == 0x0000F0, "Member 'UHuntingCreatureTeleportComponent::DispelDuration' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, CachedHitReactComponent) == 0x0000F8, "Member 'UHuntingCreatureTeleportComponent::CachedHitReactComponent' has a wrong offset!");
static_assert(offsetof(UHuntingCreatureTeleportComponent, CachedCreature) == 0x000100, "Member 'UHuntingCreatureTeleportComponent::CachedCreature' has a wrong offset!");

// Class Palia.RequirementFetcher
// 0x0000 (0x0028 - 0x0028)
class IRequirementFetcher final : public IInterface
{
public:
	bool GetRequirement(struct FRequirement* Requirement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RequirementFetcher">();
	}
	static class IRequirementFetcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRequirementFetcher>();
	}
};
static_assert(alignof(IRequirementFetcher) == 0x000008, "Wrong alignment on IRequirementFetcher");
static_assert(sizeof(IRequirementFetcher) == 0x000028, "Wrong size on IRequirementFetcher");

// Class Palia.HurtComponent
// 0x0018 (0x00B8 - 0x00A0)
class UHurtComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnHurt;                                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ShadeTemplate;                                     // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void NotifyHurt();
	void RpcClient_NotifyHurt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HurtComponent">();
	}
	static class UHurtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHurtComponent>();
	}
};
static_assert(alignof(UHurtComponent) == 0x000008, "Wrong alignment on UHurtComponent");
static_assert(sizeof(UHurtComponent) == 0x0000B8, "Wrong size on UHurtComponent");
static_assert(offsetof(UHurtComponent, OnHurt) == 0x0000A0, "Member 'UHurtComponent::OnHurt' has a wrong offset!");
static_assert(offsetof(UHurtComponent, ShadeTemplate) == 0x0000B0, "Member 'UHurtComponent::ShadeTemplate' has a wrong offset!");

// Class Palia.IllusionComponent
// 0x0040 (0x00E0 - 0x00A0)
class UIllusionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_28A0[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentOpacity;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A1[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            OpacityCurve;                                      // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlickerMinPeriod;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlickerMaxPeriod;                                  // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLifetime;                                       // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanReverse;                                        // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A2[0x13];                                    // 0x00C5(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FadingOut;                                         // 0x00D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A3[0x7];                                     // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeAway(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IllusionComponent">();
	}
	static class UIllusionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIllusionComponent>();
	}
};
static_assert(alignof(UIllusionComponent) == 0x000008, "Wrong alignment on UIllusionComponent");
static_assert(sizeof(UIllusionComponent) == 0x0000E0, "Wrong size on UIllusionComponent");
static_assert(offsetof(UIllusionComponent, CurrentOpacity) == 0x0000A8, "Member 'UIllusionComponent::CurrentOpacity' has a wrong offset!");
static_assert(offsetof(UIllusionComponent, OpacityCurve) == 0x0000B0, "Member 'UIllusionComponent::OpacityCurve' has a wrong offset!");
static_assert(offsetof(UIllusionComponent, FlickerMinPeriod) == 0x0000B8, "Member 'UIllusionComponent::FlickerMinPeriod' has a wrong offset!");
static_assert(offsetof(UIllusionComponent, FlickerMaxPeriod) == 0x0000BC, "Member 'UIllusionComponent::FlickerMaxPeriod' has a wrong offset!");
static_assert(offsetof(UIllusionComponent, MaxLifetime) == 0x0000C0, "Member 'UIllusionComponent::MaxLifetime' has a wrong offset!");
static_assert(offsetof(UIllusionComponent, CanReverse) == 0x0000C4, "Member 'UIllusionComponent::CanReverse' has a wrong offset!");
static_assert(offsetof(UIllusionComponent, FadingOut) == 0x0000D8, "Member 'UIllusionComponent::FadingOut' has a wrong offset!");

// Class Palia.ShopComponent
// 0x0028 (0x00C8 - 0x00A0)
class UShopComponent final : public UActorComponent
{
public:
	int32                                         ShopConfigId;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A4[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UShopSlotComponent*>             ShopSlots;                                         // 0x00A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bIsShopOpen;                                       // 0x00B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28A5[0xF];                                     // 0x00B9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopComponent">();
	}
	static class UShopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopComponent>();
	}
};
static_assert(alignof(UShopComponent) == 0x000008, "Wrong alignment on UShopComponent");
static_assert(sizeof(UShopComponent) == 0x0000C8, "Wrong size on UShopComponent");
static_assert(offsetof(UShopComponent, ShopConfigId) == 0x0000A0, "Member 'UShopComponent::ShopConfigId' has a wrong offset!");
static_assert(offsetof(UShopComponent, ShopSlots) == 0x0000A8, "Member 'UShopComponent::ShopSlots' has a wrong offset!");
static_assert(offsetof(UShopComponent, bIsShopOpen) == 0x0000B8, "Member 'UShopComponent::bIsShopOpen' has a wrong offset!");

// Class Palia.IllusionTrailComponent
// 0x0028 (0x00C8 - 0x00A0)
class UIllusionTrailComponent final : public UActorComponent
{
public:
	TSubclassOf<class AActor>                     IllusionTemplate;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SpawnedIllusions;                                  // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SpawnInterval;                                     // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutSpeed;                                      // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A6[0x8];                                     // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeath(class UDeathComponent* Death);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IllusionTrailComponent">();
	}
	static class UIllusionTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIllusionTrailComponent>();
	}
};
static_assert(alignof(UIllusionTrailComponent) == 0x000008, "Wrong alignment on UIllusionTrailComponent");
static_assert(sizeof(UIllusionTrailComponent) == 0x0000C8, "Wrong size on UIllusionTrailComponent");
static_assert(offsetof(UIllusionTrailComponent, IllusionTemplate) == 0x0000A0, "Member 'UIllusionTrailComponent::IllusionTemplate' has a wrong offset!");
static_assert(offsetof(UIllusionTrailComponent, SpawnedIllusions) == 0x0000A8, "Member 'UIllusionTrailComponent::SpawnedIllusions' has a wrong offset!");
static_assert(offsetof(UIllusionTrailComponent, SpawnInterval) == 0x0000B8, "Member 'UIllusionTrailComponent::SpawnInterval' has a wrong offset!");
static_assert(offsetof(UIllusionTrailComponent, FadeOutSpeed) == 0x0000BC, "Member 'UIllusionTrailComponent::FadeOutSpeed' has a wrong offset!");

// Class Palia.InactiveDespawnComponent
// 0x0020 (0x00C0 - 0x00A0)
class UInactiveDespawnComponent final : public UActorComponent
{
public:
	int32                                         InactivitySeconds;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DespawnDelaySeconds;                               // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCharacterDespawnDistance;                       // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCharacterLOSDistance;                           // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           InactivityTimerHandle;                             // 0x00B0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28A7[0x8];                                     // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCharacterAddedAsThreat(class AValeriaCharacter* Character);
	void HandleHealthChanged(float PreviousHealth, float NewHealth, float MaxHealth);
	void HandleInactivityTimerComplete();
	void HandleProjectileHitReact(class AActor* Instigator, class UVAL_ItemTypeDefinitionAsset* AmmoType);
	void HandleVitalsChanged(class UVitalsComponent* VitalsComponent, const struct FVitalsChange& Change);
	void ResetInactivityTimer();

	bool CanDespawnActorNow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InactiveDespawnComponent">();
	}
	static class UInactiveDespawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInactiveDespawnComponent>();
	}
};
static_assert(alignof(UInactiveDespawnComponent) == 0x000008, "Wrong alignment on UInactiveDespawnComponent");
static_assert(sizeof(UInactiveDespawnComponent) == 0x0000C0, "Wrong size on UInactiveDespawnComponent");
static_assert(offsetof(UInactiveDespawnComponent, InactivitySeconds) == 0x0000A0, "Member 'UInactiveDespawnComponent::InactivitySeconds' has a wrong offset!");
static_assert(offsetof(UInactiveDespawnComponent, DespawnDelaySeconds) == 0x0000A4, "Member 'UInactiveDespawnComponent::DespawnDelaySeconds' has a wrong offset!");
static_assert(offsetof(UInactiveDespawnComponent, MinCharacterDespawnDistance) == 0x0000A8, "Member 'UInactiveDespawnComponent::MinCharacterDespawnDistance' has a wrong offset!");
static_assert(offsetof(UInactiveDespawnComponent, MaxCharacterLOSDistance) == 0x0000AC, "Member 'UInactiveDespawnComponent::MaxCharacterLOSDistance' has a wrong offset!");
static_assert(offsetof(UInactiveDespawnComponent, InactivityTimerHandle) == 0x0000B0, "Member 'UInactiveDespawnComponent::InactivityTimerHandle' has a wrong offset!");

// Class Palia.VAL_PaliaPassRewardObject_Base
// 0x0008 (0x0030 - 0x0028)
class UVAL_PaliaPassRewardObject_Base : public UObject
{
public:
	int32                                         RewardNumber;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A8[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PaliaPassRewardObject_Base">();
	}
	static class UVAL_PaliaPassRewardObject_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PaliaPassRewardObject_Base>();
	}
};
static_assert(alignof(UVAL_PaliaPassRewardObject_Base) == 0x000008, "Wrong alignment on UVAL_PaliaPassRewardObject_Base");
static_assert(sizeof(UVAL_PaliaPassRewardObject_Base) == 0x000030, "Wrong size on UVAL_PaliaPassRewardObject_Base");
static_assert(offsetof(UVAL_PaliaPassRewardObject_Base, RewardNumber) == 0x000028, "Member 'UVAL_PaliaPassRewardObject_Base::RewardNumber' has a wrong offset!");

// Class Palia.VAL_PaliaPassRewardObject_Item
// 0x0060 (0x0090 - 0x0030)
class UVAL_PaliaPassRewardObject_Item final : public UVAL_PaliaPassRewardObject_Base
{
public:
	struct FValeriaItem                           Item;                                              // 0x0030(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PaliaPassRewardObject_Item">();
	}
	static class UVAL_PaliaPassRewardObject_Item* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PaliaPassRewardObject_Item>();
	}
};
static_assert(alignof(UVAL_PaliaPassRewardObject_Item) == 0x000008, "Wrong alignment on UVAL_PaliaPassRewardObject_Item");
static_assert(sizeof(UVAL_PaliaPassRewardObject_Item) == 0x000090, "Wrong size on UVAL_PaliaPassRewardObject_Item");
static_assert(offsetof(UVAL_PaliaPassRewardObject_Item, Item) == 0x000030, "Member 'UVAL_PaliaPassRewardObject_Item::Item' has a wrong offset!");

// Class Palia.SubgameCutawayManagerComponent
// 0x0008 (0x0110 - 0x0108)
class USubgameCutawayManagerComponent : public USubgameManagerComponent
{
public:
	class ASubgameCutawayScene*                   ManagedSubgameCutawayScene;                        // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ASubgameCutawayScene* GetManagedSubgameCutawayScene() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubgameCutawayManagerComponent">();
	}
	static class USubgameCutawayManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubgameCutawayManagerComponent>();
	}
};
static_assert(alignof(USubgameCutawayManagerComponent) == 0x000008, "Wrong alignment on USubgameCutawayManagerComponent");
static_assert(sizeof(USubgameCutawayManagerComponent) == 0x000110, "Wrong size on USubgameCutawayManagerComponent");
static_assert(offsetof(USubgameCutawayManagerComponent, ManagedSubgameCutawayScene) == 0x000108, "Member 'USubgameCutawayManagerComponent::ManagedSubgameCutawayScene' has a wrong offset!");

// Class Palia.SlidingPuzzleSubgameManagerComponent
// 0x0018 (0x0128 - 0x0110)
class USlidingPuzzleSubgameManagerComponent final : public USubgameCutawayManagerComponent
{
public:
	TSubclassOf<class ASlidingPuzzleBoard>        SlidingPuzzleBoardClass;                           // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlidingPuzzleConfig*                   SlidingPuzzleConfig;                               // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASlidingPuzzleBoard*                    ManagedSlidingPuzzleBoard;                         // 0x0120(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CreateSlidingPuzzleBoard();
	void SlidingPuzzleBoardCompleted(class ASlidingPuzzleBoard* CompletedSlidingPuzzleBoard);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlidingPuzzleSubgameManagerComponent">();
	}
	static class USlidingPuzzleSubgameManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlidingPuzzleSubgameManagerComponent>();
	}
};
static_assert(alignof(USlidingPuzzleSubgameManagerComponent) == 0x000008, "Wrong alignment on USlidingPuzzleSubgameManagerComponent");
static_assert(sizeof(USlidingPuzzleSubgameManagerComponent) == 0x000128, "Wrong size on USlidingPuzzleSubgameManagerComponent");
static_assert(offsetof(USlidingPuzzleSubgameManagerComponent, SlidingPuzzleBoardClass) == 0x000110, "Member 'USlidingPuzzleSubgameManagerComponent::SlidingPuzzleBoardClass' has a wrong offset!");
static_assert(offsetof(USlidingPuzzleSubgameManagerComponent, SlidingPuzzleConfig) == 0x000118, "Member 'USlidingPuzzleSubgameManagerComponent::SlidingPuzzleConfig' has a wrong offset!");
static_assert(offsetof(USlidingPuzzleSubgameManagerComponent, ManagedSlidingPuzzleBoard) == 0x000120, "Member 'USlidingPuzzleSubgameManagerComponent::ManagedSlidingPuzzleBoard' has a wrong offset!");

// Class Palia.VAL_InputGlobalConfig
// 0x00A0 (0x00D0 - 0x0030)
class UVAL_InputGlobalConfig final : public UDataAsset
{
public:
	TMap<EInteractEventIndex, struct FInputMappingPriorityData> InputMappingPriorityDataForEventIndex;             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UInputAction>> ItemTagToInputActionMappings;                      // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_InputGlobalConfig">();
	}
	static class UVAL_InputGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_InputGlobalConfig>();
	}
};
static_assert(alignof(UVAL_InputGlobalConfig) == 0x000008, "Wrong alignment on UVAL_InputGlobalConfig");
static_assert(sizeof(UVAL_InputGlobalConfig) == 0x0000D0, "Wrong size on UVAL_InputGlobalConfig");
static_assert(offsetof(UVAL_InputGlobalConfig, InputMappingPriorityDataForEventIndex) == 0x000030, "Member 'UVAL_InputGlobalConfig::InputMappingPriorityDataForEventIndex' has a wrong offset!");
static_assert(offsetof(UVAL_InputGlobalConfig, ItemTagToInputActionMappings) == 0x000080, "Member 'UVAL_InputGlobalConfig::ItemTagToInputActionMappings' has a wrong offset!");

// Class Palia.InstrumentSongConfig
// 0x0070 (0x00A0 - 0x0030)
class UInstrumentSongConfig final : public UDataAsset
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_InstrumentSongConfig;                         // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         InstrumentTierRequirement;                         // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A9[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RequiresText;                                      // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<int32>                                 Pitches;                                           // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectToApply;                             // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InstrumentSongConfig">();
	}
	static class UInstrumentSongConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInstrumentSongConfig>();
	}
};
static_assert(alignof(UInstrumentSongConfig) == 0x000008, "Wrong alignment on UInstrumentSongConfig");
static_assert(sizeof(UInstrumentSongConfig) == 0x0000A0, "Wrong size on UInstrumentSongConfig");
static_assert(offsetof(UInstrumentSongConfig, Tag) == 0x000030, "Member 'UInstrumentSongConfig::Tag' has a wrong offset!");
static_assert(offsetof(UInstrumentSongConfig, Name_InstrumentSongConfig) == 0x000038, "Member 'UInstrumentSongConfig::Name_InstrumentSongConfig' has a wrong offset!");
static_assert(offsetof(UInstrumentSongConfig, Description) == 0x000050, "Member 'UInstrumentSongConfig::Description' has a wrong offset!");
static_assert(offsetof(UInstrumentSongConfig, InstrumentTierRequirement) == 0x000068, "Member 'UInstrumentSongConfig::InstrumentTierRequirement' has a wrong offset!");
static_assert(offsetof(UInstrumentSongConfig, RequiresText) == 0x000070, "Member 'UInstrumentSongConfig::RequiresText' has a wrong offset!");
static_assert(offsetof(UInstrumentSongConfig, Pitches) == 0x000088, "Member 'UInstrumentSongConfig::Pitches' has a wrong offset!");
static_assert(offsetof(UInstrumentSongConfig, GameplayEffectToApply) == 0x000098, "Member 'UInstrumentSongConfig::GameplayEffectToApply' has a wrong offset!");

// Class Palia.SlidingPuzzleConfig
// 0x0028 (0x00C0 - 0x0098)
class USlidingPuzzleConfig final : public USubgameConfig
{
public:
	class UMaterialInstance*                      PuzzlePieceMaterial;                               // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRowsAndColumns;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlidingPuzzleOpenPieceSlot                   OpenPieceSlot;                                     // 0x00A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlidingPuzzleOpenPieceSlot                   SavedOpenPieceSlot;                                // 0x00A5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AA[0x2];                                     // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NewPieceLocations;                                 // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         AutoGenerateNumMovesRequired;                      // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AB[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESlidingPuzzleCardinalDirections GetOppositeCardinalDirection(ESlidingPuzzleCardinalDirections InDirection);

	struct FIntPoint GetFinalOpenSpacePoint() const;
	int32 GetIntegerFromIntPoint(struct FIntPoint& InIntPoint) const;
	struct FIntPoint GetIntPointFromInteger(int32 InInteger) const;
	TMap<struct FIntPoint, int32> GetPieceLocationsWithIntPointKey() const;
	bool IsPuzzleFormattedCorrectly(class FString* FormattingError) const;
	bool IsPuzzleSolvable(class FString* SolveError) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlidingPuzzleConfig">();
	}
	static class USlidingPuzzleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlidingPuzzleConfig>();
	}
};
static_assert(alignof(USlidingPuzzleConfig) == 0x000008, "Wrong alignment on USlidingPuzzleConfig");
static_assert(sizeof(USlidingPuzzleConfig) == 0x0000C0, "Wrong size on USlidingPuzzleConfig");
static_assert(offsetof(USlidingPuzzleConfig, PuzzlePieceMaterial) == 0x000098, "Member 'USlidingPuzzleConfig::PuzzlePieceMaterial' has a wrong offset!");
static_assert(offsetof(USlidingPuzzleConfig, NumRowsAndColumns) == 0x0000A0, "Member 'USlidingPuzzleConfig::NumRowsAndColumns' has a wrong offset!");
static_assert(offsetof(USlidingPuzzleConfig, OpenPieceSlot) == 0x0000A4, "Member 'USlidingPuzzleConfig::OpenPieceSlot' has a wrong offset!");
static_assert(offsetof(USlidingPuzzleConfig, SavedOpenPieceSlot) == 0x0000A5, "Member 'USlidingPuzzleConfig::SavedOpenPieceSlot' has a wrong offset!");
static_assert(offsetof(USlidingPuzzleConfig, NewPieceLocations) == 0x0000A8, "Member 'USlidingPuzzleConfig::NewPieceLocations' has a wrong offset!");
static_assert(offsetof(USlidingPuzzleConfig, AutoGenerateNumMovesRequired) == 0x0000B8, "Member 'USlidingPuzzleConfig::AutoGenerateNumMovesRequired' has a wrong offset!");

// Class Palia.InstrumentGlobalConfig
// 0x00A0 (0x00D0 - 0x0030)
class UInstrumentGlobalConfig final : public UDataAsset
{
public:
	TMap<int32, struct FInstrumentPitch>          Pitches;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EInstrumentType, struct FInstrumentNotes> InstrumentTypeNotes;                               // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InstrumentGlobalConfig">();
	}
	static class UInstrumentGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInstrumentGlobalConfig>();
	}
};
static_assert(alignof(UInstrumentGlobalConfig) == 0x000008, "Wrong alignment on UInstrumentGlobalConfig");
static_assert(sizeof(UInstrumentGlobalConfig) == 0x0000D0, "Wrong size on UInstrumentGlobalConfig");
static_assert(offsetof(UInstrumentGlobalConfig, Pitches) == 0x000030, "Member 'UInstrumentGlobalConfig::Pitches' has a wrong offset!");
static_assert(offsetof(UInstrumentGlobalConfig, InstrumentTypeNotes) == 0x000080, "Member 'UInstrumentGlobalConfig::InstrumentTypeNotes' has a wrong offset!");

// Class Palia.Interactable
// 0x0000 (0x0028 - 0x0028)
class IInteractable final : public IInterface
{
public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Player, const struct FInteractEventParams& Params_0);
	struct FUseEventResult OnClientUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void OnServerUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FServerUseEventParams& Params_0);

	bool GetEventIndexForInputAction(class AValeriaCharacter* Character, TSoftObjectPtr<class UInputAction>& InputAction, EInteractEventIndex* OutEventIndex) const;
	TSoftObjectPtr<class UInputAction> GetInputActionForEventIndex(class AValeriaCharacter* Character, EInteractEventIndex EventIndex) const;
	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	bool GetUseableIMC(class AValeriaCharacter* Character, EInteractEventIndex InteractIndex, struct FInputMappingPriorityData* OutMappingData, struct FModifyContextOptions* OutOptions) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable">();
	}
	static class IInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractable>();
	}
};
static_assert(alignof(IInteractable) == 0x000008, "Wrong alignment on IInteractable");
static_assert(sizeof(IInteractable) == 0x000028, "Wrong size on IInteractable");

// Class Palia.ShaderBasedAnimationComponent
// 0x0050 (0x00F0 - 0x00A0)
class UShaderBasedAnimationComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAnimEventWasTriggered;                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FShaderBasedAnimationPlayback          CurrentlyPlayingNormalLayer;                       // 0x00B0(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FShaderBasedAnimationPlayback          CurrentlyPlayingOneOffLayer;                       // 0x00C8(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FMaterialInstanceDynamicToAnimate> MaterialInstancesToAnimate;                        // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	class UMaterialInstanceDynamic* AddMaterialToAnimate(class UPrimitiveComponent* PrimitiveComponent, int32 MaterialIndex, class FName ParameterToAnimate);
	void PlayAnimation(class UShaderBasedAnimation* Animation, float PlaybackSpeed, bool bRestartIfAlreadyPlaying, EShaderBasedAnimPlaybackLayer AnimationLayer, EShaderBasedAnimPlaybackCycle AnimationCycle);
	void RemoveMaterialToAnimate(class UMaterialInstanceDynamic* MaterialInstance);
	void SetAnimationNormalizedTime(EShaderBasedAnimPlaybackLayer AnimationLayer, float NormalizedTime, bool bTriggerAnimEvents, bool bPausePlayback);
	void StopAnimationLayer(EShaderBasedAnimPlaybackLayer AnimationLayer);

	const class UShaderBasedAnimation* GetCurrentAnimation() const;
	float GetCurrentAnimationLength() const;
	float GetCurrentAnimationNormalizedTime() const;
	float GetCurrentAnimationTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShaderBasedAnimationComponent">();
	}
	static class UShaderBasedAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShaderBasedAnimationComponent>();
	}
};
static_assert(alignof(UShaderBasedAnimationComponent) == 0x000008, "Wrong alignment on UShaderBasedAnimationComponent");
static_assert(sizeof(UShaderBasedAnimationComponent) == 0x0000F0, "Wrong size on UShaderBasedAnimationComponent");
static_assert(offsetof(UShaderBasedAnimationComponent, OnAnimEventWasTriggered) == 0x0000A0, "Member 'UShaderBasedAnimationComponent::OnAnimEventWasTriggered' has a wrong offset!");
static_assert(offsetof(UShaderBasedAnimationComponent, CurrentlyPlayingNormalLayer) == 0x0000B0, "Member 'UShaderBasedAnimationComponent::CurrentlyPlayingNormalLayer' has a wrong offset!");
static_assert(offsetof(UShaderBasedAnimationComponent, CurrentlyPlayingOneOffLayer) == 0x0000C8, "Member 'UShaderBasedAnimationComponent::CurrentlyPlayingOneOffLayer' has a wrong offset!");
static_assert(offsetof(UShaderBasedAnimationComponent, MaterialInstancesToAnimate) == 0x0000E0, "Member 'UShaderBasedAnimationComponent::MaterialInstancesToAnimate' has a wrong offset!");

// Class Palia.DecorStateChange
// 0x0000 (0x0028 - 0x0028)
class IDecorStateChange final : public IInterface
{
public:
	void OnDecorStateChange(int32 State);
	void OnDecorStateChangeRejected();

	bool CanChangeStateAtPermissionLevel(EHousingPermissionLevel PermissionLevel) const;
	bool ShouldPersistDecorState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecorStateChange">();
	}
	static class IDecorStateChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDecorStateChange>();
	}
};
static_assert(alignof(IDecorStateChange) == 0x000008, "Wrong alignment on IDecorStateChange");
static_assert(sizeof(IDecorStateChange) == 0x000028, "Wrong size on IDecorStateChange");

// Class Palia.InteractablePlate
// 0x0000 (0x0028 - 0x0028)
class IInteractablePlate final : public IInterface
{
public:
	void Update(class UInteractableComponent* Interactable, struct FInteractablePlatePayload& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractablePlate">();
	}
	static class IInteractablePlate* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractablePlate>();
	}
};
static_assert(alignof(IInteractablePlate) == 0x000008, "Wrong alignment on IInteractablePlate");
static_assert(sizeof(IInteractablePlate) == 0x000028, "Wrong size on IInteractablePlate");

// Class Palia.SubgameCutawayScene
// 0x0010 (0x02B8 - 0x02A8)
class ASubgameCutawayScene : public AActor
{
public:
	class USceneComponent*                        SubgameCutawaySceneRootComponent;                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       SubgameCutawaySceneCameraComponent;                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeSubgameCutawayScene(class USubgameConfig* InSubgameConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubgameCutawayScene">();
	}
	static class ASubgameCutawayScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASubgameCutawayScene>();
	}
};
static_assert(alignof(ASubgameCutawayScene) == 0x000008, "Wrong alignment on ASubgameCutawayScene");
static_assert(sizeof(ASubgameCutawayScene) == 0x0002B8, "Wrong size on ASubgameCutawayScene");
static_assert(offsetof(ASubgameCutawayScene, SubgameCutawaySceneRootComponent) == 0x0002A8, "Member 'ASubgameCutawayScene::SubgameCutawaySceneRootComponent' has a wrong offset!");
static_assert(offsetof(ASubgameCutawayScene, SubgameCutawaySceneCameraComponent) == 0x0002B0, "Member 'ASubgameCutawayScene::SubgameCutawaySceneCameraComponent' has a wrong offset!");

// Class Palia.SlidingPuzzleSubgameCutawayScene
// 0x0008 (0x02C0 - 0x02B8)
class ASlidingPuzzleSubgameCutawayScene final : public ASubgameCutawayScene
{
public:
	class USceneComponent*                        SlidingPuzzleSpawnRootComponent;                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class USceneComponent* GetSlidingPuzzleSpawnRootComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlidingPuzzleSubgameCutawayScene">();
	}
	static class ASlidingPuzzleSubgameCutawayScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlidingPuzzleSubgameCutawayScene>();
	}
};
static_assert(alignof(ASlidingPuzzleSubgameCutawayScene) == 0x000008, "Wrong alignment on ASlidingPuzzleSubgameCutawayScene");
static_assert(sizeof(ASlidingPuzzleSubgameCutawayScene) == 0x0002C0, "Wrong size on ASlidingPuzzleSubgameCutawayScene");
static_assert(offsetof(ASlidingPuzzleSubgameCutawayScene, SlidingPuzzleSpawnRootComponent) == 0x0002B8, "Member 'ASlidingPuzzleSubgameCutawayScene::SlidingPuzzleSpawnRootComponent' has a wrong offset!");

// Class Palia.InteractableComponent
// 0x0208 (0x02A8 - 0x00A0)
class UInteractableComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             IInteractableStateChanged;                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHighlightToggled;                                // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractableChanged;                             // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHideDueToRequirementsNotMet;                     // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowDueToRequirementsMet;                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientInteract;                                  // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractorLockChanged;                           // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerInteract;                                  // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPropReleasedFromCharacter;                       // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVAL_GameplayConditionDef*              InteractCondition;                                 // 0x0130(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    QuestActiveRequirement;                            // 0x0138(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         QuestOnStep;                                       // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28BC[0x4];                                     // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestActivityPrereq>           QuestActivityRequirements;                         // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTimeOfDayFilter                       TimeOfDayRequirement;                              // 0x0160(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVAL_ContentBatchAsset>  ContentBatch;                                      // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendTelemetryEventOnServerInteract;               // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28BD[0x7];                                     // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULimitedEventDataAsset*                 TelemLimitedEvent;                                 // 0x01A8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TelemInteractableName;                             // 0x01B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelemMaxFrequencySec;                              // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionProfile;                                  // 0x01C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PlayerCollisionProfile;                            // 0x01CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SkipAngleChecks;                                   // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AngleInteractLimit;                                // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FacingInteractLimit;                               // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPersistentTagFilter>           PlayerTagRequirements;                             // 0x01E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	ECharacterState                               RequiredCharacterState;                            // 0x01F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HideIfRequirementsNotMet;                          // 0x01F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HideRequirementsFullCheck;                         // 0x01F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28BE[0x1];                                     // 0x01F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideRequirementsCheckInterval;                     // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           CheckRequirementsForHideHandle;                    // 0x01F8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28BF[0x1];                                     // 0x0200(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisableOutlineOnHighlight;                         // 0x0201(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InteractPlateUseSphereLocation;                    // 0x0202(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOnlyUseIInteractableInputActions;                 // 0x0203(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinInteractionDistance;                            // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxInteractionDistance;                            // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreMaxInteractionDistWhenInPickupMode;         // 0x020C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C0[0x3];                                     // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USphereComponent*>               InteractableLocations;                             // 0x0210(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FVAL_InteractableInteractorLock> LocationLocks;                                     // 0x0220(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AValeriaCharacter*>              EngagedCharacters;                                 // 0x0230(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FVAL_ClientInteractableProp>    InteractableProps;                                 // 0x0240(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         InteractionBlockerCount;                           // 0x0250(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C1[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       PlateUi;                                           // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProximityChecker*                      ProximityChecker;                                  // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DefaultPlatePosition;                              // 0x0268(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AValeriaCharacter*                      CachedLocalPlayer;                                 // 0x0280(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         OutlinedHighlightedActors;                         // 0x0288(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bBlockInteractionInPlacementMode;                  // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C2[0xF];                                     // 0x0299(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInteractionBlocker();
	void HandleCharacterAnimNotifyMontageEvent(class UAbilityAnimationComponent* AbilityAnimationComponent, class FName& NotifyName, struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void HandleCharacterAnimNotifyStateBegin(class UAbilityAnimationComponent* AbilityAnimationComponent, class FName& NotifyName, struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void HandleCharacterAnimNotifyStateEnd(class UAbilityAnimationComponent* AbilityAnimationComponent, class FName& NotifyName, struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void HandleDestroyedInteractableProp(class AActor* DestroyedProp);
	void HandleLockChanged(struct FVAL_InteractorLockParams& LockParams, class UInteractorComponent* Interactor, bool bLockEngaged);
	void HandlePlacementFinalizedHighlights(class UPlacementComponent* Placement, const TArray<class AActor*>& AllActors, bool bWasCancelled);
	void HandlePlacementInteractChange(class AValeriaCharacter* Character, bool InteractChange);
	void HandlePlacementMultiSelectChange(class UPlacementComponent* Placement);
	void HandlePlacementRequestedMoreHighlights(class UPlacementComponent* Placement, const TArray<class AActor*>& NewActors);
	void HandleProximityChanged(class UProximityChecker* Tracker, class AActor* Tracked, bool IsWithin);
	void OnRep_EngagedCharacters(TArray<class AValeriaCharacter*>& OldEngagedCharacters);
	void OnRep_LocationLocks(TArray<struct FVAL_InteractableInteractorLock>& OldEngagedLocations);
	void OutlineHighlight(class AValeriaPlayerController* Player, bool Enable);
	void RemoveInteractionBlocker();
	void SetPreventHideByRequirementsCheck(bool bShouldPrevent);

	class UObject* GetInteractable(EInteractEventIndex Param_Index, class AValeriaCharacter* VC, class USphereComponent* Sphere) const;
	bool HasInteractingPawns() const;
	bool InteractableRequirementsMet(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character) const;
	const class USphereComponent* K2_FindClosestInteractableLocation(class AValeriaCharacter* VC) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableComponent">();
	}
	static class UInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableComponent>();
	}
};
static_assert(alignof(UInteractableComponent) == 0x000008, "Wrong alignment on UInteractableComponent");
static_assert(sizeof(UInteractableComponent) == 0x0002A8, "Wrong size on UInteractableComponent");
static_assert(offsetof(UInteractableComponent, IInteractableStateChanged) == 0x0000A0, "Member 'UInteractableComponent::IInteractableStateChanged' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnHighlightToggled) == 0x0000B0, "Member 'UInteractableComponent::OnHighlightToggled' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnInteractableChanged) == 0x0000C0, "Member 'UInteractableComponent::OnInteractableChanged' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnHideDueToRequirementsNotMet) == 0x0000D0, "Member 'UInteractableComponent::OnHideDueToRequirementsNotMet' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnShowDueToRequirementsMet) == 0x0000E0, "Member 'UInteractableComponent::OnShowDueToRequirementsMet' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnClientInteract) == 0x0000F0, "Member 'UInteractableComponent::OnClientInteract' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnInteractorLockChanged) == 0x000100, "Member 'UInteractableComponent::OnInteractorLockChanged' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnServerInteract) == 0x000110, "Member 'UInteractableComponent::OnServerInteract' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OnPropReleasedFromCharacter) == 0x000120, "Member 'UInteractableComponent::OnPropReleasedFromCharacter' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractCondition) == 0x000130, "Member 'UInteractableComponent::InteractCondition' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, QuestActiveRequirement) == 0x000138, "Member 'UInteractableComponent::QuestActiveRequirement' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, QuestOnStep) == 0x000148, "Member 'UInteractableComponent::QuestOnStep' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, QuestActivityRequirements) == 0x000150, "Member 'UInteractableComponent::QuestActivityRequirements' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, TimeOfDayRequirement) == 0x000160, "Member 'UInteractableComponent::TimeOfDayRequirement' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ContentBatch) == 0x000178, "Member 'UInteractableComponent::ContentBatch' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bSendTelemetryEventOnServerInteract) == 0x0001A0, "Member 'UInteractableComponent::bSendTelemetryEventOnServerInteract' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, TelemLimitedEvent) == 0x0001A8, "Member 'UInteractableComponent::TelemLimitedEvent' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, TelemInteractableName) == 0x0001B0, "Member 'UInteractableComponent::TelemInteractableName' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, TelemMaxFrequencySec) == 0x0001C0, "Member 'UInteractableComponent::TelemMaxFrequencySec' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, CollisionProfile) == 0x0001C4, "Member 'UInteractableComponent::CollisionProfile' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, PlayerCollisionProfile) == 0x0001CC, "Member 'UInteractableComponent::PlayerCollisionProfile' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, SkipAngleChecks) == 0x0001D4, "Member 'UInteractableComponent::SkipAngleChecks' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, AngleInteractLimit) == 0x0001D8, "Member 'UInteractableComponent::AngleInteractLimit' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, FacingInteractLimit) == 0x0001DC, "Member 'UInteractableComponent::FacingInteractLimit' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, PlayerTagRequirements) == 0x0001E0, "Member 'UInteractableComponent::PlayerTagRequirements' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, RequiredCharacterState) == 0x0001F0, "Member 'UInteractableComponent::RequiredCharacterState' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, HideIfRequirementsNotMet) == 0x0001F1, "Member 'UInteractableComponent::HideIfRequirementsNotMet' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, HideRequirementsFullCheck) == 0x0001F2, "Member 'UInteractableComponent::HideRequirementsFullCheck' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, HideRequirementsCheckInterval) == 0x0001F4, "Member 'UInteractableComponent::HideRequirementsCheckInterval' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, CheckRequirementsForHideHandle) == 0x0001F8, "Member 'UInteractableComponent::CheckRequirementsForHideHandle' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, DisableOutlineOnHighlight) == 0x000201, "Member 'UInteractableComponent::DisableOutlineOnHighlight' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractPlateUseSphereLocation) == 0x000202, "Member 'UInteractableComponent::InteractPlateUseSphereLocation' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bOnlyUseIInteractableInputActions) == 0x000203, "Member 'UInteractableComponent::bOnlyUseIInteractableInputActions' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, MinInteractionDistance) == 0x000204, "Member 'UInteractableComponent::MinInteractionDistance' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, MaxInteractionDistance) == 0x000208, "Member 'UInteractableComponent::MaxInteractionDistance' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bIgnoreMaxInteractionDistWhenInPickupMode) == 0x00020C, "Member 'UInteractableComponent::bIgnoreMaxInteractionDistWhenInPickupMode' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractableLocations) == 0x000210, "Member 'UInteractableComponent::InteractableLocations' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, LocationLocks) == 0x000220, "Member 'UInteractableComponent::LocationLocks' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, EngagedCharacters) == 0x000230, "Member 'UInteractableComponent::EngagedCharacters' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractableProps) == 0x000240, "Member 'UInteractableComponent::InteractableProps' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractionBlockerCount) == 0x000250, "Member 'UInteractableComponent::InteractionBlockerCount' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, PlateUi) == 0x000258, "Member 'UInteractableComponent::PlateUi' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ProximityChecker) == 0x000260, "Member 'UInteractableComponent::ProximityChecker' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, DefaultPlatePosition) == 0x000268, "Member 'UInteractableComponent::DefaultPlatePosition' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, CachedLocalPlayer) == 0x000280, "Member 'UInteractableComponent::CachedLocalPlayer' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, OutlinedHighlightedActors) == 0x000288, "Member 'UInteractableComponent::OutlinedHighlightedActors' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bBlockInteractionInPlacementMode) == 0x000298, "Member 'UInteractableComponent::bBlockInteractionInPlacementMode' has a wrong offset!");

// Class Palia.InteractableLocalPlayerDebugSubsystem
// 0x0008 (0x0038 - 0x0030)
class UInteractableLocalPlayerDebugSubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_28CB[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableLocalPlayerDebugSubsystem">();
	}
	static class UInteractableLocalPlayerDebugSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableLocalPlayerDebugSubsystem>();
	}
};
static_assert(alignof(UInteractableLocalPlayerDebugSubsystem) == 0x000008, "Wrong alignment on UInteractableLocalPlayerDebugSubsystem");
static_assert(sizeof(UInteractableLocalPlayerDebugSubsystem) == 0x000038, "Wrong size on UInteractableLocalPlayerDebugSubsystem");

// Class Palia.VAL_PlayerDataCorrectionSettings
// 0x0030 (0x0068 - 0x0038)
class UVAL_PlayerDataCorrectionSettings final : public UDeveloperSettings
{
public:
	bool                                          bRunActiveCorrectionsImmediatelyAfterLoadingCharacter; // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CC[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UVAL_CorrectionDef>> ActiveCorrections;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bEnablePermanentUnlockCorrection;                  // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CD[0x3];                                     // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PermanentUnlockCorrectionCooldownDurationSeconds;  // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   TagsNotPermanentlyUnlocked;                        // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerDataCorrectionSettings">();
	}
	static class UVAL_PlayerDataCorrectionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerDataCorrectionSettings>();
	}
};
static_assert(alignof(UVAL_PlayerDataCorrectionSettings) == 0x000008, "Wrong alignment on UVAL_PlayerDataCorrectionSettings");
static_assert(sizeof(UVAL_PlayerDataCorrectionSettings) == 0x000068, "Wrong size on UVAL_PlayerDataCorrectionSettings");
static_assert(offsetof(UVAL_PlayerDataCorrectionSettings, bRunActiveCorrectionsImmediatelyAfterLoadingCharacter) == 0x000038, "Member 'UVAL_PlayerDataCorrectionSettings::bRunActiveCorrectionsImmediatelyAfterLoadingCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerDataCorrectionSettings, ActiveCorrections) == 0x000040, "Member 'UVAL_PlayerDataCorrectionSettings::ActiveCorrections' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerDataCorrectionSettings, bEnablePermanentUnlockCorrection) == 0x000050, "Member 'UVAL_PlayerDataCorrectionSettings::bEnablePermanentUnlockCorrection' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerDataCorrectionSettings, PermanentUnlockCorrectionCooldownDurationSeconds) == 0x000054, "Member 'UVAL_PlayerDataCorrectionSettings::PermanentUnlockCorrectionCooldownDurationSeconds' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerDataCorrectionSettings, TagsNotPermanentlyUnlocked) == 0x000058, "Member 'UVAL_PlayerDataCorrectionSettings::TagsNotPermanentlyUnlocked' has a wrong offset!");

// Class Palia.StablesConfigAsset
// 0x0018 (0x0048 - 0x0030)
class UStablesConfigAsset final : public UDataAsset
{
public:
	class UTeleportTravelConfigAsset*             SelfConfig;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTeleportDestinationConfig>     DestinationConfigs;                                // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StablesConfigAsset">();
	}
	static class UStablesConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStablesConfigAsset>();
	}
};
static_assert(alignof(UStablesConfigAsset) == 0x000008, "Wrong alignment on UStablesConfigAsset");
static_assert(sizeof(UStablesConfigAsset) == 0x000048, "Wrong size on UStablesConfigAsset");
static_assert(offsetof(UStablesConfigAsset, SelfConfig) == 0x000030, "Member 'UStablesConfigAsset::SelfConfig' has a wrong offset!");
static_assert(offsetof(UStablesConfigAsset, DestinationConfigs) == 0x000038, "Member 'UStablesConfigAsset::DestinationConfigs' has a wrong offset!");

// Class Palia.InteractorComponent
// 0x0240 (0x02E0 - 0x00A0)
class UInteractorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnLockChanged;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerInteractedWithObject;                      // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CE[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InteractEventThrottleCounter;                      // 0x00C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InteractEventThrottleCountLimit;                   // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractEventThrottleTimeLimit;                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28CF[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EInteractEventIndex, struct FInputMappingPriorityData> DefaultInputMappingPriorityData;                   // 0x00D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UInputMappingContext*>           AppliedInteractionContexts;                        // 0x0128(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UInteractableComponent*                 HighlightedInteractable;                           // 0x0138(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AValeriaCharacter*                      VC;                                                // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AValeriaPlayerController*               Vpc;                                               // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterStateMachineComponent*        Csm;                                               // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVAL_InteractorInteractableLock        InteractorLock;                                    // 0x0158(0x0030)(Net, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UInteractableComponent*                 InteractorLockInteractable;                        // 0x0188(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHitResult                             CurrentInteractionHitResult;                       // 0x0190(0x00E8)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<EInteractEventIndex>                     HoldingInteractDown;                               // 0x0278(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_28D0[0x18];                                    // 0x02C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Client_TryInteractableLockSetup();
	void DisableInteractTemporarily(float DisabledTime);
	void HandleCharacterStateChanged(class UCharacterStateMachineComponent* InCSM, const struct FCharacterStateChangeParams& Params_0);
	void HandleIInteractableStateChanged(class UInteractableComponent* Interactable);
	void HandleInteractableClaimedLocationChanged(struct FVAL_InteractorLockParams& LockParams, class UInteractorComponent* InteractorComponent, bool bLocationClaimed);
	void HandleInteractDisabledTimerExpired();
	void HandleInteractLockTimerExpired();
	void HandlePawnControllerChanged(class APawn* Pawn, class AController* Controller);
	void HandlePlacementInteractChange(class AValeriaCharacter* Character, bool bEnabled);
	void HandleTeleportResult(bool bTeleportResult);
	void HighlightInteractable(class UInteractableComponent* Component);
	struct FUseEventResults InteractWithHighlighted(const struct FInteractEventParams& Params_0);
	bool LockPlayerToInteractable(const struct FVAL_InteractorLockParams& LockParams);
	void OnRep_InteractorLock(const struct FVAL_InteractorInteractableLock& OldInteractorLock);
	void OnRep_InteractorLock_Interactable();
	void ResetInteractEventThrottleCounter();
	void RpcClient_ClearInteractLock();
	void RpcServer_InteractWithHighlighted(TArray<class UObject*>& Objs, class UInteractableComponent* Component, const struct FInteractEventParams& Params_0);
	void RpcServer_NotifySuccessfulClientInteract(class UInteractableComponent* Component);
	void RpcServer_RemovePersistActors(class AHousingOwnershipActor* HomeOwner, TArray<struct FSessionActorId>& Objs);
	void RpcServer_UseEquippedOutward(class UInteractableComponent* Component, TArray<struct FServerUseEventParams>& UseParams);
	void UnhighlightInteractable();
	bool UnlockPlayerFromInteractable(struct FVAL_InteractorLockParams& LockParams);

	bool CanInteract() const;
	bool CanPlayerChangeLockWith(struct FVAL_InteractorLockParams& LockParams, EVAL_InteractorOperation Operation, bool TriggerWarnings) const;
	bool IsPlayerLockedToInteractable() const;
	bool K2_GetLockParams(struct FVAL_InteractorLockParams* OutLockParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractorComponent">();
	}
	static class UInteractorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractorComponent>();
	}
};
static_assert(alignof(UInteractorComponent) == 0x000008, "Wrong alignment on UInteractorComponent");
static_assert(sizeof(UInteractorComponent) == 0x0002E0, "Wrong size on UInteractorComponent");
static_assert(offsetof(UInteractorComponent, OnLockChanged) == 0x0000A0, "Member 'UInteractorComponent::OnLockChanged' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, OnServerInteractedWithObject) == 0x0000B0, "Member 'UInteractorComponent::OnServerInteractedWithObject' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, InteractEventThrottleCounter) == 0x0000C8, "Member 'UInteractorComponent::InteractEventThrottleCounter' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, InteractEventThrottleCountLimit) == 0x0000CC, "Member 'UInteractorComponent::InteractEventThrottleCountLimit' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, InteractEventThrottleTimeLimit) == 0x0000D0, "Member 'UInteractorComponent::InteractEventThrottleTimeLimit' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, DefaultInputMappingPriorityData) == 0x0000D8, "Member 'UInteractorComponent::DefaultInputMappingPriorityData' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, AppliedInteractionContexts) == 0x000128, "Member 'UInteractorComponent::AppliedInteractionContexts' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, HighlightedInteractable) == 0x000138, "Member 'UInteractorComponent::HighlightedInteractable' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, VC) == 0x000140, "Member 'UInteractorComponent::VC' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, Vpc) == 0x000148, "Member 'UInteractorComponent::Vpc' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, Csm) == 0x000150, "Member 'UInteractorComponent::Csm' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, InteractorLock) == 0x000158, "Member 'UInteractorComponent::InteractorLock' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, InteractorLockInteractable) == 0x000188, "Member 'UInteractorComponent::InteractorLockInteractable' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, CurrentInteractionHitResult) == 0x000190, "Member 'UInteractorComponent::CurrentInteractionHitResult' has a wrong offset!");
static_assert(offsetof(UInteractorComponent, HoldingInteractDown) == 0x000278, "Member 'UInteractorComponent::HoldingInteractDown' has a wrong offset!");

// Class Palia.InventoryGlobals
// 0x0000 (0x0028 - 0x0028)
class UInventoryGlobals final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryGlobals">();
	}
	static class UInventoryGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryGlobals>();
	}
};
static_assert(alignof(UInventoryGlobals) == 0x000008, "Wrong alignment on UInventoryGlobals");
static_assert(sizeof(UInventoryGlobals) == 0x000028, "Wrong size on UInventoryGlobals");

// Class Palia.DefaultSpawnRarityConfig
// 0x0050 (0x0080 - 0x0030)
class UDefaultSpawnRarityConfig final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   DefaultCommonSpawn;                                // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultUncommonSpawn;                              // 0x0058(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultSpawnRarityConfig">();
	}
	static class UDefaultSpawnRarityConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultSpawnRarityConfig>();
	}
};
static_assert(alignof(UDefaultSpawnRarityConfig) == 0x000008, "Wrong alignment on UDefaultSpawnRarityConfig");
static_assert(sizeof(UDefaultSpawnRarityConfig) == 0x000080, "Wrong size on UDefaultSpawnRarityConfig");
static_assert(offsetof(UDefaultSpawnRarityConfig, DefaultCommonSpawn) == 0x000030, "Member 'UDefaultSpawnRarityConfig::DefaultCommonSpawn' has a wrong offset!");
static_assert(offsetof(UDefaultSpawnRarityConfig, DefaultUncommonSpawn) == 0x000058, "Member 'UDefaultSpawnRarityConfig::DefaultUncommonSpawn' has a wrong offset!");

// Class Palia.InventoryRequestComponent
// 0x00A0 (0x0140 - 0x00A0)
class UInventoryRequestComponent final : public UActorComponent
{
public:
	TMap<struct FGuid, struct FVAL_PendingFulfillInventoryRequestDelegates> PendingFulfillInventoryRequestDelegatesByOperationId; // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FVAL_PendingClaimInventoryRequestDelegates> PendingClaimInventoryRequestDelegatesByOperationId; // 0x00F0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void RpcClient_ClaimInventoryRequestFailed(struct FGuid& OperationId, class FText& ErrorText);
	void RpcClient_ClaimInventoryRequestSucceeded(struct FGuid& OperationId, struct FInventoryRequest& InventoryRequest);
	void RpcClient_FulfillInventoryRequestFailed(struct FGuid& OperationId, class FText& ErrorText);
	void RpcClient_FulfillInventoryRequestSucceeded(struct FGuid& OperationId, struct FInventoryRequest& InventoryRequest);
	void RpcClient_RequestCreationFailed();
	void RpcClient_RequestCreationSucceeded(struct FInventoryRequest& InventoryRequest);
	void RpcServer_ClaimInventoryRequest(struct FGuid& OperationId, struct FInventoryRequest& InventoryRequest);
	void RpcServer_CreateRequest(struct FCreateInventoryRequest& InventoryRequest);
	void RpcServer_FulfillInventoryRequest(struct FGuid& OperationId, struct FInventoryRequest& InventoryRequest);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryRequestComponent">();
	}
	static class UInventoryRequestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryRequestComponent>();
	}
};
static_assert(alignof(UInventoryRequestComponent) == 0x000008, "Wrong alignment on UInventoryRequestComponent");
static_assert(sizeof(UInventoryRequestComponent) == 0x000140, "Wrong size on UInventoryRequestComponent");
static_assert(offsetof(UInventoryRequestComponent, PendingFulfillInventoryRequestDelegatesByOperationId) == 0x0000A0, "Member 'UInventoryRequestComponent::PendingFulfillInventoryRequestDelegatesByOperationId' has a wrong offset!");
static_assert(offsetof(UInventoryRequestComponent, PendingClaimInventoryRequestDelegatesByOperationId) == 0x0000F0, "Member 'UInventoryRequestComponent::PendingClaimInventoryRequestDelegatesByOperationId' has a wrong offset!");

// Class Palia.InventoryRequestManager
// 0x01B8 (0x01E8 - 0x0030)
class UInventoryRequestManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnCreateRequestSucceeded;                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCreateRequestFailed;                             // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveRequestChanged;                            // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOpenRequestsChanged;                             // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestCompleted;                                // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D7[0x168];                                   // 0x0080(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CancelActiveRequest(struct FInventoryRequest& InventoryRequest, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	bool ClaimActiveRequest(struct FInventoryRequest& InventoryRequest, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	bool FulfillRequest(struct FInventoryRequest& InventoryRequest, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void HandleNewControlMessage(struct FControlMessage& Message);
	void OnActiveRequestChanged__DelegateSignature(class UInventoryRequestManager* InventoryRequestManager);
	void OnCreateRequest_Failed__DelegateSignature(const class FString& ErrorMsg);
	void OnCreateRequest_Succeeded__DelegateSignature(const struct FInventoryRequest& InventoryRequest);
	void OnOpenRequestsChanged__DelegateSignature(class UInventoryRequestManager* InventoryRequestManager);
	void OnRequestCompleted__DelegateSignature(class UInventoryRequestManager* InventoryRequestManager, const struct FInventoryRequest& InventoryRequest);
	void RefreshActiveRequests();
	void RefreshAllOpenRequests();

	bool CanMakeAnotherRequest(int32* OutNumRequestsAvailable) const;
	TArray<struct FInventoryRequest> GetAllOpenRequests() const;
	bool HasActiveRequest(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& Item, bool* bOutIsReadyToClaim, int32 Amount) const;
	bool TryGetActiveRequest(struct FInventoryRequest& InventoryRequest, struct FInventoryRequest* OutActiveRequest) const;
	bool TryGetActiveRequestById(struct FGuid& InventoryRequestId, struct FInventoryRequest* OutActiveRequest) const;
	bool TryGetActiveRequests(TArray<struct FInventoryRequest>* OutActiveRequests) const;
	int32 TryGetNumActiveRequests() const;
	int32 TryGetNumAvailableRequests() const;
	int32 TryGetNumMaxRequests() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryRequestManager">();
	}
	static class UInventoryRequestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryRequestManager>();
	}
};
static_assert(alignof(UInventoryRequestManager) == 0x000008, "Wrong alignment on UInventoryRequestManager");
static_assert(sizeof(UInventoryRequestManager) == 0x0001E8, "Wrong size on UInventoryRequestManager");
static_assert(offsetof(UInventoryRequestManager, OnCreateRequestSucceeded) == 0x000030, "Member 'UInventoryRequestManager::OnCreateRequestSucceeded' has a wrong offset!");
static_assert(offsetof(UInventoryRequestManager, OnCreateRequestFailed) == 0x000040, "Member 'UInventoryRequestManager::OnCreateRequestFailed' has a wrong offset!");
static_assert(offsetof(UInventoryRequestManager, OnActiveRequestChanged) == 0x000050, "Member 'UInventoryRequestManager::OnActiveRequestChanged' has a wrong offset!");
static_assert(offsetof(UInventoryRequestManager, OnOpenRequestsChanged) == 0x000060, "Member 'UInventoryRequestManager::OnOpenRequestsChanged' has a wrong offset!");
static_assert(offsetof(UInventoryRequestManager, OnRequestCompleted) == 0x000070, "Member 'UInventoryRequestManager::OnRequestCompleted' has a wrong offset!");

// Class Palia.VAL_NewsInboxComponent
// 0x0088 (0x0128 - 0x00A0)
class UVAL_NewsInboxComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnRefreshRewards;                                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRedemptionSuccess;                               // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRedemptionFailure;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FTimespan                              HideClaimedRewardsThreshold;                       // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVAL_NewsInboxData                     NewsInboxData;                                     // 0x00D8(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E1[0x30];                                    // 0x00F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_NewsInboxData();
	void RefreshRewards();
	void RpcClient_OnRedemptionFailure();
	void RpcClient_OnRedemptionSuccess();
	void RpcServer_RefreshRewards();
	void RpcServer_TryClaimMessages(TArray<struct FVAL_NewsMessage>& Messages);
	void TryClaimMessages(TArray<struct FVAL_NewsMessage>& Messages);

	int32 GetClaimedRewardCount() const;
	TSoftObjectPtr<class UTexture2D> GetEntitlementTexture(struct FVAL_RewardItem& Reward, EVAL_CharacterBodyType BodyType) const;
	bool GetMessageByIndex(int32 Param_Index, struct FVAL_NewsMessage* OutMessage, bool Claimed) const;
	int32 GetPendingRewardCount() const;
	const class AValeriaCharacter* GetValeriaCharacter() const;
	const class AValeriaPlayerController* GetValeriaPlayer() const;
	void TrackMessageGrantedTelemetry(struct FVAL_NewsMessage& Message) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_NewsInboxComponent">();
	}
	static class UVAL_NewsInboxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_NewsInboxComponent>();
	}
};
static_assert(alignof(UVAL_NewsInboxComponent) == 0x000008, "Wrong alignment on UVAL_NewsInboxComponent");
static_assert(sizeof(UVAL_NewsInboxComponent) == 0x000128, "Wrong size on UVAL_NewsInboxComponent");
static_assert(offsetof(UVAL_NewsInboxComponent, OnRefreshRewards) == 0x0000A0, "Member 'UVAL_NewsInboxComponent::OnRefreshRewards' has a wrong offset!");
static_assert(offsetof(UVAL_NewsInboxComponent, OnRedemptionSuccess) == 0x0000B0, "Member 'UVAL_NewsInboxComponent::OnRedemptionSuccess' has a wrong offset!");
static_assert(offsetof(UVAL_NewsInboxComponent, OnRedemptionFailure) == 0x0000C0, "Member 'UVAL_NewsInboxComponent::OnRedemptionFailure' has a wrong offset!");
static_assert(offsetof(UVAL_NewsInboxComponent, HideClaimedRewardsThreshold) == 0x0000D0, "Member 'UVAL_NewsInboxComponent::HideClaimedRewardsThreshold' has a wrong offset!");
static_assert(offsetof(UVAL_NewsInboxComponent, NewsInboxData) == 0x0000D8, "Member 'UVAL_NewsInboxComponent::NewsInboxData' has a wrong offset!");

// Class Palia.SlidingPuzzlePiece
// 0x0020 (0x02C8 - 0x02A8)
class ASlidingPuzzlePiece final : public AActor
{
public:
	class USceneComponent*                        SlidingPuzzlePieceRootComponent;                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASlidingPuzzleBoard*                    OwningSlidingPuzzleBoard;                          // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PieceNumber;                                       // 0x02B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              PieceLocation;                                     // 0x02BC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlidingPuzzleCardinalDirections              MovableDirection;                                  // 0x02C4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHovered;                                          // 0x02C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowingInvalidPress;                              // 0x02C6(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28E5[0x1];                                     // 0x02C7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignPieceInformation(class ASlidingPuzzleBoard* InSlidingPuzzleBoard, int32 InPieceNumber, struct FIntPoint& InPieceLocation);
	void BPIE_Client_ShowInvalidPress();
	void BPIE_HoverPiece();
	void BPIE_SlidingPuzzleBoardCompleted(class ASlidingPuzzleBoard* CompletedSlidingPuzzleBoard);
	void BPIE_SlidingPuzzleBoardMoveCompleted();
	void BPIE_SlidingPuzzleBoardMoveStarted();
	void BPIE_UnhoverPiece();
	void BPNE_MovableDirectionChanged();
	void BPNE_OwningSlidingPuzzleBoardChanged();
	void BPNE_PieceNumberChanged();
	void HoverPiece();
	void OnRep_MovableDirection();
	void OnRep_OwningSlidingPuzzleBoard();
	void OnRep_PieceNumber();
	void UnhoverPiece();
	void UpdatePieceLocation(struct FIntPoint& InPieceLocation);

	bool CanBeHovered() const;
	bool CanBeMoved() const;
	ESlidingPuzzleCardinalDirections GetMovableDirection() const;
	int32 GetPieceNumber() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlidingPuzzlePiece">();
	}
	static class ASlidingPuzzlePiece* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlidingPuzzlePiece>();
	}
};
static_assert(alignof(ASlidingPuzzlePiece) == 0x000008, "Wrong alignment on ASlidingPuzzlePiece");
static_assert(sizeof(ASlidingPuzzlePiece) == 0x0002C8, "Wrong size on ASlidingPuzzlePiece");
static_assert(offsetof(ASlidingPuzzlePiece, SlidingPuzzlePieceRootComponent) == 0x0002A8, "Member 'ASlidingPuzzlePiece::SlidingPuzzlePieceRootComponent' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzlePiece, OwningSlidingPuzzleBoard) == 0x0002B0, "Member 'ASlidingPuzzlePiece::OwningSlidingPuzzleBoard' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzlePiece, PieceNumber) == 0x0002B8, "Member 'ASlidingPuzzlePiece::PieceNumber' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzlePiece, PieceLocation) == 0x0002BC, "Member 'ASlidingPuzzlePiece::PieceLocation' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzlePiece, MovableDirection) == 0x0002C4, "Member 'ASlidingPuzzlePiece::MovableDirection' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzlePiece, bHovered) == 0x0002C5, "Member 'ASlidingPuzzlePiece::bHovered' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzlePiece, bShowingInvalidPress) == 0x0002C6, "Member 'ASlidingPuzzlePiece::bShowingInvalidPress' has a wrong offset!");

// Class Palia.ServerInventoryRequestManager
// 0x0010 (0x0040 - 0x0030)
class UServerInventoryRequestManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_28E7[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerInventoryRequestManager">();
	}
	static class UServerInventoryRequestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerInventoryRequestManager>();
	}
};
static_assert(alignof(UServerInventoryRequestManager) == 0x000008, "Wrong alignment on UServerInventoryRequestManager");
static_assert(sizeof(UServerInventoryRequestManager) == 0x000040, "Wrong size on UServerInventoryRequestManager");

// Class Palia.VAl_InventoryRequestSettings
// 0x0068 (0x00A0 - 0x0038)
class UVAl_InventoryRequestSettings final : public UDeveloperSettings
{
public:
	struct FInterestedUserGroupFilter             UserFilter;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E8[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PersonalFulfilledText;                             // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterFulfilledText;                            // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterRequestedText;                            // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalRequestedText;                             // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAl_InventoryRequestSettings">();
	}
	static class UVAl_InventoryRequestSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAl_InventoryRequestSettings>();
	}
};
static_assert(alignof(UVAl_InventoryRequestSettings) == 0x000008, "Wrong alignment on UVAl_InventoryRequestSettings");
static_assert(sizeof(UVAl_InventoryRequestSettings) == 0x0000A0, "Wrong size on UVAl_InventoryRequestSettings");
static_assert(offsetof(UVAl_InventoryRequestSettings, UserFilter) == 0x000038, "Member 'UVAl_InventoryRequestSettings::UserFilter' has a wrong offset!");
static_assert(offsetof(UVAl_InventoryRequestSettings, PersonalFulfilledText) == 0x000040, "Member 'UVAl_InventoryRequestSettings::PersonalFulfilledText' has a wrong offset!");
static_assert(offsetof(UVAl_InventoryRequestSettings, CharacterFulfilledText) == 0x000058, "Member 'UVAl_InventoryRequestSettings::CharacterFulfilledText' has a wrong offset!");
static_assert(offsetof(UVAl_InventoryRequestSettings, CharacterRequestedText) == 0x000070, "Member 'UVAl_InventoryRequestSettings::CharacterRequestedText' has a wrong offset!");
static_assert(offsetof(UVAl_InventoryRequestSettings, PersonalRequestedText) == 0x000088, "Member 'UVAl_InventoryRequestSettings::PersonalRequestedText' has a wrong offset!");

// Class Palia.PlaceableAlterationsComponent
// 0x00D8 (0x0178 - 0x00A0)
class UPlaceableAlterationsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_28E9[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ActiveAlterationGroup;                             // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FTimerHandle                           InitialSetupTimer;                                 // 0x00C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlaceableAlterationsPersistData       PersistData;                                       // 0x00D0(0x0010)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28EA[0x98];                                    // 0x00E0(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CharacterStateChanged(class UCharacterStateMachineComponent* Csm, const struct FCharacterStateChangeParams& Params_0);
	void InitialSetupTimerTick();
	void OnPersistDataReplicated();
	void PlacementItemChanged(class UVAL_ItemTypeDefinitionAsset* ItemType, bool IsCancelPlacement);
	void PlugsAndSocketsChanged(class UPlaceablePlugAndSocketsComponent* PlugAndSockets);

	bool ContainsAlteration(int32 PersistId) const;
	bool IsAvailibleAlteration(struct FPlaceableAlterationConfig& Config) const;
	bool IsDefaultAlteration(struct FPlaceableAlterationConfig& Config) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceableAlterationsComponent">();
	}
	static class UPlaceableAlterationsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceableAlterationsComponent>();
	}
};
static_assert(alignof(UPlaceableAlterationsComponent) == 0x000008, "Wrong alignment on UPlaceableAlterationsComponent");
static_assert(sizeof(UPlaceableAlterationsComponent) == 0x000178, "Wrong size on UPlaceableAlterationsComponent");
static_assert(offsetof(UPlaceableAlterationsComponent, OnChanged) == 0x0000A8, "Member 'UPlaceableAlterationsComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UPlaceableAlterationsComponent, ActiveAlterationGroup) == 0x0000B8, "Member 'UPlaceableAlterationsComponent::ActiveAlterationGroup' has a wrong offset!");
static_assert(offsetof(UPlaceableAlterationsComponent, InitialSetupTimer) == 0x0000C8, "Member 'UPlaceableAlterationsComponent::InitialSetupTimer' has a wrong offset!");
static_assert(offsetof(UPlaceableAlterationsComponent, PersistData) == 0x0000D0, "Member 'UPlaceableAlterationsComponent::PersistData' has a wrong offset!");

// Class Palia.Invitation
// 0x0088 (0x00B0 - 0x0028)
class UInvitation final : public UObject
{
public:
	struct FUniqueNetIdRepl                       SenderNetId;                                       // 0x0028(0x0030)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       RecipientNetId;                                    // 0x0058(0x0030)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerName;                                        // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstanceAddressAndPort;                            // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpiryTime;                                        // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Invitation">();
	}
	static class UInvitation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvitation>();
	}
};
static_assert(alignof(UInvitation) == 0x000008, "Wrong alignment on UInvitation");
static_assert(sizeof(UInvitation) == 0x0000B0, "Wrong size on UInvitation");
static_assert(offsetof(UInvitation, SenderNetId) == 0x000028, "Member 'UInvitation::SenderNetId' has a wrong offset!");
static_assert(offsetof(UInvitation, RecipientNetId) == 0x000058, "Member 'UInvitation::RecipientNetId' has a wrong offset!");
static_assert(offsetof(UInvitation, ServerName) == 0x000088, "Member 'UInvitation::ServerName' has a wrong offset!");
static_assert(offsetof(UInvitation, InstanceAddressAndPort) == 0x000098, "Member 'UInvitation::InstanceAddressAndPort' has a wrong offset!");
static_assert(offsetof(UInvitation, ExpiryTime) == 0x0000A8, "Member 'UInvitation::ExpiryTime' has a wrong offset!");

// Class Palia.InvitationManager
// 0x0068 (0x0098 - 0x0030)
class UInvitationManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnInviteReceived;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInviteFailed;                                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInviteAccepted;                                  // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInviteDeclined;                                  // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<class UInvitation*>                    SentInvitations;                                   // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UInvitation*>                    ReceivedInvitations;                               // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           Client_CheckServerSyncRequestsHandle;              // 0x0090(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AcceptInvite(class UInvitation* Invitation);
	void DeclineInvite(class UInvitation* Invitation);
	void HandleNewControlMessage(struct FControlMessage& ControlMessage);
	bool HasPendingSentInvitation(struct FUniqueNetIdRepl& UserId);
	void InvitePlayer(struct FUniqueNetIdRepl& UserId);
	void OnInvite__DelegateSignature(class UInvitation* Invitation);
	void OnInviteFailed__DelegateSignature(class UInvitation* Invitation, EInvitationFailureReason FailureReason);

	TArray<class UInvitation*> GetReceivedInvitations() const;
	TArray<class UInvitation*> GetSentInvitations() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvitationManager">();
	}
	static class UInvitationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvitationManager>();
	}
};
static_assert(alignof(UInvitationManager) == 0x000008, "Wrong alignment on UInvitationManager");
static_assert(sizeof(UInvitationManager) == 0x000098, "Wrong size on UInvitationManager");
static_assert(offsetof(UInvitationManager, OnInviteReceived) == 0x000030, "Member 'UInvitationManager::OnInviteReceived' has a wrong offset!");
static_assert(offsetof(UInvitationManager, OnInviteFailed) == 0x000040, "Member 'UInvitationManager::OnInviteFailed' has a wrong offset!");
static_assert(offsetof(UInvitationManager, OnInviteAccepted) == 0x000050, "Member 'UInvitationManager::OnInviteAccepted' has a wrong offset!");
static_assert(offsetof(UInvitationManager, OnInviteDeclined) == 0x000060, "Member 'UInvitationManager::OnInviteDeclined' has a wrong offset!");
static_assert(offsetof(UInvitationManager, SentInvitations) == 0x000070, "Member 'UInvitationManager::SentInvitations' has a wrong offset!");
static_assert(offsetof(UInvitationManager, ReceivedInvitations) == 0x000080, "Member 'UInvitationManager::ReceivedInvitations' has a wrong offset!");
static_assert(offsetof(UInvitationManager, Client_CheckServerSyncRequestsHandle) == 0x000090, "Member 'UInvitationManager::Client_CheckServerSyncRequestsHandle' has a wrong offset!");

// Class Palia.TeleportTravelConfigAsset
// 0x0118 (0x0148 - 0x0030)
class UTeleportTravelConfigAsset final : public UDataAsset
{
public:
	ETeleportTravelType                           TravelType;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F1[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DestinationDisplayName;                            // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UExperiencePackageConfig> ExperiencePackage;                                 // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UExperiencePackageConfig> PrereqExperiencePackage;                           // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPrivateSpaceConfig>     PrivateSpaceConfig;                                // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CrossMapTrackingTypes;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F2[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPersistentTagFilter>           PlayerTagRequirements;                             // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UVAL_GameplayConditionDef*              ConditionPrereq;                                   // 0x00E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAL_GameplayConditionDef*              Condition;                                         // 0x00E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   WrongTagsErrorMessage;                             // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bFadeScreen;                                       // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeamlessTeleport;                                 // 0x0109(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F3[0x6];                                     // 0x010A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpecificLocationOverride;                          // 0x0110(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpecficRotationOverride;                           // 0x0128(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class ULimitedEventDataAsset*                 LimitedEvent;                                      // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool ArePlayerTagRequirementsMet(class AValeriaCharacter* ValeriaCharacter) const;
	bool IsDestinationActive(class UObject* WorldContextObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportTravelConfigAsset">();
	}
	static class UTeleportTravelConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportTravelConfigAsset>();
	}
};
static_assert(alignof(UTeleportTravelConfigAsset) == 0x000008, "Wrong alignment on UTeleportTravelConfigAsset");
static_assert(sizeof(UTeleportTravelConfigAsset) == 0x000148, "Wrong size on UTeleportTravelConfigAsset");
static_assert(offsetof(UTeleportTravelConfigAsset, TravelType) == 0x000030, "Member 'UTeleportTravelConfigAsset::TravelType' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, DestinationDisplayName) == 0x000038, "Member 'UTeleportTravelConfigAsset::DestinationDisplayName' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, ExperiencePackage) == 0x000050, "Member 'UTeleportTravelConfigAsset::ExperiencePackage' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, PrereqExperiencePackage) == 0x000078, "Member 'UTeleportTravelConfigAsset::PrereqExperiencePackage' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, PrivateSpaceConfig) == 0x0000A0, "Member 'UTeleportTravelConfigAsset::PrivateSpaceConfig' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, CrossMapTrackingTypes) == 0x0000C8, "Member 'UTeleportTravelConfigAsset::CrossMapTrackingTypes' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, PlayerTagRequirements) == 0x0000D0, "Member 'UTeleportTravelConfigAsset::PlayerTagRequirements' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, ConditionPrereq) == 0x0000E0, "Member 'UTeleportTravelConfigAsset::ConditionPrereq' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, Condition) == 0x0000E8, "Member 'UTeleportTravelConfigAsset::Condition' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, WrongTagsErrorMessage) == 0x0000F0, "Member 'UTeleportTravelConfigAsset::WrongTagsErrorMessage' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, bFadeScreen) == 0x000108, "Member 'UTeleportTravelConfigAsset::bFadeScreen' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, bSeamlessTeleport) == 0x000109, "Member 'UTeleportTravelConfigAsset::bSeamlessTeleport' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, SpecificLocationOverride) == 0x000110, "Member 'UTeleportTravelConfigAsset::SpecificLocationOverride' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, SpecficRotationOverride) == 0x000128, "Member 'UTeleportTravelConfigAsset::SpecficRotationOverride' has a wrong offset!");
static_assert(offsetof(UTeleportTravelConfigAsset, LimitedEvent) == 0x000140, "Member 'UTeleportTravelConfigAsset::LimitedEvent' has a wrong offset!");

// Class Palia.GardenBuffConfig
// 0x0040 (0x0070 - 0x0030)
class UGardenBuffConfig final : public UDataAsset
{
public:
	EGardenBuffEffectType                         EffectType;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F6[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CompanionIcon;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FertilizerColor;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GardenBuffConfig">();
	}
	static class UGardenBuffConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGardenBuffConfig>();
	}
};
static_assert(alignof(UGardenBuffConfig) == 0x000008, "Wrong alignment on UGardenBuffConfig");
static_assert(sizeof(UGardenBuffConfig) == 0x000070, "Wrong size on UGardenBuffConfig");
static_assert(offsetof(UGardenBuffConfig, EffectType) == 0x000030, "Member 'UGardenBuffConfig::EffectType' has a wrong offset!");
static_assert(offsetof(UGardenBuffConfig, DisplayName) == 0x000038, "Member 'UGardenBuffConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(UGardenBuffConfig, Icon) == 0x000050, "Member 'UGardenBuffConfig::Icon' has a wrong offset!");
static_assert(offsetof(UGardenBuffConfig, CompanionIcon) == 0x000058, "Member 'UGardenBuffConfig::CompanionIcon' has a wrong offset!");
static_assert(offsetof(UGardenBuffConfig, FertilizerColor) == 0x000060, "Member 'UGardenBuffConfig::FertilizerColor' has a wrong offset!");

// Class Palia.ItemUpgradeConfig
// 0x0010 (0x0040 - 0x0030)
class UItemUpgradeConfig final : public UDataAsset
{
public:
	TArray<struct FItemUpgradeMapping>            Upgrades;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemUpgradeConfig">();
	}
	static class UItemUpgradeConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemUpgradeConfig>();
	}
};
static_assert(alignof(UItemUpgradeConfig) == 0x000008, "Wrong alignment on UItemUpgradeConfig");
static_assert(sizeof(UItemUpgradeConfig) == 0x000040, "Wrong size on UItemUpgradeConfig");
static_assert(offsetof(UItemUpgradeConfig, Upgrades) == 0x000030, "Member 'UItemUpgradeConfig::Upgrades' has a wrong offset!");

// Class Palia.PlacementRegionComponent
// 0x00C0 (0x0360 - 0x02A0)
class UPlacementRegionComponent final : public USceneComponent
{
public:
	float                                         TotalRowLength;                                    // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalColLength;                                    // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberRows;                                        // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberCols;                                        // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisualGridRatio;                                   // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlacementGameplayTag;                              // 0x02B4(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHiddenDuringPlacement;                           // 0x02BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F7[0x2];                                     // 0x02BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RotationInterval;                                  // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelRequired;                                     // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DisableIfAnySocketActive;                          // 0x02C8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 PersistAnchorUniqueId;                             // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldCheckPlotUnlocks;                            // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEnforceBoundary;                            // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F8[0x2];                                     // 0x02FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallSupportGridSize;                               // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallSupportTraceLength;                            // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisplayCenterLineOnPlacementGrid;                  // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F9[0x3];                                     // 0x0305(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            CustomPlacementGridMesh;                           // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStickySnap;                                     // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStickySnapAutoRotate;                           // 0x0311(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28FA[0x2];                                     // 0x0312(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StickySnapDistanceThreshold;                       // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SocketMode;                                        // 0x0318(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28FB[0x7];                                     // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlacementRegionSnapPointInfo>  PlacementRegionSnapPoints;                         // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         SocketChildLimit;                                  // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SocketInteractionAngleXY;                          // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28FC[0x1];                                     // 0x0338(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasBoundToCharacterEvents;                        // 0x0339(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28FD[0x6];                                     // 0x033A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           BindToCharacterEventsTimerHandle;                  // 0x0340(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanLocalPlayerPlaceHere;                          // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsSocketInteractable;                             // 0x0349(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28FE[0x2];                                     // 0x034A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastFailureReason;                                 // 0x034C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28FF[0x4];                                     // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlacementRegionMatActor*               MatActor;                                          // 0x0358(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool IsBuildingClusterLimitEnabled();

	void CharacterStateChanged(class UCharacterStateMachineComponent* Csm, const struct FCharacterStateChangeParams& Params_0);
	void FreePlacementChanged(class UPlacementComponent* PC);
	void OnPlacementInteractChanged(class AValeriaCharacter* VC, bool Flag);
	void PlacementChanged(class UPlacementComponent* PC, bool IsPlacing);
	void PlacementItemChanged(class UVAL_ItemTypeDefinitionAsset* Item, bool bCancelPlacement);
	void RpcClient_RecheckPlacementValidity();
	void TryBindToCharacterEvents();

	bool CanLocalPlayerPlaceHere() const;
	bool IsCeilingPlacementRegion() const;
	bool IsWallPlacementRegion() const;
	struct FVector SnapWorldPositionToGrid(struct FVector& WorldPosition, struct FQuat& Orientation, struct FVector& Extents, int32 CellScale) const;
	struct FVector SnapWorldPositionToNearestNeighbor(struct FVector& WorldPosition, struct FQuat& Orientation, class UVAL_ItemTypeDefinitionAsset* ItemType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacementRegionComponent">();
	}
	static class UPlacementRegionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlacementRegionComponent>();
	}
};
static_assert(alignof(UPlacementRegionComponent) == 0x000010, "Wrong alignment on UPlacementRegionComponent");
static_assert(sizeof(UPlacementRegionComponent) == 0x000360, "Wrong size on UPlacementRegionComponent");
static_assert(offsetof(UPlacementRegionComponent, TotalRowLength) == 0x0002A0, "Member 'UPlacementRegionComponent::TotalRowLength' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, TotalColLength) == 0x0002A4, "Member 'UPlacementRegionComponent::TotalColLength' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, NumberRows) == 0x0002A8, "Member 'UPlacementRegionComponent::NumberRows' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, NumberCols) == 0x0002AC, "Member 'UPlacementRegionComponent::NumberCols' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, VisualGridRatio) == 0x0002B0, "Member 'UPlacementRegionComponent::VisualGridRatio' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, PlacementGameplayTag) == 0x0002B4, "Member 'UPlacementRegionComponent::PlacementGameplayTag' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, IsEnabled) == 0x0002BC, "Member 'UPlacementRegionComponent::IsEnabled' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, IsHiddenDuringPlacement) == 0x0002BD, "Member 'UPlacementRegionComponent::IsHiddenDuringPlacement' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, RotationInterval) == 0x0002C0, "Member 'UPlacementRegionComponent::RotationInterval' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, LevelRequired) == 0x0002C4, "Member 'UPlacementRegionComponent::LevelRequired' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, DisableIfAnySocketActive) == 0x0002C8, "Member 'UPlacementRegionComponent::DisableIfAnySocketActive' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, PersistAnchorUniqueId) == 0x0002E8, "Member 'UPlacementRegionComponent::PersistAnchorUniqueId' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, ShouldCheckPlotUnlocks) == 0x0002F8, "Member 'UPlacementRegionComponent::ShouldCheckPlotUnlocks' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, bShouldEnforceBoundary) == 0x0002F9, "Member 'UPlacementRegionComponent::bShouldEnforceBoundary' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, WallSupportGridSize) == 0x0002FC, "Member 'UPlacementRegionComponent::WallSupportGridSize' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, WallSupportTraceLength) == 0x000300, "Member 'UPlacementRegionComponent::WallSupportTraceLength' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, DisplayCenterLineOnPlacementGrid) == 0x000304, "Member 'UPlacementRegionComponent::DisplayCenterLineOnPlacementGrid' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, CustomPlacementGridMesh) == 0x000308, "Member 'UPlacementRegionComponent::CustomPlacementGridMesh' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, UseStickySnap) == 0x000310, "Member 'UPlacementRegionComponent::UseStickySnap' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, UseStickySnapAutoRotate) == 0x000311, "Member 'UPlacementRegionComponent::UseStickySnapAutoRotate' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, StickySnapDistanceThreshold) == 0x000314, "Member 'UPlacementRegionComponent::StickySnapDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, SocketMode) == 0x000318, "Member 'UPlacementRegionComponent::SocketMode' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, PlacementRegionSnapPoints) == 0x000320, "Member 'UPlacementRegionComponent::PlacementRegionSnapPoints' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, SocketChildLimit) == 0x000330, "Member 'UPlacementRegionComponent::SocketChildLimit' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, SocketInteractionAngleXY) == 0x000334, "Member 'UPlacementRegionComponent::SocketInteractionAngleXY' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, bHasBoundToCharacterEvents) == 0x000339, "Member 'UPlacementRegionComponent::bHasBoundToCharacterEvents' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, BindToCharacterEventsTimerHandle) == 0x000340, "Member 'UPlacementRegionComponent::BindToCharacterEventsTimerHandle' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, bCanLocalPlayerPlaceHere) == 0x000348, "Member 'UPlacementRegionComponent::bCanLocalPlayerPlaceHere' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, bIsSocketInteractable) == 0x000349, "Member 'UPlacementRegionComponent::bIsSocketInteractable' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, LastFailureReason) == 0x00034C, "Member 'UPlacementRegionComponent::LastFailureReason' has a wrong offset!");
static_assert(offsetof(UPlacementRegionComponent, MatActor) == 0x000358, "Member 'UPlacementRegionComponent::MatActor' has a wrong offset!");

// Class Palia.ItemTrackingComponent
// 0x0068 (0x0108 - 0x00A0)
class UItemTrackingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2907[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemTrackingHistory                   History;                                           // 0x00A8(0x0010)(Net, NativeAccessSpecifierPrivate)
	struct FItemTrackingPersistBlock              ItemTrackingPersistBlock;                          // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)

public:
	int32 GetNumberOfTimesPurchased(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTrackingComponent">();
	}
	static class UItemTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTrackingComponent>();
	}
};
static_assert(alignof(UItemTrackingComponent) == 0x000008, "Wrong alignment on UItemTrackingComponent");
static_assert(sizeof(UItemTrackingComponent) == 0x000108, "Wrong size on UItemTrackingComponent");
static_assert(offsetof(UItemTrackingComponent, History) == 0x0000A8, "Member 'UItemTrackingComponent::History' has a wrong offset!");
static_assert(offsetof(UItemTrackingComponent, ItemTrackingPersistBlock) == 0x0000B8, "Member 'UItemTrackingComponent::ItemTrackingPersistBlock' has a wrong offset!");

// Class Palia.ItemUpgradeComponent
// 0x0010 (0x00B0 - 0x00A0)
class UItemUpgradeComponent final : public UActorComponent
{
public:
	class UInventoryComponent*                    Inventory;                                         // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URecipeInventoryComponent*              RecipeInventory;                                   // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FullyRepairTool(class AActor* RepairStationActor, struct FBagSlotLocation& ToolSlot, bool bAllowRepairKitsFromStorage);
	void PurchaseFullRepair(class AActor* RepairStationActor, struct FBagSlotLocation& ToolSlot);
	void PurchaseRepair(class AActor* RepairStationActor, struct FBagSlotLocation& ToolSlot, int32 GoldSpent);
	void RepairTool(class AActor* RepairStationActor, struct FBagSlotLocation& ToolSlot, int32 RepairKits, bool bAllowRepairKitsFromStorage);
	void RpcServer_FullyRepairTool(class AActor* RepairStationActor, struct FBagSlotLocation& ToolSlot, bool bAllowRepairKitsFromStorage);
	void RpcServer_PurchaseFullRepair(class AActor* RepairStationActor, struct FBagSlotLocation& ToolSlot);
	void RpcServer_PurchaseRepair(class AActor* RepairStationActor, struct FBagSlotLocation& ToolSlot, int32 GoldSpent);
	void RpcServer_RepairTool(class AActor* RepairStationActor, struct FBagSlotLocation& ToolSlot, int32 Kits, bool bAllowRepairKitsFromStorage);
	void RpcServer_UpgradeToolWithKit(struct FBagSlotLocation& ToolSlot, struct FBagSlotLocation& UpgradeKitSlot);
	bool UpgradeTool(struct FBagSlotLocation& ToolSlot);
	bool UpgradeToolWithKit(struct FBagSlotLocation& ToolSlot, struct FBagSlotLocation& UpgradeKitSlot);

	bool CanUpgradeTool(struct FBagSlotLocation& ToolSlot) const;
	bool CanUpgradeToolWithKit(struct FBagSlotLocation& ToolSlot, struct FBagSlotLocation& UpgradeKitSlot) const;
	int32 GetCoinsRepairCost(struct FValeriaItem& ToolItem, float* RepairPerGold) const;
	int32 GetRepairKitsAvailable(bool bAllowRepairKitsFromStorage) const;
	int32 GetRepairKitsRequired(struct FValeriaItem& ToolItem, int32* RepairPerKit) const;
	bool IsSlotUpgradeKit(struct FBagSlotLocation& ItemSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemUpgradeComponent">();
	}
	static class UItemUpgradeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemUpgradeComponent>();
	}
};
static_assert(alignof(UItemUpgradeComponent) == 0x000008, "Wrong alignment on UItemUpgradeComponent");
static_assert(sizeof(UItemUpgradeComponent) == 0x0000B0, "Wrong size on UItemUpgradeComponent");
static_assert(offsetof(UItemUpgradeComponent, Inventory) == 0x0000A0, "Member 'UItemUpgradeComponent::Inventory' has a wrong offset!");
static_assert(offsetof(UItemUpgradeComponent, RecipeInventory) == 0x0000A8, "Member 'UItemUpgradeComponent::RecipeInventory' has a wrong offset!");

// Class Palia.PersistentTagMapComponent
// 0x0120 (0x01C0 - 0x00A0)
class UPersistentTagMapComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2915[0x60];                                    // 0x00A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bRequiresConnectionHandshake;                      // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReceivedConnectionHandshake;                   // 0x0111(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2916[0x6];                                     // 0x0112(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagMapPersistBlock                    TagMapPersistBlock;                                // 0x0118(0x0060)(NativeAccessSpecifierPrivate)
	bool                                          bBatchingUpdates;                                  // 0x0178(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBatchingUpdatesOccurred;                          // 0x0179(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2917[0x6];                                     // 0x017A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           BatchFinishedCheckTimerHandle;                     // 0x0180(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTagEntry>                      QueuedPlayerEntries;                               // 0x0188(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FTagEntry>                      QueuedPlotEntries;                                 // 0x0198(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FTagEntry                              MostRecentlyUpdatedTagEntry;                       // 0x01A8(0x000C)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2918[0x4];                                     // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           NetworkSendTagsTimerHandle;                        // 0x01B8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_MostRecentlyUpdatedTagEntry();
	void PersistentTagValuesUpdated();
	void RpcClient_SendTagsToUpdate(TArray<struct FTagEntry>& SentPlayerEntries, TArray<struct FTagEntry>& SentPlotEntries);
	void Server_SendTagsToUpdate();
	void ServerApplyScriptedWriteback(struct FPersistentTagWriteback& TagWriteback);

	float ComputeTagScore(struct FTagScoreRubric& Rubric) const;
	TArray<struct FTagEntry> GetAllTagValues() const;
	TArray<struct FTagEntry> GetCachedPlaceableTagValuesContainingString(const class FString& InString, bool bSort) const;
	int32 GetTagValue(struct FGameplayTag& Tag) const;
	TArray<struct FTagEntry> GetTagValuesContainingString(const class FString& InString, bool bSort) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistentTagMapComponent">();
	}
	static class UPersistentTagMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersistentTagMapComponent>();
	}
};
static_assert(alignof(UPersistentTagMapComponent) == 0x000008, "Wrong alignment on UPersistentTagMapComponent");
static_assert(sizeof(UPersistentTagMapComponent) == 0x0001C0, "Wrong size on UPersistentTagMapComponent");
static_assert(offsetof(UPersistentTagMapComponent, OnChanged) == 0x000100, "Member 'UPersistentTagMapComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, bRequiresConnectionHandshake) == 0x000110, "Member 'UPersistentTagMapComponent::bRequiresConnectionHandshake' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, bHasReceivedConnectionHandshake) == 0x000111, "Member 'UPersistentTagMapComponent::bHasReceivedConnectionHandshake' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, TagMapPersistBlock) == 0x000118, "Member 'UPersistentTagMapComponent::TagMapPersistBlock' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, bBatchingUpdates) == 0x000178, "Member 'UPersistentTagMapComponent::bBatchingUpdates' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, bBatchingUpdatesOccurred) == 0x000179, "Member 'UPersistentTagMapComponent::bBatchingUpdatesOccurred' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, BatchFinishedCheckTimerHandle) == 0x000180, "Member 'UPersistentTagMapComponent::BatchFinishedCheckTimerHandle' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, QueuedPlayerEntries) == 0x000188, "Member 'UPersistentTagMapComponent::QueuedPlayerEntries' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, QueuedPlotEntries) == 0x000198, "Member 'UPersistentTagMapComponent::QueuedPlotEntries' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, MostRecentlyUpdatedTagEntry) == 0x0001A8, "Member 'UPersistentTagMapComponent::MostRecentlyUpdatedTagEntry' has a wrong offset!");
static_assert(offsetof(UPersistentTagMapComponent, NetworkSendTagsTimerHandle) == 0x0001B8, "Member 'UPersistentTagMapComponent::NetworkSendTagsTimerHandle' has a wrong offset!");

// Class Palia.ItemVariantComponent
// 0x0068 (0x0108 - 0x00A0)
class UItemVariantComponent final : public UActorComponent
{
public:
	uint8                                         Pad_291C[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemVariantChanged;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemMeshVariantChanged;                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         TintPersistID;                                     // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MeshVariantID;                                     // 0x00CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> ItemAssetOverride;                                 // 0x00D0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDefaultVariantMaterialAssignment> Originals;                                         // 0x00F8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> GetItemAssetOverride();
	void OnRep_MeshVariantID();
	void OnRep_TintPersistID();
	void SetItemAssetOverride(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& Param_ItemAssetOverride);
	void SetTintPersistID(int32 Param_TintPersistID);

	int32 GetTintPersistID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVariantComponent">();
	}
	static class UItemVariantComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemVariantComponent>();
	}
};
static_assert(alignof(UItemVariantComponent) == 0x000008, "Wrong alignment on UItemVariantComponent");
static_assert(sizeof(UItemVariantComponent) == 0x000108, "Wrong size on UItemVariantComponent");
static_assert(offsetof(UItemVariantComponent, OnItemVariantChanged) == 0x0000A8, "Member 'UItemVariantComponent::OnItemVariantChanged' has a wrong offset!");
static_assert(offsetof(UItemVariantComponent, OnItemMeshVariantChanged) == 0x0000B8, "Member 'UItemVariantComponent::OnItemMeshVariantChanged' has a wrong offset!");
static_assert(offsetof(UItemVariantComponent, TintPersistID) == 0x0000C8, "Member 'UItemVariantComponent::TintPersistID' has a wrong offset!");
static_assert(offsetof(UItemVariantComponent, MeshVariantID) == 0x0000CC, "Member 'UItemVariantComponent::MeshVariantID' has a wrong offset!");
static_assert(offsetof(UItemVariantComponent, ItemAssetOverride) == 0x0000D0, "Member 'UItemVariantComponent::ItemAssetOverride' has a wrong offset!");
static_assert(offsetof(UItemVariantComponent, Originals) == 0x0000F8, "Member 'UItemVariantComponent::Originals' has a wrong offset!");

// Class Palia.ItemVariantCustomizerComponent
// 0x0008 (0x00A8 - 0x00A0)
class UItemVariantCustomizerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_291D[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Vpc, const struct FInteractEventParams& EventParams);

	bool GetText(class AValeriaCharacter* VC, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	bool HasRequirementsToSwitchVariant(class AValeriaPlayerController* Vpc, const struct FValeriaItem& Item, int32 TintPersistID) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* VC, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVariantCustomizerComponent">();
	}
	static class UItemVariantCustomizerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemVariantCustomizerComponent>();
	}
};
static_assert(alignof(UItemVariantCustomizerComponent) == 0x000008, "Wrong alignment on UItemVariantCustomizerComponent");
static_assert(sizeof(UItemVariantCustomizerComponent) == 0x0000A8, "Wrong size on UItemVariantCustomizerComponent");

// Class Palia.TeleportDestinationComponent
// 0x0040 (0x02E0 - 0x02A0)
class UTeleportDestinationComponent final : public USceneComponent
{
public:
	class UTeleportTravelConfigAsset*             DestinationAddress;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnArrival;                                         // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DestinationReadyCallback;                          // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class AHousingPlotActor*                      OwningPlot;                                        // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorldPartitionStreamingSourceComponent* StreamingSourceComponent;                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2923[0x8];                                     // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportDestinationComponent">();
	}
	static class UTeleportDestinationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportDestinationComponent>();
	}
};
static_assert(alignof(UTeleportDestinationComponent) == 0x000010, "Wrong alignment on UTeleportDestinationComponent");
static_assert(sizeof(UTeleportDestinationComponent) == 0x0002E0, "Wrong size on UTeleportDestinationComponent");
static_assert(offsetof(UTeleportDestinationComponent, DestinationAddress) == 0x0002A0, "Member 'UTeleportDestinationComponent::DestinationAddress' has a wrong offset!");
static_assert(offsetof(UTeleportDestinationComponent, OnArrival) == 0x0002A8, "Member 'UTeleportDestinationComponent::OnArrival' has a wrong offset!");
static_assert(offsetof(UTeleportDestinationComponent, DestinationReadyCallback) == 0x0002B8, "Member 'UTeleportDestinationComponent::DestinationReadyCallback' has a wrong offset!");
static_assert(offsetof(UTeleportDestinationComponent, OwningPlot) == 0x0002C8, "Member 'UTeleportDestinationComponent::OwningPlot' has a wrong offset!");
static_assert(offsetof(UTeleportDestinationComponent, StreamingSourceComponent) == 0x0002D0, "Member 'UTeleportDestinationComponent::StreamingSourceComponent' has a wrong offset!");

// Class Palia.LevelerComponent
// 0x0088 (0x0128 - 0x00A0)
class ULevelerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2924[0x10];                                    // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnLevelChanged;                                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLevelItemContributionChanged;                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimerHandle                           UpgradeCompleteTimerHandle;                        // 0x00D0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentLevel;                                      // 0x00D8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LevelerConfigName;                                 // 0x00DC(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2925[0x4];                                     // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelerProgress                       LevelerProgress;                                   // 0x00E8(0x0028)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FValeriaItem>                   ItemsToDeduct;                                     // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2926[0x8];                                     // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItemToDeduct(class UVAL_ItemTypeDefinitionAsset* ItemType, int32 Amount);
	void AttemptToLevelUp(class AValeriaCharacter* Character, bool IgnoreCost);
	void CheckTimerCompleted(class ULevelerComponent* Leveler);
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Player, const struct FInteractEventParams& EventParams);
	struct FUseEventResult OnClientUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnReplicated_CurrentLevel();
	void OnReplicated_Progress();
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void OnServerUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FServerUseEventParams& Params_0);
	void Server_OnCheckTimerCompleted();

	int32 GetCurrentLevel() const;
	int64 GetEndTimeForCompletionMs() const;
	int32 GetItemProgress(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType) const;
	int64 GetRemainingTimeForCompletionMs() const;
	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	bool HasBegunLeveling() const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsAtMaxLevel() const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;
	bool IsTimedRequirementCompletedForLevelUp() const;
	bool IsTimedRequirementForLevelUp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelerComponent">();
	}
	static class ULevelerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelerComponent>();
	}
};
static_assert(alignof(ULevelerComponent) == 0x000008, "Wrong alignment on ULevelerComponent");
static_assert(sizeof(ULevelerComponent) == 0x000128, "Wrong size on ULevelerComponent");
static_assert(offsetof(ULevelerComponent, OnLevelChanged) == 0x0000B0, "Member 'ULevelerComponent::OnLevelChanged' has a wrong offset!");
static_assert(offsetof(ULevelerComponent, OnLevelItemContributionChanged) == 0x0000C0, "Member 'ULevelerComponent::OnLevelItemContributionChanged' has a wrong offset!");
static_assert(offsetof(ULevelerComponent, UpgradeCompleteTimerHandle) == 0x0000D0, "Member 'ULevelerComponent::UpgradeCompleteTimerHandle' has a wrong offset!");
static_assert(offsetof(ULevelerComponent, CurrentLevel) == 0x0000D8, "Member 'ULevelerComponent::CurrentLevel' has a wrong offset!");
static_assert(offsetof(ULevelerComponent, LevelerConfigName) == 0x0000DC, "Member 'ULevelerComponent::LevelerConfigName' has a wrong offset!");
static_assert(offsetof(ULevelerComponent, LevelerProgress) == 0x0000E8, "Member 'ULevelerComponent::LevelerProgress' has a wrong offset!");
static_assert(offsetof(ULevelerComponent, ItemsToDeduct) == 0x000110, "Member 'ULevelerComponent::ItemsToDeduct' has a wrong offset!");

// Class Palia.LightingBaseState
// 0x0410 (0x0440 - 0x0030)
class ULightingBaseState final : public UDataAsset
{
public:
	bool                                          bAffectRotation;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_292F[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotation;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DirectionalLightIntensity;                         // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DirectionalLightColor;                             // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceAngle;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftSourceAngle;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalIndirectLightingIntensity;              // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalVolumetricScatteringIntensity;          // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowAmount;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyLightIntensity;                                 // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SkyLightColor;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SkyLightLowerHemisphereColor;                      // 0x0074(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyIndirectLightingIntensity;                      // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyVolumetricScatteringIntensity;                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDensity;                                        // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExponentialHeightFogData              SecondFogData;                                     // 0x0094(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FogInscatteringColor;                              // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMaxOpacity;                                     // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance;                                     // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogCutoffDistance;                                 // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2930[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightingStatePostProcess              PostProcessSettings;                               // 0x00C0(0x0340)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HorizonHeight;                                     // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizonHardness;                                   // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZenithHeight;                                      // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZenithHardness;                                    // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HorizonSkyColor;                                   // 0x0410(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ZenithSkyColor;                                    // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ZenithSkyColor2;                                   // 0x0430(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingBaseState">();
	}
	static class ULightingBaseState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingBaseState>();
	}
};
static_assert(alignof(ULightingBaseState) == 0x000010, "Wrong alignment on ULightingBaseState");
static_assert(sizeof(ULightingBaseState) == 0x000440, "Wrong size on ULightingBaseState");
static_assert(offsetof(ULightingBaseState, bAffectRotation) == 0x000030, "Member 'ULightingBaseState::bAffectRotation' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, Rotation) == 0x000038, "Member 'ULightingBaseState::Rotation' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, DirectionalLightIntensity) == 0x000050, "Member 'ULightingBaseState::DirectionalLightIntensity' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, DirectionalLightColor) == 0x000054, "Member 'ULightingBaseState::DirectionalLightColor' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, SourceAngle) == 0x000058, "Member 'ULightingBaseState::SourceAngle' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, SoftSourceAngle) == 0x00005C, "Member 'ULightingBaseState::SoftSourceAngle' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, DirectionalIndirectLightingIntensity) == 0x000060, "Member 'ULightingBaseState::DirectionalIndirectLightingIntensity' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, DirectionalVolumetricScatteringIntensity) == 0x000064, "Member 'ULightingBaseState::DirectionalVolumetricScatteringIntensity' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, ShadowAmount) == 0x000068, "Member 'ULightingBaseState::ShadowAmount' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, SkyLightIntensity) == 0x00006C, "Member 'ULightingBaseState::SkyLightIntensity' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, SkyLightColor) == 0x000070, "Member 'ULightingBaseState::SkyLightColor' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, SkyLightLowerHemisphereColor) == 0x000074, "Member 'ULightingBaseState::SkyLightLowerHemisphereColor' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, SkyIndirectLightingIntensity) == 0x000084, "Member 'ULightingBaseState::SkyIndirectLightingIntensity' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, SkyVolumetricScatteringIntensity) == 0x000088, "Member 'ULightingBaseState::SkyVolumetricScatteringIntensity' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, FogDensity) == 0x00008C, "Member 'ULightingBaseState::FogDensity' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, FogHeightFalloff) == 0x000090, "Member 'ULightingBaseState::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, SecondFogData) == 0x000094, "Member 'ULightingBaseState::SecondFogData' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, FogInscatteringColor) == 0x0000A0, "Member 'ULightingBaseState::FogInscatteringColor' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, FogMaxOpacity) == 0x0000B0, "Member 'ULightingBaseState::FogMaxOpacity' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, StartDistance) == 0x0000B4, "Member 'ULightingBaseState::StartDistance' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, FogCutoffDistance) == 0x0000B8, "Member 'ULightingBaseState::FogCutoffDistance' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, PostProcessSettings) == 0x0000C0, "Member 'ULightingBaseState::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, HorizonHeight) == 0x000400, "Member 'ULightingBaseState::HorizonHeight' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, HorizonHardness) == 0x000404, "Member 'ULightingBaseState::HorizonHardness' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, ZenithHeight) == 0x000408, "Member 'ULightingBaseState::ZenithHeight' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, ZenithHardness) == 0x00040C, "Member 'ULightingBaseState::ZenithHardness' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, HorizonSkyColor) == 0x000410, "Member 'ULightingBaseState::HorizonSkyColor' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, ZenithSkyColor) == 0x000420, "Member 'ULightingBaseState::ZenithSkyColor' has a wrong offset!");
static_assert(offsetof(ULightingBaseState, ZenithSkyColor2) == 0x000430, "Member 'ULightingBaseState::ZenithSkyColor2' has a wrong offset!");

// Class Palia.TrackingTargetComponent
// 0x0040 (0x00E0 - 0x00A0)
class UTrackingTargetComponent final : public UActorComponent
{
public:
	class UPlayerCompassTargetConfigAsset*        Asset;                                             // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Tooltip;                                           // 0x00A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x00C0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         TrackingOn;                                        // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorldLocationContext                         WorldLocationContext;                              // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2931[0x3];                                     // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrackingTargetComponent">();
	}
	static class UTrackingTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrackingTargetComponent>();
	}
};
static_assert(alignof(UTrackingTargetComponent) == 0x000008, "Wrong alignment on UTrackingTargetComponent");
static_assert(sizeof(UTrackingTargetComponent) == 0x0000E0, "Wrong size on UTrackingTargetComponent");
static_assert(offsetof(UTrackingTargetComponent, Asset) == 0x0000A0, "Member 'UTrackingTargetComponent::Asset' has a wrong offset!");
static_assert(offsetof(UTrackingTargetComponent, Tooltip) == 0x0000A8, "Member 'UTrackingTargetComponent::Tooltip' has a wrong offset!");
static_assert(offsetof(UTrackingTargetComponent, DisplayText) == 0x0000C0, "Member 'UTrackingTargetComponent::DisplayText' has a wrong offset!");
static_assert(offsetof(UTrackingTargetComponent, TrackingOn) == 0x0000D8, "Member 'UTrackingTargetComponent::TrackingOn' has a wrong offset!");
static_assert(offsetof(UTrackingTargetComponent, WorldLocationContext) == 0x0000DC, "Member 'UTrackingTargetComponent::WorldLocationContext' has a wrong offset!");

// Class Palia.LightingModState
// 0x0000 (0x0030 - 0x0030)
class ULightingModState final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingModState">();
	}
	static class ULightingModState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingModState>();
	}
};
static_assert(alignof(ULightingModState) == 0x000008, "Wrong alignment on ULightingModState");
static_assert(sizeof(ULightingModState) == 0x000030, "Wrong size on ULightingModState");

// Class Palia.LimitedEventActivatorComponent
// 0x0030 (0x00D0 - 0x00A0)
class ULimitedEventActivatorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnLimitedEventActivated;                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLimitedEventDeactivated;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULimitedEventDataAsset*                 LimitedEvent;                                      // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultToInactive;                                // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideActor;                                        // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCollision;                                 // 0x00CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAKCulledComponents;                        // 0x00CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildActors;                           // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideTrackers;                                     // 0x00CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2932[0x2];                                     // 0x00CE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleEventManagerRegistered(class ULimitedEventDataAsset* Event, class ALimitedEventManagerBase* EventManager);
	void HandleEventStateChanged(class ALimitedEventManagerBase* EventManager, bool bIsEventActive);

	bool IsEventActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventActivatorComponent">();
	}
	static class ULimitedEventActivatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitedEventActivatorComponent>();
	}
};
static_assert(alignof(ULimitedEventActivatorComponent) == 0x000008, "Wrong alignment on ULimitedEventActivatorComponent");
static_assert(sizeof(ULimitedEventActivatorComponent) == 0x0000D0, "Wrong size on ULimitedEventActivatorComponent");
static_assert(offsetof(ULimitedEventActivatorComponent, OnLimitedEventActivated) == 0x0000A0, "Member 'ULimitedEventActivatorComponent::OnLimitedEventActivated' has a wrong offset!");
static_assert(offsetof(ULimitedEventActivatorComponent, OnLimitedEventDeactivated) == 0x0000B0, "Member 'ULimitedEventActivatorComponent::OnLimitedEventDeactivated' has a wrong offset!");
static_assert(offsetof(ULimitedEventActivatorComponent, LimitedEvent) == 0x0000C0, "Member 'ULimitedEventActivatorComponent::LimitedEvent' has a wrong offset!");
static_assert(offsetof(ULimitedEventActivatorComponent, bDefaultToInactive) == 0x0000C8, "Member 'ULimitedEventActivatorComponent::bDefaultToInactive' has a wrong offset!");
static_assert(offsetof(ULimitedEventActivatorComponent, bHideActor) == 0x0000C9, "Member 'ULimitedEventActivatorComponent::bHideActor' has a wrong offset!");
static_assert(offsetof(ULimitedEventActivatorComponent, bDisableCollision) == 0x0000CA, "Member 'ULimitedEventActivatorComponent::bDisableCollision' has a wrong offset!");
static_assert(offsetof(ULimitedEventActivatorComponent, bDisableAKCulledComponents) == 0x0000CB, "Member 'ULimitedEventActivatorComponent::bDisableAKCulledComponents' has a wrong offset!");
static_assert(offsetof(ULimitedEventActivatorComponent, bPropagateToChildActors) == 0x0000CC, "Member 'ULimitedEventActivatorComponent::bPropagateToChildActors' has a wrong offset!");
static_assert(offsetof(ULimitedEventActivatorComponent, bHideTrackers) == 0x0000CD, "Member 'ULimitedEventActivatorComponent::bHideTrackers' has a wrong offset!");

// Class Palia.LootInteractorBaseComponent
// 0x0048 (0x00E8 - 0x00A0)
class ULootInteractorBaseComponent : public UActorComponent
{
public:
	uint8                                         Pad_2934[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisallowItemsGrantingAccomplishmentProgress;       // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2935[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharacterGatheredLoot;                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          UseAbilityGather;                                  // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2936[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LootInteractionOverrideText;                       // 0x00C8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bInteractionDisabled;                              // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowLootPromptWithFullInventory;                  // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowLootToEnterOverflowBag;                      // 0x00E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2937[0x5];                                     // 0x00E3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Character, const struct FInteractEventParams& EventParams);
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	bool Server_TriggerGather(class AValeriaCharacter* Character);

	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootInteractorBaseComponent">();
	}
	static class ULootInteractorBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootInteractorBaseComponent>();
	}
};
static_assert(alignof(ULootInteractorBaseComponent) == 0x000008, "Wrong alignment on ULootInteractorBaseComponent");
static_assert(sizeof(ULootInteractorBaseComponent) == 0x0000E8, "Wrong size on ULootInteractorBaseComponent");
static_assert(offsetof(ULootInteractorBaseComponent, DisallowItemsGrantingAccomplishmentProgress) == 0x0000A8, "Member 'ULootInteractorBaseComponent::DisallowItemsGrantingAccomplishmentProgress' has a wrong offset!");
static_assert(offsetof(ULootInteractorBaseComponent, OnCharacterGatheredLoot) == 0x0000B0, "Member 'ULootInteractorBaseComponent::OnCharacterGatheredLoot' has a wrong offset!");
static_assert(offsetof(ULootInteractorBaseComponent, UseAbilityGather) == 0x0000C0, "Member 'ULootInteractorBaseComponent::UseAbilityGather' has a wrong offset!");
static_assert(offsetof(ULootInteractorBaseComponent, LootInteractionOverrideText) == 0x0000C8, "Member 'ULootInteractorBaseComponent::LootInteractionOverrideText' has a wrong offset!");
static_assert(offsetof(ULootInteractorBaseComponent, bInteractionDisabled) == 0x0000E0, "Member 'ULootInteractorBaseComponent::bInteractionDisabled' has a wrong offset!");
static_assert(offsetof(ULootInteractorBaseComponent, bShowLootPromptWithFullInventory) == 0x0000E1, "Member 'ULootInteractorBaseComponent::bShowLootPromptWithFullInventory' has a wrong offset!");
static_assert(offsetof(ULootInteractorBaseComponent, bAllowLootToEnterOverflowBag) == 0x0000E2, "Member 'ULootInteractorBaseComponent::bAllowLootToEnterOverflowBag' has a wrong offset!");

// Class Palia.TimedDropComponent
// 0x0068 (0x0150 - 0x00E8)
class UTimedDropComponent final : public ULootInteractorBaseComponent
{
public:
	uint8                                         Pad_293E[0x8];                                     // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCooldownStatusChanged;                           // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ECooldownTimerType                            CooldownType;                                      // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_293F[0x3];                                     // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumDaysCooldown;                                   // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CooldownLengthSecs;                                // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCooldownComplete;                                 // 0x010C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2940[0x3];                                     // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestRewardConfig>             Rewards;                                           // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2941[0x8];                                     // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestReward>                   RolledRewards;                                     // 0x0128(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2942[0x10];                                    // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      CachedOwnerCharacter;                              // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_bCooldownComplete();

	const class AValeriaCharacter* GetCachedOwnerCharacter() const;
	bool IsCooldownComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedDropComponent">();
	}
	static class UTimedDropComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedDropComponent>();
	}
};
static_assert(alignof(UTimedDropComponent) == 0x000008, "Wrong alignment on UTimedDropComponent");
static_assert(sizeof(UTimedDropComponent) == 0x000150, "Wrong size on UTimedDropComponent");
static_assert(offsetof(UTimedDropComponent, OnCooldownStatusChanged) == 0x0000F0, "Member 'UTimedDropComponent::OnCooldownStatusChanged' has a wrong offset!");
static_assert(offsetof(UTimedDropComponent, CooldownType) == 0x000100, "Member 'UTimedDropComponent::CooldownType' has a wrong offset!");
static_assert(offsetof(UTimedDropComponent, NumDaysCooldown) == 0x000104, "Member 'UTimedDropComponent::NumDaysCooldown' has a wrong offset!");
static_assert(offsetof(UTimedDropComponent, CooldownLengthSecs) == 0x000108, "Member 'UTimedDropComponent::CooldownLengthSecs' has a wrong offset!");
static_assert(offsetof(UTimedDropComponent, bCooldownComplete) == 0x00010C, "Member 'UTimedDropComponent::bCooldownComplete' has a wrong offset!");
static_assert(offsetof(UTimedDropComponent, Rewards) == 0x000110, "Member 'UTimedDropComponent::Rewards' has a wrong offset!");
static_assert(offsetof(UTimedDropComponent, RolledRewards) == 0x000128, "Member 'UTimedDropComponent::RolledRewards' has a wrong offset!");
static_assert(offsetof(UTimedDropComponent, CachedOwnerCharacter) == 0x000148, "Member 'UTimedDropComponent::CachedOwnerCharacter' has a wrong offset!");

// Class Palia.LimitedEventDataAsset
// 0x0088 (0x00B8 - 0x0030)
class ULimitedEventDataAsset final : public UDataAsset
{
public:
	TSoftObjectPtr<class UTexture2D>              EventIcon;                                         // 0x0030(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  EventId;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventName;                                         // 0x0068(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   EventDescription;                                  // 0x0080(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayPreview;                                   // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDynamic;                                        // 0x009A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2943[0x5];                                     // 0x009B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartTime;                                         // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ALimitedEventManagerBase>   ManagerClass;                                      // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static TArray<class FName> GetAllEventNames();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventDataAsset">();
	}
	static class ULimitedEventDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitedEventDataAsset>();
	}
};
static_assert(alignof(ULimitedEventDataAsset) == 0x000008, "Wrong alignment on ULimitedEventDataAsset");
static_assert(sizeof(ULimitedEventDataAsset) == 0x0000B8, "Wrong size on ULimitedEventDataAsset");
static_assert(offsetof(ULimitedEventDataAsset, EventIcon) == 0x000030, "Member 'ULimitedEventDataAsset::EventIcon' has a wrong offset!");
static_assert(offsetof(ULimitedEventDataAsset, EventId) == 0x000058, "Member 'ULimitedEventDataAsset::EventId' has a wrong offset!");
static_assert(offsetof(ULimitedEventDataAsset, EventName) == 0x000068, "Member 'ULimitedEventDataAsset::EventName' has a wrong offset!");
static_assert(offsetof(ULimitedEventDataAsset, EventDescription) == 0x000080, "Member 'ULimitedEventDataAsset::EventDescription' has a wrong offset!");
static_assert(offsetof(ULimitedEventDataAsset, bIsEnabled) == 0x000098, "Member 'ULimitedEventDataAsset::bIsEnabled' has a wrong offset!");
static_assert(offsetof(ULimitedEventDataAsset, bDisplayPreview) == 0x000099, "Member 'ULimitedEventDataAsset::bDisplayPreview' has a wrong offset!");
static_assert(offsetof(ULimitedEventDataAsset, bIsDynamic) == 0x00009A, "Member 'ULimitedEventDataAsset::bIsDynamic' has a wrong offset!");
static_assert(offsetof(ULimitedEventDataAsset, StartTime) == 0x0000A0, "Member 'ULimitedEventDataAsset::StartTime' has a wrong offset!");
static_assert(offsetof(ULimitedEventDataAsset, EndTime) == 0x0000A8, "Member 'ULimitedEventDataAsset::EndTime' has a wrong offset!");
static_assert(offsetof(ULimitedEventDataAsset, ManagerClass) == 0x0000B0, "Member 'ULimitedEventDataAsset::ManagerClass' has a wrong offset!");

// Class Palia.LimitedEventManagerBase
// 0x00C8 (0x0370 - 0x02A8)
class ALimitedEventManagerBase : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnEventStateChanged;                               // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>> EventExclusiveItems;                               // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 AchievementCategory;                               // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EventMenuWidget;                                   // 0x02D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EventMenuPreviewWidget;                            // 0x0300(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurrencyConfig>         CurrencyToDisplay;                                 // 0x0328(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEventDataLayerConfig>          EventDataLayers;                                   // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bEventActive;                                      // 0x0360(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2944[0x7];                                     // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULimitedEventDataAsset*                 EventDataAsset;                                    // 0x0368(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleEventActivated();
	void HandleEventDeactivated();
	void OnRep_bEventActive();

	class ULimitedEventDataAsset* GetEventDataAsset() const;
	bool IsEventActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventManagerBase">();
	}
	static class ALimitedEventManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALimitedEventManagerBase>();
	}
};
static_assert(alignof(ALimitedEventManagerBase) == 0x000008, "Wrong alignment on ALimitedEventManagerBase");
static_assert(sizeof(ALimitedEventManagerBase) == 0x000370, "Wrong size on ALimitedEventManagerBase");
static_assert(offsetof(ALimitedEventManagerBase, OnEventStateChanged) == 0x0002A8, "Member 'ALimitedEventManagerBase::OnEventStateChanged' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerBase, EventExclusiveItems) == 0x0002B8, "Member 'ALimitedEventManagerBase::EventExclusiveItems' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerBase, AchievementCategory) == 0x0002C8, "Member 'ALimitedEventManagerBase::AchievementCategory' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerBase, EventMenuWidget) == 0x0002D8, "Member 'ALimitedEventManagerBase::EventMenuWidget' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerBase, EventMenuPreviewWidget) == 0x000300, "Member 'ALimitedEventManagerBase::EventMenuPreviewWidget' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerBase, CurrencyToDisplay) == 0x000328, "Member 'ALimitedEventManagerBase::CurrencyToDisplay' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerBase, EventDataLayers) == 0x000350, "Member 'ALimitedEventManagerBase::EventDataLayers' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerBase, bEventActive) == 0x000360, "Member 'ALimitedEventManagerBase::bEventActive' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerBase, EventDataAsset) == 0x000368, "Member 'ALimitedEventManagerBase::EventDataAsset' has a wrong offset!");

// Class Palia.VAL_TaskProxy_PlayMontageAndWaitForEvent
// 0x00C0 (0x0140 - 0x0080)
class UVAL_TaskProxy_PlayMontageAndWaitForEvent final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelled;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MontageMappingName;                                // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  EventTags;                                         // 0x00E0(0x0020)(NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x0104(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x010C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHardJump;                                         // 0x010D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2945[0x32];                                    // 0x010E(0x0032)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_TaskProxy_PlayMontageAndWaitForEvent* PlayMontageByMappingAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class FName MontageMappingToPlay, const struct FGameplayTagContainer& Param_EventTags, float Param_Rate, class FName Param_StartSection, bool Param_bStopWhenAbilityEnds, bool Param_bHardJump);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TaskProxy_PlayMontageAndWaitForEvent">();
	}
	static class UVAL_TaskProxy_PlayMontageAndWaitForEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TaskProxy_PlayMontageAndWaitForEvent>();
	}
};
static_assert(alignof(UVAL_TaskProxy_PlayMontageAndWaitForEvent) == 0x000008, "Wrong alignment on UVAL_TaskProxy_PlayMontageAndWaitForEvent");
static_assert(sizeof(UVAL_TaskProxy_PlayMontageAndWaitForEvent) == 0x000140, "Wrong size on UVAL_TaskProxy_PlayMontageAndWaitForEvent");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, OnCompleted) == 0x000080, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::OnCompleted' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, OnBlendOut) == 0x000090, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, OnInterrupted) == 0x0000A0, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, OnCancelled) == 0x0000B0, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::OnCancelled' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, EventReceived) == 0x0000C0, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, MontageToPlay) == 0x0000D0, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, MontageMappingName) == 0x0000D8, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::MontageMappingName' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, EventTags) == 0x0000E0, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::EventTags' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, Rate) == 0x000100, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::Rate' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, StartSection) == 0x000104, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::StartSection' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, bStopWhenAbilityEnds) == 0x00010C, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWaitForEvent, bHardJump) == 0x00010D, "Member 'UVAL_TaskProxy_PlayMontageAndWaitForEvent::bHardJump' has a wrong offset!");

// Class Palia.LimitedEventManagerFairgrounds
// 0x0100 (0x0470 - 0x0370)
class ALimitedEventManagerFairgrounds : public ALimitedEventManagerBase
{
public:
	FMulticastInlineDelegateProperty_             OnMarketOpen;                                      // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMarketClose;                                     // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimeOfDayHourMinute                   MarketOpenTime;                                    // 0x0390(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimeOfDayHourMinute                   MarketCloseTime;                                   // 0x0398(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimeOfDayHourMinute                   ChapaaChaseStartTime;                              // 0x03A0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimeOfDayHourMinute                   FireworkShowStartTime;                             // 0x03A8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 FireworkLaunchedStatName;                          // 0x03B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpaceVisitedStatName;                              // 0x03C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerEnteredSpace;                              // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerExitedSpace;                               // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFireworkShowStarted;                             // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FireworkItemTagContainer;                          // 0x0400(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2947[0x30];                                    // 0x0420(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsMarketOpen;                                     // 0x0450(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2948[0x7];                                     // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AValeriaPlayerController*>       CurrentPlayersInSpace;                             // 0x0458(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AChapaaChaseManager*                    CachedChapaaChaseManager;                          // 0x0468(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AChapaaChaseManager* GetChapaaChaseManager();
	void HandleChapaaChaseStart(struct FVAL_TimerHandle* TimerHandle);
	void HandleMarketOpenOrCloseEvent(struct FVAL_TimerHandle* TimerHandle);
	void HandlePlayerFiredProjetile(class UProjectileFiringComponent* FiringComponent, class AValeriaProjectile* Projectile, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> Ammo, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> Tool);
	void OnRep_bIsMarketOpen();
	void PlayerEnteredSpace(class AValeriaPlayerController* Player);
	void PlayerExitedSpace(class AValeriaPlayerController* Player);
	void RpcNetMulticast_FireworkShowStarted();
	void UpdatePlayerSpaceVisitedStat(class AValeriaPlayerController* Player);

	TArray<class AValeriaPlayerController*> GetPlayersInSpace() const;
	bool IsMarketOpen() const;
	bool IsPlayerInSpace(class AValeriaPlayerController* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventManagerFairgrounds">();
	}
	static class ALimitedEventManagerFairgrounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALimitedEventManagerFairgrounds>();
	}
};
static_assert(alignof(ALimitedEventManagerFairgrounds) == 0x000008, "Wrong alignment on ALimitedEventManagerFairgrounds");
static_assert(sizeof(ALimitedEventManagerFairgrounds) == 0x000470, "Wrong size on ALimitedEventManagerFairgrounds");
static_assert(offsetof(ALimitedEventManagerFairgrounds, OnMarketOpen) == 0x000370, "Member 'ALimitedEventManagerFairgrounds::OnMarketOpen' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, OnMarketClose) == 0x000380, "Member 'ALimitedEventManagerFairgrounds::OnMarketClose' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, MarketOpenTime) == 0x000390, "Member 'ALimitedEventManagerFairgrounds::MarketOpenTime' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, MarketCloseTime) == 0x000398, "Member 'ALimitedEventManagerFairgrounds::MarketCloseTime' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, ChapaaChaseStartTime) == 0x0003A0, "Member 'ALimitedEventManagerFairgrounds::ChapaaChaseStartTime' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, FireworkShowStartTime) == 0x0003A8, "Member 'ALimitedEventManagerFairgrounds::FireworkShowStartTime' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, FireworkLaunchedStatName) == 0x0003B0, "Member 'ALimitedEventManagerFairgrounds::FireworkLaunchedStatName' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, SpaceVisitedStatName) == 0x0003C0, "Member 'ALimitedEventManagerFairgrounds::SpaceVisitedStatName' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, OnPlayerEnteredSpace) == 0x0003D0, "Member 'ALimitedEventManagerFairgrounds::OnPlayerEnteredSpace' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, OnPlayerExitedSpace) == 0x0003E0, "Member 'ALimitedEventManagerFairgrounds::OnPlayerExitedSpace' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, OnFireworkShowStarted) == 0x0003F0, "Member 'ALimitedEventManagerFairgrounds::OnFireworkShowStarted' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, FireworkItemTagContainer) == 0x000400, "Member 'ALimitedEventManagerFairgrounds::FireworkItemTagContainer' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, bIsMarketOpen) == 0x000450, "Member 'ALimitedEventManagerFairgrounds::bIsMarketOpen' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, CurrentPlayersInSpace) == 0x000458, "Member 'ALimitedEventManagerFairgrounds::CurrentPlayersInSpace' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerFairgrounds, CachedChapaaChaseManager) == 0x000468, "Member 'ALimitedEventManagerFairgrounds::CachedChapaaChaseManager' has a wrong offset!");

// Class Palia.LimitedEventManagerLNY
// 0x00F8 (0x0568 - 0x0470)
class ALimitedEventManagerLNY : public ALimitedEventManagerFairgrounds
{
public:
	class FString                                 StatNameHotPotComplete;                            // 0x0470(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameHotPotWin;                                 // 0x0480(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameHotPotWin_Salty;                           // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameHotPotWin_Spicy;                           // 0x04A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameHotPotWin_Tangy;                           // 0x04B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameHotPotWin_Umami;                           // 0x04C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNameWishesMade;                                // 0x04D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrizeWheelActorTag;                                // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNamePrizeWheelSpins;                           // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurrencyConfig>         PrizeWheelTicketCurrency;                          // 0x04F8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatNamePrizeWheelTickets;                         // 0x0520(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ACardTable*>                     HotPotTables;                                      // 0x0530(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AWishTree*                              CurrentWishTree;                                   // 0x0540(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVAL_PrizeWheelComponent*               CurrentPrizeWheelComponent;                        // 0x0548(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     ChestInteractableClass;                            // 0x0550(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ChestInteractedStatName;                           // 0x0558(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleCharacterEnteredSubgame(class USubgameActivatorComponent* SubgameActivator, class AValeriaCharacter* Character);
	void HandleHotPotGameEnd(class UHotPotSubgameManager* HotPotManager, struct FHotPotGameEndState& GameEndState);
	void HandlePrizeWheelRewardGranted(class AValeriaCharacter* SpinningCharacter, struct FVAL_PrizeWheelSlotDef& RewardedSlotDef);
	void HandleServerInteracted(class UInteractorComponent* Interactor, class UInteractableComponent* Interactable, struct FServerUseEventResult& UseResult);
	void HandleWishMade(class AWishTree* WishTree, class AValeriaCharacter* ValeriaCharacter, struct FValeriaItem& WishItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventManagerLNY">();
	}
	static class ALimitedEventManagerLNY* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALimitedEventManagerLNY>();
	}
};
static_assert(alignof(ALimitedEventManagerLNY) == 0x000008, "Wrong alignment on ALimitedEventManagerLNY");
static_assert(sizeof(ALimitedEventManagerLNY) == 0x000568, "Wrong size on ALimitedEventManagerLNY");
static_assert(offsetof(ALimitedEventManagerLNY, StatNameHotPotComplete) == 0x000470, "Member 'ALimitedEventManagerLNY::StatNameHotPotComplete' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, StatNameHotPotWin) == 0x000480, "Member 'ALimitedEventManagerLNY::StatNameHotPotWin' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, StatNameHotPotWin_Salty) == 0x000490, "Member 'ALimitedEventManagerLNY::StatNameHotPotWin_Salty' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, StatNameHotPotWin_Spicy) == 0x0004A0, "Member 'ALimitedEventManagerLNY::StatNameHotPotWin_Spicy' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, StatNameHotPotWin_Tangy) == 0x0004B0, "Member 'ALimitedEventManagerLNY::StatNameHotPotWin_Tangy' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, StatNameHotPotWin_Umami) == 0x0004C0, "Member 'ALimitedEventManagerLNY::StatNameHotPotWin_Umami' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, StatNameWishesMade) == 0x0004D0, "Member 'ALimitedEventManagerLNY::StatNameWishesMade' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, PrizeWheelActorTag) == 0x0004E0, "Member 'ALimitedEventManagerLNY::PrizeWheelActorTag' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, StatNamePrizeWheelSpins) == 0x0004E8, "Member 'ALimitedEventManagerLNY::StatNamePrizeWheelSpins' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, PrizeWheelTicketCurrency) == 0x0004F8, "Member 'ALimitedEventManagerLNY::PrizeWheelTicketCurrency' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, StatNamePrizeWheelTickets) == 0x000520, "Member 'ALimitedEventManagerLNY::StatNamePrizeWheelTickets' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, HotPotTables) == 0x000530, "Member 'ALimitedEventManagerLNY::HotPotTables' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, CurrentWishTree) == 0x000540, "Member 'ALimitedEventManagerLNY::CurrentWishTree' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, CurrentPrizeWheelComponent) == 0x000548, "Member 'ALimitedEventManagerLNY::CurrentPrizeWheelComponent' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, ChestInteractableClass) == 0x000550, "Member 'ALimitedEventManagerLNY::ChestInteractableClass' has a wrong offset!");
static_assert(offsetof(ALimitedEventManagerLNY, ChestInteractedStatName) == 0x000558, "Member 'ALimitedEventManagerLNY::ChestInteractedStatName' has a wrong offset!");

// Class Palia.TimeOfDayAudioActor
// 0x0010 (0x02B8 - 0x02A8)
class ATimeOfDayAudioActor : public AActor
{
public:
	TArray<struct FTimeOfDayAudio>                AudioSettings;                                     // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeOfDayAudioActor">();
	}
	static class ATimeOfDayAudioActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimeOfDayAudioActor>();
	}
};
static_assert(alignof(ATimeOfDayAudioActor) == 0x000008, "Wrong alignment on ATimeOfDayAudioActor");
static_assert(sizeof(ATimeOfDayAudioActor) == 0x0002B8, "Wrong size on ATimeOfDayAudioActor");
static_assert(offsetof(ATimeOfDayAudioActor, AudioSettings) == 0x0002A8, "Member 'ATimeOfDayAudioActor::AudioSettings' has a wrong offset!");

// Class Palia.LimitedEventManagerMajiMarket
// 0x0000 (0x0470 - 0x0470)
class ALimitedEventManagerMajiMarket : public ALimitedEventManagerFairgrounds
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventManagerMajiMarket">();
	}
	static class ALimitedEventManagerMajiMarket* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALimitedEventManagerMajiMarket>();
	}
};
static_assert(alignof(ALimitedEventManagerMajiMarket) == 0x000008, "Wrong alignment on ALimitedEventManagerMajiMarket");
static_assert(sizeof(ALimitedEventManagerMajiMarket) == 0x000470, "Wrong size on ALimitedEventManagerMajiMarket");

// Class Palia.LimitedEventManagerSummer
// 0x0000 (0x0370 - 0x0370)
class ALimitedEventManagerSummer : public ALimitedEventManagerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventManagerSummer">();
	}
	static class ALimitedEventManagerSummer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALimitedEventManagerSummer>();
	}
};
static_assert(alignof(ALimitedEventManagerSummer) == 0x000008, "Wrong alignment on ALimitedEventManagerSummer");
static_assert(sizeof(ALimitedEventManagerSummer) == 0x000370, "Wrong size on ALimitedEventManagerSummer");

// Class Palia.ValeriaAkHomeVerbComponent
// 0x0070 (0x03A0 - 0x0330)
class UValeriaAkHomeVerbComponent : public UAkLateReverbComponent
{
public:
	class UAkRoomComponent*                       RoomComponent;                                     // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentTotalAbsorption;                            // 0x0330(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294B[0x4];                                     // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbsorptionAuxBusSetting>       AuxBusSettings;                                    // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SendLevelDb;                                       // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VFadeRate;                                         // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UGatherableComponent*>             Gatherables;                                       // 0x0350(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	bool AddGatherable(class UGatherableComponent* GatherableComp);
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void UpdateAbsorption();
	void UpdateAuxBus(class UAkAuxBus* NewBus);
	void UpdateRoom();

	class UAkRoomComponent* GetRoomComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaAkHomeVerbComponent">();
	}
	static class UValeriaAkHomeVerbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaAkHomeVerbComponent>();
	}
};
static_assert(alignof(UValeriaAkHomeVerbComponent) == 0x000010, "Wrong alignment on UValeriaAkHomeVerbComponent");
static_assert(sizeof(UValeriaAkHomeVerbComponent) == 0x0003A0, "Wrong size on UValeriaAkHomeVerbComponent");
static_assert(offsetof(UValeriaAkHomeVerbComponent, RoomComponent) == 0x000328, "Member 'UValeriaAkHomeVerbComponent::RoomComponent' has a wrong offset!");
static_assert(offsetof(UValeriaAkHomeVerbComponent, CurrentTotalAbsorption) == 0x000330, "Member 'UValeriaAkHomeVerbComponent::CurrentTotalAbsorption' has a wrong offset!");
static_assert(offsetof(UValeriaAkHomeVerbComponent, AuxBusSettings) == 0x000338, "Member 'UValeriaAkHomeVerbComponent::AuxBusSettings' has a wrong offset!");
static_assert(offsetof(UValeriaAkHomeVerbComponent, SendLevelDb) == 0x000348, "Member 'UValeriaAkHomeVerbComponent::SendLevelDb' has a wrong offset!");
static_assert(offsetof(UValeriaAkHomeVerbComponent, VFadeRate) == 0x00034C, "Member 'UValeriaAkHomeVerbComponent::VFadeRate' has a wrong offset!");
static_assert(offsetof(UValeriaAkHomeVerbComponent, Gatherables) == 0x000350, "Member 'UValeriaAkHomeVerbComponent::Gatherables' has a wrong offset!");

// Class Palia.LimitedEventSubsystem
// 0x0060 (0x0090 - 0x0030)
class ULimitedEventSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnAnyEventStateChanged;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLimitedEventManagerRegistered;                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_294F[0x20];                                    // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLimitedEventMetadata>          CurrentEvents;                                     // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2950[0x10];                                    // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleEventStateChange(class ALimitedEventManagerBase* EventManager, bool bIsEventActive);

	TArray<TSoftObjectPtr<class ULimitedEventDataAsset>> GetActiveEvents() const;
	TArray<TSoftObjectPtr<class ULimitedEventDataAsset>> GetAllPreviewEvents() const;
	struct FGuid GetEventIdByName(class FName& EventName) const;
	class ALimitedEventManagerBase* GetEventManager(class ULimitedEventDataAsset* LimitedEventDataAsset) const;
	class ALimitedEventManagerBase* GetEventManagerBySoftObjPtr(TSoftObjectPtr<class ULimitedEventDataAsset> EventPtrObjPtr) const;
	class FString GetEventNameById(struct FGuid& EventId) const;
	bool IsAnyEventActive() const;
	bool IsEventActive(class ULimitedEventDataAsset* LimitedEventDataAsset) const;
	bool IsEventIdActive(struct FGuid& EventId) const;
	bool IsEventPreview(class ULimitedEventDataAsset* LimitedEventDataAsset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedEventSubsystem">();
	}
	static class ULimitedEventSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitedEventSubsystem>();
	}
};
static_assert(alignof(ULimitedEventSubsystem) == 0x000008, "Wrong alignment on ULimitedEventSubsystem");
static_assert(sizeof(ULimitedEventSubsystem) == 0x000090, "Wrong size on ULimitedEventSubsystem");
static_assert(offsetof(ULimitedEventSubsystem, OnAnyEventStateChanged) == 0x000030, "Member 'ULimitedEventSubsystem::OnAnyEventStateChanged' has a wrong offset!");
static_assert(offsetof(ULimitedEventSubsystem, OnLimitedEventManagerRegistered) == 0x000040, "Member 'ULimitedEventSubsystem::OnLimitedEventManagerRegistered' has a wrong offset!");
static_assert(offsetof(ULimitedEventSubsystem, CurrentEvents) == 0x000070, "Member 'ULimitedEventSubsystem::CurrentEvents' has a wrong offset!");

// Class Palia.LocalStateComponent
// 0x0000 (0x00A0 - 0x00A0)
class ULocalStateComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalStateComponent">();
	}
	static class ULocalStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalStateComponent>();
	}
};
static_assert(alignof(ULocalStateComponent) == 0x000008, "Wrong alignment on ULocalStateComponent");
static_assert(sizeof(ULocalStateComponent) == 0x0000A0, "Wrong size on ULocalStateComponent");

// Class Palia.TransitiveDecorComponent
// 0x0060 (0x0100 - 0x00A0)
class UTransitiveDecorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnProgressTransitiveDecor;                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTransitiveStimulusUpdate;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          ManualTransition;                                  // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2955[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSessionActorId                        SessionActorId;                                    // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVAL_TransitiveDecorAsset*              AssetReference;                                    // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentState;                                      // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransitiveDecorStimulusType                  CurrentStimulusType;                               // 0x00D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2956[0x3];                                     // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentStimulusValue;                              // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentStimulusValueTarget;                        // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TransitiveRootNode;                                // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        PlacementGhostNode;                                // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>                TransitiveAssetComponents;                         // 0x00F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool CanInteractOnCurrentState(class AValeriaCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransitiveDecorComponent">();
	}
	static class UTransitiveDecorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransitiveDecorComponent>();
	}
};
static_assert(alignof(UTransitiveDecorComponent) == 0x000008, "Wrong alignment on UTransitiveDecorComponent");
static_assert(sizeof(UTransitiveDecorComponent) == 0x000100, "Wrong size on UTransitiveDecorComponent");
static_assert(offsetof(UTransitiveDecorComponent, OnProgressTransitiveDecor) == 0x0000A0, "Member 'UTransitiveDecorComponent::OnProgressTransitiveDecor' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, OnTransitiveStimulusUpdate) == 0x0000B0, "Member 'UTransitiveDecorComponent::OnTransitiveStimulusUpdate' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, ManualTransition) == 0x0000C0, "Member 'UTransitiveDecorComponent::ManualTransition' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, SessionActorId) == 0x0000C4, "Member 'UTransitiveDecorComponent::SessionActorId' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, AssetReference) == 0x0000C8, "Member 'UTransitiveDecorComponent::AssetReference' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, CurrentState) == 0x0000D0, "Member 'UTransitiveDecorComponent::CurrentState' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, CurrentStimulusType) == 0x0000D4, "Member 'UTransitiveDecorComponent::CurrentStimulusType' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, CurrentStimulusValue) == 0x0000D8, "Member 'UTransitiveDecorComponent::CurrentStimulusValue' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, CurrentStimulusValueTarget) == 0x0000DC, "Member 'UTransitiveDecorComponent::CurrentStimulusValueTarget' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, TransitiveRootNode) == 0x0000E0, "Member 'UTransitiveDecorComponent::TransitiveRootNode' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, PlacementGhostNode) == 0x0000E8, "Member 'UTransitiveDecorComponent::PlacementGhostNode' has a wrong offset!");
static_assert(offsetof(UTransitiveDecorComponent, TransitiveAssetComponents) == 0x0000F0, "Member 'UTransitiveDecorComponent::TransitiveAssetComponents' has a wrong offset!");

// Class Palia.LonelyActorTrackingComponent
// 0x0030 (0x00D0 - 0x00A0)
class ULonelyActorTrackingComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnActorAloneChanged;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsNeverLonely;                                    // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2958[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsBeforeDeactivating;                         // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastAloneTime;                                     // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMarkedAlone;                                    // 0x00BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsReallyAlone;                                    // 0x00BD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2959[0x2];                                     // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                ComponentsToDeactivate;                            // 0x00C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void ActorAloneChanged(bool IsNowAlone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LonelyActorTrackingComponent">();
	}
	static class ULonelyActorTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULonelyActorTrackingComponent>();
	}
};
static_assert(alignof(ULonelyActorTrackingComponent) == 0x000008, "Wrong alignment on ULonelyActorTrackingComponent");
static_assert(sizeof(ULonelyActorTrackingComponent) == 0x0000D0, "Wrong size on ULonelyActorTrackingComponent");
static_assert(offsetof(ULonelyActorTrackingComponent, OnActorAloneChanged) == 0x0000A0, "Member 'ULonelyActorTrackingComponent::OnActorAloneChanged' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingComponent, bIsNeverLonely) == 0x0000B0, "Member 'ULonelyActorTrackingComponent::bIsNeverLonely' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingComponent, SecondsBeforeDeactivating) == 0x0000B4, "Member 'ULonelyActorTrackingComponent::SecondsBeforeDeactivating' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingComponent, LastAloneTime) == 0x0000B8, "Member 'ULonelyActorTrackingComponent::LastAloneTime' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingComponent, bIsMarkedAlone) == 0x0000BC, "Member 'ULonelyActorTrackingComponent::bIsMarkedAlone' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingComponent, bIsReallyAlone) == 0x0000BD, "Member 'ULonelyActorTrackingComponent::bIsReallyAlone' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingComponent, ComponentsToDeactivate) == 0x0000C0, "Member 'ULonelyActorTrackingComponent::ComponentsToDeactivate' has a wrong offset!");

// Class Palia.LonelyActorTrackingManager
// 0x0078 (0x00A8 - 0x0030)
class ULonelyActorTrackingManager final : public UGameInstanceSubsystem
{
public:
	float                                         GridSize;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerGridRange;                                   // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULonelyActorTrackingComponent*>  WatchList;                                         // 0x0038(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_295A[0x50];                                    // 0x0048(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           UpdateAloneStatusTimerHandle;                      // 0x0098(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           UpdateDebugViewTimerHandle;                        // 0x00A0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LonelyActorTrackingManager">();
	}
	static class ULonelyActorTrackingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULonelyActorTrackingManager>();
	}
};
static_assert(alignof(ULonelyActorTrackingManager) == 0x000008, "Wrong alignment on ULonelyActorTrackingManager");
static_assert(sizeof(ULonelyActorTrackingManager) == 0x0000A8, "Wrong size on ULonelyActorTrackingManager");
static_assert(offsetof(ULonelyActorTrackingManager, GridSize) == 0x000030, "Member 'ULonelyActorTrackingManager::GridSize' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingManager, PlayerGridRange) == 0x000034, "Member 'ULonelyActorTrackingManager::PlayerGridRange' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingManager, WatchList) == 0x000038, "Member 'ULonelyActorTrackingManager::WatchList' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingManager, UpdateAloneStatusTimerHandle) == 0x000098, "Member 'ULonelyActorTrackingManager::UpdateAloneStatusTimerHandle' has a wrong offset!");
static_assert(offsetof(ULonelyActorTrackingManager, UpdateDebugViewTimerHandle) == 0x0000A0, "Member 'ULonelyActorTrackingManager::UpdateDebugViewTimerHandle' has a wrong offset!");

// Class Palia.WorldGatherableBase
// 0x0060 (0x0308 - 0x02A8)
class AWorldGatherableBase : public AActor
{
public:
	class USceneComponent*                        GatherableRootComponent;                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        RootVisual;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MeshVisual;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       InteractableCollider;                              // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkCulledComponent*                     AkCulledComponent;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticLootInteractorComponent*         StaticLootInteractorComponent;                     // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          IdleLoopSFX;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          GatherSFX;                                         // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClientValidForGather;                             // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295B[0x7];                                     // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      CachedLocalValeriaCharacter;                       // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TryGetValeriaCharacterTimerHandle;                 // 0x0300(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BPIE_GatherableDisabled();
	void BPIE_GatherableEnabled();
	void BPIE_GatherableGathered(class AValeriaCharacter* GatheringCharacter);
	void CharacterGatheredLoot(class AValeriaCharacter* GatheringCharacter, class ULootInteractorBaseComponent* GatheredLootComponent);
	void Client_TryGetValeriaCharacter();
	void RpcNetMulticast_RequestUpdateGatherableEnabledState();
	void SetGatherableEnabled(bool bInEnabled);
	void UpdateGatherableEnabledState();

	bool CanGather(class AValeriaCharacter* GatheringCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldGatherableBase">();
	}
	static class AWorldGatherableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldGatherableBase>();
	}
};
static_assert(alignof(AWorldGatherableBase) == 0x000008, "Wrong alignment on AWorldGatherableBase");
static_assert(sizeof(AWorldGatherableBase) == 0x000308, "Wrong size on AWorldGatherableBase");
static_assert(offsetof(AWorldGatherableBase, GatherableRootComponent) == 0x0002A8, "Member 'AWorldGatherableBase::GatherableRootComponent' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, RootVisual) == 0x0002B0, "Member 'AWorldGatherableBase::RootVisual' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, MeshVisual) == 0x0002B8, "Member 'AWorldGatherableBase::MeshVisual' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, InteractableCollider) == 0x0002C0, "Member 'AWorldGatherableBase::InteractableCollider' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, AkCulledComponent) == 0x0002C8, "Member 'AWorldGatherableBase::AkCulledComponent' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, InteractableComponent) == 0x0002D0, "Member 'AWorldGatherableBase::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, StaticLootInteractorComponent) == 0x0002D8, "Member 'AWorldGatherableBase::StaticLootInteractorComponent' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, IdleLoopSFX) == 0x0002E0, "Member 'AWorldGatherableBase::IdleLoopSFX' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, GatherSFX) == 0x0002E8, "Member 'AWorldGatherableBase::GatherSFX' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, bClientValidForGather) == 0x0002F0, "Member 'AWorldGatherableBase::bClientValidForGather' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, CachedLocalValeriaCharacter) == 0x0002F8, "Member 'AWorldGatherableBase::CachedLocalValeriaCharacter' has a wrong offset!");
static_assert(offsetof(AWorldGatherableBase, TryGetValeriaCharacterTimerHandle) == 0x000300, "Member 'AWorldGatherableBase::TryGetValeriaCharacterTimerHandle' has a wrong offset!");

// Class Palia.TimedLootPile
// 0x0010 (0x0318 - 0x0308)
class ATimedLootPile final : public AWorldGatherableBase
{
public:
	bool                                          bInitialized;                                      // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295D[0x3];                                     // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GroupTag;                                          // 0x030C(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActivated;                                        // 0x0314(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295E[0x3];                                     // 0x0315(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bActivated();
	void TimedLootPileAdded(const struct FGameplayTag& InTag, class FName InActorName);

	bool IsActivated() const;
	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedLootPile">();
	}
	static class ATimedLootPile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimedLootPile>();
	}
};
static_assert(alignof(ATimedLootPile) == 0x000008, "Wrong alignment on ATimedLootPile");
static_assert(sizeof(ATimedLootPile) == 0x000318, "Wrong size on ATimedLootPile");
static_assert(offsetof(ATimedLootPile, bInitialized) == 0x000308, "Member 'ATimedLootPile::bInitialized' has a wrong offset!");
static_assert(offsetof(ATimedLootPile, GroupTag) == 0x00030C, "Member 'ATimedLootPile::GroupTag' has a wrong offset!");
static_assert(offsetof(ATimedLootPile, bActivated) == 0x000314, "Member 'ATimedLootPile::bActivated' has a wrong offset!");

// Class Palia.StaticLootInteractorComponent
// 0x0050 (0x0138 - 0x00E8)
class UStaticLootInteractorComponent final : public ULootInteractorBaseComponent
{
public:
	struct FTimerHandle                           CacheClientFirstCharacterTimerHandle;              // 0x00E8(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AValeriaCharacter*                      ClientFirstCharacter;                              // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FQuestReward>                   Loot;                                              // 0x00F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         RandomLootSeed;                                    // 0x0108(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295F[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestRewardConfig>             RewardConfiguration;                               // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    LootBundleConfig;                                  // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDetermineLootOnPickup;                            // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoDisableWhenNoQuestsCanStart;                  // 0x0131(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoDisableWhenTagWritebackAlreadySet;            // 0x0132(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2960[0x5];                                     // 0x0133(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_RandomLootSeed();
	void Server_ChangeRandomLootSeed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticLootInteractorComponent">();
	}
	static class UStaticLootInteractorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticLootInteractorComponent>();
	}
};
static_assert(alignof(UStaticLootInteractorComponent) == 0x000008, "Wrong alignment on UStaticLootInteractorComponent");
static_assert(sizeof(UStaticLootInteractorComponent) == 0x000138, "Wrong size on UStaticLootInteractorComponent");
static_assert(offsetof(UStaticLootInteractorComponent, CacheClientFirstCharacterTimerHandle) == 0x0000E8, "Member 'UStaticLootInteractorComponent::CacheClientFirstCharacterTimerHandle' has a wrong offset!");
static_assert(offsetof(UStaticLootInteractorComponent, ClientFirstCharacter) == 0x0000F0, "Member 'UStaticLootInteractorComponent::ClientFirstCharacter' has a wrong offset!");
static_assert(offsetof(UStaticLootInteractorComponent, Loot) == 0x0000F8, "Member 'UStaticLootInteractorComponent::Loot' has a wrong offset!");
static_assert(offsetof(UStaticLootInteractorComponent, RandomLootSeed) == 0x000108, "Member 'UStaticLootInteractorComponent::RandomLootSeed' has a wrong offset!");
static_assert(offsetof(UStaticLootInteractorComponent, RewardConfiguration) == 0x000110, "Member 'UStaticLootInteractorComponent::RewardConfiguration' has a wrong offset!");
static_assert(offsetof(UStaticLootInteractorComponent, LootBundleConfig) == 0x000120, "Member 'UStaticLootInteractorComponent::LootBundleConfig' has a wrong offset!");
static_assert(offsetof(UStaticLootInteractorComponent, bDetermineLootOnPickup) == 0x000130, "Member 'UStaticLootInteractorComponent::bDetermineLootOnPickup' has a wrong offset!");
static_assert(offsetof(UStaticLootInteractorComponent, bAutoDisableWhenNoQuestsCanStart) == 0x000131, "Member 'UStaticLootInteractorComponent::bAutoDisableWhenNoQuestsCanStart' has a wrong offset!");
static_assert(offsetof(UStaticLootInteractorComponent, bAutoDisableWhenTagWritebackAlreadySet) == 0x000132, "Member 'UStaticLootInteractorComponent::bAutoDisableWhenTagWritebackAlreadySet' has a wrong offset!");

// Class Palia.ValeriaAkCulledAmbientSound
// 0x0008 (0x02B0 - 0x02A8)
class AValeriaAkCulledAmbientSound final : public AActor
{
public:
	class UAkCulledComponent*                     AkCulledComponent;                                 // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaAkCulledAmbientSound">();
	}
	static class AValeriaAkCulledAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaAkCulledAmbientSound>();
	}
};
static_assert(alignof(AValeriaAkCulledAmbientSound) == 0x000008, "Wrong alignment on AValeriaAkCulledAmbientSound");
static_assert(sizeof(AValeriaAkCulledAmbientSound) == 0x0002B0, "Wrong size on AValeriaAkCulledAmbientSound");
static_assert(offsetof(AValeriaAkCulledAmbientSound, AkCulledComponent) == 0x0002A8, "Member 'AValeriaAkCulledAmbientSound::AkCulledComponent' has a wrong offset!");

// Class Palia.LootInteractorComponent
// 0x0058 (0x0140 - 0x00E8)
class ULootInteractorComponent final : public ULootInteractorBaseComponent
{
public:
	TArray<struct FQuestReward>                   SelectedLoot;                                      // 0x00E8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2961[0x8];                                     // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AValeriaCharacter*>              PlayersToGrantLootTo;                              // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2962[0x30];                                    // 0x0110(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAchievementCreditType(ELootAchievementCreditType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootInteractorComponent">();
	}
	static class ULootInteractorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootInteractorComponent>();
	}
};
static_assert(alignof(ULootInteractorComponent) == 0x000008, "Wrong alignment on ULootInteractorComponent");
static_assert(sizeof(ULootInteractorComponent) == 0x000140, "Wrong size on ULootInteractorComponent");
static_assert(offsetof(ULootInteractorComponent, SelectedLoot) == 0x0000E8, "Member 'ULootInteractorComponent::SelectedLoot' has a wrong offset!");
static_assert(offsetof(ULootInteractorComponent, PlayersToGrantLootTo) == 0x000100, "Member 'ULootInteractorComponent::PlayersToGrantLootTo' has a wrong offset!");

// Class Palia.MailboxComponent
// 0x00C8 (0x0168 - 0x00A0)
class UMailboxComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateMailCallSuccess;                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateMailCallFailure;                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSendMailCallSuccess;                             // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSendMailCallFailure;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetMailCallSuccess;                              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetMailCallFailure;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UMailboxStorage*                        MailboxStorage;                                    // 0x0100(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2963[0x60];                                    // 0x0108(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ArchiveMail(const class FString& MailId);
	void DeleteMail(const class FString& MailId);
	class FString GetCharacterName();
	void GetMail(const struct FMailboxFilter& MailboxFilter);
	class FString GetUserId();
	class AValeriaCharacter* GetValeriaCharacter();
	class UValeriaGameInstance* GetValeriaGameInstance();
	void MarkMailOpened(const class FString& MailId);
	void RpcClient_GetMailFailure(const class FString& Error);
	void RpcClient_GetMailResult(struct FMailbox& Mailbox);
	void RpcClient_NotifySendFailure(const class FString& Error);
	void RpcClient_NotifySendSuccess();
	void RpcClient_NotifyUpdateFailure(const class FString& Error);
	void RpcClient_NotifyUpdateSuccess();
	void RpcServer_GetMail(const struct FMailboxFilter& MailboxFilter);
	void RpcServer_SendMail(const struct FMail& Mail);
	void RpcServer_SetReadStatus(const class FString& MailId, EReadStatus ReadStatus);
	void RpcServer_TakeMailAction(const class FString& MailId);
	void SendMail(const struct FMail& Mail);
	void TakeMailAction(const class FString& MailId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailboxComponent">();
	}
	static class UMailboxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMailboxComponent>();
	}
};
static_assert(alignof(UMailboxComponent) == 0x000008, "Wrong alignment on UMailboxComponent");
static_assert(sizeof(UMailboxComponent) == 0x000168, "Wrong size on UMailboxComponent");
static_assert(offsetof(UMailboxComponent, OnUpdateMailCallSuccess) == 0x0000A0, "Member 'UMailboxComponent::OnUpdateMailCallSuccess' has a wrong offset!");
static_assert(offsetof(UMailboxComponent, OnUpdateMailCallFailure) == 0x0000B0, "Member 'UMailboxComponent::OnUpdateMailCallFailure' has a wrong offset!");
static_assert(offsetof(UMailboxComponent, OnSendMailCallSuccess) == 0x0000C0, "Member 'UMailboxComponent::OnSendMailCallSuccess' has a wrong offset!");
static_assert(offsetof(UMailboxComponent, OnSendMailCallFailure) == 0x0000D0, "Member 'UMailboxComponent::OnSendMailCallFailure' has a wrong offset!");
static_assert(offsetof(UMailboxComponent, OnGetMailCallSuccess) == 0x0000E0, "Member 'UMailboxComponent::OnGetMailCallSuccess' has a wrong offset!");
static_assert(offsetof(UMailboxComponent, OnGetMailCallFailure) == 0x0000F0, "Member 'UMailboxComponent::OnGetMailCallFailure' has a wrong offset!");
static_assert(offsetof(UMailboxComponent, MailboxStorage) == 0x000100, "Member 'UMailboxComponent::MailboxStorage' has a wrong offset!");

// Class Palia.ValeriaClientPriMovementComponent
// 0x0040 (0x0BC0 - 0x0B80)
class UValeriaClientPriMovementComponent : public UValeriaBaseMovementComponent
{
public:
	uint8                                         Pad_2965[0x1];                                     // 0x0B78(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EMovementMode                                 TargetMovementMode;                                // 0x0B79(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TargetCustomSubMode;                               // 0x0B7A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasStationary;                                    // 0x0B7B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2966[0x4];                                     // 0x0B7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PreviousRotationForStationaryCheck;                // 0x0B80(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                PreviousPositionForStationaryCheck;                // 0x0B98(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReceivedPostTeleportMove;                         // 0x0BB0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2967[0x3];                                     // 0x0BB1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SendServerRpcThrottleLimit;                        // 0x0BB4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SendServerRpcThrottleCounter;                      // 0x0BB8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastTeleport;                             // 0x0BBC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RpcServer_RequestFollowPawn(class AValeriaMoveablePawn* OtherPawn, float Distance);
	void RpcServer_RequestPathToPoint(const struct FVector& WorldPoint);
	void RpcServer_SendMovement(struct FValeriaClientToServerMoveInfo& MoveInfo);
	void StartPathToPoint(const struct FVector& WorldPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaClientPriMovementComponent">();
	}
	static class UValeriaClientPriMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaClientPriMovementComponent>();
	}
};
static_assert(alignof(UValeriaClientPriMovementComponent) == 0x000010, "Wrong alignment on UValeriaClientPriMovementComponent");
static_assert(sizeof(UValeriaClientPriMovementComponent) == 0x000BC0, "Wrong size on UValeriaClientPriMovementComponent");
static_assert(offsetof(UValeriaClientPriMovementComponent, TargetMovementMode) == 0x000B79, "Member 'UValeriaClientPriMovementComponent::TargetMovementMode' has a wrong offset!");
static_assert(offsetof(UValeriaClientPriMovementComponent, TargetCustomSubMode) == 0x000B7A, "Member 'UValeriaClientPriMovementComponent::TargetCustomSubMode' has a wrong offset!");
static_assert(offsetof(UValeriaClientPriMovementComponent, bWasStationary) == 0x000B7B, "Member 'UValeriaClientPriMovementComponent::bWasStationary' has a wrong offset!");
static_assert(offsetof(UValeriaClientPriMovementComponent, PreviousRotationForStationaryCheck) == 0x000B80, "Member 'UValeriaClientPriMovementComponent::PreviousRotationForStationaryCheck' has a wrong offset!");
static_assert(offsetof(UValeriaClientPriMovementComponent, PreviousPositionForStationaryCheck) == 0x000B98, "Member 'UValeriaClientPriMovementComponent::PreviousPositionForStationaryCheck' has a wrong offset!");
static_assert(offsetof(UValeriaClientPriMovementComponent, bReceivedPostTeleportMove) == 0x000BB0, "Member 'UValeriaClientPriMovementComponent::bReceivedPostTeleportMove' has a wrong offset!");
static_assert(offsetof(UValeriaClientPriMovementComponent, SendServerRpcThrottleLimit) == 0x000BB4, "Member 'UValeriaClientPriMovementComponent::SendServerRpcThrottleLimit' has a wrong offset!");
static_assert(offsetof(UValeriaClientPriMovementComponent, SendServerRpcThrottleCounter) == 0x000BB8, "Member 'UValeriaClientPriMovementComponent::SendServerRpcThrottleCounter' has a wrong offset!");
static_assert(offsetof(UValeriaClientPriMovementComponent, TimeSinceLastTeleport) == 0x000BBC, "Member 'UValeriaClientPriMovementComponent::TimeSinceLastTeleport' has a wrong offset!");

// Class Palia.MailboxStorage
// 0x0000 (0x0028 - 0x0028)
class UMailboxStorage final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailboxStorage">();
	}
	static class UMailboxStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMailboxStorage>();
	}
};
static_assert(alignof(UMailboxStorage) == 0x000008, "Wrong alignment on UMailboxStorage");
static_assert(sizeof(UMailboxStorage) == 0x000028, "Wrong size on UMailboxStorage");

// Class Palia.MapAreaTransformation
// 0x0058 (0x0300 - 0x02A8)
class AMapAreaTransformation final : public AActor
{
public:
	uint8                                         Pad_2969[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransformationStep>            TransformationSteps;                               // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FVAL_FoliageData>               OverlappingFoliageSpawnPoints;                     // 0x02C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_296A[0x8];                                     // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PercentDestroyedToTriggerDeactivation;             // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTransformationActive;                           // 0x02DC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_296B[0x23];                                    // 0x02DD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate();
	void Client_ActivateVFX();
	void Client_DeactivateVFX();
	void Deactivate();
	void HandleActorDestroyed(class AActor* DestroyedActor);
	void OnRep_IsTransformationActive();
	void Server_NotifyAllClients(EMapAreaTransformationNotificationType NotificationType);

	bool AreFlowTreeGrovesEnabled() const;
	bool CanActivate() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapAreaTransformation">();
	}
	static class AMapAreaTransformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapAreaTransformation>();
	}
};
static_assert(alignof(AMapAreaTransformation) == 0x000008, "Wrong alignment on AMapAreaTransformation");
static_assert(sizeof(AMapAreaTransformation) == 0x000300, "Wrong size on AMapAreaTransformation");
static_assert(offsetof(AMapAreaTransformation, TransformationSteps) == 0x0002B0, "Member 'AMapAreaTransformation::TransformationSteps' has a wrong offset!");
static_assert(offsetof(AMapAreaTransformation, OverlappingFoliageSpawnPoints) == 0x0002C0, "Member 'AMapAreaTransformation::OverlappingFoliageSpawnPoints' has a wrong offset!");
static_assert(offsetof(AMapAreaTransformation, PercentDestroyedToTriggerDeactivation) == 0x0002D8, "Member 'AMapAreaTransformation::PercentDestroyedToTriggerDeactivation' has a wrong offset!");
static_assert(offsetof(AMapAreaTransformation, bIsTransformationActive) == 0x0002DC, "Member 'AMapAreaTransformation::bIsTransformationActive' has a wrong offset!");

// Class Palia.ValeriaAkTriggerComponent
// 0x0010 (0x02B0 - 0x02A0)
class UValeriaAkTriggerComponent : public USceneComponent
{
public:
	class UPrimitiveComponent*                    PrimitiveParent;                                   // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_296C[0x8];                                     // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetParameters();
	void TriggerUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaAkTriggerComponent">();
	}
	static class UValeriaAkTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaAkTriggerComponent>();
	}
};
static_assert(alignof(UValeriaAkTriggerComponent) == 0x000010, "Wrong alignment on UValeriaAkTriggerComponent");
static_assert(sizeof(UValeriaAkTriggerComponent) == 0x0002B0, "Wrong size on UValeriaAkTriggerComponent");
static_assert(offsetof(UValeriaAkTriggerComponent, PrimitiveParent) == 0x0002A0, "Member 'UValeriaAkTriggerComponent::PrimitiveParent' has a wrong offset!");

// Class Palia.MeleeAttackCollider
// 0x0040 (0x02E0 - 0x02A0)
class UMeleeAttackCollider final : public USceneComponent
{
public:
	float                                         CollisionRadius;                                   // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DesiredCollisionTag;                               // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_296F[0x3];                                     // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnShapeCastHitDetected;                            // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2970[0x28];                                    // 0x02B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeAttackCollider">();
	}
	static class UMeleeAttackCollider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeleeAttackCollider>();
	}
};
static_assert(alignof(UMeleeAttackCollider) == 0x000010, "Wrong alignment on UMeleeAttackCollider");
static_assert(sizeof(UMeleeAttackCollider) == 0x0002E0, "Wrong size on UMeleeAttackCollider");
static_assert(offsetof(UMeleeAttackCollider, CollisionRadius) == 0x0002A0, "Member 'UMeleeAttackCollider::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UMeleeAttackCollider, DesiredCollisionTag) == 0x0002A4, "Member 'UMeleeAttackCollider::DesiredCollisionTag' has a wrong offset!");
static_assert(offsetof(UMeleeAttackCollider, OnShapeCastHitDetected) == 0x0002A8, "Member 'UMeleeAttackCollider::OnShapeCastHitDetected' has a wrong offset!");

// Class Palia.MeleeAttackComponent
// 0x0040 (0x00E0 - 0x00A0)
class UMeleeAttackComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnHitValidTargetServerSide;                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DashDistance;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2971[0x2C];                                    // 0x00B4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableWeaponCollision(class FName DesiredColliderTag);
	void EnableWeaponCollision(class FName DesiredColliderTag);
	void FireAnalyticsEvent(class AActor* HitActor);
	class AActor* GetEquippedMeleeWeapon();
	EMeleeAttackType GetLastPerformedMeleeAttack();
	bool IsLocalClient();
	void NotifySwingReady();
	void NotifySwingReadyEnd();
	void NotifyTargetHit(class AActor* Target);
	void NotifyTargetHitWithTargetData(const struct FGameplayAbilityTargetDataHandle& Target);
	void RpcServer_NotifyTargetHit(class AActor* Target);
	void SetLastPerformedMeleeAttack(EMeleeAttackType Type);
	class AActor* SnapToFaceEnemyInRange(float Radius, float AllowedAngle, const struct FGameplayTag& DesiredParticipationTag);
	void TriggerComboIfInputQueued(bool InputReleased);
	void TriggerDash(float DashDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeAttackComponent">();
	}
	static class UMeleeAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeleeAttackComponent>();
	}
};
static_assert(alignof(UMeleeAttackComponent) == 0x000008, "Wrong alignment on UMeleeAttackComponent");
static_assert(sizeof(UMeleeAttackComponent) == 0x0000E0, "Wrong size on UMeleeAttackComponent");
static_assert(offsetof(UMeleeAttackComponent, OnHitValidTargetServerSide) == 0x0000A0, "Member 'UMeleeAttackComponent::OnHitValidTargetServerSide' has a wrong offset!");
static_assert(offsetof(UMeleeAttackComponent, DashDistance) == 0x0000B0, "Member 'UMeleeAttackComponent::DashDistance' has a wrong offset!");

// Class Palia.Useable
// 0x0000 (0x0028 - 0x0028)
class IUseable final : public IInterface
{
public:
	struct FSelfUseEventResult OnClientUseEquippedInward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	struct FSelfUseEventResult OnClientUseEquippedOutward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Useable">();
	}
	static class IUseable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUseable>();
	}
};
static_assert(alignof(IUseable) == 0x000008, "Wrong alignment on IUseable");
static_assert(sizeof(IUseable) == 0x000028, "Wrong size on IUseable");

// Class Palia.MessageTargetManager
// 0x0058 (0x0088 - 0x0030)
class UMessageTargetManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnNewMessageTarget;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMessageTargetRemoved;                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<struct FMessageTarget>                 KnownMessageTargets;                               // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2974[0x28];                                    // 0x0060(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FMessageTarget MakeMessageTarget_DirectMessage(struct FUniqueNetIdRepl& RecipientNetId, const class FString& CharacterName);

	void AddNewMessageTarget(const struct FMessageTarget& NewTarget, int32 Param_Index);
	TArray<struct FMessageTarget> GetKnownMessageTargets();
	const struct FMessageTarget GetMostRecentDirectMessageTarget();
	void RemoveKnownMessageTarget(const struct FMessageTarget& TargetToRemove);

	void DumpAllKnownMessageTargets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageTargetManager">();
	}
	static class UMessageTargetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageTargetManager>();
	}
};
static_assert(alignof(UMessageTargetManager) == 0x000008, "Wrong alignment on UMessageTargetManager");
static_assert(sizeof(UMessageTargetManager) == 0x000088, "Wrong size on UMessageTargetManager");
static_assert(offsetof(UMessageTargetManager, OnNewMessageTarget) == 0x000030, "Member 'UMessageTargetManager::OnNewMessageTarget' has a wrong offset!");
static_assert(offsetof(UMessageTargetManager, OnMessageTargetRemoved) == 0x000040, "Member 'UMessageTargetManager::OnMessageTargetRemoved' has a wrong offset!");
static_assert(offsetof(UMessageTargetManager, KnownMessageTargets) == 0x000050, "Member 'UMessageTargetManager::KnownMessageTargets' has a wrong offset!");

// Class Palia.MinigameComponentTilling
// 0x0148 (0x0218 - 0x00D0)
class UMinigameComponentTilling final : public UMinigameComponentBase
{
public:
	FMulticastInlineDelegateProperty_             OnTillingStarted;                                  // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AGardenTile*>                    AvailableGardenActors;                             // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, class AGardenTile*>               TillingMaskRequests;                               // 0x00F0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class AGardenTile*, int64>               LastReadPixelsTimestamps;                          // 0x0140(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2976[0x50];                                    // 0x0190(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               TillingSplatBrush;                                 // 0x01E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeSpentOnCurrentTillSwing;                       // 0x01E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TillSwingDurationSecs;                             // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              TillSwingStartOffset;                              // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              TillSwingEndOffset;                                // 0x0200(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2977[0x8];                                     // 0x0210(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Till();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinigameComponentTilling">();
	}
	static class UMinigameComponentTilling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinigameComponentTilling>();
	}
};
static_assert(alignof(UMinigameComponentTilling) == 0x000008, "Wrong alignment on UMinigameComponentTilling");
static_assert(sizeof(UMinigameComponentTilling) == 0x000218, "Wrong size on UMinigameComponentTilling");
static_assert(offsetof(UMinigameComponentTilling, OnTillingStarted) == 0x0000D0, "Member 'UMinigameComponentTilling::OnTillingStarted' has a wrong offset!");
static_assert(offsetof(UMinigameComponentTilling, AvailableGardenActors) == 0x0000E0, "Member 'UMinigameComponentTilling::AvailableGardenActors' has a wrong offset!");
static_assert(offsetof(UMinigameComponentTilling, TillingMaskRequests) == 0x0000F0, "Member 'UMinigameComponentTilling::TillingMaskRequests' has a wrong offset!");
static_assert(offsetof(UMinigameComponentTilling, LastReadPixelsTimestamps) == 0x000140, "Member 'UMinigameComponentTilling::LastReadPixelsTimestamps' has a wrong offset!");
static_assert(offsetof(UMinigameComponentTilling, TillingSplatBrush) == 0x0001E0, "Member 'UMinigameComponentTilling::TillingSplatBrush' has a wrong offset!");
static_assert(offsetof(UMinigameComponentTilling, TimeSpentOnCurrentTillSwing) == 0x0001E8, "Member 'UMinigameComponentTilling::TimeSpentOnCurrentTillSwing' has a wrong offset!");
static_assert(offsetof(UMinigameComponentTilling, TillSwingDurationSecs) == 0x0001EC, "Member 'UMinigameComponentTilling::TillSwingDurationSecs' has a wrong offset!");
static_assert(offsetof(UMinigameComponentTilling, TillSwingStartOffset) == 0x0001F0, "Member 'UMinigameComponentTilling::TillSwingStartOffset' has a wrong offset!");
static_assert(offsetof(UMinigameComponentTilling, TillSwingEndOffset) == 0x000200, "Member 'UMinigameComponentTilling::TillSwingEndOffset' has a wrong offset!");

// Class Palia.MusicManager
// 0x0000 (0x0028 - 0x0028)
class UMusicManager : public UObject
{
public:
	void Initialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicManager">();
	}
	static class UMusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicManager>();
	}
};
static_assert(alignof(UMusicManager) == 0x000008, "Wrong alignment on UMusicManager");
static_assert(sizeof(UMusicManager) == 0x000028, "Wrong size on UMusicManager");

// Class Palia.NavPointComponent
// 0x0000 (0x05A0 - 0x05A0)
class UNavPointComponent final : public UBillboardComponent
{
public:
	class FName                                   Identifier;                                        // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavPointComponent">();
	}
	static class UNavPointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavPointComponent>();
	}
};
static_assert(alignof(UNavPointComponent) == 0x000010, "Wrong alignment on UNavPointComponent");
static_assert(sizeof(UNavPointComponent) == 0x0005A0, "Wrong size on UNavPointComponent");
static_assert(offsetof(UNavPointComponent, Identifier) == 0x000598, "Member 'UNavPointComponent::Identifier' has a wrong offset!");

// Class Palia.VAl_MapSettings
// 0x0088 (0x00C0 - 0x0038)
class UVAl_MapSettings final : public UDeveloperSettings
{
public:
	TMap<class FName, class FText>                MapDisplayNameTable;                               // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   InvalidMapDisplayName;                             // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         MapListing_DebugServers;                           // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWorld>>          MapsWithHousing;                                   // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAl_MapSettings">();
	}
	static class UVAl_MapSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAl_MapSettings>();
	}
};
static_assert(alignof(UVAl_MapSettings) == 0x000008, "Wrong alignment on UVAl_MapSettings");
static_assert(sizeof(UVAl_MapSettings) == 0x0000C0, "Wrong size on UVAl_MapSettings");
static_assert(offsetof(UVAl_MapSettings, MapDisplayNameTable) == 0x000038, "Member 'UVAl_MapSettings::MapDisplayNameTable' has a wrong offset!");
static_assert(offsetof(UVAl_MapSettings, InvalidMapDisplayName) == 0x000088, "Member 'UVAl_MapSettings::InvalidMapDisplayName' has a wrong offset!");
static_assert(offsetof(UVAl_MapSettings, MapListing_DebugServers) == 0x0000A0, "Member 'UVAl_MapSettings::MapListing_DebugServers' has a wrong offset!");
static_assert(offsetof(UVAl_MapSettings, MapsWithHousing) == 0x0000B0, "Member 'UVAl_MapSettings::MapsWithHousing' has a wrong offset!");

// Class Palia.PaliaEngine
// 0x0008 (0x10D8 - 0x10D0)
class UPaliaEngine final : public UGameEngine
{
public:
	uint8                                         Pad_2978[0x8];                                     // 0x10D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaliaEngine">();
	}
	static class UPaliaEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaliaEngine>();
	}
};
static_assert(alignof(UPaliaEngine) == 0x000008, "Wrong alignment on UPaliaEngine");
static_assert(sizeof(UPaliaEngine) == 0x0010D8, "Wrong size on UPaliaEngine");

// Class Palia.PaliaLoadingSettings
// 0x00C8 (0x0100 - 0x0038)
class UPaliaLoadingSettings final : public UDeveloperSettings
{
public:
	float                                         TimeToWaitForCharacterTeleportInSeconds;           // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2979[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPaliaLoadingScreenSettings            LoadScreen;                                        // 0x0040(0x0060)(Edit, Config, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LoadingScreenWidgetClass;                          // 0x00A0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPaliaLoadingScreenTip>         Tips;                                              // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         LoadingSecondsDownToBlack;                         // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingSecondsBlackToDown;                         // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingSecondsBlackToFull;                         // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingSecondsFullToBlack;                         // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingSecondsHold_ScalabilityLow;                 // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingSecondsHold_ScalabilityMedium;              // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingSecondsHold_ScalabilityHigh;                // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingSecondsHold_ScalabilityUltra;               // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadingSecondsUntilTimeout;                        // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_297A[0x4];                                     // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaliaLoadingSettings">();
	}
	static class UPaliaLoadingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaliaLoadingSettings>();
	}
};
static_assert(alignof(UPaliaLoadingSettings) == 0x000008, "Wrong alignment on UPaliaLoadingSettings");
static_assert(sizeof(UPaliaLoadingSettings) == 0x000100, "Wrong size on UPaliaLoadingSettings");
static_assert(offsetof(UPaliaLoadingSettings, TimeToWaitForCharacterTeleportInSeconds) == 0x000038, "Member 'UPaliaLoadingSettings::TimeToWaitForCharacterTeleportInSeconds' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadScreen) == 0x000040, "Member 'UPaliaLoadingSettings::LoadScreen' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingScreenWidgetClass) == 0x0000A0, "Member 'UPaliaLoadingSettings::LoadingScreenWidgetClass' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, Tips) == 0x0000C8, "Member 'UPaliaLoadingSettings::Tips' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingSecondsDownToBlack) == 0x0000D8, "Member 'UPaliaLoadingSettings::LoadingSecondsDownToBlack' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingSecondsBlackToDown) == 0x0000DC, "Member 'UPaliaLoadingSettings::LoadingSecondsBlackToDown' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingSecondsBlackToFull) == 0x0000E0, "Member 'UPaliaLoadingSettings::LoadingSecondsBlackToFull' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingSecondsFullToBlack) == 0x0000E4, "Member 'UPaliaLoadingSettings::LoadingSecondsFullToBlack' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingSecondsHold_ScalabilityLow) == 0x0000E8, "Member 'UPaliaLoadingSettings::LoadingSecondsHold_ScalabilityLow' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingSecondsHold_ScalabilityMedium) == 0x0000EC, "Member 'UPaliaLoadingSettings::LoadingSecondsHold_ScalabilityMedium' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingSecondsHold_ScalabilityHigh) == 0x0000F0, "Member 'UPaliaLoadingSettings::LoadingSecondsHold_ScalabilityHigh' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingSecondsHold_ScalabilityUltra) == 0x0000F4, "Member 'UPaliaLoadingSettings::LoadingSecondsHold_ScalabilityUltra' has a wrong offset!");
static_assert(offsetof(UPaliaLoadingSettings, LoadingSecondsUntilTimeout) == 0x0000F8, "Member 'UPaliaLoadingSettings::LoadingSecondsUntilTimeout' has a wrong offset!");

// Class Palia.VillagerStoreConfig
// 0x01F0 (0x0220 - 0x0030)
class UVillagerStoreConfig final : public UDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UCurrencyConfig*                        PrimaryCurrency;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLootRequirements                      Requirements;                                      // 0x0050(0x00D8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EItemCategory>                         BuyCategories;                                     // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTagList                               BuyTags;                                           // 0x0138(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FStoreItemConfig>               Items;                                             // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStoreRecipeConfig>             Recipes;                                           // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         VillagerIdToGainFriendshipFor;                     // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VillagerCoreIdToGainFriendshipFor;                 // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     FriendshipForCost;                                 // 0x0180(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FQuestRewardConfig>             BuyRewards;                                        // 0x0208(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EStoreTab                                     StoreTabOnOpen;                                    // 0x0218(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_297B[0x7];                                     // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerStoreConfig">();
	}
	static class UVillagerStoreConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerStoreConfig>();
	}
};
static_assert(alignof(UVillagerStoreConfig) == 0x000008, "Wrong alignment on UVillagerStoreConfig");
static_assert(sizeof(UVillagerStoreConfig) == 0x000220, "Wrong size on UVillagerStoreConfig");
static_assert(offsetof(UVillagerStoreConfig, DisplayName) == 0x000030, "Member 'UVillagerStoreConfig::DisplayName' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, PrimaryCurrency) == 0x000048, "Member 'UVillagerStoreConfig::PrimaryCurrency' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, Requirements) == 0x000050, "Member 'UVillagerStoreConfig::Requirements' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, BuyCategories) == 0x000128, "Member 'UVillagerStoreConfig::BuyCategories' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, BuyTags) == 0x000138, "Member 'UVillagerStoreConfig::BuyTags' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, Items) == 0x000158, "Member 'UVillagerStoreConfig::Items' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, Recipes) == 0x000168, "Member 'UVillagerStoreConfig::Recipes' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, VillagerIdToGainFriendshipFor) == 0x000178, "Member 'UVillagerStoreConfig::VillagerIdToGainFriendshipFor' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, VillagerCoreIdToGainFriendshipFor) == 0x00017C, "Member 'UVillagerStoreConfig::VillagerCoreIdToGainFriendshipFor' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, FriendshipForCost) == 0x000180, "Member 'UVillagerStoreConfig::FriendshipForCost' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, BuyRewards) == 0x000208, "Member 'UVillagerStoreConfig::BuyRewards' has a wrong offset!");
static_assert(offsetof(UVillagerStoreConfig, StoreTabOnOpen) == 0x000218, "Member 'UVillagerStoreConfig::StoreTabOnOpen' has a wrong offset!");

// Class Palia.PaliaScreenManager
// 0x0180 (0x01B0 - 0x0030)
class UPaliaScreenManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_297C[0x70];                                    // 0x0030(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnScreenStateChanged;                              // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_297D[0x100];                                   // 0x00B0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsLoadingScreenVisible();
	void OnScreenStateChanged__DelegateSignature(EPaliaScreenState State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaliaScreenManager">();
	}
	static class UPaliaScreenManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaliaScreenManager>();
	}
};
static_assert(alignof(UPaliaScreenManager) == 0x000008, "Wrong alignment on UPaliaScreenManager");
static_assert(sizeof(UPaliaScreenManager) == 0x0001B0, "Wrong size on UPaliaScreenManager");
static_assert(offsetof(UPaliaScreenManager, OnScreenStateChanged) == 0x0000A0, "Member 'UPaliaScreenManager::OnScreenStateChanged' has a wrong offset!");

// Class Palia.ParticipantComponent
// 0x0000 (0x00A0 - 0x00A0)
class UParticipantComponent final : public UActorComponent
{
public:
	bool FlagAsParticipant(const struct FGameplayTag& ParticipationTag, float ParticipationRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticipantComponent">();
	}
	static class UParticipantComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticipantComponent>();
	}
};
static_assert(alignof(UParticipantComponent) == 0x000008, "Wrong alignment on UParticipantComponent");
static_assert(sizeof(UParticipantComponent) == 0x0000A0, "Wrong size on UParticipantComponent");

// Class Palia.VisibilityComponent
// 0x0050 (0x00F0 - 0x00A0)
class UVisibilityComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnVisibilityComponentStateChanged;                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 OwningActor;                                       // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class IVisibilityInterface>  OwningActorVisibilityInterface;                    // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVAL_VisibilityModifierSource>  ServerVisibilityModifierSources;                   // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVAL_VisibilityModifierSource>  ClientVisibilityModifierSources;                   // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bVisible;                                          // 0x00E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_297F[0x7];                                     // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_AddVisibilityModifierSource(struct FVAL_VisibilityModifierSource& NewVisibilityModifierSource);
	bool Client_RemoveVisibilityModifierSourceByKey(class FName InKey);
	bool Client_RemoveVisibilityModifierSourceByObject(class UObject* InObject);
	TArray<struct FVAL_VisibilityModifierSource> GetVisibilityModifierSources(bool bServerSide);
	void OnRep_ServerVisibilityModifierSources();
	void Server_AddVisibilityModifierSource(struct FVAL_VisibilityModifierSource& NewVisibilityModifierSource);
	bool Server_RemoveVisibilityModifierSourceByKey(class FName InKey);
	bool Server_RemoveVisibilityModifierSourceByObject(class UObject* InObject);
	void SourceActorDestroyed(class AActor* DestroyedActor);

	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibilityComponent">();
	}
	static class UVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibilityComponent>();
	}
};
static_assert(alignof(UVisibilityComponent) == 0x000008, "Wrong alignment on UVisibilityComponent");
static_assert(sizeof(UVisibilityComponent) == 0x0000F0, "Wrong size on UVisibilityComponent");
static_assert(offsetof(UVisibilityComponent, OnVisibilityComponentStateChanged) == 0x0000A0, "Member 'UVisibilityComponent::OnVisibilityComponentStateChanged' has a wrong offset!");
static_assert(offsetof(UVisibilityComponent, OwningActor) == 0x0000B0, "Member 'UVisibilityComponent::OwningActor' has a wrong offset!");
static_assert(offsetof(UVisibilityComponent, OwningActorVisibilityInterface) == 0x0000B8, "Member 'UVisibilityComponent::OwningActorVisibilityInterface' has a wrong offset!");
static_assert(offsetof(UVisibilityComponent, ServerVisibilityModifierSources) == 0x0000C8, "Member 'UVisibilityComponent::ServerVisibilityModifierSources' has a wrong offset!");
static_assert(offsetof(UVisibilityComponent, ClientVisibilityModifierSources) == 0x0000D8, "Member 'UVisibilityComponent::ClientVisibilityModifierSources' has a wrong offset!");
static_assert(offsetof(UVisibilityComponent, bVisible) == 0x0000E8, "Member 'UVisibilityComponent::bVisible' has a wrong offset!");

// Class Palia.PathStepComponent
// 0x0000 (0x05A0 - 0x05A0)
class UPathStepComponent final : public UBillboardComponent
{
public:
	int32                                         StepIndex;                                         // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2985[0x4];                                     // 0x059C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStepComponent">();
	}
	static class UPathStepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStepComponent>();
	}
};
static_assert(alignof(UPathStepComponent) == 0x000010, "Wrong alignment on UPathStepComponent");
static_assert(sizeof(UPathStepComponent) == 0x0005A0, "Wrong size on UPathStepComponent");
static_assert(offsetof(UPathStepComponent, StepIndex) == 0x000598, "Member 'UPathStepComponent::StepIndex' has a wrong offset!");

// Class Palia.PersistComponent
// 0x0228 (0x02C8 - 0x00A0)
class UPersistComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnParentOrChildChanged;                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMoved;                                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoved;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHousingSlotChanged;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPersistActorId                        ParentPersistActorId;                              // 0x00E0(0x0024)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPersistActorId                        PersistActorId;                                    // 0x0104(0x0024)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSessionActorId                        AnchorSessionId;                                   // 0x0128(0x0004)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2986[0x24];                                    // 0x012C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSessionActorId                        SessionActorId;                                    // 0x0150(0x0004)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2987[0x4];                                     // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPersistComponentChildArray            PersistChildren;                                   // 0x0158(0x0120)(Net, NativeAccessSpecifierPrivate)
	bool                                          PersistWasRemoved;                                 // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsQueuedForDestruction;                           // 0x0279(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2988[0x6];                                     // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> PersistItemType;                                   // 0x0280(0x0028)(Net, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPersistAnchorType                            PersistAnchorType;                                 // 0x02A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2989[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PersistAnchorUniqueId;                             // 0x02B0(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HousingSlotId;                                     // 0x02C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         ActorEnableCollisionAndVisibility : 1;             // 0x02C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         ActorPlacementChanged : 1;                         // 0x02C4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_298A[0x3];                                     // 0x02C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActorEnableCollisionAndVisibility();
	void OnRep_ActorPlacementChange();
	void OnRep_AnchorSessionId();
	void OnRep_SessionId();
	void ReplicatedParentOrChild();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistComponent">();
	}
	static class UPersistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersistComponent>();
	}
};
static_assert(alignof(UPersistComponent) == 0x000008, "Wrong alignment on UPersistComponent");
static_assert(sizeof(UPersistComponent) == 0x0002C8, "Wrong size on UPersistComponent");
static_assert(offsetof(UPersistComponent, OnParentOrChildChanged) == 0x0000A0, "Member 'UPersistComponent::OnParentOrChildChanged' has a wrong offset!");
static_assert(offsetof(UPersistComponent, OnMoved) == 0x0000B0, "Member 'UPersistComponent::OnMoved' has a wrong offset!");
static_assert(offsetof(UPersistComponent, OnRemoved) == 0x0000C0, "Member 'UPersistComponent::OnRemoved' has a wrong offset!");
static_assert(offsetof(UPersistComponent, OnHousingSlotChanged) == 0x0000D0, "Member 'UPersistComponent::OnHousingSlotChanged' has a wrong offset!");
static_assert(offsetof(UPersistComponent, ParentPersistActorId) == 0x0000E0, "Member 'UPersistComponent::ParentPersistActorId' has a wrong offset!");
static_assert(offsetof(UPersistComponent, PersistActorId) == 0x000104, "Member 'UPersistComponent::PersistActorId' has a wrong offset!");
static_assert(offsetof(UPersistComponent, AnchorSessionId) == 0x000128, "Member 'UPersistComponent::AnchorSessionId' has a wrong offset!");
static_assert(offsetof(UPersistComponent, SessionActorId) == 0x000150, "Member 'UPersistComponent::SessionActorId' has a wrong offset!");
static_assert(offsetof(UPersistComponent, PersistChildren) == 0x000158, "Member 'UPersistComponent::PersistChildren' has a wrong offset!");
static_assert(offsetof(UPersistComponent, PersistWasRemoved) == 0x000278, "Member 'UPersistComponent::PersistWasRemoved' has a wrong offset!");
static_assert(offsetof(UPersistComponent, bIsQueuedForDestruction) == 0x000279, "Member 'UPersistComponent::bIsQueuedForDestruction' has a wrong offset!");
static_assert(offsetof(UPersistComponent, PersistItemType) == 0x000280, "Member 'UPersistComponent::PersistItemType' has a wrong offset!");
static_assert(offsetof(UPersistComponent, PersistAnchorType) == 0x0002A8, "Member 'UPersistComponent::PersistAnchorType' has a wrong offset!");
static_assert(offsetof(UPersistComponent, PersistAnchorUniqueId) == 0x0002B0, "Member 'UPersistComponent::PersistAnchorUniqueId' has a wrong offset!");
static_assert(offsetof(UPersistComponent, HousingSlotId) == 0x0002C0, "Member 'UPersistComponent::HousingSlotId' has a wrong offset!");

// Class Palia.VoiceLocalPlayerSubsystem
// 0x0018 (0x0048 - 0x0030)
class UVoiceLocalPlayerSubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_298B[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMuted();
	bool JoinRoom(const class FString& RoomName);
	bool LeaveRoom(const class FString& RoomName);
	void MuteAudioDevices();
	void UnmuteAudioDevices();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceLocalPlayerSubsystem">();
	}
	static class UVoiceLocalPlayerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoiceLocalPlayerSubsystem>();
	}
};
static_assert(alignof(UVoiceLocalPlayerSubsystem) == 0x000008, "Wrong alignment on UVoiceLocalPlayerSubsystem");
static_assert(sizeof(UVoiceLocalPlayerSubsystem) == 0x000048, "Wrong size on UVoiceLocalPlayerSubsystem");

// Class Palia.PersistSpawnerActor
// 0x0030 (0x02D8 - 0x02A8)
class APersistSpawnerActor final : public AActor
{
public:
	class UVAL_ItemTypeDefinitionAsset*           ItemTypeToSpawn;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PersistAnchorUniqueId;                             // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    Billboard;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsReadyToSpawn;                                   // 0x02D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298E[0x7];                                     // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistSpawnerActor">();
	}
	static class APersistSpawnerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APersistSpawnerActor>();
	}
};
static_assert(alignof(APersistSpawnerActor) == 0x000008, "Wrong alignment on APersistSpawnerActor");
static_assert(sizeof(APersistSpawnerActor) == 0x0002D8, "Wrong size on APersistSpawnerActor");
static_assert(offsetof(APersistSpawnerActor, ItemTypeToSpawn) == 0x0002A8, "Member 'APersistSpawnerActor::ItemTypeToSpawn' has a wrong offset!");
static_assert(offsetof(APersistSpawnerActor, PersistAnchorUniqueId) == 0x0002B0, "Member 'APersistSpawnerActor::PersistAnchorUniqueId' has a wrong offset!");
static_assert(offsetof(APersistSpawnerActor, Root) == 0x0002C0, "Member 'APersistSpawnerActor::Root' has a wrong offset!");
static_assert(offsetof(APersistSpawnerActor, Billboard) == 0x0002C8, "Member 'APersistSpawnerActor::Billboard' has a wrong offset!");
static_assert(offsetof(APersistSpawnerActor, bIsReadyToSpawn) == 0x0002D0, "Member 'APersistSpawnerActor::bIsReadyToSpawn' has a wrong offset!");

// Class Palia.PlaceablePlugAndSocketsComponent
// 0x00A8 (0x0148 - 0x00A0)
class UPlaceablePlugAndSocketsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_298F[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPlaceablePlugPersistData              PlugPersistData;                                   // 0x00B8(0x0028)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPlaceablePlugAndSocketStatuses        PlugAndSocketStatuses;                             // 0x00E0(0x0060)(Net, RepNotify, NativeAccessSpecifierPrivate)
	class UDataTable*                             SocketsTable;                                      // 0x0140(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLevelChanged(class ULevelerComponent* Leveler);
	void OnStatusReplicated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceablePlugAndSocketsComponent">();
	}
	static class UPlaceablePlugAndSocketsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceablePlugAndSocketsComponent>();
	}
};
static_assert(alignof(UPlaceablePlugAndSocketsComponent) == 0x000008, "Wrong alignment on UPlaceablePlugAndSocketsComponent");
static_assert(sizeof(UPlaceablePlugAndSocketsComponent) == 0x000148, "Wrong size on UPlaceablePlugAndSocketsComponent");
static_assert(offsetof(UPlaceablePlugAndSocketsComponent, OnChanged) == 0x0000A8, "Member 'UPlaceablePlugAndSocketsComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UPlaceablePlugAndSocketsComponent, PlugPersistData) == 0x0000B8, "Member 'UPlaceablePlugAndSocketsComponent::PlugPersistData' has a wrong offset!");
static_assert(offsetof(UPlaceablePlugAndSocketsComponent, PlugAndSocketStatuses) == 0x0000E0, "Member 'UPlaceablePlugAndSocketsComponent::PlugAndSocketStatuses' has a wrong offset!");
static_assert(offsetof(UPlaceablePlugAndSocketsComponent, SocketsTable) == 0x000140, "Member 'UPlaceablePlugAndSocketsComponent::SocketsTable' has a wrong offset!");

// Class Palia.Waterable
// 0x0000 (0x0028 - 0x0028)
class IWaterable final : public IInterface
{
public:
	struct FVector GetSnapLocationFromWaterLocation(struct FVector& WaterLocation);
	bool Server_WaterPosition(struct FVector& WaterLocation, class AValeriaCharacter* Character, struct FBagSlotLocation& CanLocation, int32 UseWaterAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Waterable">();
	}
	static class IWaterable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWaterable>();
	}
};
static_assert(alignof(IWaterable) == 0x000008, "Wrong alignment on IWaterable");
static_assert(sizeof(IWaterable) == 0x000028, "Wrong size on IWaterable");

// Class Palia.PlacementComponent
// 0x0320 (0x03C0 - 0x00A0)
class UPlacementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2991[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputRotationDegreesPerSecond;                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RotationDegreeInterval;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlacementViewActor>        PlacementViewActor;                                // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlacementUpAngle;                               // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFenceSectionCount;                              // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlacementChanged;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlacementConfirmed;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlacementItemChanged;                            // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFreePlacementModeChanged;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAxisPlacementModeChanged;                        // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMultiSelectModeChanged;                          // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCanPlaceHereChanged;                             // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGradualGatherUpdated;                            // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGradualGatherCompleted;                          // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bNeedsCurrentRotationInit;                         // 0x0150(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2992[0x7];                                     // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlacementReferenceLocation;                        // 0x0158(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             PlacementItemTransform;                            // 0x0170(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingStickySnapped;                             // 0x01D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EItemPlacementState                           PlacingState;                                      // 0x01D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          CanPlaceHere;                                      // 0x01D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2993[0x5];                                     // 0x01D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemToPlaceParams                     ItemToPlaceParams;                                 // 0x01D8(0x00E0)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	class APlacementViewActor*                    ItemToPlaceView;                                   // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         GradualGatherResults;                              // 0x02C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         GradualGatherReferenceActors;                      // 0x02D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         NextGradualGatherReferenceStartIndex;              // 0x02E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGradualGatherIncludesChildren;                    // 0x02E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2994[0x3];                                     // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         GradualGatherIgnoreActors;                         // 0x02E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UPlacementRegionComponent*>      QueuedHiddenGridRegions;                           // 0x02F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UPlacementRegionComponent*              RegionToPlaceIn;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> ItemTypeToPlace;                                   // 0x0310(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentRotation;                                   // 0x0338(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PlacementFailureMessage;                           // 0x033C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsOnLimitedAxisMovement;                           // 0x0344(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2995[0x3];                                     // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LimitedAxisMovementOrigin;                         // 0x0348(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlacementRegionComponent*              LimitedAxisRegionToPlaceIn;                        // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLimitedAxisModeActive;                            // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFreePlacementModeActive;                          // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMultiSelectActive;                                // 0x036A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRecheckLockedPlacementItems;                      // 0x036B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWaitForLockedPlacement;                           // 0x036C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2996[0x3];                                     // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastGoodCanPlaceLocation;                          // 0x0370(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSessionActorId                        ActiveLockedPlacementItem;                         // 0x0388(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasLockedRaycastScreenSpaceSource;                // 0x038C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2997[0x3];                                     // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LockedRaycastScreenSpaceSourcePosition;            // 0x0390(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WallpaperRegionToPlaceInAnchorName;                // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WallpaperRegionToPlaceInSurfaceId;                 // 0x03A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2998[0x4];                                     // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFenceMeshComponent*>            ConnectingFenceMeshes;                             // 0x03B0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool CancelPlacement();
	void Client_CancelPlacement();
	bool ConfirmPlacement();
	void HandleEquipmentChanged(class UEquipmentComponent* EquipmentComponent, const struct FEquipmentItem& Item);
	void LockRaycastScreenSpaceSource(class AValeriaPlayerController* Vpc);
	void NotifyLockedUpdate();
	struct FSelfUseEventResult OnClientUseEquippedOutward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnStateChanged(class UCharacterStateMachineComponent* Csm, const struct FCharacterStateChangeParams& Params_0);
	void PlayPlacementAudio(bool bPlaced);
	void RpcServer_LockItemsToPlace(TArray<struct FSessionActorId>& ActorIds);
	void RpcServer_LockItemToPlace(const struct FSessionActorId& ActorId);
	void RpcServer_PlaceItem(const struct FItemToPlaceParams& Params_0, class AHousingOwnershipActor* HousingOwner, struct FPlacementRegionId& Anchor, const struct FVector& Position, const struct FRotator& Rotation, int32 MetadataFlags);
	void RpcServer_UnlockItemsToPlace(TArray<struct FSessionActorId>& ActorIds);
	void RpcServer_UnlockItemToPlace(const struct FSessionActorId& ActorId);
	void RpcServer_UpdateLockedItemToPlace(const struct FSessionActorId& ActorId, const struct FVector& Position, const struct FRotator& Rotation);
	void SetFreePlacementModeActive(bool bActive);
	void SetMultiSelectActive(bool bActive);
	bool StartMoving(class AActor* Actor);
	bool StartPlacing(const struct FItemToPlaceParams& Params_0);
	bool StartPlacingFromHouseInventory(int32 HouseInventoryIndex);
	bool StartPlacingFromInventory(const struct FBagSlotLocation& Location);
	void UnlockRaycastScreenSpaceSource();

	class AActor* GetActorMoving() const;
	TArray<struct FPlacementHoverInfo> GetAlterationPoints() const;
	struct FPlacementHoverInfo GetHoveredObject() const;
	int32 GetItemToPlaceItemConfigId() const;
	int32 GetItemToPlaceStackCount() const;
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> GetItemTypeToPlace() const;
	void GetPlacedItemsCount(int32* OutRequired, int32* OutAvailable) const;
	bool IsBeingStickySnapped() const;
	bool IsFreePlacementModeActive() const;
	bool IsPlacing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacementComponent">();
	}
	static class UPlacementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlacementComponent>();
	}
};
static_assert(alignof(UPlacementComponent) == 0x000010, "Wrong alignment on UPlacementComponent");
static_assert(sizeof(UPlacementComponent) == 0x0003C0, "Wrong size on UPlacementComponent");
static_assert(offsetof(UPlacementComponent, InputRotationDegreesPerSecond) == 0x0000A8, "Member 'UPlacementComponent::InputRotationDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, RotationDegreeInterval) == 0x0000AC, "Member 'UPlacementComponent::RotationDegreeInterval' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, PlacementViewActor) == 0x0000B0, "Member 'UPlacementComponent::PlacementViewActor' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, MaxPlacementUpAngle) == 0x0000B8, "Member 'UPlacementComponent::MaxPlacementUpAngle' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, MaxFenceSectionCount) == 0x0000BC, "Member 'UPlacementComponent::MaxFenceSectionCount' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, OnPlacementChanged) == 0x0000C0, "Member 'UPlacementComponent::OnPlacementChanged' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, OnPlacementConfirmed) == 0x0000D0, "Member 'UPlacementComponent::OnPlacementConfirmed' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, OnPlacementItemChanged) == 0x0000E0, "Member 'UPlacementComponent::OnPlacementItemChanged' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, OnFreePlacementModeChanged) == 0x0000F0, "Member 'UPlacementComponent::OnFreePlacementModeChanged' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, OnAxisPlacementModeChanged) == 0x000100, "Member 'UPlacementComponent::OnAxisPlacementModeChanged' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, OnMultiSelectModeChanged) == 0x000110, "Member 'UPlacementComponent::OnMultiSelectModeChanged' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, OnCanPlaceHereChanged) == 0x000120, "Member 'UPlacementComponent::OnCanPlaceHereChanged' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, OnGradualGatherUpdated) == 0x000130, "Member 'UPlacementComponent::OnGradualGatherUpdated' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, OnGradualGatherCompleted) == 0x000140, "Member 'UPlacementComponent::OnGradualGatherCompleted' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, bNeedsCurrentRotationInit) == 0x000150, "Member 'UPlacementComponent::bNeedsCurrentRotationInit' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, PlacementReferenceLocation) == 0x000158, "Member 'UPlacementComponent::PlacementReferenceLocation' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, PlacementItemTransform) == 0x000170, "Member 'UPlacementComponent::PlacementItemTransform' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, bIsBeingStickySnapped) == 0x0001D0, "Member 'UPlacementComponent::bIsBeingStickySnapped' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, PlacingState) == 0x0001D1, "Member 'UPlacementComponent::PlacingState' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, CanPlaceHere) == 0x0001D2, "Member 'UPlacementComponent::CanPlaceHere' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, ItemToPlaceParams) == 0x0001D8, "Member 'UPlacementComponent::ItemToPlaceParams' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, ItemToPlaceView) == 0x0002B8, "Member 'UPlacementComponent::ItemToPlaceView' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, GradualGatherResults) == 0x0002C0, "Member 'UPlacementComponent::GradualGatherResults' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, GradualGatherReferenceActors) == 0x0002D0, "Member 'UPlacementComponent::GradualGatherReferenceActors' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, NextGradualGatherReferenceStartIndex) == 0x0002E0, "Member 'UPlacementComponent::NextGradualGatherReferenceStartIndex' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, bGradualGatherIncludesChildren) == 0x0002E4, "Member 'UPlacementComponent::bGradualGatherIncludesChildren' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, GradualGatherIgnoreActors) == 0x0002E8, "Member 'UPlacementComponent::GradualGatherIgnoreActors' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, QueuedHiddenGridRegions) == 0x0002F8, "Member 'UPlacementComponent::QueuedHiddenGridRegions' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, RegionToPlaceIn) == 0x000308, "Member 'UPlacementComponent::RegionToPlaceIn' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, ItemTypeToPlace) == 0x000310, "Member 'UPlacementComponent::ItemTypeToPlace' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, CurrentRotation) == 0x000338, "Member 'UPlacementComponent::CurrentRotation' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, PlacementFailureMessage) == 0x00033C, "Member 'UPlacementComponent::PlacementFailureMessage' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, IsOnLimitedAxisMovement) == 0x000344, "Member 'UPlacementComponent::IsOnLimitedAxisMovement' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, LimitedAxisMovementOrigin) == 0x000348, "Member 'UPlacementComponent::LimitedAxisMovementOrigin' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, LimitedAxisRegionToPlaceIn) == 0x000360, "Member 'UPlacementComponent::LimitedAxisRegionToPlaceIn' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, bLimitedAxisModeActive) == 0x000368, "Member 'UPlacementComponent::bLimitedAxisModeActive' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, bFreePlacementModeActive) == 0x000369, "Member 'UPlacementComponent::bFreePlacementModeActive' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, bMultiSelectActive) == 0x00036A, "Member 'UPlacementComponent::bMultiSelectActive' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, bRecheckLockedPlacementItems) == 0x00036B, "Member 'UPlacementComponent::bRecheckLockedPlacementItems' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, bWaitForLockedPlacement) == 0x00036C, "Member 'UPlacementComponent::bWaitForLockedPlacement' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, LastGoodCanPlaceLocation) == 0x000370, "Member 'UPlacementComponent::LastGoodCanPlaceLocation' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, ActiveLockedPlacementItem) == 0x000388, "Member 'UPlacementComponent::ActiveLockedPlacementItem' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, bHasLockedRaycastScreenSpaceSource) == 0x00038C, "Member 'UPlacementComponent::bHasLockedRaycastScreenSpaceSource' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, LockedRaycastScreenSpaceSourcePosition) == 0x000390, "Member 'UPlacementComponent::LockedRaycastScreenSpaceSourcePosition' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, WallpaperRegionToPlaceInAnchorName) == 0x0003A0, "Member 'UPlacementComponent::WallpaperRegionToPlaceInAnchorName' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, WallpaperRegionToPlaceInSurfaceId) == 0x0003A8, "Member 'UPlacementComponent::WallpaperRegionToPlaceInSurfaceId' has a wrong offset!");
static_assert(offsetof(UPlacementComponent, ConnectingFenceMeshes) == 0x0003B0, "Member 'UPlacementComponent::ConnectingFenceMeshes' has a wrong offset!");

// Class Palia.PlacementRegionMatActor
// 0x0148 (0x03F0 - 0x02A8)
class APlacementRegionMatActor : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   GridMesh;                                          // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   CollisionPlane;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          PlaceableActorBounds;                              // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          ConnectorSockets;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          ConnectorSocketsInUse;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   SocketMesh;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   SocketCollision;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USphereComponent*>               SnapPointCollisions;                               // 0x02E8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FLinearColor                           GridLineColor;                                     // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           HighlightLineColor;                                // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GridLineThickness;                                 // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HighlightLineThickness;                            // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GridFadeStartDistance;                             // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GridFadeEndDistance;                               // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SocketModeValidInnerColor;                         // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SocketModeValidOuterColor;                         // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SocketModeInvalidInnerColor;                       // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SocketModeInvalidOuterColor;                       // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SocketModeOpenInnerColor;                          // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SocketModeOpenOuterColor;                          // 0x0378(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHideGrid;                                         // 0x0388(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCurrentlyFocusedOn;                              // 0x0389(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A0[0x6];                                     // 0x038A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastUpdatePlacementReferenceLocation;              // 0x0390(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           LastUpdateExtentsAsColor;                          // 0x03A8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LastUpdatePlacementAxisLockMode;                   // 0x03B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A1[0x7];                                     // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_ItemTypeDefinitionAsset*           LastUpdateItemTypeToPlace;                         // 0x03C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MajorUpdateCounter;                                // 0x03C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedsUpdateRefresh;                               // 0x03CC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A2[0x3];                                     // 0x03CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlacementComponent*                    CachedPlacementComponent;                          // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               GridMaterialInstance;                              // 0x03D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               SocketModeMaterialInstance;                        // 0x03E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29A3[0x8];                                     // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacementRegionMatActor">();
	}
	static class APlacementRegionMatActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlacementRegionMatActor>();
	}
};
static_assert(alignof(APlacementRegionMatActor) == 0x000008, "Wrong alignment on APlacementRegionMatActor");
static_assert(sizeof(APlacementRegionMatActor) == 0x0003F0, "Wrong size on APlacementRegionMatActor");
static_assert(offsetof(APlacementRegionMatActor, Root) == 0x0002A8, "Member 'APlacementRegionMatActor::Root' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, GridMesh) == 0x0002B0, "Member 'APlacementRegionMatActor::GridMesh' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, CollisionPlane) == 0x0002B8, "Member 'APlacementRegionMatActor::CollisionPlane' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, PlaceableActorBounds) == 0x0002C0, "Member 'APlacementRegionMatActor::PlaceableActorBounds' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, ConnectorSockets) == 0x0002C8, "Member 'APlacementRegionMatActor::ConnectorSockets' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, ConnectorSocketsInUse) == 0x0002D0, "Member 'APlacementRegionMatActor::ConnectorSocketsInUse' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SocketMesh) == 0x0002D8, "Member 'APlacementRegionMatActor::SocketMesh' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SocketCollision) == 0x0002E0, "Member 'APlacementRegionMatActor::SocketCollision' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SnapPointCollisions) == 0x0002E8, "Member 'APlacementRegionMatActor::SnapPointCollisions' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, GridLineColor) == 0x0002F8, "Member 'APlacementRegionMatActor::GridLineColor' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, HighlightLineColor) == 0x000308, "Member 'APlacementRegionMatActor::HighlightLineColor' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, GridLineThickness) == 0x000318, "Member 'APlacementRegionMatActor::GridLineThickness' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, HighlightLineThickness) == 0x00031C, "Member 'APlacementRegionMatActor::HighlightLineThickness' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, GridFadeStartDistance) == 0x000320, "Member 'APlacementRegionMatActor::GridFadeStartDistance' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, GridFadeEndDistance) == 0x000324, "Member 'APlacementRegionMatActor::GridFadeEndDistance' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SocketModeValidInnerColor) == 0x000328, "Member 'APlacementRegionMatActor::SocketModeValidInnerColor' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SocketModeValidOuterColor) == 0x000338, "Member 'APlacementRegionMatActor::SocketModeValidOuterColor' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SocketModeInvalidInnerColor) == 0x000348, "Member 'APlacementRegionMatActor::SocketModeInvalidInnerColor' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SocketModeInvalidOuterColor) == 0x000358, "Member 'APlacementRegionMatActor::SocketModeInvalidOuterColor' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SocketModeOpenInnerColor) == 0x000368, "Member 'APlacementRegionMatActor::SocketModeOpenInnerColor' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SocketModeOpenOuterColor) == 0x000378, "Member 'APlacementRegionMatActor::SocketModeOpenOuterColor' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, bHideGrid) == 0x000388, "Member 'APlacementRegionMatActor::bHideGrid' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, IsCurrentlyFocusedOn) == 0x000389, "Member 'APlacementRegionMatActor::IsCurrentlyFocusedOn' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, LastUpdatePlacementReferenceLocation) == 0x000390, "Member 'APlacementRegionMatActor::LastUpdatePlacementReferenceLocation' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, LastUpdateExtentsAsColor) == 0x0003A8, "Member 'APlacementRegionMatActor::LastUpdateExtentsAsColor' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, LastUpdatePlacementAxisLockMode) == 0x0003B8, "Member 'APlacementRegionMatActor::LastUpdatePlacementAxisLockMode' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, LastUpdateItemTypeToPlace) == 0x0003C0, "Member 'APlacementRegionMatActor::LastUpdateItemTypeToPlace' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, MajorUpdateCounter) == 0x0003C8, "Member 'APlacementRegionMatActor::MajorUpdateCounter' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, bNeedsUpdateRefresh) == 0x0003CC, "Member 'APlacementRegionMatActor::bNeedsUpdateRefresh' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, CachedPlacementComponent) == 0x0003D0, "Member 'APlacementRegionMatActor::CachedPlacementComponent' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, GridMaterialInstance) == 0x0003D8, "Member 'APlacementRegionMatActor::GridMaterialInstance' has a wrong offset!");
static_assert(offsetof(APlacementRegionMatActor, SocketModeMaterialInstance) == 0x0003E0, "Member 'APlacementRegionMatActor::SocketModeMaterialInstance' has a wrong offset!");

// Class Palia.VAL_MQTTAsyncStreamBase
// 0x0020 (0x0048 - 0x0028)
class UVAL_MQTTAsyncStreamBase : public UObject
{
public:
	uint8                                         Pad_29A4[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_MQTTAsyncStreamBase">();
	}
	static class UVAL_MQTTAsyncStreamBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_MQTTAsyncStreamBase>();
	}
};
static_assert(alignof(UVAL_MQTTAsyncStreamBase) == 0x000008, "Wrong alignment on UVAL_MQTTAsyncStreamBase");
static_assert(sizeof(UVAL_MQTTAsyncStreamBase) == 0x000048, "Wrong size on UVAL_MQTTAsyncStreamBase");

// Class Palia.VAL_ServerKickAllAsyncStream
// 0x0010 (0x0058 - 0x0048)
class UVAL_ServerKickAllAsyncStream final : public UVAL_MQTTAsyncStreamBase
{
public:
	uint8                                         Pad_29A5[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ServerKickAllAsyncStream">();
	}
	static class UVAL_ServerKickAllAsyncStream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ServerKickAllAsyncStream>();
	}
};
static_assert(alignof(UVAL_ServerKickAllAsyncStream) == 0x000008, "Wrong alignment on UVAL_ServerKickAllAsyncStream");
static_assert(sizeof(UVAL_ServerKickAllAsyncStream) == 0x000058, "Wrong size on UVAL_ServerKickAllAsyncStream");

// Class Palia.PlayerActionRequirementFilterComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPlayerActionRequirementFilterComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerActionRequirementFilterComponent">();
	}
	static class UPlayerActionRequirementFilterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerActionRequirementFilterComponent>();
	}
};
static_assert(alignof(UPlayerActionRequirementFilterComponent) == 0x000008, "Wrong alignment on UPlayerActionRequirementFilterComponent");
static_assert(sizeof(UPlayerActionRequirementFilterComponent) == 0x0000A0, "Wrong size on UPlayerActionRequirementFilterComponent");

// Class Palia.VAL_ShrineInteraction
// 0x0318 (0x05C0 - 0x02A8)
class AVAL_ShrineInteraction final : public AActor
{
public:
	uint8                                         Pad_29A6[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComp;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQuestRewardConfig                     FirstTimeReward;                                   // 0x02B8(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FQuestRewardConfig                     RepeatReward;                                      // 0x0430(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CanCommunePrereqTag;                               // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ShrineRelevantUpgradeTag;                          // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShrineRelevantUpgradeMaxLevel;                     // 0x05B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A7[0x4];                                     // 0x05BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_TryShrineTelemetry(class AValeriaCharacter* Character, class FString& ShrineName, struct FVitalsChange& VitalsChange, int32 PreviousVitalsState, int32 NewVitalsState);

	bool CanPlayerCommune(class AValeriaCharacter* Character) const;
	EVAL_ShrineReadiness DetermineShrineReadiness(class AValeriaCharacter* Character, bool bCheckResources) const;
	void DetermineShrineUpgradeCost(class AValeriaCharacter* Character, EVitalType* VitalType, int32* Cost) const;
	int32 GetRelevantUpgradeLevel(class AValeriaCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ShrineInteraction">();
	}
	static class AVAL_ShrineInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_ShrineInteraction>();
	}
};
static_assert(alignof(AVAL_ShrineInteraction) == 0x000008, "Wrong alignment on AVAL_ShrineInteraction");
static_assert(sizeof(AVAL_ShrineInteraction) == 0x0005C0, "Wrong size on AVAL_ShrineInteraction");
static_assert(offsetof(AVAL_ShrineInteraction, InteractableComp) == 0x0002B0, "Member 'AVAL_ShrineInteraction::InteractableComp' has a wrong offset!");
static_assert(offsetof(AVAL_ShrineInteraction, FirstTimeReward) == 0x0002B8, "Member 'AVAL_ShrineInteraction::FirstTimeReward' has a wrong offset!");
static_assert(offsetof(AVAL_ShrineInteraction, RepeatReward) == 0x000430, "Member 'AVAL_ShrineInteraction::RepeatReward' has a wrong offset!");
static_assert(offsetof(AVAL_ShrineInteraction, CanCommunePrereqTag) == 0x0005A8, "Member 'AVAL_ShrineInteraction::CanCommunePrereqTag' has a wrong offset!");
static_assert(offsetof(AVAL_ShrineInteraction, ShrineRelevantUpgradeTag) == 0x0005B0, "Member 'AVAL_ShrineInteraction::ShrineRelevantUpgradeTag' has a wrong offset!");
static_assert(offsetof(AVAL_ShrineInteraction, ShrineRelevantUpgradeMaxLevel) == 0x0005B8, "Member 'AVAL_ShrineInteraction::ShrineRelevantUpgradeMaxLevel' has a wrong offset!");

// Class Palia.PlayerEventRespondable
// 0x0000 (0x0028 - 0x0028)
class IPlayerEventRespondable final : public IInterface
{
public:
	void OnControllerAttachedToCharacter(class AValeriaPlayerController* Player, class AValeriaCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerEventRespondable">();
	}
	static class IPlayerEventRespondable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerEventRespondable>();
	}
};
static_assert(alignof(IPlayerEventRespondable) == 0x000008, "Wrong alignment on IPlayerEventRespondable");
static_assert(sizeof(IPlayerEventRespondable) == 0x000028, "Wrong size on IPlayerEventRespondable");

// Class Palia.PlayerWorldStateComponent
// 0x0108 (0x01A8 - 0x00A0)
class UPlayerWorldStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_29AC[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWorldPersistGatherableAdded;                     // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimedLootPileAdded;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPlayerWorldStatePersistBlock          PlayerWorldStatePersistBlock;                      // 0x00C8(0x00E0)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void RpcClient_InitializeTimedLootPilesGroup(TArray<struct FGameplayTag>& InTags, TArray<struct FTimedLootPileData>& InTimedLootPileDatas);
	void RpcClient_InitializeWorldPersistGatherablesGroup(TArray<struct FGameplayTag>& InTags, TArray<struct FWorldPersistGatherableData>& InWorldPersistGatherableDatas);
	void RpcClient_UpdateTimedLootPile(struct FGameplayTag& InTag, class FName& InActorName, struct FTimedLootPileData& InTimedLootPileData);
	void RpcClient_UpdateWorldPersistGatherable(struct FGameplayTag& InTag, struct FWorldPersistGatherableData& InWorldPersistGatherableData);

	bool HasGatheredTimedLootPileToday(struct FGameplayTag& InTag, class FName& InActorName) const;
	bool HasGatheredWorldPersistGatherable(struct FGameplayTag& InTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerWorldStateComponent">();
	}
	static class UPlayerWorldStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerWorldStateComponent>();
	}
};
static_assert(alignof(UPlayerWorldStateComponent) == 0x000008, "Wrong alignment on UPlayerWorldStateComponent");
static_assert(sizeof(UPlayerWorldStateComponent) == 0x0001A8, "Wrong size on UPlayerWorldStateComponent");
static_assert(offsetof(UPlayerWorldStateComponent, OnWorldPersistGatherableAdded) == 0x0000A8, "Member 'UPlayerWorldStateComponent::OnWorldPersistGatherableAdded' has a wrong offset!");
static_assert(offsetof(UPlayerWorldStateComponent, OnTimedLootPileAdded) == 0x0000B8, "Member 'UPlayerWorldStateComponent::OnTimedLootPileAdded' has a wrong offset!");
static_assert(offsetof(UPlayerWorldStateComponent, PlayerWorldStatePersistBlock) == 0x0000C8, "Member 'UPlayerWorldStateComponent::PlayerWorldStatePersistBlock' has a wrong offset!");

// Class Palia.VAL_Spray
// 0x0080 (0x0328 - 0x02A8)
class AVAL_Spray final : public AActor
{
public:
	struct FVAL_SprayData                         SprayData;                                         // 0x02A8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_29AF[0x10];                                    // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        DecalComponent;                                    // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      SprayMaterial;                                     // 0x02F8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SprayMaterialTextureParamName;                     // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSprayAssetReplicated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_Spray">();
	}
	static class AVAL_Spray* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_Spray>();
	}
};
static_assert(alignof(AVAL_Spray) == 0x000008, "Wrong alignment on AVAL_Spray");
static_assert(sizeof(AVAL_Spray) == 0x000328, "Wrong size on AVAL_Spray");
static_assert(offsetof(AVAL_Spray, SprayData) == 0x0002A8, "Member 'AVAL_Spray::SprayData' has a wrong offset!");
static_assert(offsetof(AVAL_Spray, DecalComponent) == 0x0002F0, "Member 'AVAL_Spray::DecalComponent' has a wrong offset!");
static_assert(offsetof(AVAL_Spray, SprayMaterial) == 0x0002F8, "Member 'AVAL_Spray::SprayMaterial' has a wrong offset!");
static_assert(offsetof(AVAL_Spray, SprayMaterialTextureParamName) == 0x000320, "Member 'AVAL_Spray::SprayMaterialTextureParamName' has a wrong offset!");

// Class Palia.PrivateSpaceConfig
// 0x0148 (0x0190 - 0x0048)
class UPrivateSpaceConfig final : public UGuidDataAsset
{
public:
	TSoftObjectPtr<class UWorld>                  PrivateSpaceMap;                                   // 0x0048(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrivateSpaceManagedName;                           // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrivateSpaceVillagerDeterminantConfig* VillagerDeterminantConfig;                         // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDialogueRoom;                             // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGiftingAllowed;                                 // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B0[0x6];                                     // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      OverrideDialogueRoomBackgroundWallMaterial;        // 0x0090(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeAtSpecificTime;                             // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B1[0x3];                                     // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FrozenTimeHour;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrozenTimeMinute;                                  // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompassDisplaySettingFlags;                        // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarOffTrackerDistance;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B2[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTravelPayload                         TravelPayload;                                     // 0x00D0(0x00C0)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	float GetFrozenTimeAsPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrivateSpaceConfig">();
	}
	static class UPrivateSpaceConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrivateSpaceConfig>();
	}
};
static_assert(alignof(UPrivateSpaceConfig) == 0x000008, "Wrong alignment on UPrivateSpaceConfig");
static_assert(sizeof(UPrivateSpaceConfig) == 0x000190, "Wrong size on UPrivateSpaceConfig");
static_assert(offsetof(UPrivateSpaceConfig, PrivateSpaceMap) == 0x000048, "Member 'UPrivateSpaceConfig::PrivateSpaceMap' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, PrivateSpaceManagedName) == 0x000070, "Member 'UPrivateSpaceConfig::PrivateSpaceManagedName' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, VillagerDeterminantConfig) == 0x000080, "Member 'UPrivateSpaceConfig::VillagerDeterminantConfig' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, bOverrideDialogueRoom) == 0x000088, "Member 'UPrivateSpaceConfig::bOverrideDialogueRoom' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, bIsGiftingAllowed) == 0x000089, "Member 'UPrivateSpaceConfig::bIsGiftingAllowed' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, OverrideDialogueRoomBackgroundWallMaterial) == 0x000090, "Member 'UPrivateSpaceConfig::OverrideDialogueRoomBackgroundWallMaterial' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, bFreezeAtSpecificTime) == 0x0000B8, "Member 'UPrivateSpaceConfig::bFreezeAtSpecificTime' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, FrozenTimeHour) == 0x0000BC, "Member 'UPrivateSpaceConfig::FrozenTimeHour' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, FrozenTimeMinute) == 0x0000C0, "Member 'UPrivateSpaceConfig::FrozenTimeMinute' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, CompassDisplaySettingFlags) == 0x0000C4, "Member 'UPrivateSpaceConfig::CompassDisplaySettingFlags' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, FarOffTrackerDistance) == 0x0000C8, "Member 'UPrivateSpaceConfig::FarOffTrackerDistance' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceConfig, TravelPayload) == 0x0000D0, "Member 'UPrivateSpaceConfig::TravelPayload' has a wrong offset!");

// Class Palia.PrivateSpaceManager
// 0x0078 (0x00A8 - 0x0030)
class UPrivateSpaceManager final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnVillagerInPrivateSpaceForScheduleChanged;        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<int32, struct FPrivateSpaceScheduledVillagerSpawnInfo> VillagerConfigsInPrivateSpacesForSchedule;         // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UPrivateSpaceLevelHandle*>       LoadedPrivateSpaces;                               // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29B3[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearVillagerInPrivateSpaceForSchedule(int32 VillagerId);
	void ClientUpdatePrivateSpaceLocation(class AValeriaCharacter* Player, const class FString& HandleID, class UPrivateSpaceConfig* PrivateSpaceConfig, int32 SlotId);
	void MarkVillagerInPrivateSpaceForSchedule(int32 VillagerId, class UPrivateSpaceConfig* PrivateSpace, const struct FVillagerSpawnParams& SpawnParams);
	void Server_LeavePrivateSpace(class AValeriaCharacter* Player, class UPrivateSpaceConfig* PrivateSpaceConfig);
	void SetVisibilityOfPrivateSpaceSublevelForCharacter(class AValeriaCharacter* Player, const class FString& SublevelName, bool bInShouldBeVisible);
	void SpawnPrivateSpaceForCharacter(class AValeriaCharacter* Player, class UPrivateSpaceConfig* PrivateSpaceConfig);

	bool CharacterHasActivePrivateSpace(class AValeriaCharacter* Player) const;
	const class UPrivateSpaceConfig* GetActivePrivateSpaceForCharacter(class AValeriaCharacter* Player) const;
	TArray<struct FTitleAndRowsInfo> GetAllLoadedPrivateSpaceTitleAndRowsInfo() const;
	const class UPrivateSpaceConfig* GetCurrentPrivateSpaceForVillagerSchedule(int32 VillagerId) const;
	TArray<struct FTitleAndRowsInfo> GetLoadedPrivateSpaceTitleAndRowsInfoForPlayerController(class AValeriaPlayerController* InValeriaPlayerController) const;
	class AValeriaPlayerController* GetPrivateSpaceInstigator(class AActor* InActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrivateSpaceManager">();
	}
	static class UPrivateSpaceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrivateSpaceManager>();
	}
};
static_assert(alignof(UPrivateSpaceManager) == 0x000008, "Wrong alignment on UPrivateSpaceManager");
static_assert(sizeof(UPrivateSpaceManager) == 0x0000A8, "Wrong size on UPrivateSpaceManager");
static_assert(offsetof(UPrivateSpaceManager, OnVillagerInPrivateSpaceForScheduleChanged) == 0x000030, "Member 'UPrivateSpaceManager::OnVillagerInPrivateSpaceForScheduleChanged' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceManager, VillagerConfigsInPrivateSpacesForSchedule) == 0x000040, "Member 'UPrivateSpaceManager::VillagerConfigsInPrivateSpacesForSchedule' has a wrong offset!");
static_assert(offsetof(UPrivateSpaceManager, LoadedPrivateSpaces) == 0x000090, "Member 'UPrivateSpaceManager::LoadedPrivateSpaces' has a wrong offset!");

// Class Palia.VAL_PrizeWheelDef
// 0x0040 (0x0098 - 0x0058)
class UVAL_PrizeWheelDef final : public UVAL_DataAsset
{
public:
	struct FVAL_PrizeWheelCostDef                 CostPerPlay;                                       // 0x0058(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FVAL_PrizeWheelSlotDef>         Slots;                                             // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PrizeWheelDef">();
	}
	static class UVAL_PrizeWheelDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PrizeWheelDef>();
	}
};
static_assert(alignof(UVAL_PrizeWheelDef) == 0x000008, "Wrong alignment on UVAL_PrizeWheelDef");
static_assert(sizeof(UVAL_PrizeWheelDef) == 0x000098, "Wrong size on UVAL_PrizeWheelDef");
static_assert(offsetof(UVAL_PrizeWheelDef, CostPerPlay) == 0x000058, "Member 'UVAL_PrizeWheelDef::CostPerPlay' has a wrong offset!");
static_assert(offsetof(UVAL_PrizeWheelDef, Slots) == 0x000088, "Member 'UVAL_PrizeWheelDef::Slots' has a wrong offset!");

// Class Palia.ProjectileFiringComponent
// 0x00E8 (0x0188 - 0x00A0)
class UProjectileFiringComponent final : public UActorComponent
{
public:
	uint8                                         Pad_29B9[0x10];                                    // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnProjectileFired;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectedAmmo;                                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	class FName                                   FiringLocationSocketName;                          // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FProjectileFiringPersistBlock          ProjectileFiringPersistBlock;                      // 0x00D8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFiredProjectileData>           FiredProjectiles;                                  // 0x0128(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPreemptiveHitData>             PreemptiveHits;                                    // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29BA[0x10];                                    // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_ItemTypeDefinitionAsset*           SelectedAmmoType;                                  // 0x0158(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AValeriaProjectile>         ProjectileActorClass;                              // 0x0160(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29BB[0x10];                                    // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NextProjectileId;                                  // 0x0178(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAimRaycastDistance;                             // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinAimRaycastDistance;                             // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29BC[0x4];                                     // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool EquipProjectileAt(const struct FBagSlotLocation& AmmoSlotToEquip, EAmmoType Type, bool IsServerInitiated);
	void FireProjectile(class FName SocketToFireFrom);
	void HandleEquipmentChanged(class UEquipmentComponent* EquipmentComponent, const struct FEquipmentItem& Item);
	void NotifyAbilityStarted(class UValeriaGASComponent* GasComponent, class UValeriaGASGameplayAbility* Ability);
	struct FSelfUseEventResult OnClientUseEquippedInward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	struct FSelfUseEventResult OnClientUseEquippedOutward(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnRep_SelectedAmmoTypeUpdated();
	void RetryEquipProjectileFromPersistBlock(class UInventoryComponent* Inventory);
	void RpcClient_SetEquippedAmmo(const struct FBagSlotLocation& AmmoSlotToEquip, EAmmoType Type);
	void RpcNetMulticast_FireProjectile(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& AmmoItemType, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ToolItemType, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, int32 ProjectileId, int32 SelectedColor);
	void RpcServer_EquipProjectile(const struct FBagSlotLocation& Slot, EAmmoType Type);
	void RpcServer_FireProjectile(const struct FBagSlotLocation& AmmoSlotLocation, const struct FBagSlotLocation& ToolSlotLocation, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, int32 ProjectileId, int32 SelectedColor);
	void RpcServer_NotifyProjectileHit(int32 ProjectileId, class AActor* HitActor, const struct FVector& HitLocation);
	void TryAutoEquipAmmo();

	struct FBagSlotLocation GetEquippedAmmoSlot() const;
	struct FValeriaItem GetSelectedAmmo() const;
	const class UVAL_ItemTypeDefinitionAsset* GetSelectedAmmoType() const;
	bool HasUsableAmmoEquipped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileFiringComponent">();
	}
	static class UProjectileFiringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileFiringComponent>();
	}
};
static_assert(alignof(UProjectileFiringComponent) == 0x000008, "Wrong alignment on UProjectileFiringComponent");
static_assert(sizeof(UProjectileFiringComponent) == 0x000188, "Wrong size on UProjectileFiringComponent");
static_assert(offsetof(UProjectileFiringComponent, OnProjectileFired) == 0x0000B0, "Member 'UProjectileFiringComponent::OnProjectileFired' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, OnSelectedAmmo) == 0x0000C0, "Member 'UProjectileFiringComponent::OnSelectedAmmo' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, FiringLocationSocketName) == 0x0000D0, "Member 'UProjectileFiringComponent::FiringLocationSocketName' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, ProjectileFiringPersistBlock) == 0x0000D8, "Member 'UProjectileFiringComponent::ProjectileFiringPersistBlock' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, FiredProjectiles) == 0x000128, "Member 'UProjectileFiringComponent::FiredProjectiles' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, PreemptiveHits) == 0x000138, "Member 'UProjectileFiringComponent::PreemptiveHits' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, SelectedAmmoType) == 0x000158, "Member 'UProjectileFiringComponent::SelectedAmmoType' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, ProjectileActorClass) == 0x000160, "Member 'UProjectileFiringComponent::ProjectileActorClass' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, NextProjectileId) == 0x000178, "Member 'UProjectileFiringComponent::NextProjectileId' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, MaxAimRaycastDistance) == 0x00017C, "Member 'UProjectileFiringComponent::MaxAimRaycastDistance' has a wrong offset!");
static_assert(offsetof(UProjectileFiringComponent, MinAimRaycastDistance) == 0x000180, "Member 'UProjectileFiringComponent::MinAimRaycastDistance' has a wrong offset!");

// Class Palia.ProximityChecker
// 0x0070 (0x0310 - 0x02A0)
class UProximityChecker final : public USceneComponent
{
public:
	float                                         DistanceToTrack;                                   // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C3[0x4];                                     // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTrackerChanged;                                  // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C4[0x8];                                     // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, bool>                     ActorsToTrack;                                     // 0x02C0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void DeactivateTracking();
	void OnActorDestroyed(class AActor* InActor);
	void StartTracking(class AActor* ActorToTrack);
	void StopTracking(class AActor* ActorToTrack);

	bool IsTrackingActive() const;
	bool IsTrackingActor(class AActor* ActorToTrack) const;
	bool IsWithinDistance(class AActor* ActorToTrack) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProximityChecker">();
	}
	static class UProximityChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProximityChecker>();
	}
};
static_assert(alignof(UProximityChecker) == 0x000010, "Wrong alignment on UProximityChecker");
static_assert(sizeof(UProximityChecker) == 0x000310, "Wrong size on UProximityChecker");
static_assert(offsetof(UProximityChecker, DistanceToTrack) == 0x0002A0, "Member 'UProximityChecker::DistanceToTrack' has a wrong offset!");
static_assert(offsetof(UProximityChecker, OnTrackerChanged) == 0x0002A8, "Member 'UProximityChecker::OnTrackerChanged' has a wrong offset!");
static_assert(offsetof(UProximityChecker, ActorsToTrack) == 0x0002C0, "Member 'UProximityChecker::ActorsToTrack' has a wrong offset!");

// Class Palia.VAL_QuestDef
// 0x00A8 (0x0128 - 0x0080)
class UVAL_QuestDef final : public UVAL_BatchedDataAsset
{
public:
	bool                                          bEnabled;                                          // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C7[0x3];                                     // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Version;                                           // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAccomplishment;                                 // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C8[0x7];                                     // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVAL_QuestCategory                            QuestCategory;                                     // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAutoPinToTracker;                           // 0x00E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActivityQuest;                                  // 0x00EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C9[0x5];                                     // 0x00EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestRewardConfig>             StartRewards;                                      // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bLastsForever;                                     // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29CA[0x7];                                     // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_GameplayConditionDef*              ExpirationCondition;                               // 0x0108(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatable;                                       // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29CB[0x3];                                     // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CooldownAfterCompletionSecs;                       // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVAL_QuestStepDef>              Steps;                                             // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static const TSoftObjectPtr<class UVAL_QuestDef> GetAssetByPersistId_Cast(int32 PersistIdToGet);
	static TArray<TSoftObjectPtr<class UVAL_QuestDef>> GetAssetsOfType_Cast();

	bool IsHidden() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_QuestDef">();
	}
	static class UVAL_QuestDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_QuestDef>();
	}
};
static_assert(alignof(UVAL_QuestDef) == 0x000008, "Wrong alignment on UVAL_QuestDef");
static_assert(sizeof(UVAL_QuestDef) == 0x000128, "Wrong size on UVAL_QuestDef");
static_assert(offsetof(UVAL_QuestDef, bEnabled) == 0x000080, "Member 'UVAL_QuestDef::bEnabled' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, Version) == 0x000084, "Member 'UVAL_QuestDef::Version' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, bIsAccomplishment) == 0x000088, "Member 'UVAL_QuestDef::bIsAccomplishment' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, Title) == 0x000090, "Member 'UVAL_QuestDef::Title' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, Description) == 0x0000A8, "Member 'UVAL_QuestDef::Description' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, Icon) == 0x0000C0, "Member 'UVAL_QuestDef::Icon' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, QuestCategory) == 0x0000E8, "Member 'UVAL_QuestDef::QuestCategory' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, bShouldAutoPinToTracker) == 0x0000E9, "Member 'UVAL_QuestDef::bShouldAutoPinToTracker' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, bIsActivityQuest) == 0x0000EA, "Member 'UVAL_QuestDef::bIsActivityQuest' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, StartRewards) == 0x0000F0, "Member 'UVAL_QuestDef::StartRewards' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, bLastsForever) == 0x000100, "Member 'UVAL_QuestDef::bLastsForever' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, ExpirationCondition) == 0x000108, "Member 'UVAL_QuestDef::ExpirationCondition' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, bRepeatable) == 0x000110, "Member 'UVAL_QuestDef::bRepeatable' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, CooldownAfterCompletionSecs) == 0x000114, "Member 'UVAL_QuestDef::CooldownAfterCompletionSecs' has a wrong offset!");
static_assert(offsetof(UVAL_QuestDef, Steps) == 0x000118, "Member 'UVAL_QuestDef::Steps' has a wrong offset!");

// Class Palia.QuestGiverComponent
// 0x0080 (0x0120 - 0x00A0)
class UQuestGiverComponent final : public UActorComponent
{
public:
	uint8                                         Pad_29CD[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QuestSelectorConfigId;                             // 0x00A8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29CE[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestReward>                   CurrentRewards;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPublic)
	struct FQuest                                 CurrentQuest;                                      // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NativeAccessSpecifierPublic)
	int32                                         TimeQuestStartedAtSecs;                            // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeQuestEndsAtSecs;                               // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasBeenShared;                                    // 0x0100(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29CF[0x7];                                     // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPersistGuid>                   RewardsCollectedByPlayerIds;                       // 0x0108(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         TimeWhenNextQuestStartsSecs;                       // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29D0[0x4];                                     // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Character, const struct FInteractEventParams& Params_0);
	struct FUseEventResult OnClientUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FUseEventParams& Params_0);
	void OnReplicatedAndShouldBroadcast();
	struct FServerUseEventResult OnServerInteract(class UInteractableComponent* Interactable, class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams);
	void OnServerUsedEquippedOnMe(class AValeriaPlayerController* Player, const struct FServerUseEventParams& Params_0);

	bool CanCollectReward(class AValeriaCharacter* Character) const;
	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	bool HasBeenShared() const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;
	bool IsQuestReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestGiverComponent">();
	}
	static class UQuestGiverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestGiverComponent>();
	}
};
static_assert(alignof(UQuestGiverComponent) == 0x000008, "Wrong alignment on UQuestGiverComponent");
static_assert(sizeof(UQuestGiverComponent) == 0x000120, "Wrong size on UQuestGiverComponent");
static_assert(offsetof(UQuestGiverComponent, QuestSelectorConfigId) == 0x0000A8, "Member 'UQuestGiverComponent::QuestSelectorConfigId' has a wrong offset!");
static_assert(offsetof(UQuestGiverComponent, CurrentRewards) == 0x0000B0, "Member 'UQuestGiverComponent::CurrentRewards' has a wrong offset!");
static_assert(offsetof(UQuestGiverComponent, CurrentQuest) == 0x0000C0, "Member 'UQuestGiverComponent::CurrentQuest' has a wrong offset!");
static_assert(offsetof(UQuestGiverComponent, TimeQuestStartedAtSecs) == 0x0000E8, "Member 'UQuestGiverComponent::TimeQuestStartedAtSecs' has a wrong offset!");
static_assert(offsetof(UQuestGiverComponent, TimeQuestEndsAtSecs) == 0x0000EC, "Member 'UQuestGiverComponent::TimeQuestEndsAtSecs' has a wrong offset!");
static_assert(offsetof(UQuestGiverComponent, OnChanged) == 0x0000F0, "Member 'UQuestGiverComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UQuestGiverComponent, bHasBeenShared) == 0x000100, "Member 'UQuestGiverComponent::bHasBeenShared' has a wrong offset!");
static_assert(offsetof(UQuestGiverComponent, RewardsCollectedByPlayerIds) == 0x000108, "Member 'UQuestGiverComponent::RewardsCollectedByPlayerIds' has a wrong offset!");
static_assert(offsetof(UQuestGiverComponent, TimeWhenNextQuestStartsSecs) == 0x000118, "Member 'UQuestGiverComponent::TimeWhenNextQuestStartsSecs' has a wrong offset!");

// Class Palia.QuestProgressComponent
// 0x0170 (0x0210 - 0x00A0)
class UQuestProgressComponent final : public UActorComponent
{
public:
	uint8                                         Pad_29D7[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuestStarted;                                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuestCompleted;                                  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuestStepCompleted;                              // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuestStepProgressed;                             // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuestGoalProgressed;                             // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, struct FQuestDialogueArray> CurrentQuestTurnInDialogueAssets;                  // 0x0108(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class AValeriaCharacter*                      VC;                                                // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           RunQuestUpdatesHandle;                             // 0x0160(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVAL_QuestProgressPersistBlock         QuestProgressPersistBlock;                         // 0x0168(0x00A0)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29D8[0x8];                                     // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_QuestProgressPersistBlock(struct FVAL_QuestProgressPersistBlock& OldQuestProgressPersistBlock);
	void RpcClient_ForceMarkQuestProgressReplicated();
	void RpcServer_ToggleQuestPin(int32 QuestPersistId);
	void Server_RunQuestCleanups();
	void Server_RunQuestUpdates();
	void ToggleQuestPin(int32 QuestPersistId);

	void Debug_UpdateClientDebugView() const;
	struct FVAL_QuestState FindActiveQuestInfo(int32 ID) const;
	struct FVAL_QuestState FindInactiveQuestInfo(int32 ID) const;
	struct FVAL_QuestState FindQuestInfo(int32 ID) const;
	TArray<struct FVAL_QuestState> GetActiveAccomplishments() const;
	const TArray<struct FVAL_QuestState> GetAllAccomplishments() const;
	TArray<struct FVAL_QuestState> GetAllActiveQuests() const;
	TArray<struct FVAL_QuestState> GetAllInactiveQuests() const;
	const TArray<struct FVAL_QuestState> GetCompletedAccomplishments() const;
	TArray<struct FVAL_QuestState> GetCompletedQuests() const;
	TArray<struct FVAL_QuestState> GetDisplayableQuests() const;
	struct FVAL_QuestState GetFirstActiveQuestInfo() const;
	int32 GetNumPinned() const;
	const TArray<struct FVAL_QuestState> GetUnstartedAccomplishments() const;
	bool IsBelowPinLimit() const;
	bool IsQuestActiveByDef(TSoftObjectPtr<class UVAL_QuestDef> InQuestDef) const;
	bool IsQuestActiveByID(int32 ID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestProgressComponent">();
	}
	static class UQuestProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestProgressComponent>();
	}
};
static_assert(alignof(UQuestProgressComponent) == 0x000008, "Wrong alignment on UQuestProgressComponent");
static_assert(sizeof(UQuestProgressComponent) == 0x000210, "Wrong size on UQuestProgressComponent");
static_assert(offsetof(UQuestProgressComponent, OnChanged) == 0x0000A8, "Member 'UQuestProgressComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UQuestProgressComponent, OnQuestStarted) == 0x0000B8, "Member 'UQuestProgressComponent::OnQuestStarted' has a wrong offset!");
static_assert(offsetof(UQuestProgressComponent, OnQuestCompleted) == 0x0000C8, "Member 'UQuestProgressComponent::OnQuestCompleted' has a wrong offset!");
static_assert(offsetof(UQuestProgressComponent, OnQuestStepCompleted) == 0x0000D8, "Member 'UQuestProgressComponent::OnQuestStepCompleted' has a wrong offset!");
static_assert(offsetof(UQuestProgressComponent, OnQuestStepProgressed) == 0x0000E8, "Member 'UQuestProgressComponent::OnQuestStepProgressed' has a wrong offset!");
static_assert(offsetof(UQuestProgressComponent, OnQuestGoalProgressed) == 0x0000F8, "Member 'UQuestProgressComponent::OnQuestGoalProgressed' has a wrong offset!");
static_assert(offsetof(UQuestProgressComponent, CurrentQuestTurnInDialogueAssets) == 0x000108, "Member 'UQuestProgressComponent::CurrentQuestTurnInDialogueAssets' has a wrong offset!");
static_assert(offsetof(UQuestProgressComponent, VC) == 0x000158, "Member 'UQuestProgressComponent::VC' has a wrong offset!");
static_assert(offsetof(UQuestProgressComponent, RunQuestUpdatesHandle) == 0x000160, "Member 'UQuestProgressComponent::RunQuestUpdatesHandle' has a wrong offset!");
static_assert(offsetof(UQuestProgressComponent, QuestProgressPersistBlock) == 0x000168, "Member 'UQuestProgressComponent::QuestProgressPersistBlock' has a wrong offset!");

// Class Palia.ReplicationTrackingComponent
// 0x0018 (0x00B8 - 0x00A0)
class UReplicationTrackingComponent final : public UActorComponent
{
public:
	TArray<int32>                                 VillagersToTrack;                                  // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bAllVillagersTracked;                              // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29DE[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RpcServer_ChangeAllVillagerTracking(bool Tracked);
	void Server_TrackVillager(int32 VillagerId);
	void Server_UntrackVillager(int32 VillagerId);
	void TrackAllVillagers();
	void UntrackAllVillagers();

	bool Server_IsTrackingVillager(int32 VillagerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicationTrackingComponent">();
	}
	static class UReplicationTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplicationTrackingComponent>();
	}
};
static_assert(alignof(UReplicationTrackingComponent) == 0x000008, "Wrong alignment on UReplicationTrackingComponent");
static_assert(sizeof(UReplicationTrackingComponent) == 0x0000B8, "Wrong size on UReplicationTrackingComponent");
static_assert(offsetof(UReplicationTrackingComponent, VillagersToTrack) == 0x0000A0, "Member 'UReplicationTrackingComponent::VillagersToTrack' has a wrong offset!");
static_assert(offsetof(UReplicationTrackingComponent, bAllVillagersTracked) == 0x0000B0, "Member 'UReplicationTrackingComponent::bAllVillagersTracked' has a wrong offset!");

// Class Palia.ResourceTrackerGlobalConfig
// 0x0050 (0x0080 - 0x0030)
class UResourceTrackerGlobalConfig final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FResourceTrackerTypeConfig> TrackableResourceTypes;                            // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceTrackerGlobalConfig">();
	}
	static class UResourceTrackerGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResourceTrackerGlobalConfig>();
	}
};
static_assert(alignof(UResourceTrackerGlobalConfig) == 0x000008, "Wrong alignment on UResourceTrackerGlobalConfig");
static_assert(sizeof(UResourceTrackerGlobalConfig) == 0x000080, "Wrong size on UResourceTrackerGlobalConfig");
static_assert(offsetof(UResourceTrackerGlobalConfig, TrackableResourceTypes) == 0x000030, "Member 'UResourceTrackerGlobalConfig::TrackableResourceTypes' has a wrong offset!");

// Class Palia.SceneGenData
// 0x0058 (0x0088 - 0x0030)
class USceneGenData final : public UPrimaryDataAsset
{
public:
	int32                                         Instance;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E0[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0038(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        Streamer;                                          // 0x0060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActorSocket*>                   Sockets;                                           // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AAttachmentGenerator*                   Generator;                                         // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Loaded;                                            // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E1[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneGenData">();
	}
	static class USceneGenData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneGenData>();
	}
};
static_assert(alignof(USceneGenData) == 0x000008, "Wrong alignment on USceneGenData");
static_assert(sizeof(USceneGenData) == 0x000088, "Wrong size on USceneGenData");
static_assert(offsetof(USceneGenData, Instance) == 0x000030, "Member 'USceneGenData::Instance' has a wrong offset!");
static_assert(offsetof(USceneGenData, Level) == 0x000038, "Member 'USceneGenData::Level' has a wrong offset!");
static_assert(offsetof(USceneGenData, Streamer) == 0x000060, "Member 'USceneGenData::Streamer' has a wrong offset!");
static_assert(offsetof(USceneGenData, Sockets) == 0x000068, "Member 'USceneGenData::Sockets' has a wrong offset!");
static_assert(offsetof(USceneGenData, Generator) == 0x000078, "Member 'USceneGenData::Generator' has a wrong offset!");
static_assert(offsetof(USceneGenData, Loaded) == 0x000080, "Member 'USceneGenData::Loaded' has a wrong offset!");

// Class Palia.ActorSocket
// 0x00B8 (0x0360 - 0x02A8)
class AActorSocket final : public AActor
{
public:
	struct FGameplayTagRequirements               Requirements;                                      // 0x02A8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	class AActorSocket*                           ConnectedSocket;                                   // 0x0330(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0338(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetAttached(class AActorSocket* Actor);

	bool IsAttached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSocket">();
	}
	static class AActorSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorSocket>();
	}
};
static_assert(alignof(AActorSocket) == 0x000008, "Wrong alignment on AActorSocket");
static_assert(sizeof(AActorSocket) == 0x000360, "Wrong size on AActorSocket");
static_assert(offsetof(AActorSocket, Requirements) == 0x0002A8, "Member 'AActorSocket::Requirements' has a wrong offset!");
static_assert(offsetof(AActorSocket, ConnectedSocket) == 0x000330, "Member 'AActorSocket::ConnectedSocket' has a wrong offset!");
static_assert(offsetof(AActorSocket, Level) == 0x000338, "Member 'AActorSocket::Level' has a wrong offset!");

// Class Palia.ShaderBasedAnimation
// 0x0020 (0x0050 - 0x0030)
class UShaderBasedAnimation final : public UDataAsset
{
public:
	float                                         StartFrame;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndFrame;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalFrames;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FramesPerSecond;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FShaderBasedAnimEvent>          Events;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	float GetDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShaderBasedAnimation">();
	}
	static class UShaderBasedAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShaderBasedAnimation>();
	}
};
static_assert(alignof(UShaderBasedAnimation) == 0x000008, "Wrong alignment on UShaderBasedAnimation");
static_assert(sizeof(UShaderBasedAnimation) == 0x000050, "Wrong size on UShaderBasedAnimation");
static_assert(offsetof(UShaderBasedAnimation, StartFrame) == 0x000030, "Member 'UShaderBasedAnimation::StartFrame' has a wrong offset!");
static_assert(offsetof(UShaderBasedAnimation, EndFrame) == 0x000034, "Member 'UShaderBasedAnimation::EndFrame' has a wrong offset!");
static_assert(offsetof(UShaderBasedAnimation, TotalFrames) == 0x000038, "Member 'UShaderBasedAnimation::TotalFrames' has a wrong offset!");
static_assert(offsetof(UShaderBasedAnimation, FramesPerSecond) == 0x00003C, "Member 'UShaderBasedAnimation::FramesPerSecond' has a wrong offset!");
static_assert(offsetof(UShaderBasedAnimation, Events) == 0x000040, "Member 'UShaderBasedAnimation::Events' has a wrong offset!");

// Class Palia.ShippingBinComponent
// 0x0020 (0x01E8 - 0x01C8)
class UShippingBinComponent final : public UInventoryComponent
{
public:
	uint8                                         Pad_29E2[0x8];                                     // 0x01C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CheckAndTryToSellItemsTimerHandle;                 // 0x01D0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         LastCheckedTimeToSell;                             // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SecondsUntilNextShipment;                          // 0x01E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29E3[0x4];                                     // 0x01E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetTimeUntilNextShipment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShippingBinComponent">();
	}
	static class UShippingBinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShippingBinComponent>();
	}
};
static_assert(alignof(UShippingBinComponent) == 0x000008, "Wrong alignment on UShippingBinComponent");
static_assert(sizeof(UShippingBinComponent) == 0x0001E8, "Wrong size on UShippingBinComponent");
static_assert(offsetof(UShippingBinComponent, CheckAndTryToSellItemsTimerHandle) == 0x0001D0, "Member 'UShippingBinComponent::CheckAndTryToSellItemsTimerHandle' has a wrong offset!");
static_assert(offsetof(UShippingBinComponent, LastCheckedTimeToSell) == 0x0001D8, "Member 'UShippingBinComponent::LastCheckedTimeToSell' has a wrong offset!");
static_assert(offsetof(UShippingBinComponent, SecondsUntilNextShipment) == 0x0001E0, "Member 'UShippingBinComponent::SecondsUntilNextShipment' has a wrong offset!");

// Class Palia.ShopSlotComponent
// 0x0010 (0x02B0 - 0x02A0)
class UShopSlotComponent final : public USceneComponent
{
public:
	class FName                                   ShopSelectorName;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttachedActor;                                     // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AttachedActorWasDestroyed(class AActor* ActorDestroyed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopSlotComponent">();
	}
	static class UShopSlotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopSlotComponent>();
	}
};
static_assert(alignof(UShopSlotComponent) == 0x000010, "Wrong alignment on UShopSlotComponent");
static_assert(sizeof(UShopSlotComponent) == 0x0002B0, "Wrong size on UShopSlotComponent");
static_assert(offsetof(UShopSlotComponent, ShopSelectorName) == 0x0002A0, "Member 'UShopSlotComponent::ShopSelectorName' has a wrong offset!");
static_assert(offsetof(UShopSlotComponent, AttachedActor) == 0x0002A8, "Member 'UShopSlotComponent::AttachedActor' has a wrong offset!");

// Class Palia.SlidingPuzzleBoard
// 0x00F0 (0x0398 - 0x02A8)
class ASlidingPuzzleBoard final : public AActor
{
public:
	class USceneComponent*                        SlidingPuzzleBoardRootComponent;                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SlidingPuzzlePiecesRootComponent;                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SlidingPuzzleBoardCompletedDel;                    // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SlidingPuzzleBoardMoveStartedDel;                  // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SlidingPuzzleBoardMoveCompletedDel;                // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class ASlidingPuzzlePiece>        SlidingPuzzlePieceClass;                           // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PieceSpacing;                                      // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PieceMovementTime;                                 // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FIntPoint, class ASlidingPuzzlePiece*> PuzzlePieceGrid;                                   // 0x02F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	class USlidingPuzzleConfig*                   CachedSlidingPuzzleConfig;                         // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlidingPuzzleMove                     SlidingPuzzleMove;                                 // 0x0350(0x0038)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FIntPoint                              OpenSpaceLocation;                                 // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCompleted;                                        // 0x0390(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovingPiece;                                      // 0x0391(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29E4[0x2];                                     // 0x0392(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentPieceMovementTime;                          // 0x0394(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CheckPuzzleCompletion();
	void CreatePieces();
	void InitializeSlidingPuzzleBoard(class USlidingPuzzleConfig* InSlidingPuzzleConfig);
	void MoveSlidingPuzzlePiece(class ASlidingPuzzlePiece* InPiece);
	void MoveSlidingPuzzlePieceWithDirection(ESlidingPuzzleCardinalDirections InDirection);
	void OnRep_bCompleted();
	void OnRep_SlidingPuzzleMove();
	void TryResetPuzzle();

	bool CanMovePiece(class ASlidingPuzzlePiece* InPiece) const;
	bool CanResetPuzzle() const;
	bool IsCompleted() const;
	bool IsMovingPiece() const;
	bool IsPointAdjacentToOpenSpace(struct FIntPoint& InPoint) const;
	bool IsPuzzleSolved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlidingPuzzleBoard">();
	}
	static class ASlidingPuzzleBoard* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlidingPuzzleBoard>();
	}
};
static_assert(alignof(ASlidingPuzzleBoard) == 0x000008, "Wrong alignment on ASlidingPuzzleBoard");
static_assert(sizeof(ASlidingPuzzleBoard) == 0x000398, "Wrong size on ASlidingPuzzleBoard");
static_assert(offsetof(ASlidingPuzzleBoard, SlidingPuzzleBoardRootComponent) == 0x0002A8, "Member 'ASlidingPuzzleBoard::SlidingPuzzleBoardRootComponent' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, SlidingPuzzlePiecesRootComponent) == 0x0002B0, "Member 'ASlidingPuzzleBoard::SlidingPuzzlePiecesRootComponent' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, SlidingPuzzleBoardCompletedDel) == 0x0002B8, "Member 'ASlidingPuzzleBoard::SlidingPuzzleBoardCompletedDel' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, SlidingPuzzleBoardMoveStartedDel) == 0x0002C8, "Member 'ASlidingPuzzleBoard::SlidingPuzzleBoardMoveStartedDel' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, SlidingPuzzleBoardMoveCompletedDel) == 0x0002D8, "Member 'ASlidingPuzzleBoard::SlidingPuzzleBoardMoveCompletedDel' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, SlidingPuzzlePieceClass) == 0x0002E8, "Member 'ASlidingPuzzleBoard::SlidingPuzzlePieceClass' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, PieceSpacing) == 0x0002F0, "Member 'ASlidingPuzzleBoard::PieceSpacing' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, PieceMovementTime) == 0x0002F4, "Member 'ASlidingPuzzleBoard::PieceMovementTime' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, PuzzlePieceGrid) == 0x0002F8, "Member 'ASlidingPuzzleBoard::PuzzlePieceGrid' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, CachedSlidingPuzzleConfig) == 0x000348, "Member 'ASlidingPuzzleBoard::CachedSlidingPuzzleConfig' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, SlidingPuzzleMove) == 0x000350, "Member 'ASlidingPuzzleBoard::SlidingPuzzleMove' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, OpenSpaceLocation) == 0x000388, "Member 'ASlidingPuzzleBoard::OpenSpaceLocation' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, bCompleted) == 0x000390, "Member 'ASlidingPuzzleBoard::bCompleted' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, bMovingPiece) == 0x000391, "Member 'ASlidingPuzzleBoard::bMovingPiece' has a wrong offset!");
static_assert(offsetof(ASlidingPuzzleBoard, CurrentPieceMovementTime) == 0x000394, "Member 'ASlidingPuzzleBoard::CurrentPieceMovementTime' has a wrong offset!");

// Class Palia.SlidingPuzzleInputHandlerComponent
// 0x0020 (0x0110 - 0x00F0)
class USlidingPuzzleInputHandlerComponent final : public USubgameInputHandlerComponent
{
public:
	TArray<EObjectTypeQuery>                      MouseQueryObjectTypes;                             // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USlidingPuzzleSubgameManagerComponent*  SlidingPuzzleSubgameManagerComponent;              // 0x0100(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ASlidingPuzzlePiece>     HoveredPuzzlePiece;                                // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateHoveredPuzzlePiece(class ASlidingPuzzlePiece* InSlidingPuzzlePiece);

	bool CanHoverPieces() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlidingPuzzleInputHandlerComponent">();
	}
	static class USlidingPuzzleInputHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlidingPuzzleInputHandlerComponent>();
	}
};
static_assert(alignof(USlidingPuzzleInputHandlerComponent) == 0x000008, "Wrong alignment on USlidingPuzzleInputHandlerComponent");
static_assert(sizeof(USlidingPuzzleInputHandlerComponent) == 0x000110, "Wrong size on USlidingPuzzleInputHandlerComponent");
static_assert(offsetof(USlidingPuzzleInputHandlerComponent, MouseQueryObjectTypes) == 0x0000F0, "Member 'USlidingPuzzleInputHandlerComponent::MouseQueryObjectTypes' has a wrong offset!");
static_assert(offsetof(USlidingPuzzleInputHandlerComponent, SlidingPuzzleSubgameManagerComponent) == 0x000100, "Member 'USlidingPuzzleInputHandlerComponent::SlidingPuzzleSubgameManagerComponent' has a wrong offset!");
static_assert(offsetof(USlidingPuzzleInputHandlerComponent, HoveredPuzzlePiece) == 0x000108, "Member 'USlidingPuzzleInputHandlerComponent::HoveredPuzzlePiece' has a wrong offset!");

// Class Palia.SpawnerComponent
// 0x01C8 (0x0268 - 0x00A0)
class USpawnerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSpawned;                                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDespawned;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ESpawnerKind                                  SpawnerKind;                                       // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E7[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeightedActorToSpawn>          ActorsToSpawn;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         IntervalBetweenSpawnsSecs;                         // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialSpawnDelay;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinActorsOnStartup;                                // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxActors;                                         // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysOrientUpAxisToZAxis;                         // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RaycastToSpawnOnTerrain;                           // 0x00E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RaycastToSpawnOnWater;                             // 0x00EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E8[0x1];                                     // 0x00EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceOffsetOfTerrain;                           // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DespawnTimerOverride;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnerMode                                  SpawnMode;                                         // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E9[0x3];                                     // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnOnFoliageTag;                                 // 0x00FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29EA[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         ActorTypesToAttachTo;                              // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CoopSpawningEnabled;                               // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29EB[0x3];                                     // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoopSpawningDestroyTimeAfterFirstGatherSecs;       // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalNumSpawnedActors;                             // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextTimeToSpawn;                                   // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDevOnly;                                        // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBeginSpawningAutomatically;                       // 0x0129(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReadyToSpawn;                                   // 0x012A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29EC[0x5];                                     // 0x012B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SpawningIsReadyTimer;                              // 0x0130(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USpawnPointComponent*>           SpawnPoints;                                       // 0x0138(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ActorsSpawned;                                     // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class AActor>, int32>        ActorClassMap;                                     // 0x0158(0x0050)(NativeAccessSpecifierPrivate)
	TMap<TSoftObjectPtr<class AActor>, struct FLimitedTimeFilterToCheck> LimitedTimeActorsMap;                              // 0x01A8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FString, int32>                    SpawnCountTracking;                                // 0x01F8(0x0050)(NativeAccessSpecifierPrivate)
	int32                                         LastTrackingAmountDisplayed;                       // 0x0248(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastTrackingTime;                                  // 0x024C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29ED[0x10];                                    // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         SpawnerIdForTelemetry;                             // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SpawnedActorWasDestroyed(class AActor* InActorDestroyed);

	const TArray<class AActor*> GetSpawnedActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerComponent">();
	}
	static class USpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerComponent>();
	}
};
static_assert(alignof(USpawnerComponent) == 0x000008, "Wrong alignment on USpawnerComponent");
static_assert(sizeof(USpawnerComponent) == 0x000268, "Wrong size on USpawnerComponent");
static_assert(offsetof(USpawnerComponent, OnSpawned) == 0x0000A0, "Member 'USpawnerComponent::OnSpawned' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnDespawned) == 0x0000B0, "Member 'USpawnerComponent::OnDespawned' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnerKind) == 0x0000C0, "Member 'USpawnerComponent::SpawnerKind' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, ActorsToSpawn) == 0x0000C8, "Member 'USpawnerComponent::ActorsToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, IntervalBetweenSpawnsSecs) == 0x0000D8, "Member 'USpawnerComponent::IntervalBetweenSpawnsSecs' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, InitialSpawnDelay) == 0x0000DC, "Member 'USpawnerComponent::InitialSpawnDelay' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, MinActorsOnStartup) == 0x0000E0, "Member 'USpawnerComponent::MinActorsOnStartup' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, MaxActors) == 0x0000E4, "Member 'USpawnerComponent::MaxActors' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, AlwaysOrientUpAxisToZAxis) == 0x0000E8, "Member 'USpawnerComponent::AlwaysOrientUpAxisToZAxis' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, RaycastToSpawnOnTerrain) == 0x0000E9, "Member 'USpawnerComponent::RaycastToSpawnOnTerrain' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, RaycastToSpawnOnWater) == 0x0000EA, "Member 'USpawnerComponent::RaycastToSpawnOnWater' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, DistanceOffsetOfTerrain) == 0x0000EC, "Member 'USpawnerComponent::DistanceOffsetOfTerrain' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, DespawnTimerOverride) == 0x0000F0, "Member 'USpawnerComponent::DespawnTimerOverride' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnMode) == 0x0000F4, "Member 'USpawnerComponent::SpawnMode' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, Radius) == 0x0000F8, "Member 'USpawnerComponent::Radius' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnOnFoliageTag) == 0x0000FC, "Member 'USpawnerComponent::SpawnOnFoliageTag' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, ActorTypesToAttachTo) == 0x000108, "Member 'USpawnerComponent::ActorTypesToAttachTo' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, CoopSpawningEnabled) == 0x000118, "Member 'USpawnerComponent::CoopSpawningEnabled' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, CoopSpawningDestroyTimeAfterFirstGatherSecs) == 0x00011C, "Member 'USpawnerComponent::CoopSpawningDestroyTimeAfterFirstGatherSecs' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, TotalNumSpawnedActors) == 0x000120, "Member 'USpawnerComponent::TotalNumSpawnedActors' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, NextTimeToSpawn) == 0x000124, "Member 'USpawnerComponent::NextTimeToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bIsDevOnly) == 0x000128, "Member 'USpawnerComponent::bIsDevOnly' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bBeginSpawningAutomatically) == 0x000129, "Member 'USpawnerComponent::bBeginSpawningAutomatically' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bIsReadyToSpawn) == 0x00012A, "Member 'USpawnerComponent::bIsReadyToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawningIsReadyTimer) == 0x000130, "Member 'USpawnerComponent::SpawningIsReadyTimer' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnPoints) == 0x000138, "Member 'USpawnerComponent::SpawnPoints' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, ActorsSpawned) == 0x000148, "Member 'USpawnerComponent::ActorsSpawned' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, ActorClassMap) == 0x000158, "Member 'USpawnerComponent::ActorClassMap' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, LimitedTimeActorsMap) == 0x0001A8, "Member 'USpawnerComponent::LimitedTimeActorsMap' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnCountTracking) == 0x0001F8, "Member 'USpawnerComponent::SpawnCountTracking' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, LastTrackingAmountDisplayed) == 0x000248, "Member 'USpawnerComponent::LastTrackingAmountDisplayed' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, LastTrackingTime) == 0x00024C, "Member 'USpawnerComponent::LastTrackingTime' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnerIdForTelemetry) == 0x000260, "Member 'USpawnerComponent::SpawnerIdForTelemetry' has a wrong offset!");

// Class Palia.SpawningManager
// 0x0078 (0x00A8 - 0x0030)
class USpawningManager final : public UGameInstanceSubsystem
{
public:
	bool                                          bIsHoneyLureDebuggerEnabled;                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDevOnlySpawnsEnabled;                             // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29EE[0x6];                                     // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USpawnerComponent*>              AllSpawners;                                       // 0x0038(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FTelemetryInfoForSpawnedResource> TelemetryInfoFromSpawnedResources;                 // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	int64                                         NextUniqueIdForTelemetry;                          // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldSendSpawnInfoToTelemetry;                   // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29EF[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int64 GenerateUniqueIdForTelemetry();
	class AActor* SpawnActorAtSpawnPointAroundArea(const struct FVector& Center, float Radius, class UClass* ClassTypesToSpawn, class UDefaultSpawnRarityConfig* DefaultSpawns, EWhereToSpawnActors WhereToSpawn, class UObject* Instigator, int64 TelemetryUniqueId);
	void SpawnedActorWasDestroyed(class AActor* ActorDestroyed);
	class AActor* SpawnSecondaryActor(class AActor* OwnerActor, TSubclassOf<class AActor> ActorClassToSpawn, const class FString& SpawnerName, EResourceSpawnedReason SpawnReason, float MinSpawnRadius, float MaxSpawnRadius);

	int32 FindAllPossibleSpawnsInArea(const struct FVector& Center, float Radius, class UClass* ClassTypesToSpawn, TArray<class UClass*>* OutClassesConsidered) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawningManager">();
	}
	static class USpawningManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawningManager>();
	}
};
static_assert(alignof(USpawningManager) == 0x000008, "Wrong alignment on USpawningManager");
static_assert(sizeof(USpawningManager) == 0x0000A8, "Wrong size on USpawningManager");
static_assert(offsetof(USpawningManager, bIsHoneyLureDebuggerEnabled) == 0x000030, "Member 'USpawningManager::bIsHoneyLureDebuggerEnabled' has a wrong offset!");
static_assert(offsetof(USpawningManager, bDevOnlySpawnsEnabled) == 0x000031, "Member 'USpawningManager::bDevOnlySpawnsEnabled' has a wrong offset!");
static_assert(offsetof(USpawningManager, AllSpawners) == 0x000038, "Member 'USpawningManager::AllSpawners' has a wrong offset!");
static_assert(offsetof(USpawningManager, TelemetryInfoFromSpawnedResources) == 0x000048, "Member 'USpawningManager::TelemetryInfoFromSpawnedResources' has a wrong offset!");
static_assert(offsetof(USpawningManager, NextUniqueIdForTelemetry) == 0x000098, "Member 'USpawningManager::NextUniqueIdForTelemetry' has a wrong offset!");
static_assert(offsetof(USpawningManager, bShouldSendSpawnInfoToTelemetry) == 0x0000A0, "Member 'USpawningManager::bShouldSendSpawnInfoToTelemetry' has a wrong offset!");

// Class Palia.VAl_PartySettings
// 0x0200 (0x0238 - 0x0038)
class UVAl_PartySettings final : public UDeveloperSettings
{
public:
	int32                                         PartyInviteExpiryTimeInSeconds;                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyCreationWaitTimeInSeconds;                    // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CharacterKickedText;                               // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalKickedText;                                // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PartyDeletedText;                                  // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterLeftText;                                 // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalLeftText;                                  // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterJoinedText;                               // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalCreatedText;                               // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalJoinedText;                                // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalDeclinedInviteText;                        // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   DeclinedInviteText;                                // 0x0118(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   DeclinedInviteFullText;                            // 0x0130(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalDeclinedInviteFullText;                    // 0x0148(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   DeclinedInviteAlreadyInPartyText;                  // 0x0160(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalLeaderChangedText;                         // 0x0178(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   LeaderChangedText;                                 // 0x0190(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalInviteRescindedText;                       // 0x01A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   InviteRescindedText;                               // 0x01C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   SentInviteTimedOutText;                            // 0x01D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ReceivedInviteTimedOutText;                        // 0x01F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   MemberPromotedText;                                // 0x0208(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   AcceptedInviteFTUEErrorText;                       // 0x0220(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAl_PartySettings">();
	}
	static class UVAl_PartySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAl_PartySettings>();
	}
};
static_assert(alignof(UVAl_PartySettings) == 0x000008, "Wrong alignment on UVAl_PartySettings");
static_assert(sizeof(UVAl_PartySettings) == 0x000238, "Wrong size on UVAl_PartySettings");
static_assert(offsetof(UVAl_PartySettings, PartyInviteExpiryTimeInSeconds) == 0x000038, "Member 'UVAl_PartySettings::PartyInviteExpiryTimeInSeconds' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PartyCreationWaitTimeInSeconds) == 0x00003C, "Member 'UVAl_PartySettings::PartyCreationWaitTimeInSeconds' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, CharacterKickedText) == 0x000040, "Member 'UVAl_PartySettings::CharacterKickedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PersonalKickedText) == 0x000058, "Member 'UVAl_PartySettings::PersonalKickedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PartyDeletedText) == 0x000070, "Member 'UVAl_PartySettings::PartyDeletedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, CharacterLeftText) == 0x000088, "Member 'UVAl_PartySettings::CharacterLeftText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PersonalLeftText) == 0x0000A0, "Member 'UVAl_PartySettings::PersonalLeftText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, CharacterJoinedText) == 0x0000B8, "Member 'UVAl_PartySettings::CharacterJoinedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PersonalCreatedText) == 0x0000D0, "Member 'UVAl_PartySettings::PersonalCreatedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PersonalJoinedText) == 0x0000E8, "Member 'UVAl_PartySettings::PersonalJoinedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PersonalDeclinedInviteText) == 0x000100, "Member 'UVAl_PartySettings::PersonalDeclinedInviteText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, DeclinedInviteText) == 0x000118, "Member 'UVAl_PartySettings::DeclinedInviteText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, DeclinedInviteFullText) == 0x000130, "Member 'UVAl_PartySettings::DeclinedInviteFullText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PersonalDeclinedInviteFullText) == 0x000148, "Member 'UVAl_PartySettings::PersonalDeclinedInviteFullText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, DeclinedInviteAlreadyInPartyText) == 0x000160, "Member 'UVAl_PartySettings::DeclinedInviteAlreadyInPartyText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PersonalLeaderChangedText) == 0x000178, "Member 'UVAl_PartySettings::PersonalLeaderChangedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, LeaderChangedText) == 0x000190, "Member 'UVAl_PartySettings::LeaderChangedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, PersonalInviteRescindedText) == 0x0001A8, "Member 'UVAl_PartySettings::PersonalInviteRescindedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, InviteRescindedText) == 0x0001C0, "Member 'UVAl_PartySettings::InviteRescindedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, SentInviteTimedOutText) == 0x0001D8, "Member 'UVAl_PartySettings::SentInviteTimedOutText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, ReceivedInviteTimedOutText) == 0x0001F0, "Member 'UVAl_PartySettings::ReceivedInviteTimedOutText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, MemberPromotedText) == 0x000208, "Member 'UVAl_PartySettings::MemberPromotedText' has a wrong offset!");
static_assert(offsetof(UVAl_PartySettings, AcceptedInviteFTUEErrorText) == 0x000220, "Member 'UVAl_PartySettings::AcceptedInviteFTUEErrorText' has a wrong offset!");

// Class Palia.SpawnOnFoliageManager
// 0x0188 (0x01B0 - 0x0028)
class USpawnOnFoliageManager : public UObject
{
public:
	TArray<struct FSpawnOnFoliageSetup>           Foliages;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F6[0x50];                                    // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, struct FTagAndIndexPair>  ActorsOccupyingPoints;                             // 0x0088(0x0050)(Transient, NativeAccessSpecifierPrivate)
	ESpawnOnFoliageStatus                         Status;                                            // 0x00D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29F7[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           WaitForWorldPartitionToLoadTimerHandle;            // 0x00E0(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FVector>           ActorToCoordinateMap;                              // 0x00E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29F8[0x10];                                    // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSoftObjectPtr<class UFoliageType>>      FoliageTypesToHide;                                // 0x0148(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         FoliageErrorHeight;                                // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FoliageErrorRadius;                                // 0x019C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 FoliageErrorColor;                                 // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TerrainRaycastStartOffset;                         // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TerrainRaycastEndOffset;                           // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F9[0x4];                                     // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelAddedToWorld(class ULevel* InLevel, class UWorld* InWorld);
	void SpawnedActorWasDestroyed(class AActor* ActorDestroyed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnOnFoliageManager">();
	}
	static class USpawnOnFoliageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnOnFoliageManager>();
	}
};
static_assert(alignof(USpawnOnFoliageManager) == 0x000008, "Wrong alignment on USpawnOnFoliageManager");
static_assert(sizeof(USpawnOnFoliageManager) == 0x0001B0, "Wrong size on USpawnOnFoliageManager");
static_assert(offsetof(USpawnOnFoliageManager, Foliages) == 0x000028, "Member 'USpawnOnFoliageManager::Foliages' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, ActorsOccupyingPoints) == 0x000088, "Member 'USpawnOnFoliageManager::ActorsOccupyingPoints' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, Status) == 0x0000D8, "Member 'USpawnOnFoliageManager::Status' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, WaitForWorldPartitionToLoadTimerHandle) == 0x0000E0, "Member 'USpawnOnFoliageManager::WaitForWorldPartitionToLoadTimerHandle' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, ActorToCoordinateMap) == 0x0000E8, "Member 'USpawnOnFoliageManager::ActorToCoordinateMap' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, FoliageTypesToHide) == 0x000148, "Member 'USpawnOnFoliageManager::FoliageTypesToHide' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, FoliageErrorHeight) == 0x000198, "Member 'USpawnOnFoliageManager::FoliageErrorHeight' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, FoliageErrorRadius) == 0x00019C, "Member 'USpawnOnFoliageManager::FoliageErrorRadius' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, FoliageErrorColor) == 0x0001A0, "Member 'USpawnOnFoliageManager::FoliageErrorColor' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, TerrainRaycastStartOffset) == 0x0001A4, "Member 'USpawnOnFoliageManager::TerrainRaycastStartOffset' has a wrong offset!");
static_assert(offsetof(USpawnOnFoliageManager, TerrainRaycastEndOffset) == 0x0001A8, "Member 'USpawnOnFoliageManager::TerrainRaycastEndOffset' has a wrong offset!");

// Class Palia.SpawnOnLevelComponent
// 0x0040 (0x05E0 - 0x05A0)
class USpawnOnLevelComponent final : public UBillboardComponent
{
public:
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> ItemTypeToSpawn;                                   // 0x0598(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LevelEarnedAt;                                     // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29FA[0x4];                                     // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PersistAnchorUniqueIdOfPlacementRegionToUse;       // 0x05C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29FB[0x8];                                     // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnOnLevelComponent">();
	}
	static class USpawnOnLevelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnOnLevelComponent>();
	}
};
static_assert(alignof(USpawnOnLevelComponent) == 0x000010, "Wrong alignment on USpawnOnLevelComponent");
static_assert(sizeof(USpawnOnLevelComponent) == 0x0005E0, "Wrong size on USpawnOnLevelComponent");
static_assert(offsetof(USpawnOnLevelComponent, ItemTypeToSpawn) == 0x000598, "Member 'USpawnOnLevelComponent::ItemTypeToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnOnLevelComponent, LevelEarnedAt) == 0x0005C0, "Member 'USpawnOnLevelComponent::LevelEarnedAt' has a wrong offset!");
static_assert(offsetof(USpawnOnLevelComponent, PersistAnchorUniqueIdOfPlacementRegionToUse) == 0x0005C8, "Member 'USpawnOnLevelComponent::PersistAnchorUniqueIdOfPlacementRegionToUse' has a wrong offset!");

// Class Palia.SpawnPointComponent
// 0x0010 (0x05B0 - 0x05A0)
class USpawnPointComponent final : public UBillboardComponent
{
public:
	class AActor*                                 OccupiedBy;                                        // 0x0598(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29FC[0x10];                                    // 0x05A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPointComponent">();
	}
	static class USpawnPointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnPointComponent>();
	}
};
static_assert(alignof(USpawnPointComponent) == 0x000010, "Wrong alignment on USpawnPointComponent");
static_assert(sizeof(USpawnPointComponent) == 0x0005B0, "Wrong size on USpawnPointComponent");
static_assert(offsetof(USpawnPointComponent, OccupiedBy) == 0x000598, "Member 'USpawnPointComponent::OccupiedBy' has a wrong offset!");

// Class Palia.SpawnStartingItemComponent
// 0x0010 (0x05B0 - 0x05A0)
class USpawnStartingItemComponent final : public UBillboardComponent
{
public:
	bool                                          bIsSpawnEnabled;                                   // 0x0598(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29FD[0x7];                                     // 0x0599(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_ItemTypeDefinitionAsset*           ItemTypeToSpawn;                                   // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29FE[0x8];                                     // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnStartingItemComponent">();
	}
	static class USpawnStartingItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnStartingItemComponent>();
	}
};
static_assert(alignof(USpawnStartingItemComponent) == 0x000010, "Wrong alignment on USpawnStartingItemComponent");
static_assert(sizeof(USpawnStartingItemComponent) == 0x0005B0, "Wrong size on USpawnStartingItemComponent");
static_assert(offsetof(USpawnStartingItemComponent, bIsSpawnEnabled) == 0x000598, "Member 'USpawnStartingItemComponent::bIsSpawnEnabled' has a wrong offset!");
static_assert(offsetof(USpawnStartingItemComponent, ItemTypeToSpawn) == 0x0005A0, "Member 'USpawnStartingItemComponent::ItemTypeToSpawn' has a wrong offset!");

// Class Palia.StartingLoadoutGlobalConfig
// 0x0000 (0x0030 - 0x0030)
class UStartingLoadoutGlobalConfig final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartingLoadoutGlobalConfig">();
	}
	static class UStartingLoadoutGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartingLoadoutGlobalConfig>();
	}
};
static_assert(alignof(UStartingLoadoutGlobalConfig) == 0x000008, "Wrong alignment on UStartingLoadoutGlobalConfig");
static_assert(sizeof(UStartingLoadoutGlobalConfig) == 0x000030, "Wrong size on UStartingLoadoutGlobalConfig");

// Class Palia.StorageComponent
// 0x01A0 (0x0240 - 0x00A0)
class UStorageComponent final : public UActorComponent
{
public:
	uint8                                         Pad_29FF[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ItemAdded;                                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ItemAddedNotification;                             // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ItemRemoved;                                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ItemsFullyLoaded;                                  // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMoveAllModifierUpdated;                          // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDraggedItemDropped;                              // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemDragged;                                     // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FStoragePool                           PrimaryStorage;                                    // 0x0128(0x0068)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FStoragePool                           LockboxStorage;                                    // 0x0190(0x0068)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A00[0x4];                                     // 0x01F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InteractableStorageConfigId;                       // 0x01FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> InteractableStorageItemType;                       // 0x0200(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A01[0x10];                                    // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SendItemsQueuedHandle;                             // 0x0238(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CallOnDraggedItemDropped();
	void CallOnItemDragged();
	void CallOnMoveAllModifierUpdated(bool IsMoveAllModifierDown);
	void OnInventoryChanged(class UInventoryComponent* Inventory);
	void OnItemGathered(class AValeriaCharacter* VC, class UGatherableComponent* GatherableComponent, struct FValeriaItem& Item);
	void OnItemPlaced(class AValeriaCharacter* VC, struct FValeriaItem& Item, struct FPlacementRegionId& Anchor);
	void OnReplicatedAndShouldBroadcast();
	void RpcClient_AddItem(EStoragePoolType StoragePoolType, const struct FValeriaItem& Item, bool bShouldDisplayNotification);
	void RpcClient_RemoveItem(EStoragePoolType StoragePoolType, const struct FValeriaItem& Item);
	void RpcClient_SendItemsQueued(EStoragePoolType StoragePoolType, TArray<struct FValeriaItemPersist>& Data, bool FullyLoaded);
	void SendInitialItemsToClient_TimerTick();
	void SetActiveStoragePool(EStoragePoolType StoragePool);
	void SortItems(TArray<struct FValeriaItem>& ItemsToSort);

	EStoragePoolType GetActiveStoragePool() const;
	TArray<struct FValeriaItem> GetAllItemsOfType(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, EStoragePoolType StoragePool) const;
	struct FValeriaItem GetItem(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 QualityStars, int32 Durability, EStoragePoolType StoragePool) const;
	int32 GetItemAmountByTag(struct FGameplayTag& IngredientTag, struct FStarQualityConstraint& StarQualityConstraint, EStoragePoolType PoolType) const;
	int32 GetItemAmountByType(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, struct FStarQualityConstraint& StarQualityConstraint, EStoragePoolType StoragePool) const;
	int32 GetItemCapacity(EStoragePoolType StoragePool) const;
	int32 GetItemCount(EStoragePoolType StoragePool) const;
	int32 GetItemFreeSpace(EStoragePoolType StoragePool) const;
	int32 GetItemMaxCapacity(EStoragePoolType StoragePool) const;
	const TArray<struct FValeriaItem> GetItemsOfCategory(EStoragePoolType PoolType, EItemStorageCategory Category) const;
	TArray<struct FValeriaItem> GetItemsWithPlacementTags(struct FGameplayTagContainer& IncludeTag, struct FGameplayTagContainer& ExcludeTag, EStoragePoolType StoragePool) const;
	TArray<struct FValeriaItem> GetItemsWithTags(struct FGameplayTagContainer& IncludeTag, struct FGameplayTagContainer& ExcludeTag, EStoragePoolType StoragePool) const;
	struct FValeriaItem GetItemVariant(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, int32 QualityStars, int32 TintPersistID, EStoragePoolType StoragePool) const;
	struct FValeriaItem GetSpecificItem(struct FValeriaItem& Item, EStoragePoolType StoragePool) const;
	bool HasFullyLoadedItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StorageComponent">();
	}
	static class UStorageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStorageComponent>();
	}
};
static_assert(alignof(UStorageComponent) == 0x000008, "Wrong alignment on UStorageComponent");
static_assert(sizeof(UStorageComponent) == 0x000240, "Wrong size on UStorageComponent");
static_assert(offsetof(UStorageComponent, OnChanged) == 0x0000A8, "Member 'UStorageComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UStorageComponent, ItemAdded) == 0x0000B8, "Member 'UStorageComponent::ItemAdded' has a wrong offset!");
static_assert(offsetof(UStorageComponent, ItemAddedNotification) == 0x0000C8, "Member 'UStorageComponent::ItemAddedNotification' has a wrong offset!");
static_assert(offsetof(UStorageComponent, ItemRemoved) == 0x0000D8, "Member 'UStorageComponent::ItemRemoved' has a wrong offset!");
static_assert(offsetof(UStorageComponent, ItemsFullyLoaded) == 0x0000E8, "Member 'UStorageComponent::ItemsFullyLoaded' has a wrong offset!");
static_assert(offsetof(UStorageComponent, OnMoveAllModifierUpdated) == 0x0000F8, "Member 'UStorageComponent::OnMoveAllModifierUpdated' has a wrong offset!");
static_assert(offsetof(UStorageComponent, OnDraggedItemDropped) == 0x000108, "Member 'UStorageComponent::OnDraggedItemDropped' has a wrong offset!");
static_assert(offsetof(UStorageComponent, OnItemDragged) == 0x000118, "Member 'UStorageComponent::OnItemDragged' has a wrong offset!");
static_assert(offsetof(UStorageComponent, PrimaryStorage) == 0x000128, "Member 'UStorageComponent::PrimaryStorage' has a wrong offset!");
static_assert(offsetof(UStorageComponent, LockboxStorage) == 0x000190, "Member 'UStorageComponent::LockboxStorage' has a wrong offset!");
static_assert(offsetof(UStorageComponent, InteractableStorageConfigId) == 0x0001FC, "Member 'UStorageComponent::InteractableStorageConfigId' has a wrong offset!");
static_assert(offsetof(UStorageComponent, InteractableStorageItemType) == 0x000200, "Member 'UStorageComponent::InteractableStorageItemType' has a wrong offset!");
static_assert(offsetof(UStorageComponent, SendItemsQueuedHandle) == 0x000238, "Member 'UStorageComponent::SendItemsQueuedHandle' has a wrong offset!");

// Class Palia.SubgameSettings
// 0x0030 (0x0068 - 0x0038)
class USubgameSettings final : public UDeveloperSettings
{
public:
	struct FVector                                BaseSpawnOffset;                                   // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnSeparation;                                   // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubgameSettings">();
	}
	static class USubgameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubgameSettings>();
	}
};
static_assert(alignof(USubgameSettings) == 0x000008, "Wrong alignment on USubgameSettings");
static_assert(sizeof(USubgameSettings) == 0x000068, "Wrong size on USubgameSettings");
static_assert(offsetof(USubgameSettings, BaseSpawnOffset) == 0x000038, "Member 'USubgameSettings::BaseSpawnOffset' has a wrong offset!");
static_assert(offsetof(USubgameSettings, SpawnSeparation) == 0x000050, "Member 'USubgameSettings::SpawnSeparation' has a wrong offset!");

// Class Palia.WorldMapGlobalConfig
// 0x00A0 (0x00D0 - 0x0030)
class UWorldMapGlobalConfig final : public UDataAsset
{
public:
	TMap<class FName, struct FWorldMapConfig>     WorldMaps;                                         // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<TSoftObjectPtr<class UPrivateSpaceConfig>, struct FWorldMapConfig> PrivateSpaceMaps;                                  // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	bool GetPrivateSpaceMapInfo(TSoftObjectPtr<class UPrivateSpaceConfig>& InPrivateSpaceConfig, struct FWorldMapConfig* OutMapInfo) const;
	bool GetWorldMapInfo(class FName& InMapName, struct FWorldMapConfig* OutMapInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapGlobalConfig">();
	}
	static class UWorldMapGlobalConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldMapGlobalConfig>();
	}
};
static_assert(alignof(UWorldMapGlobalConfig) == 0x000008, "Wrong alignment on UWorldMapGlobalConfig");
static_assert(sizeof(UWorldMapGlobalConfig) == 0x0000D0, "Wrong size on UWorldMapGlobalConfig");
static_assert(offsetof(UWorldMapGlobalConfig, WorldMaps) == 0x000030, "Member 'UWorldMapGlobalConfig::WorldMaps' has a wrong offset!");
static_assert(offsetof(UWorldMapGlobalConfig, PrivateSpaceMaps) == 0x000080, "Member 'UWorldMapGlobalConfig::PrivateSpaceMaps' has a wrong offset!");

// Class Palia.VAL_TaskProxy_PlayMontageAndWait
// 0x0088 (0x0108 - 0x0080)
class UVAL_TaskProxy_PlayMontageAndWait final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelled;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MontageMappingName;                                // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x00D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHardJump;                                         // 0x00DD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A16[0x2A];                                    // 0x00DE(0x002A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_TaskProxy_PlayMontageAndWait* PlayMontageByMappingAndWait(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class FName MontageMappingToPlay, float Param_Rate, class FName Param_StartSection, bool Param_bStopWhenAbilityEnds, bool Param_bHardJump);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TaskProxy_PlayMontageAndWait">();
	}
	static class UVAL_TaskProxy_PlayMontageAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TaskProxy_PlayMontageAndWait>();
	}
};
static_assert(alignof(UVAL_TaskProxy_PlayMontageAndWait) == 0x000008, "Wrong alignment on UVAL_TaskProxy_PlayMontageAndWait");
static_assert(sizeof(UVAL_TaskProxy_PlayMontageAndWait) == 0x000108, "Wrong size on UVAL_TaskProxy_PlayMontageAndWait");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, OnCompleted) == 0x000080, "Member 'UVAL_TaskProxy_PlayMontageAndWait::OnCompleted' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, OnBlendOut) == 0x000090, "Member 'UVAL_TaskProxy_PlayMontageAndWait::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, OnInterrupted) == 0x0000A0, "Member 'UVAL_TaskProxy_PlayMontageAndWait::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, OnCancelled) == 0x0000B0, "Member 'UVAL_TaskProxy_PlayMontageAndWait::OnCancelled' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, MontageToPlay) == 0x0000C0, "Member 'UVAL_TaskProxy_PlayMontageAndWait::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, MontageMappingName) == 0x0000C8, "Member 'UVAL_TaskProxy_PlayMontageAndWait::MontageMappingName' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, Rate) == 0x0000D0, "Member 'UVAL_TaskProxy_PlayMontageAndWait::Rate' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, StartSection) == 0x0000D4, "Member 'UVAL_TaskProxy_PlayMontageAndWait::StartSection' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, bStopWhenAbilityEnds) == 0x0000DC, "Member 'UVAL_TaskProxy_PlayMontageAndWait::bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(UVAL_TaskProxy_PlayMontageAndWait, bHardJump) == 0x0000DD, "Member 'UVAL_TaskProxy_PlayMontageAndWait::bHardJump' has a wrong offset!");

// Class Palia.TeleportOriginComponent
// 0x0060 (0x0100 - 0x00A0)
class UTeleportOriginComponent final : public UActorComponent
{
public:
	class UTeleportTravelConfigAsset*             DefaultDestinationAddress;                         // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeleportTravelConfigAsset*             TargetTravelAsset;                                 // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AValeriaCharacter*, class UTeleportTravelConfigAsset*> CharacterSpecificTravelRegistry;                   // 0x00B0(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	bool ExecuteClientTeleport(class AValeriaCharacter* TeleportingCharacter, class AActor* SeamlessAnchor);
	bool ExecuteServerTeleport(class AValeriaCharacter* TeleportingCharacter, class AActor* SeamlessAnchor);
	class UTeleportTravelConfigAsset* GetTravelAsset(class AValeriaCharacter* TravelingCharacter);
	bool HasValidTravelDestination(class AValeriaCharacter* TeleportingCharacter);
	void SetTravelAsset(class UTeleportTravelConfigAsset* InTravelAsset, class AValeriaCharacter* InSettingCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportOriginComponent">();
	}
	static class UTeleportOriginComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportOriginComponent>();
	}
};
static_assert(alignof(UTeleportOriginComponent) == 0x000008, "Wrong alignment on UTeleportOriginComponent");
static_assert(sizeof(UTeleportOriginComponent) == 0x000100, "Wrong size on UTeleportOriginComponent");
static_assert(offsetof(UTeleportOriginComponent, DefaultDestinationAddress) == 0x0000A0, "Member 'UTeleportOriginComponent::DefaultDestinationAddress' has a wrong offset!");
static_assert(offsetof(UTeleportOriginComponent, TargetTravelAsset) == 0x0000A8, "Member 'UTeleportOriginComponent::TargetTravelAsset' has a wrong offset!");
static_assert(offsetof(UTeleportOriginComponent, CharacterSpecificTravelRegistry) == 0x0000B0, "Member 'UTeleportOriginComponent::CharacterSpecificTravelRegistry' has a wrong offset!");

// Class Palia.TimedBroadcastComponent
// 0x0030 (0x00D0 - 0x00A0)
class UTimedBroadcastComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnTimerTriggered;                                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTimeOfDayHourMinute>           BroadcastTimes;                                    // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1B[0x10];                                    // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleTimerTriggered(struct FVAL_TimerHandle* TimerHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedBroadcastComponent">();
	}
	static class UTimedBroadcastComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedBroadcastComponent>();
	}
};
static_assert(alignof(UTimedBroadcastComponent) == 0x000008, "Wrong alignment on UTimedBroadcastComponent");
static_assert(sizeof(UTimedBroadcastComponent) == 0x0000D0, "Wrong size on UTimedBroadcastComponent");
static_assert(offsetof(UTimedBroadcastComponent, OnTimerTriggered) == 0x0000A0, "Member 'UTimedBroadcastComponent::OnTimerTriggered' has a wrong offset!");
static_assert(offsetof(UTimedBroadcastComponent, BroadcastTimes) == 0x0000B0, "Member 'UTimedBroadcastComponent::BroadcastTimes' has a wrong offset!");

// Class Palia.TimedLootPileManager
// 0x0030 (0x02D8 - 0x02A8)
class ATimedLootPileManager final : public AActor
{
public:
	struct FGameplayTag                           GroupTag;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ATimedLootPile*>                 TimedLootPiles;                                    // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	int32                                         NumLootPilesToActivate;                            // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1C[0x4];                                     // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATimedLootPile*>                 ValidTimedLootPiles;                               // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ServerDailyReset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedLootPileManager">();
	}
	static class ATimedLootPileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimedLootPileManager>();
	}
};
static_assert(alignof(ATimedLootPileManager) == 0x000008, "Wrong alignment on ATimedLootPileManager");
static_assert(sizeof(ATimedLootPileManager) == 0x0002D8, "Wrong size on ATimedLootPileManager");
static_assert(offsetof(ATimedLootPileManager, GroupTag) == 0x0002A8, "Member 'ATimedLootPileManager::GroupTag' has a wrong offset!");
static_assert(offsetof(ATimedLootPileManager, TimedLootPiles) == 0x0002B0, "Member 'ATimedLootPileManager::TimedLootPiles' has a wrong offset!");
static_assert(offsetof(ATimedLootPileManager, NumLootPilesToActivate) == 0x0002C0, "Member 'ATimedLootPileManager::NumLootPilesToActivate' has a wrong offset!");
static_assert(offsetof(ATimedLootPileManager, ValidTimedLootPiles) == 0x0002C8, "Member 'ATimedLootPileManager::ValidTimedLootPiles' has a wrong offset!");

// Class Palia.TrackedResourceComponent
// 0x0010 (0x00B0 - 0x00A0)
class UTrackedResourceComponent final : public UActorComponent
{
public:
	bool                                          bTrackable;                                        // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTrackOnBeginPlay;                           // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1D[0x2];                                     // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ResourceTag;                                       // 0x00A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1E[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FGameplayTag GetResourceTag() const;
	bool IsTrackable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrackedResourceComponent">();
	}
	static class UTrackedResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrackedResourceComponent>();
	}
};
static_assert(alignof(UTrackedResourceComponent) == 0x000008, "Wrong alignment on UTrackedResourceComponent");
static_assert(sizeof(UTrackedResourceComponent) == 0x0000B0, "Wrong size on UTrackedResourceComponent");
static_assert(offsetof(UTrackedResourceComponent, bTrackable) == 0x0000A0, "Member 'UTrackedResourceComponent::bTrackable' has a wrong offset!");
static_assert(offsetof(UTrackedResourceComponent, bShouldTrackOnBeginPlay) == 0x0000A1, "Member 'UTrackedResourceComponent::bShouldTrackOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UTrackedResourceComponent, ResourceTag) == 0x0000A4, "Member 'UTrackedResourceComponent::ResourceTag' has a wrong offset!");

// Class Palia.TrackingComponent
// 0x0598 (0x0638 - 0x00A0)
class UTrackingComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnItemTracked;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemUntracked;                                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrackedItemChanged;                              // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUserMarkerSet;                                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrackedVillagerInfosChangedRecently;             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSearchAreaActiveStateChanged;                    // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AValeriaPlayerController*               ValeriaPlayerController;                           // 0x0100(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTrackedItemSerializer                 TrackedItemList;                                   // 0x0108(0x0120)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTrackedVillagerInfoSerializer         OnMapTrackedVillagerInfos;                         // 0x0228(0x0120)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTrackedVillagerInfoSerializer         OffMapTrackedVillagerInfos;                        // 0x0348(0x0120)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         FocusedItemId;                                     // 0x0468(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceQuestIconUpdateTime;                          // 0x046C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateVillagerInfosTime;                           // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckTrackedVillagerInfosChangedRecentlyTime;      // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateActiveSearchAreaTrackedItemsTime;            // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1F[0x4];                                     // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   TrackedResourceTags;                               // 0x0480(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             UnmetVillagerIcon;                                 // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             LocalPlayerIcon;                                   // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             RemotePlayerIcon;                                  // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             UserMarkerIcon;                                    // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             PartyMarkerIcon;                                   // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     InWorldMarkerClass_LocalPlayer;                    // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     InWorldMarkerClass_PartyMemberFocus;               // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     InWorldMarkerClass_QuestGoal;                      // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             WorldMapTraceCollisionChannel;                     // 0x04D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A20[0x7];                                     // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      ValeriaCharacter;                                  // 0x04D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle;                                       // 0x04E0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         QuestTrackedActors;                                // 0x04E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class AActor*>                    ClientSpawnedInWorldMarkers;                       // 0x04F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A21[0x18];                                    // 0x0548(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           UpdateTrackedResourcesHandle;                      // 0x0560(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ForceQuestIconUpdateHandle;                        // 0x0568(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           UpdateVillagerInfosHandle;                         // 0x0570(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckForTrackedVillagerInfosChangedRecentlyTimerHandle; // 0x0578(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrackedVillagerInfosChangedRecently;              // 0x0580(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A22[0x7];                                     // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FTrackableDialogueCache> TrackableVillagerDialogue;                         // 0x0588(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bWasInsideActiveSearchArea;                        // 0x05D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A23[0x7];                                     // 0x05D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           UpdateActiveSearchAreaTrackedItemsTimerHandle;     // 0x05E0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class UClass*>                           ClassesToConsiderForTrackedResources;              // 0x05E8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void Client_HandleOnPartyMemberLocationContextChangedAfterDelay(class AValeriaCharacter* Character, EWorldLocationContext LocationContext);
	bool Client_SetFocusedItem(int32 NewItemId);
	void Client_SetUserMarker(const struct FVector& MarkerLocation);
	void Client_SetUserMarkerViaWorldMap(const struct FVector2D& WorldMapMarkerLocation);
	void FindClosestResourceTracked(const struct FVector& Center, struct FTrackedItemInfo* OutClosestItemInfo, EValeriaFuncResult* OutResult);
	void ForceQuestIconUpdate();
	EDialogueType GetDialogueTypeForBestVillagerId(int32 InVillagerId, EDialogueTypeCategory InDialogueTypeCategory);
	EDialogueType GetDialogueTypeForOffMapVillagerId(int32 InVillagerId, EDialogueTypeCategory InDialogueTypeCategory);
	EDialogueType GetDialogueTypeForOnMapVillager(class AValeriaVillagerCharacter* InVillager, EDialogueTypeCategory InDialogueTypeCategory);
	EDialogueType GetDialogueTypeForOnMapVillagerId(int32 InVillagerId, EDialogueTypeCategory InDialogueTypeCategory);
	void HandleCurrentActivityChanged(class AValeriaVillagerController* VillagerController);
	void HandleDestroyedTrackingActor(class AActor* DestroyedTrackingActor);
	void HandleDialogueHistoryChanged(class UDialogueManagerComponent* DialogueHistoryComponent);
	void HandleOnPartyMemberChanged(struct FVAL_PartyMember& Member);
	void HandleOnPartyStateChanged(EVAL_PartyManagerState State);
	void HandlePossessionChanged(class AValeriaPlayerController* PlayerController);
	void HandlePrivateSpaceChanged(class AValeriaCharacter* Character, class UPrivateSpaceConfig* PrivateSpaceConfig);
	void HandleQuestProgressChanged(class UQuestProgressComponent* QuestProgress);
	void HandleSkillsLevelChanged(ESkillType SkillType);
	void HandleTeleported(class AValeriaPlayerController* Controller);
	void HandleVillagersOnMapChanged();
	void HandleVisibilityChanged(class AValeriaVillagerCharacter* Villager);
	void HandleVitalsChanged(class UVitalsComponent* Vitals);
	void RpcClient_HandleOnPartyMemberLocationContextChanged(class AValeriaCharacter* Character, EWorldLocationContext LocationContext);
	void RpcClient_SetUserMarkerViaWorldMap(struct FVector& MarkerLocation);
	void RpcServer_SetFocusedItem(int32 NewFocusedItemId);
	void RpcServer_SetPartyMembers(TArray<struct FUniqueNetIdRepl>& PartyMembers);
	void RpcServer_SetUserMarker(const struct FVector& Location);
	void RpcServer_SetUserMarkerViaWorldMap(struct FVector2D& WorldMapMarkerLocation);
	void RpcServer_TeleportToResource();
	void RpcServer_UpdateQuestTracking();
	void Server_OnCharacterLocationContextChanged(class AValeriaCharacter* Character, EWorldLocationContext LocationContext);
	void UpdateTrackedResources();

	bool Client_IsFocusedItem(int32 TrackedItemId) const;
	const TArray<struct FTrackedItemInfo> GetTrackedItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrackingComponent">();
	}
	static class UTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrackingComponent>();
	}
};
static_assert(alignof(UTrackingComponent) == 0x000008, "Wrong alignment on UTrackingComponent");
static_assert(sizeof(UTrackingComponent) == 0x000638, "Wrong size on UTrackingComponent");
static_assert(offsetof(UTrackingComponent, OnItemTracked) == 0x0000A0, "Member 'UTrackingComponent::OnItemTracked' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, OnItemUntracked) == 0x0000B0, "Member 'UTrackingComponent::OnItemUntracked' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, OnTrackedItemChanged) == 0x0000C0, "Member 'UTrackingComponent::OnTrackedItemChanged' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, OnUserMarkerSet) == 0x0000D0, "Member 'UTrackingComponent::OnUserMarkerSet' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, OnTrackedVillagerInfosChangedRecently) == 0x0000E0, "Member 'UTrackingComponent::OnTrackedVillagerInfosChangedRecently' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, OnSearchAreaActiveStateChanged) == 0x0000F0, "Member 'UTrackingComponent::OnSearchAreaActiveStateChanged' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, ValeriaPlayerController) == 0x000100, "Member 'UTrackingComponent::ValeriaPlayerController' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, TrackedItemList) == 0x000108, "Member 'UTrackingComponent::TrackedItemList' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, OnMapTrackedVillagerInfos) == 0x000228, "Member 'UTrackingComponent::OnMapTrackedVillagerInfos' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, OffMapTrackedVillagerInfos) == 0x000348, "Member 'UTrackingComponent::OffMapTrackedVillagerInfos' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, FocusedItemId) == 0x000468, "Member 'UTrackingComponent::FocusedItemId' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, ForceQuestIconUpdateTime) == 0x00046C, "Member 'UTrackingComponent::ForceQuestIconUpdateTime' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, UpdateVillagerInfosTime) == 0x000470, "Member 'UTrackingComponent::UpdateVillagerInfosTime' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, CheckTrackedVillagerInfosChangedRecentlyTime) == 0x000474, "Member 'UTrackingComponent::CheckTrackedVillagerInfosChangedRecentlyTime' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, UpdateActiveSearchAreaTrackedItemsTime) == 0x000478, "Member 'UTrackingComponent::UpdateActiveSearchAreaTrackedItemsTime' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, TrackedResourceTags) == 0x000480, "Member 'UTrackingComponent::TrackedResourceTags' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, UnmetVillagerIcon) == 0x000490, "Member 'UTrackingComponent::UnmetVillagerIcon' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, LocalPlayerIcon) == 0x000498, "Member 'UTrackingComponent::LocalPlayerIcon' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, RemotePlayerIcon) == 0x0004A0, "Member 'UTrackingComponent::RemotePlayerIcon' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, UserMarkerIcon) == 0x0004A8, "Member 'UTrackingComponent::UserMarkerIcon' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, PartyMarkerIcon) == 0x0004B0, "Member 'UTrackingComponent::PartyMarkerIcon' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, InWorldMarkerClass_LocalPlayer) == 0x0004B8, "Member 'UTrackingComponent::InWorldMarkerClass_LocalPlayer' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, InWorldMarkerClass_PartyMemberFocus) == 0x0004C0, "Member 'UTrackingComponent::InWorldMarkerClass_PartyMemberFocus' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, InWorldMarkerClass_QuestGoal) == 0x0004C8, "Member 'UTrackingComponent::InWorldMarkerClass_QuestGoal' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, WorldMapTraceCollisionChannel) == 0x0004D0, "Member 'UTrackingComponent::WorldMapTraceCollisionChannel' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, ValeriaCharacter) == 0x0004D8, "Member 'UTrackingComponent::ValeriaCharacter' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, TimerHandle) == 0x0004E0, "Member 'UTrackingComponent::TimerHandle' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, QuestTrackedActors) == 0x0004E8, "Member 'UTrackingComponent::QuestTrackedActors' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, ClientSpawnedInWorldMarkers) == 0x0004F8, "Member 'UTrackingComponent::ClientSpawnedInWorldMarkers' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, UpdateTrackedResourcesHandle) == 0x000560, "Member 'UTrackingComponent::UpdateTrackedResourcesHandle' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, ForceQuestIconUpdateHandle) == 0x000568, "Member 'UTrackingComponent::ForceQuestIconUpdateHandle' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, UpdateVillagerInfosHandle) == 0x000570, "Member 'UTrackingComponent::UpdateVillagerInfosHandle' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, CheckForTrackedVillagerInfosChangedRecentlyTimerHandle) == 0x000578, "Member 'UTrackingComponent::CheckForTrackedVillagerInfosChangedRecentlyTimerHandle' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, bTrackedVillagerInfosChangedRecently) == 0x000580, "Member 'UTrackingComponent::bTrackedVillagerInfosChangedRecently' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, TrackableVillagerDialogue) == 0x000588, "Member 'UTrackingComponent::TrackableVillagerDialogue' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, bWasInsideActiveSearchArea) == 0x0005D8, "Member 'UTrackingComponent::bWasInsideActiveSearchArea' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, UpdateActiveSearchAreaTrackedItemsTimerHandle) == 0x0005E0, "Member 'UTrackingComponent::UpdateActiveSearchAreaTrackedItemsTimerHandle' has a wrong offset!");
static_assert(offsetof(UTrackingComponent, ClassesToConsiderForTrackedResources) == 0x0005E8, "Member 'UTrackingComponent::ClassesToConsiderForTrackedResources' has a wrong offset!");

// Class Palia.TravelManager
// 0x0360 (0x0390 - 0x0030)
class UTravelManager final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_2A2E[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnJoinSessionSuccess;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJoinSessionFailure;                              // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStatusChanged;                                   // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTravelFailure;                                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNetworkFailure;                                  // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMatchmakingRequestDeletedResultObtained;         // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerQueueNumberUpdated;                        // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 NetworkTravelFailureErrorMsg;                      // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   KickedReason;                                      // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTravelCompleted;                                 // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AOSSVAL_BeaconClient*                   BeaconClient;                                      // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A2F[0x138];                                   // 0x00E8(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             IconTexture;                                       // 0x0220(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A30[0x138];                                   // 0x0228(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaliaScreenStateRequester*             TravelScreenStateRequester;                        // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A31[0x28];                                    // 0x0368(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearKickReason();
	void ClearTravelNetworkFailure();
	void FindSession(const class FString& MapName);
	void JoinSession(struct FBlueprintSessionResult& Session);
	void OnMatchmakingRequestDeletedResultObtained__DelegateSignature(struct FOSSVAL_MatchmakingResult& Result);
	void OnNetworkFailure__DelegateSignature(const class FString& ErrorMsg);
	void OnServerQueueNumberUpdated__DelegateSignature(int32 Number);
	void OnTravelCompleted__DelegateSignature(const class FString& StartMap, const class FString& EndMap);
	void OnTravelFailure__DelegateSignature(const class FString& ErrorMsg);
	void RequestReservationForSession(struct FBlueprintSessionResult& Session);
	void SetDestination(struct FTravelDestination& Destination);
	void SetLoadingScreenVisibility(bool IsVisible);
	void SetMapTravelReason(EMapTravelReason MapTravelReason);
	void StoreKickReason(class FText& Reason);
	void StoreTravelNetworkFailure(const class FString& Msg);

	ETravelManagerStatus GetCurrentStatus() const;
	class FString GetPostTravelMapName() const;
	class FString GetPreTravelMapName() const;
	class FText GetPrintableTextForStatus(ETravelManagerStatus Status) const;
	bool HadTravelNetworkFailure() const;
	bool IsCurrentlyMatchmaking() const;
	bool IsTravelStatusAFailure(ETravelManagerStatus Status) const;
	bool WasKicked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TravelManager">();
	}
	static class UTravelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTravelManager>();
	}
};
static_assert(alignof(UTravelManager) == 0x000008, "Wrong alignment on UTravelManager");
static_assert(sizeof(UTravelManager) == 0x000390, "Wrong size on UTravelManager");
static_assert(offsetof(UTravelManager, OnJoinSessionSuccess) == 0x000038, "Member 'UTravelManager::OnJoinSessionSuccess' has a wrong offset!");
static_assert(offsetof(UTravelManager, OnJoinSessionFailure) == 0x000048, "Member 'UTravelManager::OnJoinSessionFailure' has a wrong offset!");
static_assert(offsetof(UTravelManager, OnStatusChanged) == 0x000058, "Member 'UTravelManager::OnStatusChanged' has a wrong offset!");
static_assert(offsetof(UTravelManager, OnTravelFailure) == 0x000068, "Member 'UTravelManager::OnTravelFailure' has a wrong offset!");
static_assert(offsetof(UTravelManager, OnNetworkFailure) == 0x000078, "Member 'UTravelManager::OnNetworkFailure' has a wrong offset!");
static_assert(offsetof(UTravelManager, OnMatchmakingRequestDeletedResultObtained) == 0x000088, "Member 'UTravelManager::OnMatchmakingRequestDeletedResultObtained' has a wrong offset!");
static_assert(offsetof(UTravelManager, OnServerQueueNumberUpdated) == 0x000098, "Member 'UTravelManager::OnServerQueueNumberUpdated' has a wrong offset!");
static_assert(offsetof(UTravelManager, NetworkTravelFailureErrorMsg) == 0x0000A8, "Member 'UTravelManager::NetworkTravelFailureErrorMsg' has a wrong offset!");
static_assert(offsetof(UTravelManager, KickedReason) == 0x0000B8, "Member 'UTravelManager::KickedReason' has a wrong offset!");
static_assert(offsetof(UTravelManager, OnTravelCompleted) == 0x0000D0, "Member 'UTravelManager::OnTravelCompleted' has a wrong offset!");
static_assert(offsetof(UTravelManager, BeaconClient) == 0x0000E0, "Member 'UTravelManager::BeaconClient' has a wrong offset!");
static_assert(offsetof(UTravelManager, IconTexture) == 0x000220, "Member 'UTravelManager::IconTexture' has a wrong offset!");
static_assert(offsetof(UTravelManager, TravelScreenStateRequester) == 0x000360, "Member 'UTravelManager::TravelScreenStateRequester' has a wrong offset!");

// Class Palia.ValeriaAkAmbientSound
// 0x0008 (0x02F0 - 0x02E8)
class AValeriaAkAmbientSound final : public AAkAmbientSound
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaAkAmbientSound">();
	}
	static class AValeriaAkAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaAkAmbientSound>();
	}
};
static_assert(alignof(AValeriaAkAmbientSound) == 0x000008, "Wrong alignment on AValeriaAkAmbientSound");
static_assert(sizeof(AValeriaAkAmbientSound) == 0x0002F0, "Wrong size on AValeriaAkAmbientSound");
static_assert(offsetof(AValeriaAkAmbientSound, AkEvent) == 0x0002E8, "Member 'AValeriaAkAmbientSound::AkEvent' has a wrong offset!");

// Class Palia.ValeriaAkFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UValeriaAkFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAkNotifyId(class USkeletalMeshComponent* Mesh, class UAnimNotifyState* NotifyState, int32 ID);
	static class UAkComponent* AkSpawnAtLocation(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, class AActor* Actor, const struct FVector& Location, const struct FRotator& Orientation, bool AutoPost, const class FString& EventName, bool AutoDestroy);
	static void ClearAkNotifyIds();
	static float FindClosestActorCollision(class UObject* WorldContextObject, struct FVector& Point, class AActor* Actor, ECollisionChannel TraceChannel, struct FVector& ClosestPointOnCollision);
	static void ForceDestroyComponent(class UActorComponent* Component, bool bPromoteChildren);
	static int32 GetAkNotifyId(class USkeletalMeshComponent* Mesh, class UAnimNotifyState* NotifyState, bool Remove);
	static TArray<class UAkRoomComponent*> GetAudioRoomComponents(class UObject* WorldContextObject);
	static void GetValeriaAudioListenerPosition(class UObject* WorldContextObject, struct FVector* OutLocation, struct FVector* OutFrontDir, struct FVector* OutRightDir);
	static void K2_AkSetRTPC(class UAkRtpc* Rtpc, float Value, int32 InterpolationTimeMs, class AActor* Actor);
	static bool TryToPropagateRtpcs(class AActor* Actor, class UAkComponent* AkComponent);
	static int32 VAkEventComponent(class UAkAudioEvent* AkEvent, class UAkComponent* AkComponent);
	static int32 VAkEventLocation(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, const struct FVector& Location, class AActor* Instigator, class UAkComponent** OutComponent);
	static class UAkComponent* VAkGetComponent(class USceneComponent* AttachToComponent, bool* ComponentCreated, class FName AttachPointName, const struct FVector& Location, EAttachLocation LocationType, bool bAutoDestroy);
	static void VExecuteActionOnPlayingID(EAkActionOnEventType ActionType, int32 PlayingID, int32 TransitionDuration, EAkCurveInterpolation FadeCurve);
	static bool VIsWithinAttenuation(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, const struct FVector& Location);
	static void VTrackAkComponent(class UAkComponent* AkComponent, class UAkAudioEvent* AkEvent, const struct FVector& Location, int32 PlayingID, bool bOverrideExisting);
	static void VTrackAkEventAtLocation(class UObject* WorldContextObject, int32 PlayingID, class UAkAudioEvent* AkEvent, const struct FVector& Location, bool bOverrideExisting);
	static void VTrackAkEventOnActor(int32 PlayingID, class UAkAudioEvent* AkEvent, class AActor* Actor, bool bOverrideExisting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaAkFunctionLibrary">();
	}
	static class UValeriaAkFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaAkFunctionLibrary>();
	}
};
static_assert(alignof(UValeriaAkFunctionLibrary) == 0x000008, "Wrong alignment on UValeriaAkFunctionLibrary");
static_assert(sizeof(UValeriaAkFunctionLibrary) == 0x000028, "Wrong size on UValeriaAkFunctionLibrary");

// Class Palia.ValeriaAkListenerComponent
// 0x0000 (0x0490 - 0x0490)
class UValeriaAkListenerComponent final : public UAkComponent
{
public:
	class UObject*                                OriginalOuter;                                     // 0x0488(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaAkListenerComponent">();
	}
	static class UValeriaAkListenerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaAkListenerComponent>();
	}
};
static_assert(alignof(UValeriaAkListenerComponent) == 0x000010, "Wrong alignment on UValeriaAkListenerComponent");
static_assert(sizeof(UValeriaAkListenerComponent) == 0x000490, "Wrong size on UValeriaAkListenerComponent");
static_assert(offsetof(UValeriaAkListenerComponent, OriginalOuter) == 0x000488, "Member 'UValeriaAkListenerComponent::OriginalOuter' has a wrong offset!");

// Class Palia.SimMoveThrottleMapping
// 0x0288 (0x02B8 - 0x0030)
class USimMoveThrottleMapping final : public UDataAsset
{
public:
	float                                         MinDistance;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EVALM_ThrottleType, uint8>               MeshNotRelevant_FrustumOutside;                    // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EVALM_ThrottleType, uint8>               MeshNotRelevant_FrustumInside;                     // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EVALM_ThrottleType, uint8>               WithinMinDistance_FrustumOutside;                  // 0x00D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EVALM_ThrottleType, uint8>               WithinMinDistance_FrustumInside;                   // 0x0128(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EVALM_ThrottleType, uint8>               WithinMaxDistance_FrustumOutside;                  // 0x0178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EVALM_ThrottleType, uint8>               WithinMaxDistance_FrustumInside;                   // 0x01C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EVALM_ThrottleType, uint8>               BeyondMaxDistance_FrustumOutside;                  // 0x0218(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EVALM_ThrottleType, uint8>               BeyondMaxDistance_FrustumInside;                   // 0x0268(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimMoveThrottleMapping">();
	}
	static class USimMoveThrottleMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimMoveThrottleMapping>();
	}
};
static_assert(alignof(USimMoveThrottleMapping) == 0x000008, "Wrong alignment on USimMoveThrottleMapping");
static_assert(sizeof(USimMoveThrottleMapping) == 0x0002B8, "Wrong size on USimMoveThrottleMapping");
static_assert(offsetof(USimMoveThrottleMapping, MinDistance) == 0x000030, "Member 'USimMoveThrottleMapping::MinDistance' has a wrong offset!");
static_assert(offsetof(USimMoveThrottleMapping, MaxDistance) == 0x000034, "Member 'USimMoveThrottleMapping::MaxDistance' has a wrong offset!");
static_assert(offsetof(USimMoveThrottleMapping, MeshNotRelevant_FrustumOutside) == 0x000038, "Member 'USimMoveThrottleMapping::MeshNotRelevant_FrustumOutside' has a wrong offset!");
static_assert(offsetof(USimMoveThrottleMapping, MeshNotRelevant_FrustumInside) == 0x000088, "Member 'USimMoveThrottleMapping::MeshNotRelevant_FrustumInside' has a wrong offset!");
static_assert(offsetof(USimMoveThrottleMapping, WithinMinDistance_FrustumOutside) == 0x0000D8, "Member 'USimMoveThrottleMapping::WithinMinDistance_FrustumOutside' has a wrong offset!");
static_assert(offsetof(USimMoveThrottleMapping, WithinMinDistance_FrustumInside) == 0x000128, "Member 'USimMoveThrottleMapping::WithinMinDistance_FrustumInside' has a wrong offset!");
static_assert(offsetof(USimMoveThrottleMapping, WithinMaxDistance_FrustumOutside) == 0x000178, "Member 'USimMoveThrottleMapping::WithinMaxDistance_FrustumOutside' has a wrong offset!");
static_assert(offsetof(USimMoveThrottleMapping, WithinMaxDistance_FrustumInside) == 0x0001C8, "Member 'USimMoveThrottleMapping::WithinMaxDistance_FrustumInside' has a wrong offset!");
static_assert(offsetof(USimMoveThrottleMapping, BeyondMaxDistance_FrustumOutside) == 0x000218, "Member 'USimMoveThrottleMapping::BeyondMaxDistance_FrustumOutside' has a wrong offset!");
static_assert(offsetof(USimMoveThrottleMapping, BeyondMaxDistance_FrustumInside) == 0x000268, "Member 'USimMoveThrottleMapping::BeyondMaxDistance_FrustumInside' has a wrong offset!");

// Class Palia.ValeriaCharacter
// 0x0FD0 (0x1490 - 0x04C0)
class AValeriaCharacter : public AValeriaMoveablePawn
{
public:
	uint8                                         Pad_2A48[0x18];                                    // 0x04C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseTurnRate;                                      // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlacementRotationRate;                             // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnstuckSavePeriod;                                 // 0x04E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A49[0x8];                                     // 0x04E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DebugSphere;                                       // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x04F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  PlayerId;                                          // 0x0508(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  LoadoutId;                                         // 0x0518(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHouseOwnershipTitle                   PrimaryHome;                                       // 0x0528(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LastKnownPrimaryHousingPlotValue;                  // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4A[0x4];                                     // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            CorrectionsApplied;                                // 0x0558(0x0050)(Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemPlaced;                                      // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemGathered;                                    // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4B[0x10];                                    // 0x05D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGardenInspectToggle;                             // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnyInventoryChanged;                             // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSprintChange;                                    // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlacementInteractChange;                         // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlacementMoveModifierChange;                     // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInspirationSequenceChange;                       // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHousingVisitionPermissionChanged;                // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHousingVisitorListChange;                        // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterLocationContextChanged;                 // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bWasPressingJump : 1;                              // 0x0678(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A4C[0x7];                                     // 0x0679(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMailboxComponent*                      Mailbox;                                           // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UVAL_CharacterCustomizationComponent> CharacterCustomizationComponentClass;              // 0x0688(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBundlesComponent*                      BundlesComponent;                                  // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInInspirationSequence;                           // 0x0698(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4D[0x3];                                     // 0x0699(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelfiePhotoMode_DollyDistance_Minimum;             // 0x069C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfiePhotoMode_DollyDistance_Maximum;             // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPSPhotoMode_FOV_Minimum;                          // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPSPhotoMode_FOV_Maximum;                          // 0x06A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4E[0x4];                                     // 0x06AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USubgameManagerComponent*               PlayingSubgameManager;                             // 0x06B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterMovementInputTriggered;                 // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrimaryInteractPressed;                          // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPrimaryInteractReleased;                         // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         GroundCheckDistance;                               // 0x06E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckFrequency;                              // 0x06EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialTeleportComplete;                          // 0x06F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorldLocationContext                         CurrentLocationContext;                            // 0x06F1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4F[0x6];                                     // 0x06F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PersistExpPkg;                                     // 0x06F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastGoodPersistPosition;                           // 0x0708(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LastGoodPersistRotation;                           // 0x0720(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnToolUsed;                                        // 0x0738(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVAL_EmergencyContentKillSwitchCache   EmergencyContentKillSwitchCache;                   // 0x0748(0x0190)(Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterUnstuck;                                // 0x08D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AValeriaPlayerController*               ValeriaPlayerController;                           // 0x08E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpringArmComponent*                    CameraBoom;                                        // 0x08F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FollowCamera;                                      // 0x08F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFollowCameraManagerComponent*          FollowCameraManager;                               // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGardenPlantingComponent*               GardenPlanting;                                    // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMinigameComponentTilling*              MinigameTilling;                                   // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMinigameComponentMasterQTE*            MinigameQTE;                                       // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerInventoryComponent*              InventoryComp;                                     // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStorageComponent*                      Storage;                                           // 0x0928(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWarpStoneComponent*                    WarpStones;                                        // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerWorldStateComponent*             PlayerWorldStateComponent;                         // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPersistedVitalsComponent*              Vitals;                                            // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFishingComponent*                      Fishing;                                           // 0x0948(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlacementComponent*                    Placement;                                         // 0x0950(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillLevelsComponent*                  SkillLevels;                                       // 0x0958(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterStateMachineComponent*        CharacterStateMachine;                             // 0x0960(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDialogueManagerComponent*              DialogueManager;                                   // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPersistentTagMapComponent*             PersistentTags;                                    // 0x0970(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_ChallengeProgressComponent*        ChallengeProgress;                                 // 0x0978(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UQuestProgressComponent*                QuestProgress;                                     // 0x0980(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVillagerRelationshipsComponent*        Relationships;                                     // 0x0988(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVillagerGiftHistoryComponent*          VillagerGiftHistory;                               // 0x0990(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URecipeInventoryComponent*              RecipeInventory;                                   // 0x0998(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPersistComponent*                      Persister;                                         // 0x09A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBuffComponent*                         Buffs;                                             // 0x09A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractorComponent*                   Interactor;                                        // 0x09B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaGASComponent*                   ValeriaGAS;                                        // 0x09B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeleeAttackComponent*                  Melee;                                             // 0x09C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemUpgradeComponent*                  ItemUpgrade;                                       // 0x09C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaCharacterTeleportComponent*     TeleportComponent;                                 // 0x09D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaGASAttributeSet*                AttributeSet;                                      // 0x09D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaGASFishingAttributeSet*         FishingAttributeSet;                               // 0x09E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaGASSprintingAttributeSet*       SprintingAttributeSet;                             // 0x09E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityAnimationComponent*             AbilityAnimation;                                  // 0x09F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHouseInventoryComponent*               HouseInventory;                                    // 0x09F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVillagerMailInboxComponent*            VillagerMailInbox;                                 // 0x0A00(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBookReadingComponent*                  BookReadingComponent;                              // 0x0A08(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGiftPreferenceTrackingComponent*       GiftPreferenceTrackingComponent;                   // 0x0A10(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugInfoComponent*                    DebugInfoComponent;                                // 0x0A18(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIPerceptionStimuliSourceComponent*    AIStimuliComponent;                                // 0x0A20(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimingComponent*                       AimingComponent;                                   // 0x0A28(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileFiringComponent*             FiringComponent;                                   // 0x0A30(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemTrackingComponent*                 ItemTracking;                                      // 0x0A38(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerCraftingHistoryComponent*        CraftingHistory;                                   // 0x0A40(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryRequestComponent*             InventoryRequest;                                  // 0x0A48(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaEmoteComponent*                 EmoteComponent;                                    // 0x0A50(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArcadeCommandComponent*                ArcadeComponent;                                   // 0x0A58(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_CharacterCustomizationComponent*   CharacterCustomizationComponent;                   // 0x0A60(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVALDTOS_MetaCharacterFormat           MetaCharacterData;                                 // 0x0A68(0x0778)(Net, NativeAccessSpecifierPrivate)
	class UVillagerStoreComponent*                StoreComponent;                                    // 0x11E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVillagerVisitComponent*                VillagerVisitComponent;                            // 0x11E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentComponent*                    EquipmentComponent;                                // 0x11F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGearComponent*                         GearComponent;                                     // 0x11F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_TimerComponent*                    TimerComponent;                                    // 0x1200(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_ScoreComponent*                    ScoreComponent;                                    // 0x1208(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHousingPlotActor*                      VisitingHousingPlot;                               // 0x1210(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasSpawnedInitialItems;                           // 0x1218(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A50[0x67];                                    // 0x1219(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          GodMode;                                           // 0x1280(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MasterKey;                                         // 0x1281(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A51[0x6];                                     // 0x1282(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         TimeLastLoggedOffMs;                               // 0x1288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A52[0x18];                                    // 0x1290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnstuckIncrement;                                  // 0x12A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A53[0x4];                                     // 0x12AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVAL_UnstuckStackMap                   UnstuckLocations;                                  // 0x12B0(0x0068)(NativeAccessSpecifierPrivate)
	bool                                          bDevChallengeEasyMode;                             // 0x1318(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A54[0x7];                                     // 0x1319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SafeLocationInTeleportVolume;                      // 0x1320(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               SafeRotationInTeleportVolume;                      // 0x1338(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bInOOBVolume;                                      // 0x1350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInTeleportVolume;                                 // 0x1351(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A55[0x16];                                    // 0x1352(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         LastPermanentUnlockVerificationTime;               // 0x1368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A56[0x8];                                     // 0x1370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FSoftObjectPath, class UAnimMontage*> CachedAnimMontages;                                // 0x1378(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A57[0x10];                                    // 0x13C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharacterReachedZLevel;                          // 0x13D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              InstigatedLocalActorLimits;                        // 0x13E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FInstigatedLocalActors> InstigatedLocalActorsByType;                       // 0x1438(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A58[0x8];                                     // 0x1488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddScriptedReward(struct FQuestRewardConfig& RewardConfig, EQuestRewardSourceType Source);
	void ApplyCheatSet(class UCheatSetConfig* InCheatSetConfig);
	void AsyncLoadMontageByName(class FName& MontageName);
	void CancelAction();
	bool CanUpdateUnstuckLocation();
	void CharacterEnteredPrivateSpace(class AValeriaCharacter* InValeriaCharacter, class UPrivateSpaceConfig* PrivateSpaceConfig);
	void CharacterExitedPrivateSpace(class AValeriaCharacter* InValeriaCharacter, class UPrivateSpaceConfig* PrivateSpaceConfig);
	void ChargeForStableUsage(class AActor* StablesActor, class UTeleportTravelConfigAsset* DestinationConfig);
	void ClearMontagePropHelper();
	void Client_BeginInspirationSequence();
	void Client_DisplayCrafter(class UCrafterComponent* Crafter);
	void Client_EndInspirationSequence();
	void Client_SetHiddenForCinematic(bool bHideForCinematic);
	void CloseSubgameScreen();
	void ConfirmAction();
	void ConfirmRecipeSelection(int32 SelectedRecipeId);
	void DebugTeleportForward();
	void DebugTeleportToResource();
	void DeleteAction();
	void DisplayAmmoMenu(EAmmoType AmmoType);
	void DisplayHousingEditMode(class AHousingPlotActor* HousingPlotActor);
	void DisplaySubgameScreen(class USubgameConfig* InSubgameConfig);
	void EndInspirationSequence();
	void EnterOOBVolume();
	void EnterTeleportVolume();
	void ExitOOBVolume();
	void ExitTeleportVolume();
	bool GetIsFilterModeHotbar();
	class UItemUpgradeComponent* GetItemUpgradeComponent();
	int32 GetValueForTag(class FName TagQuery);
	void GroundCheck();
	void HandleCharacterStateChanged(class UCharacterStateMachineComponent* InCharacterStateMachine, const struct FCharacterStateChangeParams& InStateChangeParams);
	void HandleClimbingChanged(bool IsClimbing);
	void HandleEquipmentChanged(class UEquipmentComponent* Param_EquipmentComponent, const struct FEquipmentItem& Item);
	void HandleGliderPropChanged(TSoftClassPtr<class UClass>& GliderPropClass, class FName& AttachPoint);
	void HandleInitialTeleportComplete();
	void HandleInspirationSequenceMontageEnded();
	void HandleInteractorLockChanged(struct FVAL_InteractorLockParams& LockParams, class UInteractorComponent* InInteractor, bool bLockEngaged);
	void HandlePropMontageFinish(class UAnimMontage* Montage, bool bInterrupted);
	void HideInWorldMapMarkers();
	void HousingModePanForward(float Value);
	void HousingModePanRight(float Value);
	void InteractableActionPressed(class UInputAction* InputAction);
	void InteractableActionReleased(class UInputAction* InputAction);
	bool IsUnstuckLocationAlreadyRegistered(const struct FVector& CheckLocation);
	void LookUp(float Rate);
	void LookUpAtRate(float Rate);
	void MoveForward(float Value);
	void MoveRight(float Value);
	void NotifyComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void NotifyComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnAudioEventReplicated(class AActor* ActorHit, bool WasDamaged, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& HeldItemType, class AActor* ExtInstigator);
	void OnHousingInventoryChanged(class UHouseInventoryComponent* HouseInv);
	void OnInventoryChanged(class UInventoryComponent* Inv);
	void OnMovementSettingsChanged(struct FValeriaGameplaySettings& GameplaySettings);
	void OnPlacementCompAxisModeChanged(class UPlacementComponent* PlacementComp);
	void OnRep_CurrentLocationContext();
	void OnReplicated();
	void OnVitalFull(EVitalType VitalType);
	void OpenHousingUpgrade();
	void PersistParentingWasChanged(class UPersistComponent* P);
	bool PlaceMapMarker(int32 SecondsToDisplayMarkers, struct FVector* MarkerLocation);
	void PlacementPickupModeToggle();
	void PlacementRotationCCW();
	void PlacementRotationCW();
	void PlacementRotationWheel(float Rate);
	void PlacementRotationWheelEnded(float Rate);
	void PlacementZoomWheel(float Rate);
	void PlayerCancel();
	void PrimaryActionPressed(class UInputAction* InputAction);
	void PrimaryActionReleased(class UInputAction* InputAction);
	void PrimaryInteractPressed();
	void PrimaryInteractReleased();
	void PushNewUnstuckLocation(const struct FVector& NewLocation);
	void RequestMontagePropHelper(TMap<ECharacterAttachPoint, TSoftClassPtr<class UClass>>& Props, class FName& RelevantMappingName, class FName& RelevantSectionName);
	void RevealInWorldMapMarkers();
	void RpcClient_CloseSubgameScreen();
	void RpcClient_DisplayInspirationRecipeChoices(int32 NumChoices, TArray<int32>& RecipeIDs);
	void RpcClient_DisplaySubgameScreen(class USubgameConfig* InSubgameConfig);
	void RpcClient_PlayCinematic(class UCinematicSequenceConfig* CinConfig);
	void RpcClient_SetupGroundCheck();
	void RpcServer_ApplyCheatSet(class UCheatSetConfig* InCheatSetConfig);
	void RpcServer_ChargeForStableUsage(class AActor* StablesActor, class UTeleportTravelConfigAsset* DestinationConfig);
	void RpcServer_ConfirmRecipeSelection(int32 SelectedRecipeId);
	void RpcServer_GroundFound();
	void RpcServer_ToggleDevChallengeEasyMode();
	void RpcServer_Unstuck(ES6UnstuckType UnstuckType, bool bPop);
	void SecondaryActionPressed();
	void SecondaryActionReleased();
	void Server_Unstuck(ES6UnstuckType UnstuckType, bool bPop);
	void SetCharacterForInspirationSequence();
	void SetFPSPhotoModeFOV(float Value);
	void SetIsFilterModeHotbar(bool bIsEnterHotbarFilterMode);
	void SetItemActorForMeshSocket(int32 ItemId, class FName Socket);
	void SetMetaCharacterData(const struct FVALDTOS_MetaCharacterFormat& NewMetaCharacterData);
	void SetPlacementMoveModifier(bool bIsModifying);
	void SetSelfieModeDollyDistance(float Value);
	void Sprint_Pressed();
	void Sprint_Released();
	void StartJump();
	void StartPlaceOnKeyPress();
	void StopJump();
	bool TeleportToLocationWithGroundCheck(struct FVector& DestLocation, struct FRotator& DestRotation, float DownDistance, float UpDistance, bool bIsATest, bool bNoCheck);
	void TeleportToNearestSafePoint();
	void ToggleAutorun();
	void ToggleDebugSphere(bool IsOn);
	void ToggleDevChallengeEasyMode();
	void ToolPrimaryActionPressed();
	void ToolPrimaryActionReleased();
	void TrackLimitedLocalInstigatedActor(struct FGameplayTag& Tag, class AActor* LocalInstigatedActor);
	void TriggerTeleportGroundSafeguard();
	void Turn(float Rate);
	void TurnAtRate(float Rate);
	void Unstuck();
	void UpdateUnstuckLocation(bool bFreshStack);
	void VirtualButtonClicked(class FName buttonName);
	void VirtualButtonPressed(class FName buttonName);
	void VirtualButtonReleased(class FName buttonName);
	void Walk_Pressed();
	void Walk_Released();
	void WasUpdated(EValeriaCharacterEvent Event);

	bool CanChangeActionBar() const;
	bool CanOpenMenus() const;
	int32 CountNumItemsPlaced() const;
	class UAbilityAnimationComponent* GetAbilityAnimation() const;
	class UAimingComponent* GetAimingComponent() const;
	class UAIPerceptionStimuliSourceComponent* GetAIStimuliComponent() const;
	class UArcadeCommandComponent* GetArcadeComponent() const;
	class UValeriaGASAttributeSet* GetAttributeSet() const;
	class UBookReadingComponent* GetBookReadingComponent() const;
	class UBuffComponent* GetBuffs() const;
	class UBundlesComponent* GetBundlesComponent() const;
	class UVAL_ChallengeProgressComponent* GetChallengeProgress() const;
	class UVAL_CharacterCustomizationComponent* GetCharacterCustomizationComponent() const;
	class UPlayerCraftingHistoryComponent* GetCraftingHistoryComponent() const;
	class UCharacterStateMachineComponent* GetCSM() const;
	class UDebugInfoComponent* GetDebugInfoComponent() const;
	class UDialogueManagerComponent* GetDialogueManager() const;
	class UValeriaEmoteComponent* GetEmoteComponent() const;
	class UEquipmentComponent* GetEquipment() const;
	struct FValeriaItem GetEquippedItem() const;
	class UProjectileFiringComponent* GetFiringComponent() const;
	class UFishingComponent* GetFishing() const;
	float GetFPSPhotoModeFOV() const;
	class UGardenPlantingComponent* GetGardenPlanting() const;
	class UValeriaGASComponent* GetGAS() const;
	class UGearComponent* GetGear() const;
	class UGiftPreferenceTrackingComponent* GetGiftPreferenceTrackingComponent() const;
	class UHouseInventoryComponent* GetHouseInventory() const;
	class UInteractorComponent* GetInteractorComponent() const;
	class UPlayerInventoryComponent* GetInventory() const;
	class UInventoryRequestComponent* GetInventoryRequest() const;
	class UItemTrackingComponent* GetItemTrackingComponent() const;
	int32 GetMaxStorage(EStoragePoolType StoragePool) const;
	class UMeleeAttackComponent* GetMeleeAttackComponent() const;
	struct FVALDTOS_MetaCharacterFormat GetMetaCharacterData() const;
	const class AHousingOwnershipActor* GetOccupiedHousingOwnershipActor(EHousingPermissionLevel* PermissionLevel) const;
	class UPersistComponent* GetPersist() const;
	class UPersistentTagMapComponent* GetPersistentTags() const;
	class UPlacementComponent* GetPlacement() const;
	class UPlayerWorldStateComponent* GetPlayerWorldStateComponent() const;
	class ASubgameCutawayScene* GetPlayingSubgameCutawayScene() const;
	class UQuestProgressComponent* GetQuestProgress() const;
	class URecipeInventoryComponent* GetRecipeInventory() const;
	class UVillagerRelationshipsComponent* GetRelationships() const;
	class USceneCaptureComponent2D* GetSceneCaptureComponent_FirstPerson() const;
	class USceneCaptureComponent2D* GetSceneCaptureComponent_Selfie() const;
	class UVAL_ScoreComponent* GetScoreComponent() const;
	float GetSelfieModeDollyDistance() const;
	class USpringArmComponent* GetSelfieModeSpringArmComponent() const;
	class USkillLevelsComponent* GetSkillLevels() const;
	class UStorageComponent* GetStorage() const;
	class UValeriaCharacterTeleportComponent* GetTeleportComponent() const;
	class UVAL_TimerComponent* GetTimerComponent() const;
	class UValeriaCharacterMoveComponent* GetValeriaCharacterMovementComponent() const;
	class AValeriaPlayerController* GetValeriaPlayerController() const;
	class UVillagerGiftHistoryComponent* GetVillagerGiftHistory() const;
	class UVillagerMailInboxComponent* GetVillagerMailInbox() const;
	class UVillagerVisitComponent* GetVillagerVisitComponent() const;
	class UVitalsComponent* GetVitals() const;
	class UWarpStoneComponent* GetWarpStones() const;
	float GetWateringCanAmountPerUse(float TimeStep) const;
	float GetWateringCanRemainingAmount() const;
	float GetWateringCanRemainingPctg() const;
	float GetWateringCanTotalCapacity() const;
	bool HasEnoughWaterInCan(int32 WaterAmount) const;
	bool HasEnoughWaterInCanByTimeStep(float TimeStep) const;
	bool IsContentBatchEnabled(int32 ContentBatchPersistId) const;
	bool IsGodModeEnabled() const;
	bool IsInDialogue() const;
	bool IsInHousingEditMode() const;
	bool IsInPlacementMode() const;
	bool IsInSubgame() const;
	bool IsMasterKeyEnabled() const;
	bool IsPlacementMoveModifierActive() const;
	bool IsPlacementPickupModeActive() const;
	bool IsPlayingSubgame() const;
	int32 MaxNumItemsCanPlace() const;
	bool OwnsItem(TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaCharacter">();
	}
	static class AValeriaCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaCharacter>();
	}
};
static_assert(alignof(AValeriaCharacter) == 0x000010, "Wrong alignment on AValeriaCharacter");
static_assert(sizeof(AValeriaCharacter) == 0x001490, "Wrong size on AValeriaCharacter");
static_assert(offsetof(AValeriaCharacter, BaseTurnRate) == 0x0004D8, "Member 'AValeriaCharacter::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, BaseLookUpRate) == 0x0004DC, "Member 'AValeriaCharacter::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, PlacementRotationRate) == 0x0004E0, "Member 'AValeriaCharacter::PlacementRotationRate' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, UnstuckSavePeriod) == 0x0004E4, "Member 'AValeriaCharacter::UnstuckSavePeriod' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, DebugSphere) == 0x0004F0, "Member 'AValeriaCharacter::DebugSphere' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, CharacterName) == 0x0004F8, "Member 'AValeriaCharacter::CharacterName' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, PlayerId) == 0x000508, "Member 'AValeriaCharacter::PlayerId' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, LoadoutId) == 0x000518, "Member 'AValeriaCharacter::LoadoutId' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, PrimaryHome) == 0x000528, "Member 'AValeriaCharacter::PrimaryHome' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, LastKnownPrimaryHousingPlotValue) == 0x000550, "Member 'AValeriaCharacter::LastKnownPrimaryHousingPlotValue' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, CorrectionsApplied) == 0x000558, "Member 'AValeriaCharacter::CorrectionsApplied' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnChanged) == 0x0005A8, "Member 'AValeriaCharacter::OnChanged' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnItemPlaced) == 0x0005B8, "Member 'AValeriaCharacter::OnItemPlaced' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnItemGathered) == 0x0005C8, "Member 'AValeriaCharacter::OnItemGathered' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnGardenInspectToggle) == 0x0005E8, "Member 'AValeriaCharacter::OnGardenInspectToggle' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnAnyInventoryChanged) == 0x0005F8, "Member 'AValeriaCharacter::OnAnyInventoryChanged' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnSprintChange) == 0x000608, "Member 'AValeriaCharacter::OnSprintChange' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnPlacementInteractChange) == 0x000618, "Member 'AValeriaCharacter::OnPlacementInteractChange' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnPlacementMoveModifierChange) == 0x000628, "Member 'AValeriaCharacter::OnPlacementMoveModifierChange' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnInspirationSequenceChange) == 0x000638, "Member 'AValeriaCharacter::OnInspirationSequenceChange' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnHousingVisitionPermissionChanged) == 0x000648, "Member 'AValeriaCharacter::OnHousingVisitionPermissionChanged' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnHousingVisitorListChange) == 0x000658, "Member 'AValeriaCharacter::OnHousingVisitorListChange' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnCharacterLocationContextChanged) == 0x000668, "Member 'AValeriaCharacter::OnCharacterLocationContextChanged' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Mailbox) == 0x000680, "Member 'AValeriaCharacter::Mailbox' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, CharacterCustomizationComponentClass) == 0x000688, "Member 'AValeriaCharacter::CharacterCustomizationComponentClass' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, BundlesComponent) == 0x000690, "Member 'AValeriaCharacter::BundlesComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, IsInInspirationSequence) == 0x000698, "Member 'AValeriaCharacter::IsInInspirationSequence' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, SelfiePhotoMode_DollyDistance_Minimum) == 0x00069C, "Member 'AValeriaCharacter::SelfiePhotoMode_DollyDistance_Minimum' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, SelfiePhotoMode_DollyDistance_Maximum) == 0x0006A0, "Member 'AValeriaCharacter::SelfiePhotoMode_DollyDistance_Maximum' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, FPSPhotoMode_FOV_Minimum) == 0x0006A4, "Member 'AValeriaCharacter::FPSPhotoMode_FOV_Minimum' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, FPSPhotoMode_FOV_Maximum) == 0x0006A8, "Member 'AValeriaCharacter::FPSPhotoMode_FOV_Maximum' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, PlayingSubgameManager) == 0x0006B0, "Member 'AValeriaCharacter::PlayingSubgameManager' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnCharacterMovementInputTriggered) == 0x0006B8, "Member 'AValeriaCharacter::OnCharacterMovementInputTriggered' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnPrimaryInteractPressed) == 0x0006C8, "Member 'AValeriaCharacter::OnPrimaryInteractPressed' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnPrimaryInteractReleased) == 0x0006D8, "Member 'AValeriaCharacter::OnPrimaryInteractReleased' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, GroundCheckDistance) == 0x0006E8, "Member 'AValeriaCharacter::GroundCheckDistance' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, GroundCheckFrequency) == 0x0006EC, "Member 'AValeriaCharacter::GroundCheckFrequency' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, bInitialTeleportComplete) == 0x0006F0, "Member 'AValeriaCharacter::bInitialTeleportComplete' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, CurrentLocationContext) == 0x0006F1, "Member 'AValeriaCharacter::CurrentLocationContext' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, PersistExpPkg) == 0x0006F8, "Member 'AValeriaCharacter::PersistExpPkg' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, LastGoodPersistPosition) == 0x000708, "Member 'AValeriaCharacter::LastGoodPersistPosition' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, LastGoodPersistRotation) == 0x000720, "Member 'AValeriaCharacter::LastGoodPersistRotation' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnToolUsed) == 0x000738, "Member 'AValeriaCharacter::OnToolUsed' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, EmergencyContentKillSwitchCache) == 0x000748, "Member 'AValeriaCharacter::EmergencyContentKillSwitchCache' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnCharacterUnstuck) == 0x0008D8, "Member 'AValeriaCharacter::OnCharacterUnstuck' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, ValeriaPlayerController) == 0x0008E8, "Member 'AValeriaCharacter::ValeriaPlayerController' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, CameraBoom) == 0x0008F0, "Member 'AValeriaCharacter::CameraBoom' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, FollowCamera) == 0x0008F8, "Member 'AValeriaCharacter::FollowCamera' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, FollowCameraManager) == 0x000900, "Member 'AValeriaCharacter::FollowCameraManager' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, GardenPlanting) == 0x000908, "Member 'AValeriaCharacter::GardenPlanting' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, MinigameTilling) == 0x000910, "Member 'AValeriaCharacter::MinigameTilling' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, MinigameQTE) == 0x000918, "Member 'AValeriaCharacter::MinigameQTE' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, InventoryComp) == 0x000920, "Member 'AValeriaCharacter::InventoryComp' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Storage) == 0x000928, "Member 'AValeriaCharacter::Storage' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, WarpStones) == 0x000930, "Member 'AValeriaCharacter::WarpStones' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, PlayerWorldStateComponent) == 0x000938, "Member 'AValeriaCharacter::PlayerWorldStateComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Vitals) == 0x000940, "Member 'AValeriaCharacter::Vitals' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Fishing) == 0x000948, "Member 'AValeriaCharacter::Fishing' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Placement) == 0x000950, "Member 'AValeriaCharacter::Placement' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, SkillLevels) == 0x000958, "Member 'AValeriaCharacter::SkillLevels' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, CharacterStateMachine) == 0x000960, "Member 'AValeriaCharacter::CharacterStateMachine' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, DialogueManager) == 0x000968, "Member 'AValeriaCharacter::DialogueManager' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, PersistentTags) == 0x000970, "Member 'AValeriaCharacter::PersistentTags' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, ChallengeProgress) == 0x000978, "Member 'AValeriaCharacter::ChallengeProgress' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, QuestProgress) == 0x000980, "Member 'AValeriaCharacter::QuestProgress' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Relationships) == 0x000988, "Member 'AValeriaCharacter::Relationships' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, VillagerGiftHistory) == 0x000990, "Member 'AValeriaCharacter::VillagerGiftHistory' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, RecipeInventory) == 0x000998, "Member 'AValeriaCharacter::RecipeInventory' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Persister) == 0x0009A0, "Member 'AValeriaCharacter::Persister' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Buffs) == 0x0009A8, "Member 'AValeriaCharacter::Buffs' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Interactor) == 0x0009B0, "Member 'AValeriaCharacter::Interactor' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, ValeriaGAS) == 0x0009B8, "Member 'AValeriaCharacter::ValeriaGAS' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, Melee) == 0x0009C0, "Member 'AValeriaCharacter::Melee' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, ItemUpgrade) == 0x0009C8, "Member 'AValeriaCharacter::ItemUpgrade' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, TeleportComponent) == 0x0009D0, "Member 'AValeriaCharacter::TeleportComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, AttributeSet) == 0x0009D8, "Member 'AValeriaCharacter::AttributeSet' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, FishingAttributeSet) == 0x0009E0, "Member 'AValeriaCharacter::FishingAttributeSet' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, SprintingAttributeSet) == 0x0009E8, "Member 'AValeriaCharacter::SprintingAttributeSet' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, AbilityAnimation) == 0x0009F0, "Member 'AValeriaCharacter::AbilityAnimation' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, HouseInventory) == 0x0009F8, "Member 'AValeriaCharacter::HouseInventory' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, VillagerMailInbox) == 0x000A00, "Member 'AValeriaCharacter::VillagerMailInbox' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, BookReadingComponent) == 0x000A08, "Member 'AValeriaCharacter::BookReadingComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, GiftPreferenceTrackingComponent) == 0x000A10, "Member 'AValeriaCharacter::GiftPreferenceTrackingComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, DebugInfoComponent) == 0x000A18, "Member 'AValeriaCharacter::DebugInfoComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, AIStimuliComponent) == 0x000A20, "Member 'AValeriaCharacter::AIStimuliComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, AimingComponent) == 0x000A28, "Member 'AValeriaCharacter::AimingComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, FiringComponent) == 0x000A30, "Member 'AValeriaCharacter::FiringComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, ItemTracking) == 0x000A38, "Member 'AValeriaCharacter::ItemTracking' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, CraftingHistory) == 0x000A40, "Member 'AValeriaCharacter::CraftingHistory' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, InventoryRequest) == 0x000A48, "Member 'AValeriaCharacter::InventoryRequest' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, EmoteComponent) == 0x000A50, "Member 'AValeriaCharacter::EmoteComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, ArcadeComponent) == 0x000A58, "Member 'AValeriaCharacter::ArcadeComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, CharacterCustomizationComponent) == 0x000A60, "Member 'AValeriaCharacter::CharacterCustomizationComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, MetaCharacterData) == 0x000A68, "Member 'AValeriaCharacter::MetaCharacterData' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, StoreComponent) == 0x0011E0, "Member 'AValeriaCharacter::StoreComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, VillagerVisitComponent) == 0x0011E8, "Member 'AValeriaCharacter::VillagerVisitComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, EquipmentComponent) == 0x0011F0, "Member 'AValeriaCharacter::EquipmentComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, GearComponent) == 0x0011F8, "Member 'AValeriaCharacter::GearComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, TimerComponent) == 0x001200, "Member 'AValeriaCharacter::TimerComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, ScoreComponent) == 0x001208, "Member 'AValeriaCharacter::ScoreComponent' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, VisitingHousingPlot) == 0x001210, "Member 'AValeriaCharacter::VisitingHousingPlot' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, bHasSpawnedInitialItems) == 0x001218, "Member 'AValeriaCharacter::bHasSpawnedInitialItems' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, GodMode) == 0x001280, "Member 'AValeriaCharacter::GodMode' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, MasterKey) == 0x001281, "Member 'AValeriaCharacter::MasterKey' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, TimeLastLoggedOffMs) == 0x001288, "Member 'AValeriaCharacter::TimeLastLoggedOffMs' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, UnstuckIncrement) == 0x0012A8, "Member 'AValeriaCharacter::UnstuckIncrement' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, UnstuckLocations) == 0x0012B0, "Member 'AValeriaCharacter::UnstuckLocations' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, bDevChallengeEasyMode) == 0x001318, "Member 'AValeriaCharacter::bDevChallengeEasyMode' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, SafeLocationInTeleportVolume) == 0x001320, "Member 'AValeriaCharacter::SafeLocationInTeleportVolume' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, SafeRotationInTeleportVolume) == 0x001338, "Member 'AValeriaCharacter::SafeRotationInTeleportVolume' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, bInOOBVolume) == 0x001350, "Member 'AValeriaCharacter::bInOOBVolume' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, bInTeleportVolume) == 0x001351, "Member 'AValeriaCharacter::bInTeleportVolume' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, LastPermanentUnlockVerificationTime) == 0x001368, "Member 'AValeriaCharacter::LastPermanentUnlockVerificationTime' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, CachedAnimMontages) == 0x001378, "Member 'AValeriaCharacter::CachedAnimMontages' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, OnCharacterReachedZLevel) == 0x0013D8, "Member 'AValeriaCharacter::OnCharacterReachedZLevel' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, InstigatedLocalActorLimits) == 0x0013E8, "Member 'AValeriaCharacter::InstigatedLocalActorLimits' has a wrong offset!");
static_assert(offsetof(AValeriaCharacter, InstigatedLocalActorsByType) == 0x001438, "Member 'AValeriaCharacter::InstigatedLocalActorsByType' has a wrong offset!");

// Class Palia.ValeriaCharacterMoveComponent
// 0x0300 (0x0EC0 - 0x0BC0)
class UValeriaCharacterMoveComponent final : public UValeriaClientPriMovementComponent
{
public:
	FMulticastInlineDelegateProperty_             OnGlidingChanged;                                  // 0x0BC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClimbingChanged;                                 // 0x0BD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsClimbMovingChanged;                            // 0x0BE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLongFallingChanged;                              // 0x0BF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClimbDashingChanged;                             // 0x0C00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClimbOutroStarted;                               // 0x0C10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClimbAroundEdgeChanged;                          // 0x0C20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnforcedPositionStarted;                         // 0x0C30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnforcedPositionEnded;                           // 0x0C40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotationRateWithSpeed;                             // 0x0C50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6A[0x8];                                     // 0x0C58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      ValCharacter;                                      // 0x0C60(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            GravityScaleByVerticalSpeed;                       // 0x0C68(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FValeriaEnforcedPositionInfo           EnforcedPosition;                                  // 0x0C70(0x0038)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FValeriaEnforcedPositionInfo           ClientDrivenPosition;                              // 0x0CA8(0x0038)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                CannedInput;                                       // 0x0CE0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CannedInputTimeRemaining;                          // 0x0CF8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bJumpingIsEnabled;                                 // 0x0CFC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A6B[0x5B];                                    // 0x0CFD(0x005B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintAccelerationMultiplier;                      // 0x0D58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintingStaminaDrainRate;                         // 0x0D5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinStaminaToStartSprinting;                        // 0x0D60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesSprintingCostStamina;                         // 0x0D64(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6C[0x3];                                     // 0x0D65(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeedMultiplier;                               // 0x0D68(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkAccelerationMultiplier;                        // 0x0D6C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimWalkThreshold;                                  // 0x0D70(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimSprintThreshold;                                // 0x0D74(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSpeedMultiplier;                             // 0x0D78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A6D[0x4];                                     // 0x0D7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SlopeSpeedMultiplierCurve;                         // 0x0D80(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWantsToSprint;                                    // 0x0D88(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAbleToSprint;                                   // 0x0D89(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWantsToWalk;                                      // 0x0D8A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasSprinting;                                     // 0x0D8B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A6E[0x8];                                     // 0x0D8C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlidingFallSpeed;                                  // 0x0D94(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingFallingLateralFriction;                     // 0x0D98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6F[0x4];                                     // 0x0D9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               GlidingRotationRate;                               // 0x0DA0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GlidingMaxSpeed;                                   // 0x0DB8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespectGlideSpeedLimits;                          // 0x0DBC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAffectedByWindGust;                               // 0x0DBD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A70[0x2];                                     // 0x0DBE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsGliding : 1;                                    // 0x0DC0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_2A71[0x7];                                     // 0x0DC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlidingFrictionOnGround;                           // 0x0DC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingGroundControlScalar;                        // 0x0DCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingAirControlScalar;                           // 0x0DD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingGravScalarInAir;                            // 0x0DD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingGravScalarOnGround;                         // 0x0DD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingMaintainReach;                             // 0x0DDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingAroundSurfaceDistance;                     // 0x0DE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpUpLedgeMaxHeight;                              // 0x0DE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbIntroDuration;                                // 0x0DE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbIntroSpeed;                                   // 0x0DEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingOutHoldDuration;                           // 0x0DF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingSpeed;                                     // 0x0DF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingStepDuration;                              // 0x0DF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingSimActivationFactor;                       // 0x0DFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingAroundEdgeSpeed;                           // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingFromEdgeSpeed;                             // 0x0E04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingDashSpeed;                                 // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingDashDuration;                              // 0x0E0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingDashSimActivationFactor;                   // 0x0E10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallJumpHorizontalSpeed;                           // 0x0E14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallJumpVerticalSpeed;                             // 0x0E18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingStaminaDrainRate;                          // 0x0E1C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingDashStaminaCost;                           // 0x0E20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingJumpStaminaCost;                           // 0x0E24(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingStartDelayOnImpact;                        // 0x0E28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingUnevenSurfaceBudgeScalar;                  // 0x0E2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ClimbingSurfaceDotProductRange;                    // 0x0E30(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingEngageDotProductReq;                       // 0x0E40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A72[0x4];                                     // 0x0E44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPhysicalSurface>                      AcceptableClimbingSurfaceTypes;                    // 0x0E48(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	ECollisionChannel                             ClimbabilityCollisionChannel;                      // 0x0E58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A73[0x3];                                     // 0x0E59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ClimbableTag;                                      // 0x0E5C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotClimbableTag;                                   // 0x0E64(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UsedClimbingSpeed;                                 // 0x0E6C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClimbingDashTimeCooldown;                          // 0x0E70(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A74[0x1];                                     // 0x0E74(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsClimbMoving;                                    // 0x0E75(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasClimbing;                                      // 0x0E76(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsClimbDashing;                                   // 0x0E77(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsClimbingAroundEdge;                             // 0x0E78(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A75[0x3];                                     // 0x0E79(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentClimbMovingDuration;                        // 0x0E7C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasReleasedJumpSinceClimbStart;                   // 0x0E80(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A76[0x8];                                     // 0x0E81(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldDoFallingForwardChecksForClimbing;          // 0x0E89(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClimbingClientDrivenOut;                          // 0x0E8A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A77[0x5];                                     // 0x0E8B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ClimbingDashTimeNext;                              // 0x0E90(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        ClimbingStartTimeOnImpact;                         // 0x0E98(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAttemptingClimbOnImpact;                        // 0x0EA0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A78[0x3];                                     // 0x0EA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbingSurfaceAngleTangentX;                      // 0x0EA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbingSurfaceAngleTangentY;                      // 0x0EA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHorizontalClimbDistance;                        // 0x0EAC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalClimbIntroDistance;                      // 0x0EB0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A79[0xC];                                     // 0x0EB4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleEquipmentChanged(class UEquipmentComponent* EquipmentComponent, const struct FEquipmentItem& Item);
	void LaunchCharacter(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride, bool bStowGlider);
	void OnGearChanged(class UGearComponent* Gear);
	void OnRep_EnforcedPosition(const struct FValeriaEnforcedPositionInfo& OldEnforcedPosition);
	void OnRep_IsGliding();
	void RpcClient_ForceEndClimbing(int32 ServerStamina);
	void RpcClient_ForceEndSprinting();
	void RpcServer_CheatSetSprintingCostsStamina(bool DoesSprintingCostStamina);
	void RpcServer_CheatToggleSprintingCostsStamina();
	void SetIsLongFalling(bool bFalling);
	void SetJumpingIsEnabled(bool bEnabled);
	void StartEnforcingPosition(struct FVector& Location, struct FRotator& Facing, bool bHold);
	void StopClimbing(bool bLaunch, bool bReverseDirection, bool bTransitionStateImmediately);
	void StopEnforcingPosition();
	void ToggleSprintingCostsStamina();

	float GetMaxSpeedAbs() const;
	float GetMaxSpeedWhenRunning() const;
	float GetMaxSpeedWhenSprinting() const;
	float GetMaxSpeedWhenWalking() const;
	class AValeriaCharacter* GetValeriaCharacter() const;
	bool IsAtEnforcedPostion(float Tolerance) const;
	bool IsGliding() const;
	bool IsGlidingEnabled() const;
	bool IsInClimbingMode() const;
	bool IsInSlidingMode() const;
	bool IsJuking() const;
	bool IsSprinting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaCharacterMoveComponent">();
	}
	static class UValeriaCharacterMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaCharacterMoveComponent>();
	}
};
static_assert(alignof(UValeriaCharacterMoveComponent) == 0x000010, "Wrong alignment on UValeriaCharacterMoveComponent");
static_assert(sizeof(UValeriaCharacterMoveComponent) == 0x000EC0, "Wrong size on UValeriaCharacterMoveComponent");
static_assert(offsetof(UValeriaCharacterMoveComponent, OnGlidingChanged) == 0x000BC0, "Member 'UValeriaCharacterMoveComponent::OnGlidingChanged' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, OnClimbingChanged) == 0x000BD0, "Member 'UValeriaCharacterMoveComponent::OnClimbingChanged' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, OnIsClimbMovingChanged) == 0x000BE0, "Member 'UValeriaCharacterMoveComponent::OnIsClimbMovingChanged' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, OnLongFallingChanged) == 0x000BF0, "Member 'UValeriaCharacterMoveComponent::OnLongFallingChanged' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, OnClimbDashingChanged) == 0x000C00, "Member 'UValeriaCharacterMoveComponent::OnClimbDashingChanged' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, OnClimbOutroStarted) == 0x000C10, "Member 'UValeriaCharacterMoveComponent::OnClimbOutroStarted' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, OnClimbAroundEdgeChanged) == 0x000C20, "Member 'UValeriaCharacterMoveComponent::OnClimbAroundEdgeChanged' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, OnEnforcedPositionStarted) == 0x000C30, "Member 'UValeriaCharacterMoveComponent::OnEnforcedPositionStarted' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, OnEnforcedPositionEnded) == 0x000C40, "Member 'UValeriaCharacterMoveComponent::OnEnforcedPositionEnded' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, RotationRateWithSpeed) == 0x000C50, "Member 'UValeriaCharacterMoveComponent::RotationRateWithSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ValCharacter) == 0x000C60, "Member 'UValeriaCharacterMoveComponent::ValCharacter' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, GravityScaleByVerticalSpeed) == 0x000C68, "Member 'UValeriaCharacterMoveComponent::GravityScaleByVerticalSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, EnforcedPosition) == 0x000C70, "Member 'UValeriaCharacterMoveComponent::EnforcedPosition' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClientDrivenPosition) == 0x000CA8, "Member 'UValeriaCharacterMoveComponent::ClientDrivenPosition' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, CannedInput) == 0x000CE0, "Member 'UValeriaCharacterMoveComponent::CannedInput' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, CannedInputTimeRemaining) == 0x000CF8, "Member 'UValeriaCharacterMoveComponent::CannedInputTimeRemaining' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bJumpingIsEnabled) == 0x000CFC, "Member 'UValeriaCharacterMoveComponent::bJumpingIsEnabled' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SprintAccelerationMultiplier) == 0x000D58, "Member 'UValeriaCharacterMoveComponent::SprintAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SprintingStaminaDrainRate) == 0x000D5C, "Member 'UValeriaCharacterMoveComponent::SprintingStaminaDrainRate' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, MinStaminaToStartSprinting) == 0x000D60, "Member 'UValeriaCharacterMoveComponent::MinStaminaToStartSprinting' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bDoesSprintingCostStamina) == 0x000D64, "Member 'UValeriaCharacterMoveComponent::bDoesSprintingCostStamina' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, WalkSpeedMultiplier) == 0x000D68, "Member 'UValeriaCharacterMoveComponent::WalkSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, WalkAccelerationMultiplier) == 0x000D6C, "Member 'UValeriaCharacterMoveComponent::WalkAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SimWalkThreshold) == 0x000D70, "Member 'UValeriaCharacterMoveComponent::SimWalkThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SimSprintThreshold) == 0x000D74, "Member 'UValeriaCharacterMoveComponent::SimSprintThreshold' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SprintSpeedMultiplier) == 0x000D78, "Member 'UValeriaCharacterMoveComponent::SprintSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SlopeSpeedMultiplierCurve) == 0x000D80, "Member 'UValeriaCharacterMoveComponent::SlopeSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bWantsToSprint) == 0x000D88, "Member 'UValeriaCharacterMoveComponent::bWantsToSprint' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bIsAbleToSprint) == 0x000D89, "Member 'UValeriaCharacterMoveComponent::bIsAbleToSprint' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bWantsToWalk) == 0x000D8A, "Member 'UValeriaCharacterMoveComponent::bWantsToWalk' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bWasSprinting) == 0x000D8B, "Member 'UValeriaCharacterMoveComponent::bWasSprinting' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, GlidingFallSpeed) == 0x000D94, "Member 'UValeriaCharacterMoveComponent::GlidingFallSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, GlidingFallingLateralFriction) == 0x000D98, "Member 'UValeriaCharacterMoveComponent::GlidingFallingLateralFriction' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, GlidingRotationRate) == 0x000DA0, "Member 'UValeriaCharacterMoveComponent::GlidingRotationRate' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, GlidingMaxSpeed) == 0x000DB8, "Member 'UValeriaCharacterMoveComponent::GlidingMaxSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bRespectGlideSpeedLimits) == 0x000DBC, "Member 'UValeriaCharacterMoveComponent::bRespectGlideSpeedLimits' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bAffectedByWindGust) == 0x000DBD, "Member 'UValeriaCharacterMoveComponent::bAffectedByWindGust' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SlidingFrictionOnGround) == 0x000DC8, "Member 'UValeriaCharacterMoveComponent::SlidingFrictionOnGround' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SlidingGroundControlScalar) == 0x000DCC, "Member 'UValeriaCharacterMoveComponent::SlidingGroundControlScalar' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SlidingAirControlScalar) == 0x000DD0, "Member 'UValeriaCharacterMoveComponent::SlidingAirControlScalar' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SlidingGravScalarInAir) == 0x000DD4, "Member 'UValeriaCharacterMoveComponent::SlidingGravScalarInAir' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, SlidingGravScalarOnGround) == 0x000DD8, "Member 'UValeriaCharacterMoveComponent::SlidingGravScalarOnGround' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingMaintainReach) == 0x000DDC, "Member 'UValeriaCharacterMoveComponent::ClimbingMaintainReach' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingAroundSurfaceDistance) == 0x000DE0, "Member 'UValeriaCharacterMoveComponent::ClimbingAroundSurfaceDistance' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, JumpUpLedgeMaxHeight) == 0x000DE4, "Member 'UValeriaCharacterMoveComponent::JumpUpLedgeMaxHeight' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbIntroDuration) == 0x000DE8, "Member 'UValeriaCharacterMoveComponent::ClimbIntroDuration' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbIntroSpeed) == 0x000DEC, "Member 'UValeriaCharacterMoveComponent::ClimbIntroSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingOutHoldDuration) == 0x000DF0, "Member 'UValeriaCharacterMoveComponent::ClimbingOutHoldDuration' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingSpeed) == 0x000DF4, "Member 'UValeriaCharacterMoveComponent::ClimbingSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingStepDuration) == 0x000DF8, "Member 'UValeriaCharacterMoveComponent::ClimbingStepDuration' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingSimActivationFactor) == 0x000DFC, "Member 'UValeriaCharacterMoveComponent::ClimbingSimActivationFactor' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingAroundEdgeSpeed) == 0x000E00, "Member 'UValeriaCharacterMoveComponent::ClimbingAroundEdgeSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingFromEdgeSpeed) == 0x000E04, "Member 'UValeriaCharacterMoveComponent::ClimbingFromEdgeSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingDashSpeed) == 0x000E08, "Member 'UValeriaCharacterMoveComponent::ClimbingDashSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingDashDuration) == 0x000E0C, "Member 'UValeriaCharacterMoveComponent::ClimbingDashDuration' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingDashSimActivationFactor) == 0x000E10, "Member 'UValeriaCharacterMoveComponent::ClimbingDashSimActivationFactor' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, WallJumpHorizontalSpeed) == 0x000E14, "Member 'UValeriaCharacterMoveComponent::WallJumpHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, WallJumpVerticalSpeed) == 0x000E18, "Member 'UValeriaCharacterMoveComponent::WallJumpVerticalSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingStaminaDrainRate) == 0x000E1C, "Member 'UValeriaCharacterMoveComponent::ClimbingStaminaDrainRate' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingDashStaminaCost) == 0x000E20, "Member 'UValeriaCharacterMoveComponent::ClimbingDashStaminaCost' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingJumpStaminaCost) == 0x000E24, "Member 'UValeriaCharacterMoveComponent::ClimbingJumpStaminaCost' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingStartDelayOnImpact) == 0x000E28, "Member 'UValeriaCharacterMoveComponent::ClimbingStartDelayOnImpact' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingUnevenSurfaceBudgeScalar) == 0x000E2C, "Member 'UValeriaCharacterMoveComponent::ClimbingUnevenSurfaceBudgeScalar' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingSurfaceDotProductRange) == 0x000E30, "Member 'UValeriaCharacterMoveComponent::ClimbingSurfaceDotProductRange' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingEngageDotProductReq) == 0x000E40, "Member 'UValeriaCharacterMoveComponent::ClimbingEngageDotProductReq' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, AcceptableClimbingSurfaceTypes) == 0x000E48, "Member 'UValeriaCharacterMoveComponent::AcceptableClimbingSurfaceTypes' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbabilityCollisionChannel) == 0x000E58, "Member 'UValeriaCharacterMoveComponent::ClimbabilityCollisionChannel' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbableTag) == 0x000E5C, "Member 'UValeriaCharacterMoveComponent::ClimbableTag' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, NotClimbableTag) == 0x000E64, "Member 'UValeriaCharacterMoveComponent::NotClimbableTag' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, UsedClimbingSpeed) == 0x000E6C, "Member 'UValeriaCharacterMoveComponent::UsedClimbingSpeed' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingDashTimeCooldown) == 0x000E70, "Member 'UValeriaCharacterMoveComponent::ClimbingDashTimeCooldown' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bIsClimbMoving) == 0x000E75, "Member 'UValeriaCharacterMoveComponent::bIsClimbMoving' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bWasClimbing) == 0x000E76, "Member 'UValeriaCharacterMoveComponent::bWasClimbing' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bIsClimbDashing) == 0x000E77, "Member 'UValeriaCharacterMoveComponent::bIsClimbDashing' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bIsClimbingAroundEdge) == 0x000E78, "Member 'UValeriaCharacterMoveComponent::bIsClimbingAroundEdge' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, CurrentClimbMovingDuration) == 0x000E7C, "Member 'UValeriaCharacterMoveComponent::CurrentClimbMovingDuration' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bHasReleasedJumpSinceClimbStart) == 0x000E80, "Member 'UValeriaCharacterMoveComponent::bHasReleasedJumpSinceClimbStart' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bShouldDoFallingForwardChecksForClimbing) == 0x000E89, "Member 'UValeriaCharacterMoveComponent::bShouldDoFallingForwardChecksForClimbing' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bClimbingClientDrivenOut) == 0x000E8A, "Member 'UValeriaCharacterMoveComponent::bClimbingClientDrivenOut' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingDashTimeNext) == 0x000E90, "Member 'UValeriaCharacterMoveComponent::ClimbingDashTimeNext' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingStartTimeOnImpact) == 0x000E98, "Member 'UValeriaCharacterMoveComponent::ClimbingStartTimeOnImpact' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, bIsAttemptingClimbOnImpact) == 0x000EA0, "Member 'UValeriaCharacterMoveComponent::bIsAttemptingClimbOnImpact' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingSurfaceAngleTangentX) == 0x000EA4, "Member 'UValeriaCharacterMoveComponent::ClimbingSurfaceAngleTangentX' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, ClimbingSurfaceAngleTangentY) == 0x000EA8, "Member 'UValeriaCharacterMoveComponent::ClimbingSurfaceAngleTangentY' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, MaxHorizontalClimbDistance) == 0x000EAC, "Member 'UValeriaCharacterMoveComponent::MaxHorizontalClimbDistance' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterMoveComponent, HorizontalClimbIntroDistance) == 0x000EB0, "Member 'UValeriaCharacterMoveComponent::HorizontalClimbIntroDistance' has a wrong offset!");

// Class Palia.ValeriaCharacterTeleportComponent
// 0x0190 (0x0230 - 0x00A0)
class UValeriaCharacterTeleportComponent final : public UActorComponent
{
public:
	class UCharacterStateMachineComponent*        Csm;                                               // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AValeriaCharacter*                      VC;                                                // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnValeriaCharacterEnteredPrivateSpace;             // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnValeriaCharacterExitedPrivateSpace;              // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TeleportResult;                                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeleportOutStarted;                              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeleportInStarted;                               // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnValeriaCharacterInitialTeleportComplete;         // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeleportFlagsChanged;                            // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnValeriaCharacterTeleportComplete;                // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bInitialTeleportComplete;                          // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A7D[0x7];                                     // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDefaultDestinationsConfig*             DefaultDestinations;                               // 0x0138(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnTeleportDestinationReady;                        // 0x0140(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	struct FTravelPayload                         LockedInDestination;                               // 0x0150(0x00C0)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A7E[0x8];                                     // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeleportScreenStateRequester*          TeleportScreenStateRequester;                      // 0x0218(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ClientFadeTimerHandle;                             // 0x0220(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ServerFadeTimerHandle;                             // 0x0228(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddTeleportFlag(EVAL_TeleportCompFlags Flag);
	void Client_OnEnsureClientReadyForTeleport(struct FTravelPayload& TravelPayload);
	void Client_OnMatchmakingDeleteResultObtained(struct FOSSVAL_MatchmakingResult& Result);
	void Client_OnMatchmakingResultObtained(struct FOSSVAL_MatchmakingResult& Result);
	void Client_OnTeleportFailure(class FName SessionName);
	void Client_OnTravelOrNetworkFailureObtained(const class FString& ErrorMsg);
	bool ClientExecuteTeleport(class UTeleportTravelConfigAsset* TravelConfigAsset, class AActor* SeamlessAnchor);
	bool ClientTeleportToHousePlotByAccountID(struct FGuid& AccountId, struct FGuid& CharacterId);
	bool ClientTeleportToViewOnlyPlot(struct FGuid& PlotId, struct FGuid& CharacterId);
	bool ExecuteSpecificLocationTeleport(const struct FVector& Location, const struct FRotator& Rotation);
	void OnTeleportFlagsChanged__DelegateSignature(EVAL_TeleportCompFlags TeleportFlags);
	void RemoveTeleportFlag(EVAL_TeleportCompFlags Flag);
	void RpcClient_EnsureClientReadyForTeleport(struct FTravelPayload& TravelPayload);
	void RpcClient_NotifyInitialTeleportComplete();
	void RpcClient_NotifyLeftPrivateSpace(class UPrivateSpaceConfig* PrivateSpaceConfig);
	void RpcClient_NotifyReadyForPrivateSpace(class UPrivateSpaceConfig* PrivateSpaceConfig, const class FString& HandleID, int32 SlotId, const struct FTransform& LevelSpawnTransform);
	void RpcClient_PostTeleport(struct FTravelPayload& TravelPayload, const struct FVector& TeleportLocation, const struct FRotator& TeleportRotation, bool bSeamless, bool bTrustServer);
	void RpcClient_RestoreControl();
	void RpcClient_SendTeleportResult(bool bTeleportResult);
	void RpcClient_SpawnPrivateSpace(struct FTravelPayload& TravelPayload);
	void RpcClient_TeleportMatchmaking(struct FTravelPayload& TravelPayload);
	void RpcClient_TeleportPrivateSpace(struct FTravelPayload& TravelPayload);
	void RpcServer_ExitPrivateSpace(struct FTravelPayload& TravelPayload);
	void RpcServer_LocalPrivateSpace(struct FTravelPayload& TravelPayload, class UPrivateSpaceConfig* PrivateSpaceConfig);
	void RpcServer_LocalTeleport(struct FTravelPayload& TravelPayload);
	void RpcServer_SendTeleportResult(bool bTeleportResult);
	void RpcServer_TeleportDestinationReady(bool bTrustServer);
	void RpcServer_TeleportPrivateSpace(struct FTravelPayload& TravelPayload);
	void RpcServer_TourPlot(struct FGuid& PlotId, struct FGuid& CharacterId);
	void RpcServer_ValidateAbleToSpawnPrivateSpace(struct FTravelPayload& TravelPayload);
	void RpcServer_ValidateMatchmakingLocation(struct FTravelPayload& TravelPayload);
	void RpcServer_VisitPlotByAccountID(struct FGuid& AccountId, struct FGuid& CharacterId);
	void RpcServer_VisitPlotByPlayerId(const struct FGuid& PlayerId);
	void RpcServerTeleport_Home();
	void Server_OnLoadHousingRequestResult(bool bResult, const struct FGuid& PlotId);
	bool ServerExecuteTeleport(class UTeleportTravelConfigAsset* TravelConfigAsset, class AActor* SeamlessAnchor);
	bool ServerTeleport_Home();
	bool ServerTeleport_ViewOnlyPlot(const struct FGuid& PlotId, const struct FGuid& CharacterId);
	bool ServerTeleportToHousePlotByAccountID(struct FGuid& AccountId, struct FGuid& CharacterId);
	bool ServerTeleportToHousePlotByPlayerId(const struct FGuid& PlayerId);
	void TeleportDestinationReady();
	void TryClientTeleport_Home();
	void VAL_TeleportResult__DelegateSignature(bool bTeleportResult);
	void ValeriaCharacterEnteredPrivateSpace__DelegateSignature(class AValeriaCharacter* InValeriaCharacter, class UPrivateSpaceConfig* PrivateSpaceConfig);
	void ValeriaCharacterExitedPrivateSpace__DelegateSignature(class AValeriaCharacter* InValeriaCharacter, class UPrivateSpaceConfig* PrivateSpaceConfig);
	void ValeriaCharacterSimpleEvent__DelegateSignature(class AValeriaCharacter* InValeriaCharacter);
	void ValeriaCharacterTeleportComplete__DelegateSignature(class AValeriaCharacter* InValeriaCharacter, ETeleportTravelType TeleportTravelType, TSoftObjectPtr<class UPrivateSpaceConfig> PrivateSpaceConfig);

	EVAL_TeleportCompFlags GetTeleportFlags() const;
	bool HasTeleportFlag(EVAL_TeleportCompFlags Flag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaCharacterTeleportComponent">();
	}
	static class UValeriaCharacterTeleportComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaCharacterTeleportComponent>();
	}
};
static_assert(alignof(UValeriaCharacterTeleportComponent) == 0x000008, "Wrong alignment on UValeriaCharacterTeleportComponent");
static_assert(sizeof(UValeriaCharacterTeleportComponent) == 0x000230, "Wrong size on UValeriaCharacterTeleportComponent");
static_assert(offsetof(UValeriaCharacterTeleportComponent, Csm) == 0x0000A0, "Member 'UValeriaCharacterTeleportComponent::Csm' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, VC) == 0x0000A8, "Member 'UValeriaCharacterTeleportComponent::VC' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, OnValeriaCharacterEnteredPrivateSpace) == 0x0000B0, "Member 'UValeriaCharacterTeleportComponent::OnValeriaCharacterEnteredPrivateSpace' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, OnValeriaCharacterExitedPrivateSpace) == 0x0000C0, "Member 'UValeriaCharacterTeleportComponent::OnValeriaCharacterExitedPrivateSpace' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, TeleportResult) == 0x0000D0, "Member 'UValeriaCharacterTeleportComponent::TeleportResult' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, OnTeleportOutStarted) == 0x0000E0, "Member 'UValeriaCharacterTeleportComponent::OnTeleportOutStarted' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, OnTeleportInStarted) == 0x0000F0, "Member 'UValeriaCharacterTeleportComponent::OnTeleportInStarted' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, OnValeriaCharacterInitialTeleportComplete) == 0x000100, "Member 'UValeriaCharacterTeleportComponent::OnValeriaCharacterInitialTeleportComplete' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, OnTeleportFlagsChanged) == 0x000110, "Member 'UValeriaCharacterTeleportComponent::OnTeleportFlagsChanged' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, OnValeriaCharacterTeleportComplete) == 0x000120, "Member 'UValeriaCharacterTeleportComponent::OnValeriaCharacterTeleportComplete' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, bInitialTeleportComplete) == 0x000130, "Member 'UValeriaCharacterTeleportComponent::bInitialTeleportComplete' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, DefaultDestinations) == 0x000138, "Member 'UValeriaCharacterTeleportComponent::DefaultDestinations' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, OnTeleportDestinationReady) == 0x000140, "Member 'UValeriaCharacterTeleportComponent::OnTeleportDestinationReady' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, LockedInDestination) == 0x000150, "Member 'UValeriaCharacterTeleportComponent::LockedInDestination' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, TeleportScreenStateRequester) == 0x000218, "Member 'UValeriaCharacterTeleportComponent::TeleportScreenStateRequester' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, ClientFadeTimerHandle) == 0x000220, "Member 'UValeriaCharacterTeleportComponent::ClientFadeTimerHandle' has a wrong offset!");
static_assert(offsetof(UValeriaCharacterTeleportComponent, ServerFadeTimerHandle) == 0x000228, "Member 'UValeriaCharacterTeleportComponent::ServerFadeTimerHandle' has a wrong offset!");

// Class Palia.VAL_ItemTypeDefinitionAsset
// 0x0718 (0x0770 - 0x0058)
class UVAL_ItemTypeDefinitionAsset final : public UVAL_DataAsset
{
public:
	EVAL_BagGroup                                 BagGroup;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8B[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStackSize;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUniqueOwned;                                    // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8C[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0068(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0080(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           StarQualityDescription;                            // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ItemIcon;                                          // 0x00A8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              UnconstructedItemIcon;                             // 0x00D0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlacementConfig                       Placement;                                         // 0x00F8(0x01F0)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FStartingItemConfig                    StartsWith;                                        // 0x02E8(0x0001)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8D[0x3];                                     // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillPointCost                        SkillPointCost;                                    // 0x02EC(0x0004)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSkillPointRequirement>         SkillPointRequirements;                            // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Shop;                                              // 0x0310(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquipViewConfig                       EquippedView;                                      // 0x0338(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanBeConsumed;                                    // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSimpleDecor;                                    // 0x0389(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8E[0x6];                                     // 0x038A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVAL_TransitiveDecorAsset> TransitiveDecorAsset;                              // 0x0390(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8F[0x7];                                     // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    NormalQualityBuffConfig;                           // 0x03C0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    StarQualityBuffConfig;                             // 0x03D0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FQuestRewardConfig>             ConsumeRewards;                                    // 0x03E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ConsumeText;                                       // 0x03F0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESkillType                                    ConsumeSkillLimit;                                 // 0x0408(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A90[0x3];                                     // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConsumeSkillLimitLevel;                            // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemUseConfig                         ItemUseConfig;                                     // 0x0410(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EItemCategory                                 Category;                                          // 0x0428(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0429(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemQuality                                  Quality;                                           // 0x042A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A91[0x1];                                     // 0x042B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IngredientConfigName;                              // 0x042C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A92[0x4];                                     // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_ItemTypeDefinitionAsset*           IngredientItemType;                                // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    SellValueConfig;                                   // 0x0440(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   FishingRodConfigName;                              // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    LauncherConfig;                                    // 0x0458(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ProjectileActor;                                   // 0x0468(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             ProjectileMesh;                                    // 0x0490(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      ProjectileMaterial;                                // 0x04B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             ProjectileMeshSecondary;                           // 0x04E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      ProjectileMaterialSecondary;                       // 0x0508(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          ProjectileVFX;                                     // 0x0530(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowAutoEquip;                                   // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRandomizeColor;                             // 0x0559(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A93[0x2];                                     // 0x055A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRandColorValue;                                 // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A94[0x10];                                    // 0x0560(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProjectileMeshScale;                               // 0x0570(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventGifting;                                    // 0x0588(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A95[0x3];                                     // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WormFarmFoodValue;                                 // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StorageStackLimit;                                 // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A96[0x4];                                     // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemStorageCategory>                  CanStore;                                          // 0x0598(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   StorageName;                                       // 0x05A8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   StorageType;                                       // 0x05C0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         AddedStorageCapacity;                              // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStoragePoolType                              StoragePool;                                       // 0x05DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A97[0x3];                                     // 0x05DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AddedMaxStoragePerLevel;                           // 0x05E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    AbilitiesConfig;                                   // 0x05F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UGardenBuffConfig*                      GardenBuffConfig;                                  // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GardenBuffMaxStacks;                               // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A98[0x4];                                     // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSeedConfig                            SeedConfig;                                        // 0x0610(0x00A8)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsWateringCan;                                    // 0x06B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A99[0x3];                                     // 0x06B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemPlayerRequestConfig               PlayerRequestConfig;                               // 0x06BC(0x0004)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EVitalType                                    RequestRewardType;                                 // 0x06C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9A[0x3];                                     // 0x06C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequestRewardAmount;                               // 0x06C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemTrackingConfig                    ItemTracking;                                      // 0x06C8(0x0001)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9B[0x7];                                     // 0x06C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemUpgradeConfig*                     ItemUpgradeConfig;                                 // 0x06D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EquipGameplayEffect;                               // 0x06D8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HousingPlacementCost;                              // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoConsumeOnAcquire;                             // 0x0704(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpecialReward;                                  // 0x0705(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeDestroyed;                                   // 0x0706(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUniqueDrop;                                     // 0x0707(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNewUniqueDropIfLeavesPossession;             // 0x0708(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowGatherIfUniqueDropAlreadyOwned;              // 0x0709(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9C[0x6];                                     // 0x070A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    AudioConfig;                                       // 0x0710(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AbsorptionValue;                                   // 0x0720(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9D[0x4];                                     // 0x0724(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGearConfig*                            GearConfig;                                        // 0x0728(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemVariantsConfig                    ItemVariantsConfig;                                // 0x0730(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FQuestRewardConfig>             RewardsOnPickup;                                   // 0x0748(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    BookConfig;                                        // 0x0758(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBlockEmotesWhenEquipped;                          // 0x0768(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockGlidingWhenEquipped;                         // 0x0769(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockClimbWhenEquipped;                           // 0x076A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDisplayNotificationOnAcquisition;              // 0x076B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQuestItem;                                      // 0x076C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9E[0x3];                                     // 0x076D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> GetAssetByPersistId_Cast(int32 PersistIdToGet);
	static TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> GetAssetByPersistIdSafe_Cast(int32 PersistIdToGet);
	static TArray<TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>> GetAssetsOfType_Cast();
	static TArray<TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>> GetAssetsWithTag_Cast(struct FGameplayTag& GameplayTag);
	static TArray<TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>> GetItemTypesOfCategory(EItemCategory& Param_Category);

	bool CanFireAmmoType(class UVAL_ItemTypeDefinitionAsset* AmmoItemType) const;
	int32 GetBookConfigId() const;
	struct FLauncherConfig GetLauncherConfig() const;
	bool IsAmmunition() const;
	bool IsAnUpgradeKit() const;
	bool IsBait() const;
	bool IsDestroyable() const;
	bool IsFertilizer() const;
	bool IsFishingBait() const;
	bool IsFishingRod() const;
	bool IsGear() const;
	bool IsKeyQuestItem() const;
	bool IsLauncher() const;
	bool IsMoveable() const;
	bool IsPlaceable() const;
	bool IsPlaceableHousingBuilding() const;
	bool IsQuestStarter() const;
	bool IsReadable() const;
	bool IsRecipe() const;
	bool IsSeed() const;
	bool IsStorage() const;
	bool IsTintable() const;
	bool IsTool() const;
	bool IsUnlimitedInStorage() const;
	bool ShouldSendToStorageIfOverflowing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ItemTypeDefinitionAsset">();
	}
	static class UVAL_ItemTypeDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ItemTypeDefinitionAsset>();
	}
};
static_assert(alignof(UVAL_ItemTypeDefinitionAsset) == 0x000008, "Wrong alignment on UVAL_ItemTypeDefinitionAsset");
static_assert(sizeof(UVAL_ItemTypeDefinitionAsset) == 0x000770, "Wrong size on UVAL_ItemTypeDefinitionAsset");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, BagGroup) == 0x000058, "Member 'UVAL_ItemTypeDefinitionAsset::BagGroup' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, MaxStackSize) == 0x00005C, "Member 'UVAL_ItemTypeDefinitionAsset::MaxStackSize' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bIsUniqueOwned) == 0x000060, "Member 'UVAL_ItemTypeDefinitionAsset::bIsUniqueOwned' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, DisplayName) == 0x000068, "Member 'UVAL_ItemTypeDefinitionAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, Description) == 0x000080, "Member 'UVAL_ItemTypeDefinitionAsset::Description' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, StarQualityDescription) == 0x000098, "Member 'UVAL_ItemTypeDefinitionAsset::StarQualityDescription' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ItemIcon) == 0x0000A8, "Member 'UVAL_ItemTypeDefinitionAsset::ItemIcon' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, UnconstructedItemIcon) == 0x0000D0, "Member 'UVAL_ItemTypeDefinitionAsset::UnconstructedItemIcon' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, Placement) == 0x0000F8, "Member 'UVAL_ItemTypeDefinitionAsset::Placement' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, StartsWith) == 0x0002E8, "Member 'UVAL_ItemTypeDefinitionAsset::StartsWith' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, SkillPointCost) == 0x0002EC, "Member 'UVAL_ItemTypeDefinitionAsset::SkillPointCost' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, SkillPointRequirements) == 0x0002F0, "Member 'UVAL_ItemTypeDefinitionAsset::SkillPointRequirements' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, Materials) == 0x000300, "Member 'UVAL_ItemTypeDefinitionAsset::Materials' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, Shop) == 0x000310, "Member 'UVAL_ItemTypeDefinitionAsset::Shop' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, EquippedView) == 0x000338, "Member 'UVAL_ItemTypeDefinitionAsset::EquippedView' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bCanBeConsumed) == 0x000388, "Member 'UVAL_ItemTypeDefinitionAsset::bCanBeConsumed' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bIsSimpleDecor) == 0x000389, "Member 'UVAL_ItemTypeDefinitionAsset::bIsSimpleDecor' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, TransitiveDecorAsset) == 0x000390, "Member 'UVAL_ItemTypeDefinitionAsset::TransitiveDecorAsset' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bIsEnabled) == 0x0003B8, "Member 'UVAL_ItemTypeDefinitionAsset::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, NormalQualityBuffConfig) == 0x0003C0, "Member 'UVAL_ItemTypeDefinitionAsset::NormalQualityBuffConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, StarQualityBuffConfig) == 0x0003D0, "Member 'UVAL_ItemTypeDefinitionAsset::StarQualityBuffConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ConsumeRewards) == 0x0003E0, "Member 'UVAL_ItemTypeDefinitionAsset::ConsumeRewards' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ConsumeText) == 0x0003F0, "Member 'UVAL_ItemTypeDefinitionAsset::ConsumeText' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ConsumeSkillLimit) == 0x000408, "Member 'UVAL_ItemTypeDefinitionAsset::ConsumeSkillLimit' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ConsumeSkillLimitLevel) == 0x00040C, "Member 'UVAL_ItemTypeDefinitionAsset::ConsumeSkillLimitLevel' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ItemUseConfig) == 0x000410, "Member 'UVAL_ItemTypeDefinitionAsset::ItemUseConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, Category) == 0x000428, "Member 'UVAL_ItemTypeDefinitionAsset::Category' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, Rarity) == 0x000429, "Member 'UVAL_ItemTypeDefinitionAsset::Rarity' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, Quality) == 0x00042A, "Member 'UVAL_ItemTypeDefinitionAsset::Quality' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, IngredientConfigName) == 0x00042C, "Member 'UVAL_ItemTypeDefinitionAsset::IngredientConfigName' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, IngredientItemType) == 0x000438, "Member 'UVAL_ItemTypeDefinitionAsset::IngredientItemType' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, SellValueConfig) == 0x000440, "Member 'UVAL_ItemTypeDefinitionAsset::SellValueConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, FishingRodConfigName) == 0x000450, "Member 'UVAL_ItemTypeDefinitionAsset::FishingRodConfigName' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, LauncherConfig) == 0x000458, "Member 'UVAL_ItemTypeDefinitionAsset::LauncherConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ProjectileActor) == 0x000468, "Member 'UVAL_ItemTypeDefinitionAsset::ProjectileActor' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ProjectileMesh) == 0x000490, "Member 'UVAL_ItemTypeDefinitionAsset::ProjectileMesh' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ProjectileMaterial) == 0x0004B8, "Member 'UVAL_ItemTypeDefinitionAsset::ProjectileMaterial' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ProjectileMeshSecondary) == 0x0004E0, "Member 'UVAL_ItemTypeDefinitionAsset::ProjectileMeshSecondary' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ProjectileMaterialSecondary) == 0x000508, "Member 'UVAL_ItemTypeDefinitionAsset::ProjectileMaterialSecondary' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ProjectileVFX) == 0x000530, "Member 'UVAL_ItemTypeDefinitionAsset::ProjectileVFX' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bAllowAutoEquip) == 0x000558, "Member 'UVAL_ItemTypeDefinitionAsset::bAllowAutoEquip' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bShouldRandomizeColor) == 0x000559, "Member 'UVAL_ItemTypeDefinitionAsset::bShouldRandomizeColor' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, MaxRandColorValue) == 0x00055C, "Member 'UVAL_ItemTypeDefinitionAsset::MaxRandColorValue' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ProjectileMeshScale) == 0x000570, "Member 'UVAL_ItemTypeDefinitionAsset::ProjectileMeshScale' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, PreventGifting) == 0x000588, "Member 'UVAL_ItemTypeDefinitionAsset::PreventGifting' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, WormFarmFoodValue) == 0x00058C, "Member 'UVAL_ItemTypeDefinitionAsset::WormFarmFoodValue' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, StorageStackLimit) == 0x000590, "Member 'UVAL_ItemTypeDefinitionAsset::StorageStackLimit' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, CanStore) == 0x000598, "Member 'UVAL_ItemTypeDefinitionAsset::CanStore' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, StorageName) == 0x0005A8, "Member 'UVAL_ItemTypeDefinitionAsset::StorageName' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, StorageType) == 0x0005C0, "Member 'UVAL_ItemTypeDefinitionAsset::StorageType' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, AddedStorageCapacity) == 0x0005D8, "Member 'UVAL_ItemTypeDefinitionAsset::AddedStorageCapacity' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, StoragePool) == 0x0005DC, "Member 'UVAL_ItemTypeDefinitionAsset::StoragePool' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, AddedMaxStoragePerLevel) == 0x0005E0, "Member 'UVAL_ItemTypeDefinitionAsset::AddedMaxStoragePerLevel' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, AbilitiesConfig) == 0x0005F0, "Member 'UVAL_ItemTypeDefinitionAsset::AbilitiesConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, GardenBuffConfig) == 0x000600, "Member 'UVAL_ItemTypeDefinitionAsset::GardenBuffConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, GardenBuffMaxStacks) == 0x000608, "Member 'UVAL_ItemTypeDefinitionAsset::GardenBuffMaxStacks' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, SeedConfig) == 0x000610, "Member 'UVAL_ItemTypeDefinitionAsset::SeedConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bIsWateringCan) == 0x0006B8, "Member 'UVAL_ItemTypeDefinitionAsset::bIsWateringCan' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, PlayerRequestConfig) == 0x0006BC, "Member 'UVAL_ItemTypeDefinitionAsset::PlayerRequestConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, RequestRewardType) == 0x0006C0, "Member 'UVAL_ItemTypeDefinitionAsset::RequestRewardType' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, RequestRewardAmount) == 0x0006C4, "Member 'UVAL_ItemTypeDefinitionAsset::RequestRewardAmount' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ItemTracking) == 0x0006C8, "Member 'UVAL_ItemTypeDefinitionAsset::ItemTracking' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ItemUpgradeConfig) == 0x0006D0, "Member 'UVAL_ItemTypeDefinitionAsset::ItemUpgradeConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, EquipGameplayEffect) == 0x0006D8, "Member 'UVAL_ItemTypeDefinitionAsset::EquipGameplayEffect' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, HousingPlacementCost) == 0x000700, "Member 'UVAL_ItemTypeDefinitionAsset::HousingPlacementCost' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bAutoConsumeOnAcquire) == 0x000704, "Member 'UVAL_ItemTypeDefinitionAsset::bAutoConsumeOnAcquire' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bIsSpecialReward) == 0x000705, "Member 'UVAL_ItemTypeDefinitionAsset::bIsSpecialReward' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bCanBeDestroyed) == 0x000706, "Member 'UVAL_ItemTypeDefinitionAsset::bCanBeDestroyed' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bIsUniqueDrop) == 0x000707, "Member 'UVAL_ItemTypeDefinitionAsset::bIsUniqueDrop' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bAllowNewUniqueDropIfLeavesPossession) == 0x000708, "Member 'UVAL_ItemTypeDefinitionAsset::bAllowNewUniqueDropIfLeavesPossession' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bAllowGatherIfUniqueDropAlreadyOwned) == 0x000709, "Member 'UVAL_ItemTypeDefinitionAsset::bAllowGatherIfUniqueDropAlreadyOwned' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, AudioConfig) == 0x000710, "Member 'UVAL_ItemTypeDefinitionAsset::AudioConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, AbsorptionValue) == 0x000720, "Member 'UVAL_ItemTypeDefinitionAsset::AbsorptionValue' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, GearConfig) == 0x000728, "Member 'UVAL_ItemTypeDefinitionAsset::GearConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, ItemVariantsConfig) == 0x000730, "Member 'UVAL_ItemTypeDefinitionAsset::ItemVariantsConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, RewardsOnPickup) == 0x000748, "Member 'UVAL_ItemTypeDefinitionAsset::RewardsOnPickup' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, BookConfig) == 0x000758, "Member 'UVAL_ItemTypeDefinitionAsset::BookConfig' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bBlockEmotesWhenEquipped) == 0x000768, "Member 'UVAL_ItemTypeDefinitionAsset::bBlockEmotesWhenEquipped' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bBlockGlidingWhenEquipped) == 0x000769, "Member 'UVAL_ItemTypeDefinitionAsset::bBlockGlidingWhenEquipped' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bBlockClimbWhenEquipped) == 0x00076A, "Member 'UVAL_ItemTypeDefinitionAsset::bBlockClimbWhenEquipped' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bCanDisplayNotificationOnAcquisition) == 0x00076B, "Member 'UVAL_ItemTypeDefinitionAsset::bCanDisplayNotificationOnAcquisition' has a wrong offset!");
static_assert(offsetof(UVAL_ItemTypeDefinitionAsset, bIsQuestItem) == 0x00076C, "Member 'UVAL_ItemTypeDefinitionAsset::bIsQuestItem' has a wrong offset!");

// Class Palia.ValeriaCineCameraComponent
// 0x00B0 (0x0BF0 - 0x0B40)
class UValeriaCineCameraComponent final : public UCineCameraComponent
{
public:
	struct FValeriaCineCamLookatParams            LookatTracking;                                    // 0x0B40(0x00A8)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA3[0x8];                                     // 0x0BE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SnapToTracking(bool bImmediate);
	void SwitchTrackingToActor(class AActor* ActorToTrack, const struct FVector& RelativeOffset);
	void SwitchTrackingToSkelMesh(class USkeletalMeshComponent* SkelToTrack, class FName SkelBoneToTrack, const struct FVector& RelativeOffset);
	void SwitchTrackingToWorldLocation(const struct FVector& WorldLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaCineCameraComponent">();
	}
	static class UValeriaCineCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaCineCameraComponent>();
	}
};
static_assert(alignof(UValeriaCineCameraComponent) == 0x000010, "Wrong alignment on UValeriaCineCameraComponent");
static_assert(sizeof(UValeriaCineCameraComponent) == 0x000BF0, "Wrong size on UValeriaCineCameraComponent");
static_assert(offsetof(UValeriaCineCameraComponent, LookatTracking) == 0x000B40, "Member 'UValeriaCineCameraComponent::LookatTracking' has a wrong offset!");

// Class Palia.ValeriaCreatureManager
// 0x0038 (0x0068 - 0x0030)
class UValeriaCreatureManager final : public UGameInstanceSubsystem
{
public:
	float                                         DiveGridSize;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumWaterBodySize;                              // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UValeriaWaterBodyComponent*>     WaterBodyComponents;                               // 0x0038(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AGatherableActor*>               HidingTrees;                                       // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        ReservedDivePoints;                                // 0x0058(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void DeregisterHidingTree(class AGatherableActor* HidingTree);
	void RegisterHidingTree(class AGatherableActor* HidingTree);
	void ReserveDivePoint(struct FVector& DivePoint);
	void UnreserveDivePoint(struct FVector& DivePoint);

	bool CheckHasValidPathToDestination(class APawn* OwningPawn, class AAIController* OwningController, const struct FVector& EscapeDestination) const;
	bool FindClosestWaterBodyEscapeDestination(class APawn* OwningPawn, class AAIController* OwningController, struct FVector* OutDiveLocation, struct FVector* OutDestination) const;
	bool FindRandomPointNearEscapeDestination(class APawn* OwningPawn, class AAIController* OwningController, const struct FVector& EscapeDestination, struct FVector* OutDestination) const;
	const TArray<class AGatherableActor*> GetHidingTrees() const;
	const TArray<class UValeriaWaterBodyComponent*> GetWaterBodies() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaCreatureManager">();
	}
	static class UValeriaCreatureManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaCreatureManager>();
	}
};
static_assert(alignof(UValeriaCreatureManager) == 0x000008, "Wrong alignment on UValeriaCreatureManager");
static_assert(sizeof(UValeriaCreatureManager) == 0x000068, "Wrong size on UValeriaCreatureManager");
static_assert(offsetof(UValeriaCreatureManager, DiveGridSize) == 0x000030, "Member 'UValeriaCreatureManager::DiveGridSize' has a wrong offset!");
static_assert(offsetof(UValeriaCreatureManager, MinimumWaterBodySize) == 0x000034, "Member 'UValeriaCreatureManager::MinimumWaterBodySize' has a wrong offset!");
static_assert(offsetof(UValeriaCreatureManager, WaterBodyComponents) == 0x000038, "Member 'UValeriaCreatureManager::WaterBodyComponents' has a wrong offset!");
static_assert(offsetof(UValeriaCreatureManager, HidingTrees) == 0x000048, "Member 'UValeriaCreatureManager::HidingTrees' has a wrong offset!");
static_assert(offsetof(UValeriaCreatureManager, ReservedDivePoints) == 0x000058, "Member 'UValeriaCreatureManager::ReservedDivePoints' has a wrong offset!");

// Class Palia.VAL_LevelSequenceActor
// 0x0000 (0x0348 - 0x0348)
class AVAL_LevelSequenceActor final : public ALevelSequenceActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_LevelSequenceActor">();
	}
	static class AVAL_LevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_LevelSequenceActor>();
	}
};
static_assert(alignof(AVAL_LevelSequenceActor) == 0x000008, "Wrong alignment on AVAL_LevelSequenceActor");
static_assert(sizeof(AVAL_LevelSequenceActor) == 0x000348, "Wrong size on AVAL_LevelSequenceActor");

// Class Palia.EmoteDataAsset
// 0x0198 (0x01C8 - 0x0030)
class UEmoteDataAsset final : public UDataAsset
{
public:
	struct FGuid                                  EmoteId;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EmoteName;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVAL_ChatCommandInfo                   ChatCommandInfo;                                   // 0x0068(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         CanBeUsedOn;                                       // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA7[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EVAL_CharacterBodyType, class UAnimMontage*> BodyTypeAnimations;                                // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FacialAnimationMontage;                            // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECharacterAttachPoint, TSoftClassPtr<class UClass>> Props;                                             // 0x0150(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UTexture2D*                             EmoteSprite;                                       // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EmoteIcon;                                         // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA8[0x3];                                     // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPlayoutTime;                                    // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationPlayRate;                                 // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesEmoteCooldown;                                // 0x01BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedsUnlock;                                      // 0x01BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlocksPlayerMovement;                             // 0x01BE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptedByPlayerMovement;                      // 0x01BF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCollectable;                                    // 0x01C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA9[0x7];                                     // 0x01C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanEmoteBeUsedOnTarget(EEmoteTargetType TargetType) const;
	bool CanEmoteBeUsedOnTargets(int32 TargetFlags) const;
	bool DoesEmoteHave2D() const;
	bool DoesEmoteHave3D() const;
	float GetAnimationDuration(class UObject* Context) const;
	float GetEmoteDuration(class UObject* Context) const;
	class UAnimMontage* GetEmoteMontage(class UObject* Context) const;
	bool IsLooping() const;
	class FString ToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteDataAsset">();
	}
	static class UEmoteDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteDataAsset>();
	}
};
static_assert(alignof(UEmoteDataAsset) == 0x000008, "Wrong alignment on UEmoteDataAsset");
static_assert(sizeof(UEmoteDataAsset) == 0x0001C8, "Wrong size on UEmoteDataAsset");
static_assert(offsetof(UEmoteDataAsset, EmoteId) == 0x000030, "Member 'UEmoteDataAsset::EmoteId' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, EmoteName) == 0x000040, "Member 'UEmoteDataAsset::EmoteName' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, DisplayName) == 0x000050, "Member 'UEmoteDataAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, ChatCommandInfo) == 0x000068, "Member 'UEmoteDataAsset::ChatCommandInfo' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, CanBeUsedOn) == 0x0000F0, "Member 'UEmoteDataAsset::CanBeUsedOn' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, BodyTypeAnimations) == 0x0000F8, "Member 'UEmoteDataAsset::BodyTypeAnimations' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, FacialAnimationMontage) == 0x000148, "Member 'UEmoteDataAsset::FacialAnimationMontage' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, Props) == 0x000150, "Member 'UEmoteDataAsset::Props' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, EmoteSprite) == 0x0001A0, "Member 'UEmoteDataAsset::EmoteSprite' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, EmoteIcon) == 0x0001A8, "Member 'UEmoteDataAsset::EmoteIcon' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, bLooping) == 0x0001B0, "Member 'UEmoteDataAsset::bLooping' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, MaxPlayoutTime) == 0x0001B4, "Member 'UEmoteDataAsset::MaxPlayoutTime' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, AnimationPlayRate) == 0x0001B8, "Member 'UEmoteDataAsset::AnimationPlayRate' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, bUsesEmoteCooldown) == 0x0001BC, "Member 'UEmoteDataAsset::bUsesEmoteCooldown' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, bNeedsUnlock) == 0x0001BD, "Member 'UEmoteDataAsset::bNeedsUnlock' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, bBlocksPlayerMovement) == 0x0001BE, "Member 'UEmoteDataAsset::bBlocksPlayerMovement' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, bInterruptedByPlayerMovement) == 0x0001BF, "Member 'UEmoteDataAsset::bInterruptedByPlayerMovement' has a wrong offset!");
static_assert(offsetof(UEmoteDataAsset, bIsCollectable) == 0x0001C0, "Member 'UEmoteDataAsset::bIsCollectable' has a wrong offset!");

// Class Palia.ValeriaGameInstance
// 0x0D30 (0x0EF0 - 0x01C0)
class UValeriaGameInstance : public UGameInstance
{
public:
	TSubclassOf<class USpawnOnFoliageManager>     SpawnOnFoliage;                                    // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveGameServersUpdated;                        // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActorSpawned;                                    // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSkipCutsceneConsoleCmdRun;                       // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapInitBegin;                                    // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapInitEnd;                                      // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLastInputTypeChanged;                            // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetComponent>           DefaultInteractablePlate;                          // 0x0228(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMusicManager>              MusicManagerBlueprintClass;                        // 0x0230(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AAD[0x8];                                     // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInitializingMap;                                // 0x0240(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AAE[0x7];                                     // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EValeriaErrorMsgId, class FText>         ErrorMessageMap;                                   // 0x0248(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AAF[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConfigsManager                        Configs;                                           // 0x02A0(0x0B90)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UVAL_DialogueAsset*>             AllLoadedDialogues;                                // 0x0E30(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UMusicManager*                          MusicManager;                                      // 0x0E40(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_TimerManager*                      TimerManager;                                      // 0x0E48(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   ActiveDisconnectErrorMessage;                      // 0x0E50(0x0018)(Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           AutoClearDcErrorMessageTimerHandle;                // 0x0E68(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoClearDisconnectErrorMessageTime;               // 0x0E70(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AB0[0xC];                                     // 0x0E74(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RunHotfixProcessTimerHandle;                       // 0x0E80(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RunHotfixProcessTime;                              // 0x0E88(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AB1[0x4];                                     // 0x0E8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UValeriaAkListenerComponent*            AudioListener;                                     // 0x0E90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AB2[0x8];                                     // 0x0E98(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UExperiencePackageConfig*               ServerExperiencePackage;                           // 0x0EA0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AB3[0x8];                                     // 0x0EA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnScriptStartCinematic;                            // 0x0EB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartCinematic;                                  // 0x0EC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UCinematicSequenceConfig*               CinematicToPlayAfterTeleport;                      // 0x0ED0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB4[0x8];                                     // 0x0ED8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVAL_CachedEffectActor>         CachedEffectActorData;                             // 0x0EE0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void ClearDisconnectErrorMessage();
	class UVAL_TimerManager* GetTimerManager();
	void RpcServer_RequestEffectActors(class AValeriaPlayerController* PlayerController);
	void RunHotfixProcess();
	void Server_HandleEffectActorDestroyed(class AActor* SpawnedActor);
	void Server_HandleEffectActorSpawned(struct FVAL_EffectActorSpawnParameters& SpawnParameters, class AActor* SpawnedActor);
	void UpdateCurrentInputType(EInputType NewInputType);

	class FText GetActiveDisconnectErrorMessage() const;
	const struct FConfigsManager GetConfigsManager() const;
	EInputType GetCurrentInputType() const;
	class UMusicManager* GetMusicManager() const;
	bool HasActiveDisconnectErrorMessage() const;
	bool IsDebuggingOn() const;
	bool IsHotfixApplied() const;
	bool IsMobileEmulationOn() const;
	void PrintDebugInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGameInstance">();
	}
	static class UValeriaGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGameInstance>();
	}
};
static_assert(alignof(UValeriaGameInstance) == 0x000008, "Wrong alignment on UValeriaGameInstance");
static_assert(sizeof(UValeriaGameInstance) == 0x000EF0, "Wrong size on UValeriaGameInstance");
static_assert(offsetof(UValeriaGameInstance, SpawnOnFoliage) == 0x0001C0, "Member 'UValeriaGameInstance::SpawnOnFoliage' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, OnActiveGameServersUpdated) == 0x0001C8, "Member 'UValeriaGameInstance::OnActiveGameServersUpdated' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, OnActorSpawned) == 0x0001D8, "Member 'UValeriaGameInstance::OnActorSpawned' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, OnSkipCutsceneConsoleCmdRun) == 0x0001E8, "Member 'UValeriaGameInstance::OnSkipCutsceneConsoleCmdRun' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, OnMapInitBegin) == 0x0001F8, "Member 'UValeriaGameInstance::OnMapInitBegin' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, OnMapInitEnd) == 0x000208, "Member 'UValeriaGameInstance::OnMapInitEnd' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, OnLastInputTypeChanged) == 0x000218, "Member 'UValeriaGameInstance::OnLastInputTypeChanged' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, DefaultInteractablePlate) == 0x000228, "Member 'UValeriaGameInstance::DefaultInteractablePlate' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, MusicManagerBlueprintClass) == 0x000230, "Member 'UValeriaGameInstance::MusicManagerBlueprintClass' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, bIsInitializingMap) == 0x000240, "Member 'UValeriaGameInstance::bIsInitializingMap' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, ErrorMessageMap) == 0x000248, "Member 'UValeriaGameInstance::ErrorMessageMap' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, Configs) == 0x0002A0, "Member 'UValeriaGameInstance::Configs' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, AllLoadedDialogues) == 0x000E30, "Member 'UValeriaGameInstance::AllLoadedDialogues' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, MusicManager) == 0x000E40, "Member 'UValeriaGameInstance::MusicManager' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, TimerManager) == 0x000E48, "Member 'UValeriaGameInstance::TimerManager' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, ActiveDisconnectErrorMessage) == 0x000E50, "Member 'UValeriaGameInstance::ActiveDisconnectErrorMessage' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, AutoClearDcErrorMessageTimerHandle) == 0x000E68, "Member 'UValeriaGameInstance::AutoClearDcErrorMessageTimerHandle' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, AutoClearDisconnectErrorMessageTime) == 0x000E70, "Member 'UValeriaGameInstance::AutoClearDisconnectErrorMessageTime' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, RunHotfixProcessTimerHandle) == 0x000E80, "Member 'UValeriaGameInstance::RunHotfixProcessTimerHandle' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, RunHotfixProcessTime) == 0x000E88, "Member 'UValeriaGameInstance::RunHotfixProcessTime' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, AudioListener) == 0x000E90, "Member 'UValeriaGameInstance::AudioListener' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, ServerExperiencePackage) == 0x000EA0, "Member 'UValeriaGameInstance::ServerExperiencePackage' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, OnScriptStartCinematic) == 0x000EB0, "Member 'UValeriaGameInstance::OnScriptStartCinematic' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, OnStartCinematic) == 0x000EC0, "Member 'UValeriaGameInstance::OnStartCinematic' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, CinematicToPlayAfterTeleport) == 0x000ED0, "Member 'UValeriaGameInstance::CinematicToPlayAfterTeleport' has a wrong offset!");
static_assert(offsetof(UValeriaGameInstance, CachedEffectActorData) == 0x000EE0, "Member 'UValeriaGameInstance::CachedEffectActorData' has a wrong offset!");

// Class Palia.VAL_MatchmakingLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_MatchmakingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FOSSVAL_MatchmakingErrorResult CreateFailedResult(EOSSVAL_MatchmakingFailErrorType ErrorType, int32 ErrorCode);
	static class FText GetErrorTextFromErrorType(EOSSVAL_MatchmakingFailErrorType ErrorType);
	static bool IsCurrentlyCreatingTicket(class ULocalPlayer* LocalPlayer);
	static bool IsCurrentlyDeletingJoin(class ULocalPlayer* LocalPlayer);
	static bool IsCurrentlyJoiningServer(class ULocalPlayer* LocalPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_MatchmakingLibrary">();
	}
	static class UVAL_MatchmakingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_MatchmakingLibrary>();
	}
};
static_assert(alignof(UVAL_MatchmakingLibrary) == 0x000008, "Wrong alignment on UVAL_MatchmakingLibrary");
static_assert(sizeof(UVAL_MatchmakingLibrary) == 0x000028, "Wrong size on UVAL_MatchmakingLibrary");

// Class Palia.VAL_SessionSettings
// 0x0088 (0x00C0 - 0x0038)
class UVAL_SessionSettings final : public UDeveloperSettings
{
public:
	float                                         ServerStateInterval;                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerReadyDelay;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerAcceptedPlayerTimeout;                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ABB[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ServerKickedAllPlayersReasonText;                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	int32                                         NumAgonesConnectionAttemptsAllowed;                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ABC[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FText>              ServerRegionTextTable;                             // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	float                                         ClientMultiplayerSessionPresentIntervalInSeconds;  // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ABD[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_SessionSettings">();
	}
	static class UVAL_SessionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_SessionSettings>();
	}
};
static_assert(alignof(UVAL_SessionSettings) == 0x000008, "Wrong alignment on UVAL_SessionSettings");
static_assert(sizeof(UVAL_SessionSettings) == 0x0000C0, "Wrong size on UVAL_SessionSettings");
static_assert(offsetof(UVAL_SessionSettings, ServerStateInterval) == 0x000038, "Member 'UVAL_SessionSettings::ServerStateInterval' has a wrong offset!");
static_assert(offsetof(UVAL_SessionSettings, ServerReadyDelay) == 0x00003C, "Member 'UVAL_SessionSettings::ServerReadyDelay' has a wrong offset!");
static_assert(offsetof(UVAL_SessionSettings, ServerAcceptedPlayerTimeout) == 0x000040, "Member 'UVAL_SessionSettings::ServerAcceptedPlayerTimeout' has a wrong offset!");
static_assert(offsetof(UVAL_SessionSettings, ServerKickedAllPlayersReasonText) == 0x000048, "Member 'UVAL_SessionSettings::ServerKickedAllPlayersReasonText' has a wrong offset!");
static_assert(offsetof(UVAL_SessionSettings, NumAgonesConnectionAttemptsAllowed) == 0x000060, "Member 'UVAL_SessionSettings::NumAgonesConnectionAttemptsAllowed' has a wrong offset!");
static_assert(offsetof(UVAL_SessionSettings, ServerRegionTextTable) == 0x000068, "Member 'UVAL_SessionSettings::ServerRegionTextTable' has a wrong offset!");
static_assert(offsetof(UVAL_SessionSettings, ClientMultiplayerSessionPresentIntervalInSeconds) == 0x0000B8, "Member 'UVAL_SessionSettings::ClientMultiplayerSessionPresentIntervalInSeconds' has a wrong offset!");

// Class Palia.ValeriaGameState
// 0x03D8 (0x06F8 - 0x0320)
class AValeriaGameState : public AGameState
{
public:
	class UDynamicGiftPrefDataComponent*          DynamicGiftPrefDataComponent;                      // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVillagerManager*                       VillagerManagerComponent;                          // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVisibilityManagerComponent*            VisibilityManagerComponent;                        // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UContentBatchManagerComponent*          ContentBatchManagerComponent;                      // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VillagerTrackingUpdateRate;                        // 0x0340(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ABE[0x1C];                                    // 0x0344(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerStateUpdated;                              // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerLocationContextChanged;                    // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerHousingDataChanged;                        // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWindowResized;                                   // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTrackedVillagerSerializer             TrackedVillagerList;                               // 0x03A0(0x0120)(Net, NativeAccessSpecifierPublic)
	TArray<class UTrackingComponent*>             TrackingComponents;                                // 0x04C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FChallengeClientInfo>           ChallengeClientInfo;                               // 0x04D0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	class UVAL_EnvironmentProfileSet*             DefaultEnvProfSet;                                 // 0x04E0(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           VillagerTrackingUpdateHandle;                      // 0x04E8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVillagerTrackingUpdatesActive;                    // 0x04F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ABF[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTrackingTargetComponent*>       TrackingTargetComponents;                          // 0x04F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FHousingPlayerDataSerializer           PlayersHousingData;                                // 0x0508(0x0120)(Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC0[0x60];                                    // 0x0628(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FValeriaZoneData                       ZoneData;                                          // 0x0688(0x0028)(Net, NoDestructor, NativeAccessSpecifierPrivate)
	int64                                         LastLoggedTimestampMs;                             // 0x06B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugVillagerSpeedScalar;                          // 0x06B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC1[0x4];                                     // 0x06BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  RuntimeISMActor;                                   // 0x06C0(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     RuntimeISMActorClass;                              // 0x06E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC2[0x8];                                     // 0x06F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientUpdateVillagerTracking();
	class UContentBatchManagerComponent* GetContentBatchManagerComponent();
	class UDynamicGiftPrefDataComponent* GetDynamicGiftPrefDataComponent();
	class UVillagerManager* GetVillagerManagerComponent();
	class UVisibilityManagerComponent* GetVisibilityManagerComponent();
	void ServerUpdateVillagerTracking();

	bool IsTimeWarpEnabled() const;
	struct FHousingPlayerDataSerializeItem TryToGetPlayerHousingData(struct FUniqueNetIdRepl& TargetPlayer, bool* OutDataFound) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGameState">();
	}
	static class AValeriaGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaGameState>();
	}
};
static_assert(alignof(AValeriaGameState) == 0x000008, "Wrong alignment on AValeriaGameState");
static_assert(sizeof(AValeriaGameState) == 0x0006F8, "Wrong size on AValeriaGameState");
static_assert(offsetof(AValeriaGameState, DynamicGiftPrefDataComponent) == 0x000320, "Member 'AValeriaGameState::DynamicGiftPrefDataComponent' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, VillagerManagerComponent) == 0x000328, "Member 'AValeriaGameState::VillagerManagerComponent' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, VisibilityManagerComponent) == 0x000330, "Member 'AValeriaGameState::VisibilityManagerComponent' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, ContentBatchManagerComponent) == 0x000338, "Member 'AValeriaGameState::ContentBatchManagerComponent' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, VillagerTrackingUpdateRate) == 0x000340, "Member 'AValeriaGameState::VillagerTrackingUpdateRate' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, OnPlayerStateUpdated) == 0x000360, "Member 'AValeriaGameState::OnPlayerStateUpdated' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, OnPlayerLocationContextChanged) == 0x000370, "Member 'AValeriaGameState::OnPlayerLocationContextChanged' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, OnPlayerHousingDataChanged) == 0x000380, "Member 'AValeriaGameState::OnPlayerHousingDataChanged' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, OnWindowResized) == 0x000390, "Member 'AValeriaGameState::OnWindowResized' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, TrackedVillagerList) == 0x0003A0, "Member 'AValeriaGameState::TrackedVillagerList' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, TrackingComponents) == 0x0004C0, "Member 'AValeriaGameState::TrackingComponents' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, ChallengeClientInfo) == 0x0004D0, "Member 'AValeriaGameState::ChallengeClientInfo' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, DefaultEnvProfSet) == 0x0004E0, "Member 'AValeriaGameState::DefaultEnvProfSet' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, VillagerTrackingUpdateHandle) == 0x0004E8, "Member 'AValeriaGameState::VillagerTrackingUpdateHandle' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, bVillagerTrackingUpdatesActive) == 0x0004F0, "Member 'AValeriaGameState::bVillagerTrackingUpdatesActive' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, TrackingTargetComponents) == 0x0004F8, "Member 'AValeriaGameState::TrackingTargetComponents' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, PlayersHousingData) == 0x000508, "Member 'AValeriaGameState::PlayersHousingData' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, ZoneData) == 0x000688, "Member 'AValeriaGameState::ZoneData' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, LastLoggedTimestampMs) == 0x0006B0, "Member 'AValeriaGameState::LastLoggedTimestampMs' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, DebugVillagerSpeedScalar) == 0x0006B8, "Member 'AValeriaGameState::DebugVillagerSpeedScalar' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, RuntimeISMActor) == 0x0006C0, "Member 'AValeriaGameState::RuntimeISMActor' has a wrong offset!");
static_assert(offsetof(AValeriaGameState, RuntimeISMActorClass) == 0x0006E8, "Member 'AValeriaGameState::RuntimeISMActorClass' has a wrong offset!");

// Class Palia.VAL_MovieSceneClockSource
// 0x0068 (0x0098 - 0x0030)
class UVAL_MovieSceneClockSource final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_2AC4[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkAudioEvent>           QueryAkEvent;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QueryEventName;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC5[0x28];                                    // 0x0070(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_MovieSceneClockSource">();
	}
	static class UVAL_MovieSceneClockSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_MovieSceneClockSource>();
	}
};
static_assert(alignof(UVAL_MovieSceneClockSource) == 0x000008, "Wrong alignment on UVAL_MovieSceneClockSource");
static_assert(sizeof(UVAL_MovieSceneClockSource) == 0x000098, "Wrong size on UVAL_MovieSceneClockSource");
static_assert(offsetof(UVAL_MovieSceneClockSource, QueryAkEvent) == 0x000038, "Member 'UVAL_MovieSceneClockSource::QueryAkEvent' has a wrong offset!");
static_assert(offsetof(UVAL_MovieSceneClockSource, QueryEventName) == 0x000060, "Member 'UVAL_MovieSceneClockSource::QueryEventName' has a wrong offset!");

// Class Palia.ValeriaCustomKeyMappingDataProvider
// 0x0008 (0x0030 - 0x0028)
class UValeriaCustomKeyMappingDataProvider final : public UObject
{
public:
	uint8                                         Pad_2AC6[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaCustomKeyMappingDataProvider">();
	}
	static class UValeriaCustomKeyMappingDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaCustomKeyMappingDataProvider>();
	}
};
static_assert(alignof(UValeriaCustomKeyMappingDataProvider) == 0x000008, "Wrong alignment on UValeriaCustomKeyMappingDataProvider");
static_assert(sizeof(UValeriaCustomKeyMappingDataProvider) == 0x000030, "Wrong size on UValeriaCustomKeyMappingDataProvider");

// Class Palia.ValeriaGASAT_RepeatEveryFrame
// 0x0010 (0x0090 - 0x0080)
class UValeriaGASAT_RepeatEveryFrame final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnTicked;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UValeriaGASAT_RepeatEveryFrame* RepeatEveryFrame(class UGameplayAbility* OwningAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGASAT_RepeatEveryFrame">();
	}
	static class UValeriaGASAT_RepeatEveryFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGASAT_RepeatEveryFrame>();
	}
};
static_assert(alignof(UValeriaGASAT_RepeatEveryFrame) == 0x000008, "Wrong alignment on UValeriaGASAT_RepeatEveryFrame");
static_assert(sizeof(UValeriaGASAT_RepeatEveryFrame) == 0x000090, "Wrong size on UValeriaGASAT_RepeatEveryFrame");
static_assert(offsetof(UValeriaGASAT_RepeatEveryFrame, OnTicked) == 0x000080, "Member 'UValeriaGASAT_RepeatEveryFrame::OnTicked' has a wrong offset!");

// Class Palia.VAL_TransitiveDecorAsset
// 0x0088 (0x00B8 - 0x0030)
class UVAL_TransitiveDecorAsset final : public UPrimaryDataAsset
{
public:
	TMap<int32, struct FTransitiveDecorProgressStep> ProgressDefinition;                                // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> PlaceableToSpawnWhenDone;                          // 0x0080(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 TransitionRule;                                    // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FGameplayTagContainer GetAllTagsUpToState(int32 State) const;
	int32 GetFinalTransitionStateIndex() const;
	int32 GetNextTransitionStateIndex(int32 State) const;
	struct FTransitiveDecorProgressStep GetProgressStep(int32 TransitiveState) const;
	struct FGameplayTagContainer GetTagsForState(int32 State) const;
	bool IsFinalTransitionStateIndex(int32 State) const;
	bool IsValidTransitionState(int32 TransitiveState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TransitiveDecorAsset">();
	}
	static class UVAL_TransitiveDecorAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TransitiveDecorAsset>();
	}
};
static_assert(alignof(UVAL_TransitiveDecorAsset) == 0x000008, "Wrong alignment on UVAL_TransitiveDecorAsset");
static_assert(sizeof(UVAL_TransitiveDecorAsset) == 0x0000B8, "Wrong size on UVAL_TransitiveDecorAsset");
static_assert(offsetof(UVAL_TransitiveDecorAsset, ProgressDefinition) == 0x000030, "Member 'UVAL_TransitiveDecorAsset::ProgressDefinition' has a wrong offset!");
static_assert(offsetof(UVAL_TransitiveDecorAsset, PlaceableToSpawnWhenDone) == 0x000080, "Member 'UVAL_TransitiveDecorAsset::PlaceableToSpawnWhenDone' has a wrong offset!");
static_assert(offsetof(UVAL_TransitiveDecorAsset, TransitionRule) == 0x0000A8, "Member 'UVAL_TransitiveDecorAsset::TransitionRule' has a wrong offset!");

// Class Palia.ValeriaGASAT_WaitOverlap
// 0x0020 (0x00A0 - 0x0080)
class UValeriaGASAT_WaitOverlap final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnOverlap;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ACC[0x10];                                    // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UValeriaGASAT_WaitOverlap* ValeriaWaitForOverlap(class UGameplayAbility* OwningAbility, class FName ColliderTag, class AActor* ActorToTest);

	void OnOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGASAT_WaitOverlap">();
	}
	static class UValeriaGASAT_WaitOverlap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGASAT_WaitOverlap>();
	}
};
static_assert(alignof(UValeriaGASAT_WaitOverlap) == 0x000008, "Wrong alignment on UValeriaGASAT_WaitOverlap");
static_assert(sizeof(UValeriaGASAT_WaitOverlap) == 0x0000A0, "Wrong size on UValeriaGASAT_WaitOverlap");
static_assert(offsetof(UValeriaGASAT_WaitOverlap, OnOverlap) == 0x000080, "Member 'UValeriaGASAT_WaitOverlap::OnOverlap' has a wrong offset!");

// Class Palia.ValeriaGASFishingAttributeSet
// 0x0080 (0x00B0 - 0x0030)
class UValeriaGASFishingAttributeSet final : public UAttributeSet
{
public:
	struct FGameplayAttributeData                 RodHealthPercentIncrease;                          // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalFlatRodHealth;                           // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SafeZoneSpeedPercentIncrease;                      // 0x0050(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SafeZoneAccelerationPercentIncrease;               // 0x0060(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AdditionalFlatSafeZoneSize;                        // 0x0070(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SafeZonePercentIncrease;                           // 0x0080(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RodDamageRecoveryPercentChange;                    // 0x0090(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HookTimeReductionPercent;                          // 0x00A0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGASFishingAttributeSet">();
	}
	static class UValeriaGASFishingAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGASFishingAttributeSet>();
	}
};
static_assert(alignof(UValeriaGASFishingAttributeSet) == 0x000008, "Wrong alignment on UValeriaGASFishingAttributeSet");
static_assert(sizeof(UValeriaGASFishingAttributeSet) == 0x0000B0, "Wrong size on UValeriaGASFishingAttributeSet");
static_assert(offsetof(UValeriaGASFishingAttributeSet, RodHealthPercentIncrease) == 0x000030, "Member 'UValeriaGASFishingAttributeSet::RodHealthPercentIncrease' has a wrong offset!");
static_assert(offsetof(UValeriaGASFishingAttributeSet, AdditionalFlatRodHealth) == 0x000040, "Member 'UValeriaGASFishingAttributeSet::AdditionalFlatRodHealth' has a wrong offset!");
static_assert(offsetof(UValeriaGASFishingAttributeSet, SafeZoneSpeedPercentIncrease) == 0x000050, "Member 'UValeriaGASFishingAttributeSet::SafeZoneSpeedPercentIncrease' has a wrong offset!");
static_assert(offsetof(UValeriaGASFishingAttributeSet, SafeZoneAccelerationPercentIncrease) == 0x000060, "Member 'UValeriaGASFishingAttributeSet::SafeZoneAccelerationPercentIncrease' has a wrong offset!");
static_assert(offsetof(UValeriaGASFishingAttributeSet, AdditionalFlatSafeZoneSize) == 0x000070, "Member 'UValeriaGASFishingAttributeSet::AdditionalFlatSafeZoneSize' has a wrong offset!");
static_assert(offsetof(UValeriaGASFishingAttributeSet, SafeZonePercentIncrease) == 0x000080, "Member 'UValeriaGASFishingAttributeSet::SafeZonePercentIncrease' has a wrong offset!");
static_assert(offsetof(UValeriaGASFishingAttributeSet, RodDamageRecoveryPercentChange) == 0x000090, "Member 'UValeriaGASFishingAttributeSet::RodDamageRecoveryPercentChange' has a wrong offset!");
static_assert(offsetof(UValeriaGASFishingAttributeSet, HookTimeReductionPercent) == 0x0000A0, "Member 'UValeriaGASFishingAttributeSet::HookTimeReductionPercent' has a wrong offset!");

// Class Palia.VAL_UniqueNetIdUtils
// 0x0000 (0x0028 - 0x0028)
class UVAL_UniqueNetIdUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool EqualEqual(struct FUniqueNetIdRepl& A, struct FUniqueNetIdRepl& B);
	static struct FGuid GetAccountId(struct FUniqueNetIdRepl& NetId);
	static struct FUniqueNetIdRepl GetNetIdFromChatMessageSender(struct FValeriaChatMessage& ChatMessage);
	static struct FUniqueNetIdRepl GetNetIdFromDirectMessageTarget(struct FMessageTarget& MessageTarget);
	static struct FUniqueNetIdRepl GetNetIdFromLocalPlayer(class ULocalPlayer* LocalPlayer);
	static struct FUniqueNetIdRepl GetNetIdFromPlayerController(class APlayerController* PlayerController);
	static struct FUniqueNetIdRepl GetNetIdFromPlayerState(class APlayerState* PlayerState);
	static class FString GetSessionIdString(struct FBlueprintSessionResult& SessionResult);
	static bool IsValid(struct FUniqueNetIdRepl& NetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_UniqueNetIdUtils">();
	}
	static class UVAL_UniqueNetIdUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_UniqueNetIdUtils>();
	}
};
static_assert(alignof(UVAL_UniqueNetIdUtils) == 0x000008, "Wrong alignment on UVAL_UniqueNetIdUtils");
static_assert(sizeof(UVAL_UniqueNetIdUtils) == 0x000028, "Wrong size on UVAL_UniqueNetIdUtils");

// Class Palia.ValeriaGASSprintingAttributeSet
// 0x0010 (0x0040 - 0x0030)
class UValeriaGASSprintingAttributeSet final : public UAttributeSet
{
public:
	struct FGameplayAttributeData                 SprintStaminaUsePercentReduction;                  // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaGASSprintingAttributeSet">();
	}
	static class UValeriaGASSprintingAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaGASSprintingAttributeSet>();
	}
};
static_assert(alignof(UValeriaGASSprintingAttributeSet) == 0x000008, "Wrong alignment on UValeriaGASSprintingAttributeSet");
static_assert(sizeof(UValeriaGASSprintingAttributeSet) == 0x000040, "Wrong size on UValeriaGASSprintingAttributeSet");
static_assert(offsetof(UValeriaGASSprintingAttributeSet, SprintStaminaUsePercentReduction) == 0x000030, "Member 'UValeriaGASSprintingAttributeSet::SprintStaminaUsePercentReduction' has a wrong offset!");

// Class Palia.ValeriaNavFilter
// 0x0000 (0x0048 - 0x0048)
class UValeriaNavFilter final : public UNavFilter_AIControllerDefault
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaNavFilter">();
	}
	static class UValeriaNavFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaNavFilter>();
	}
};
static_assert(alignof(UValeriaNavFilter) == 0x000008, "Wrong alignment on UValeriaNavFilter");
static_assert(sizeof(UValeriaNavFilter) == 0x000048, "Wrong size on UValeriaNavFilter");

// Class Palia.VAL_WorldSettings
// 0x0028 (0x04F0 - 0x04C8)
class AVAL_WorldSettings final : public AWorldSettings
{
public:
	bool                                          bIsGliderEnabled;                                  // 0x04C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMinigameWorld;                                  // 0x04C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AD0[0x6];                                     // 0x04CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeleportTravelConfigAsset*             UnstuckOverrideLocation;                           // 0x04D0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseZLevelBroadcast;                               // 0x04D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AD1[0x3];                                     // 0x04D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZLevelBroadcast;                                   // 0x04DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class AStaticMeshActor>> MeshesToHideInPrivateSpaces;                       // 0x04E0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	TArray<TSoftObjectPtr<class AStaticMeshActor>> GetMeshesToHideInPrivateSpaces() const;
	class UTeleportTravelConfigAsset* GetUnstuckDestination() const;
	int32 GetZLevelBroadcast() const;
	bool IsGliderEnabled() const;
	bool IsMinigameWorld() const;
	bool ShouldUseZLevelBroadcast() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_WorldSettings">();
	}
	static class AVAL_WorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_WorldSettings>();
	}
};
static_assert(alignof(AVAL_WorldSettings) == 0x000008, "Wrong alignment on AVAL_WorldSettings");
static_assert(sizeof(AVAL_WorldSettings) == 0x0004F0, "Wrong size on AVAL_WorldSettings");
static_assert(offsetof(AVAL_WorldSettings, bIsGliderEnabled) == 0x0004C8, "Member 'AVAL_WorldSettings::bIsGliderEnabled' has a wrong offset!");
static_assert(offsetof(AVAL_WorldSettings, bIsMinigameWorld) == 0x0004C9, "Member 'AVAL_WorldSettings::bIsMinigameWorld' has a wrong offset!");
static_assert(offsetof(AVAL_WorldSettings, UnstuckOverrideLocation) == 0x0004D0, "Member 'AVAL_WorldSettings::UnstuckOverrideLocation' has a wrong offset!");
static_assert(offsetof(AVAL_WorldSettings, bUseZLevelBroadcast) == 0x0004D8, "Member 'AVAL_WorldSettings::bUseZLevelBroadcast' has a wrong offset!");
static_assert(offsetof(AVAL_WorldSettings, ZLevelBroadcast) == 0x0004DC, "Member 'AVAL_WorldSettings::ZLevelBroadcast' has a wrong offset!");
static_assert(offsetof(AVAL_WorldSettings, MeshesToHideInPrivateSpaces) == 0x0004E0, "Member 'AVAL_WorldSettings::MeshesToHideInPrivateSpaces' has a wrong offset!");

// Class Palia.ValeriaPerfManager
// 0x0050 (0x0080 - 0x0030)
class UValeriaPerfManager final : public UGameInstanceSubsystem
{
public:
	bool                                          bPreventUpload;                                    // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD2[0x17];                                    // 0x0031(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCurrentlyProcessing;                            // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AD3[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToProfileForSecs;                              // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PerfSessionId;                                     // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentCommandList;                                // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentCommandIndex;                               // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeLastProfiledAt;                                // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutomatedPerfTestCooldown;                         // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AutomatedPerfNumOfConnectionsRequired;             // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void TickAutomatedProfiler();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaPerfManager">();
	}
	static class UValeriaPerfManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaPerfManager>();
	}
};
static_assert(alignof(UValeriaPerfManager) == 0x000008, "Wrong alignment on UValeriaPerfManager");
static_assert(sizeof(UValeriaPerfManager) == 0x000080, "Wrong size on UValeriaPerfManager");
static_assert(offsetof(UValeriaPerfManager, bPreventUpload) == 0x000030, "Member 'UValeriaPerfManager::bPreventUpload' has a wrong offset!");
static_assert(offsetof(UValeriaPerfManager, bIsCurrentlyProcessing) == 0x000048, "Member 'UValeriaPerfManager::bIsCurrentlyProcessing' has a wrong offset!");
static_assert(offsetof(UValeriaPerfManager, TimeToProfileForSecs) == 0x00004C, "Member 'UValeriaPerfManager::TimeToProfileForSecs' has a wrong offset!");
static_assert(offsetof(UValeriaPerfManager, PerfSessionId) == 0x000050, "Member 'UValeriaPerfManager::PerfSessionId' has a wrong offset!");
static_assert(offsetof(UValeriaPerfManager, CurrentCommandList) == 0x000060, "Member 'UValeriaPerfManager::CurrentCommandList' has a wrong offset!");
static_assert(offsetof(UValeriaPerfManager, CurrentCommandIndex) == 0x000070, "Member 'UValeriaPerfManager::CurrentCommandIndex' has a wrong offset!");
static_assert(offsetof(UValeriaPerfManager, TimeLastProfiledAt) == 0x000074, "Member 'UValeriaPerfManager::TimeLastProfiledAt' has a wrong offset!");
static_assert(offsetof(UValeriaPerfManager, AutomatedPerfTestCooldown) == 0x000078, "Member 'UValeriaPerfManager::AutomatedPerfTestCooldown' has a wrong offset!");
static_assert(offsetof(UValeriaPerfManager, AutomatedPerfNumOfConnectionsRequired) == 0x00007C, "Member 'UValeriaPerfManager::AutomatedPerfNumOfConnectionsRequired' has a wrong offset!");

// Class Palia.VAL_WwiseMotionPS5
// 0x0000 (0x0030 - 0x0030)
class UVAL_WwiseMotionPS5 final : public UVAL_WwiseMotionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_WwiseMotionPS5">();
	}
	static class UVAL_WwiseMotionPS5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_WwiseMotionPS5>();
	}
};
static_assert(alignof(UVAL_WwiseMotionPS5) == 0x000008, "Wrong alignment on UVAL_WwiseMotionPS5");
static_assert(sizeof(UVAL_WwiseMotionPS5) == 0x000030, "Wrong size on UVAL_WwiseMotionPS5");

// Class Palia.ValeriaPlotItemRepComponent
// 0x0028 (0x00C8 - 0x00A0)
class UValeriaPlotItemRepComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2AD4[0x20];                                    // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UValeriaReplicationGraph*               RepGraph;                                          // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaPlotItemRepComponent">();
	}
	static class UValeriaPlotItemRepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaPlotItemRepComponent>();
	}
};
static_assert(alignof(UValeriaPlotItemRepComponent) == 0x000008, "Wrong alignment on UValeriaPlotItemRepComponent");
static_assert(sizeof(UValeriaPlotItemRepComponent) == 0x0000C8, "Wrong size on UValeriaPlotItemRepComponent");
static_assert(offsetof(UValeriaPlotItemRepComponent, RepGraph) == 0x0000C0, "Member 'UValeriaPlotItemRepComponent::RepGraph' has a wrong offset!");

// Class Palia.ValeriaReplicationGraphNode_TrackingNode_ForConnection
// 0x0028 (0x0078 - 0x0050)
class UValeriaReplicationGraphNode_TrackingNode_ForConnection final : public UReplicationGraphNode
{
public:
	class AValeriaPlayerController*               Player;                                            // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         TrackedActorsForConnection;                        // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ForcedAlwaysRelevantActors;                        // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ForcedAlwaysRelevantActorDestroyed(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaReplicationGraphNode_TrackingNode_ForConnection">();
	}
	static class UValeriaReplicationGraphNode_TrackingNode_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaReplicationGraphNode_TrackingNode_ForConnection>();
	}
};
static_assert(alignof(UValeriaReplicationGraphNode_TrackingNode_ForConnection) == 0x000008, "Wrong alignment on UValeriaReplicationGraphNode_TrackingNode_ForConnection");
static_assert(sizeof(UValeriaReplicationGraphNode_TrackingNode_ForConnection) == 0x000078, "Wrong size on UValeriaReplicationGraphNode_TrackingNode_ForConnection");
static_assert(offsetof(UValeriaReplicationGraphNode_TrackingNode_ForConnection, Player) == 0x000050, "Member 'UValeriaReplicationGraphNode_TrackingNode_ForConnection::Player' has a wrong offset!");
static_assert(offsetof(UValeriaReplicationGraphNode_TrackingNode_ForConnection, TrackedActorsForConnection) == 0x000058, "Member 'UValeriaReplicationGraphNode_TrackingNode_ForConnection::TrackedActorsForConnection' has a wrong offset!");
static_assert(offsetof(UValeriaReplicationGraphNode_TrackingNode_ForConnection, ForcedAlwaysRelevantActors) == 0x000068, "Member 'UValeriaReplicationGraphNode_TrackingNode_ForConnection::ForcedAlwaysRelevantActors' has a wrong offset!");

// Class Palia.VAL_PlayerGuildLevels
// 0x0010 (0x0038 - 0x0028)
class UVAL_PlayerGuildLevels final : public UObject
{
public:
	uint8                                         Pad_2AD5[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildLevels">();
	}
	static class UVAL_PlayerGuildLevels* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildLevels>();
	}
};
static_assert(alignof(UVAL_PlayerGuildLevels) == 0x000008, "Wrong alignment on UVAL_PlayerGuildLevels");
static_assert(sizeof(UVAL_PlayerGuildLevels) == 0x000038, "Wrong size on UVAL_PlayerGuildLevels");

// Class Palia.ValeriaReplicationGraphNode_AlwaysRelevantForConnection
// 0x0000 (0x00D0 - 0x00D0)
class UValeriaReplicationGraphNode_AlwaysRelevantForConnection final : public UReplicationGraphNode_ActorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaReplicationGraphNode_AlwaysRelevantForConnection">();
	}
	static class UValeriaReplicationGraphNode_AlwaysRelevantForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaReplicationGraphNode_AlwaysRelevantForConnection>();
	}
};
static_assert(alignof(UValeriaReplicationGraphNode_AlwaysRelevantForConnection) == 0x000008, "Wrong alignment on UValeriaReplicationGraphNode_AlwaysRelevantForConnection");
static_assert(sizeof(UValeriaReplicationGraphNode_AlwaysRelevantForConnection) == 0x0000D0, "Wrong size on UValeriaReplicationGraphNode_AlwaysRelevantForConnection");

// Class Palia.ValeriaReplicationGraph
// 0x0230 (0x07A0 - 0x0570)
class UValeriaReplicationGraph final : public UReplicationGraph
{
public:
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                          // 0x0570(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UValeriaReplicationGraphNode_HousingPlot* HousingPlotNode;                                   // 0x0578(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReplicationGraphNode_ActorList*        AlwaysRelNode;                                     // 0x0580(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AD6[0x128];                                   // 0x0588(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AllTrackableActors;                                // 0x06B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         DelayedConnectionRelevantActors;                   // 0x06C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         PositionUpdatedHousingPlotItems;                   // 0x06D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<uint32, struct FValeriaPlotReplicationData> HousingPlotActors;                                 // 0x06E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, class AHousingPlotActor*> ActorToHousingPlotMapping;                         // 0x0730(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AD7[0x20];                                    // 0x0780(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaReplicationGraph">();
	}
	static class UValeriaReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaReplicationGraph>();
	}
};
static_assert(alignof(UValeriaReplicationGraph) == 0x000010, "Wrong alignment on UValeriaReplicationGraph");
static_assert(sizeof(UValeriaReplicationGraph) == 0x0007A0, "Wrong size on UValeriaReplicationGraph");
static_assert(offsetof(UValeriaReplicationGraph, GridNode) == 0x000570, "Member 'UValeriaReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UValeriaReplicationGraph, HousingPlotNode) == 0x000578, "Member 'UValeriaReplicationGraph::HousingPlotNode' has a wrong offset!");
static_assert(offsetof(UValeriaReplicationGraph, AlwaysRelNode) == 0x000580, "Member 'UValeriaReplicationGraph::AlwaysRelNode' has a wrong offset!");
static_assert(offsetof(UValeriaReplicationGraph, AllTrackableActors) == 0x0006B0, "Member 'UValeriaReplicationGraph::AllTrackableActors' has a wrong offset!");
static_assert(offsetof(UValeriaReplicationGraph, DelayedConnectionRelevantActors) == 0x0006C0, "Member 'UValeriaReplicationGraph::DelayedConnectionRelevantActors' has a wrong offset!");
static_assert(offsetof(UValeriaReplicationGraph, PositionUpdatedHousingPlotItems) == 0x0006D0, "Member 'UValeriaReplicationGraph::PositionUpdatedHousingPlotItems' has a wrong offset!");
static_assert(offsetof(UValeriaReplicationGraph, HousingPlotActors) == 0x0006E0, "Member 'UValeriaReplicationGraph::HousingPlotActors' has a wrong offset!");
static_assert(offsetof(UValeriaReplicationGraph, ActorToHousingPlotMapping) == 0x000730, "Member 'UValeriaReplicationGraph::ActorToHousingPlotMapping' has a wrong offset!");

// Class Palia.ValeriaSpatialAudioVolume
// 0x0040 (0x0338 - 0x02F8)
class AValeriaSpatialAudioVolume final : public AAkSpatialAudioVolume
{
public:
	ESpatialVolumeType                            VolumeType;                                        // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpatialVolumePriority                        EPriority;                                         // 0x02F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD8[0x2];                                     // 0x02FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Priority;                                          // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransmissionLoss;                                  // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD9[0x4];                                     // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkAudioEvent;                                      // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAuxBus*                              AuxBus;                                            // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerbSendLeveldB;                                   // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ADA[0x4];                                     // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaSpatialAudioVolume*             VolumeToOverride;                                  // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAuxBus*                              OriginalAuxBus;                                    // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginalSendLevel;                                 // 0x0330(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ADB[0x4];                                     // 0x0334(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckVerb();
	float GetPriority();
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void ResetVerb();
	void SwitchVerb();
	void UpdateRoom();

	bool DoesEncompassPoint(const struct FVector& Point, float SphereRadius) const;
	bool IsPawnRelevant(class APawn* Pawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaSpatialAudioVolume">();
	}
	static class AValeriaSpatialAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaSpatialAudioVolume>();
	}
};
static_assert(alignof(AValeriaSpatialAudioVolume) == 0x000008, "Wrong alignment on AValeriaSpatialAudioVolume");
static_assert(sizeof(AValeriaSpatialAudioVolume) == 0x000338, "Wrong size on AValeriaSpatialAudioVolume");
static_assert(offsetof(AValeriaSpatialAudioVolume, VolumeType) == 0x0002F8, "Member 'AValeriaSpatialAudioVolume::VolumeType' has a wrong offset!");
static_assert(offsetof(AValeriaSpatialAudioVolume, EPriority) == 0x0002F9, "Member 'AValeriaSpatialAudioVolume::EPriority' has a wrong offset!");
static_assert(offsetof(AValeriaSpatialAudioVolume, Priority) == 0x0002FC, "Member 'AValeriaSpatialAudioVolume::Priority' has a wrong offset!");
static_assert(offsetof(AValeriaSpatialAudioVolume, TransmissionLoss) == 0x000300, "Member 'AValeriaSpatialAudioVolume::TransmissionLoss' has a wrong offset!");
static_assert(offsetof(AValeriaSpatialAudioVolume, AkAudioEvent) == 0x000308, "Member 'AValeriaSpatialAudioVolume::AkAudioEvent' has a wrong offset!");
static_assert(offsetof(AValeriaSpatialAudioVolume, AuxBus) == 0x000310, "Member 'AValeriaSpatialAudioVolume::AuxBus' has a wrong offset!");
static_assert(offsetof(AValeriaSpatialAudioVolume, VerbSendLeveldB) == 0x000318, "Member 'AValeriaSpatialAudioVolume::VerbSendLeveldB' has a wrong offset!");
static_assert(offsetof(AValeriaSpatialAudioVolume, VolumeToOverride) == 0x000320, "Member 'AValeriaSpatialAudioVolume::VolumeToOverride' has a wrong offset!");
static_assert(offsetof(AValeriaSpatialAudioVolume, OriginalAuxBus) == 0x000328, "Member 'AValeriaSpatialAudioVolume::OriginalAuxBus' has a wrong offset!");
static_assert(offsetof(AValeriaSpatialAudioVolume, OriginalSendLevel) == 0x000330, "Member 'AValeriaSpatialAudioVolume::OriginalSendLevel' has a wrong offset!");

// Class Palia.VAL_PlayerGuildQuestTrackerLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_PlayerGuildQuestTrackerLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CanPinQuest(class UVAL_PlayerGuildComponent* PlayerGuildComp, struct FGuid& QuestId);
	static TArray<struct FGuid> GetPinnedQuestIds(class UVAL_PlayerGuildComponent* PlayerGuildComp);
	static bool IsQuestPinned(class UVAL_PlayerGuildComponent* PlayerGuildComp, struct FGuid& QuestId);
	static void SetIsQuestPinned(class UVAL_PlayerGuildComponent* PlayerGuildComp, struct FGuid& QuestId, bool bIsPinned);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildQuestTrackerLibrary">();
	}
	static class UVAL_PlayerGuildQuestTrackerLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildQuestTrackerLibrary>();
	}
};
static_assert(alignof(UVAL_PlayerGuildQuestTrackerLibrary) == 0x000008, "Wrong alignment on UVAL_PlayerGuildQuestTrackerLibrary");
static_assert(sizeof(UVAL_PlayerGuildQuestTrackerLibrary) == 0x000028, "Wrong size on UVAL_PlayerGuildQuestTrackerLibrary");

// Class Palia.ValeriaSpringArmComponent
// 0x0070 (0x0410 - 0x03A0)
class UValeriaSpringArmComponent final : public USpringArmComponent
{
public:
	bool                                          bOverrideDefaultCollisionTest;                     // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE3[0x3];                                     // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowestPossibleCameraOffsetPercentage;              // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraZBlendRate;                                  // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE4[0x4];                                     // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CameraZBlendMaxDiscrepancy;                        // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraZBlendMatchDirectionOfVelocity;             // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClientOnly;                                     // 0x03C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClientViewTargetOnly;                           // 0x03C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE5[0x4D];                                    // 0x03C3(0x004D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlendToTargetOffset(struct FVector& NewTargetOffset, float BlendTime);
	void RestoreTargetOffset(float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaSpringArmComponent">();
	}
	static class UValeriaSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaSpringArmComponent>();
	}
};
static_assert(alignof(UValeriaSpringArmComponent) == 0x000010, "Wrong alignment on UValeriaSpringArmComponent");
static_assert(sizeof(UValeriaSpringArmComponent) == 0x000410, "Wrong size on UValeriaSpringArmComponent");
static_assert(offsetof(UValeriaSpringArmComponent, bOverrideDefaultCollisionTest) == 0x0003A0, "Member 'UValeriaSpringArmComponent::bOverrideDefaultCollisionTest' has a wrong offset!");
static_assert(offsetof(UValeriaSpringArmComponent, LowestPossibleCameraOffsetPercentage) == 0x0003A4, "Member 'UValeriaSpringArmComponent::LowestPossibleCameraOffsetPercentage' has a wrong offset!");
static_assert(offsetof(UValeriaSpringArmComponent, CameraZBlendRate) == 0x0003A8, "Member 'UValeriaSpringArmComponent::CameraZBlendRate' has a wrong offset!");
static_assert(offsetof(UValeriaSpringArmComponent, CameraZBlendMaxDiscrepancy) == 0x0003B0, "Member 'UValeriaSpringArmComponent::CameraZBlendMaxDiscrepancy' has a wrong offset!");
static_assert(offsetof(UValeriaSpringArmComponent, bCameraZBlendMatchDirectionOfVelocity) == 0x0003C0, "Member 'UValeriaSpringArmComponent::bCameraZBlendMatchDirectionOfVelocity' has a wrong offset!");
static_assert(offsetof(UValeriaSpringArmComponent, bIsClientOnly) == 0x0003C1, "Member 'UValeriaSpringArmComponent::bIsClientOnly' has a wrong offset!");
static_assert(offsetof(UValeriaSpringArmComponent, bIsClientViewTargetOnly) == 0x0003C2, "Member 'UValeriaSpringArmComponent::bIsClientViewTargetOnly' has a wrong offset!");

// Class Palia.ValeriaTargetPoint
// 0x0010 (0x02B8 - 0x02A8)
class AValeriaTargetPoint final : public ATargetPoint
{
public:
	bool                                          bOverrideTargetPointLabelName;                     // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE7[0x3];                                     // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetPointLabelName;                              // 0x02AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE8[0x4];                                     // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetTargetPointLabelName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaTargetPoint">();
	}
	static class AValeriaTargetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaTargetPoint>();
	}
};
static_assert(alignof(AValeriaTargetPoint) == 0x000008, "Wrong alignment on AValeriaTargetPoint");
static_assert(sizeof(AValeriaTargetPoint) == 0x0002B8, "Wrong size on AValeriaTargetPoint");
static_assert(offsetof(AValeriaTargetPoint, bOverrideTargetPointLabelName) == 0x0002A8, "Member 'AValeriaTargetPoint::bOverrideTargetPointLabelName' has a wrong offset!");
static_assert(offsetof(AValeriaTargetPoint, TargetPointLabelName) == 0x0002AC, "Member 'AValeriaTargetPoint::TargetPointLabelName' has a wrong offset!");

// Class Palia.ValeriaTimeManager
// 0x0038 (0x0068 - 0x0030)
class UValeriaTimeManager final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnServerDailyReset;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerWeeklyReset;                               // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimerHandle                           PostVALTimerManagerInitializedTimerHandle;         // 0x0050(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVAL_TimerHandle                       DailyResetTimerHandle;                             // 0x0058(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVAL_TimerHandle                       WeeklyResetTimerHandle;                            // 0x0060(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetSyncedAlphaFromDuration(float DurationInSeconds);
	int64 GetTimeWarpSecs();
	void HandlePreServerDailyReset(struct FVAL_TimerHandle* TimerHandle);
	void HandlePreServerWeeklyReset(struct FVAL_TimerHandle* TimerHandle);
	void HandleServerDailyReset();
	void HandleServerWeeklyReset();
	void TryInitializePostVALTimerManagerInitialized();

	int32 CalcHoursFromFilterStart(const struct FTimeOfDayFilter& Filter) const;
	struct FDateTime ConvertTimestampMsToRealDateTime(int64 TimestampMs) const;
	struct FClockTimeInValeria ConvertToClockTime(const struct FInt64Split& TimestampMs) const;
	int64 ConvertToGlobalTimestampMs(const struct FClockTimeInValeria& ClockTime) const;
	float ConvertValeriaTimeDurationToRealSeconds(float ValeriaHours) const;
	struct FClockTimeInValeria GetClockTime() const;
	struct FClockTimeInValeria GetClockTimeOfDay() const;
	int32 GetCurrentDay() const;
	int32 GetDailyResetHour() const;
	int64 GetGlobalTimestampMs() const;
	int32 GetRealTimeSecondsInOneGameHour() const;
	int32 GetSecondsSinceTodayStarted() const;
	float GetTimeOfDayLerp() const;
	float GetTimeOfDayLerpAt(int64 CurrTimestampMs) const;
	int64 GetTimestampOfNextHarvestDayAfter(int64 TimestampMs, int32 NumberOfHarvestDays) const;
	int32 GetTotalSecondsInADay() const;
	struct FWeeklyEventConfig GetWeeklyResetTime() const;
	bool IsValeriaTimeValid() const;
	bool IsWithinTimeOfDayFilter(const struct FTimeOfDayFilter& Filter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaTimeManager">();
	}
	static class UValeriaTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValeriaTimeManager>();
	}
};
static_assert(alignof(UValeriaTimeManager) == 0x000008, "Wrong alignment on UValeriaTimeManager");
static_assert(sizeof(UValeriaTimeManager) == 0x000068, "Wrong size on UValeriaTimeManager");
static_assert(offsetof(UValeriaTimeManager, OnServerDailyReset) == 0x000030, "Member 'UValeriaTimeManager::OnServerDailyReset' has a wrong offset!");
static_assert(offsetof(UValeriaTimeManager, OnServerWeeklyReset) == 0x000040, "Member 'UValeriaTimeManager::OnServerWeeklyReset' has a wrong offset!");
static_assert(offsetof(UValeriaTimeManager, PostVALTimerManagerInitializedTimerHandle) == 0x000050, "Member 'UValeriaTimeManager::PostVALTimerManagerInitializedTimerHandle' has a wrong offset!");
static_assert(offsetof(UValeriaTimeManager, DailyResetTimerHandle) == 0x000058, "Member 'UValeriaTimeManager::DailyResetTimerHandle' has a wrong offset!");
static_assert(offsetof(UValeriaTimeManager, WeeklyResetTimerHandle) == 0x000060, "Member 'UValeriaTimeManager::WeeklyResetTimerHandle' has a wrong offset!");

// Class Palia.ValeriaVillagerCharacter
// 0x0240 (0x0700 - 0x04C0)
class AValeriaVillagerCharacter : public AValeriaMoveablePawn
{
public:
	uint8                                         Pad_2AEC[0x8];                                     // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHiddenChanged;                                   // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEngagedChanged;                                  // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVillagerActionChangedDel;                        // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVillagerConfigIdChangedDel;                      // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVillagerAbsentStateChanged;                      // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AED[0x10];                                    // 0x0518(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFadingCharacter;                                  // 0x0528(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AEE[0x17];                                    // 0x0529(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVillagerActionInfo                    CurrentActionInfo;                                 // 0x0540(0x0070)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AEF[0x10];                                    // 0x05B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bQueuedForDespawn;                                 // 0x05C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVillagerState                                CurrentState;                                      // 0x05C1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AF0[0x2];                                     // 0x05C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  VillagerGuid;                                      // 0x05C4(0x0010)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEngaged;                                        // 0x05D4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAbsent;                                           // 0x05D5(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AF1[0x2];                                     // 0x05D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaTargetPoint*                    OriginalSpawnPoint;                                // 0x05D8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowChangeOfFocusDuringDialogue;                 // 0x05E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AF2[0x3];                                     // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VillagerConfigId;                                  // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVillagerCostumeDataAsset*              Costume;                                           // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCinematicsOnly;                                   // 0x05F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDialogueOnly;                                     // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EWorldLocationContext                         SpawnContext;                                      // 0x05F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AF3[0x5];                                     // 0x05F3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ULimitedEventDataAsset*                 SpawnContextEvent;                                 // 0x05F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkOutDuration;                                   // 0x0600(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AF4[0x4];                                     // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AnimMappings;                                      // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UDataTable*>          ExtraAnimMappings;                                 // 0x0610(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   LastUsedAnimMappingName;                           // 0x0660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLastUsedAnimWasBlendSpace;                        // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AF5[0x7];                                     // 0x0669(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPersistComponent*                      Persist;                                           // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDialogueComponent*                     Dialogue;                                          // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVillagerStoreInteractableComponent*    VillagerStore;                                     // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEquipmentComponent*                    EquipmentComponent;                                // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVillagerGiftReceiverComponent*         GiftReceiver;                                      // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAICombatStateComponent*                CombatState;                                       // 0x0698(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActorTagComponent*                     TagComponent;                                      // 0x06A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FSoftObjectPath, class UAnimMontage*> CachedDialogueMontages;                            // 0x06A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AF6[0x8];                                     // 0x06F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPIE_ApplyVillagerCostume(class UVillagerCostumeDataAsset* CostumeDA);
	void BPIE_FadeInCharacter();
	void BPIE_FadeOutCharacter();
	void BPIE_PostCurrentActionInfoChanged(struct FVillagerActionInfo& InActionInfo);
	void BPIE_ReceivedLongDespawnInfo(float Param_WalkOutDuration);
	void Client_FadeIn(struct FVAL_PostFadeParams& InOriginalPostFadeParams);
	void Client_FadeInCompleted(struct FVAL_PostFadeParams& InPostFadeParams);
	void Client_FadeOut(struct FVAL_PostFadeParams& InPostFadeParams);
	void Client_FadeOutCompleted(struct FVAL_PostFadeParams& InPostFadeParams);
	void ForceStartDialogueWithPlayer(class AValeriaCharacter* Character, bool bSkipFade);
	class UAICombatStateComponent* GetCombatState();
	void HandlePropMontageFinish(class UAnimMontage* Montage, bool bInterrupted);
	void NotifyAbsentStateChanged();
	void NotifyVillagerConfigIdChanged();
	void OnRep_bAbsent();
	void OnRep_Costume();
	void OnRep_CurrentActionInfo();
	void OnRep_IsEngaged();
	void OnRep_VillagerConfigId();
	void RpcMulticast_NotifyLongDespawnQueued(float InWalkOutDuration);
	void Server_SetCurrentAction(const struct FVillagerActionInfo& InActionInfo);
	void SetVillagerConfigId(int32 InVillagerConfigId);
	void TryDespawnOnRepeat();

	bool BPNE_CanFidget() const;
	bool DoesVillagerConfigSupportChangeOfFocusDuringDialogue() const;
	class UDataTable* GetAnimMappings(class FName& MappingQualifier) const;
	struct FVillagerActionInfo GetCurrentActionInfo() const;
	class UDialogueComponent* GetDialogue() const;
	class UEquipmentComponent* GetEquipment() const;
	class UActorTagComponent* GetTagComponent() const;
	int32 GetVillagerConfigId() const;
	class UVillagerGiftReceiverComponent* GetVillagerGiftReceiver() const;
	class UVillagerStoreInteractableComponent* GetVillagerStore() const;
	bool IsAbsent() const;
	bool IsDialogueOnly() const;
	bool IsEngaged() const;
	bool ShouldAllowChangeOfFocusWhenEngaged() const;
	bool WantsMapIndicator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaVillagerCharacter">();
	}
	static class AValeriaVillagerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaVillagerCharacter>();
	}
};
static_assert(alignof(AValeriaVillagerCharacter) == 0x000010, "Wrong alignment on AValeriaVillagerCharacter");
static_assert(sizeof(AValeriaVillagerCharacter) == 0x000700, "Wrong size on AValeriaVillagerCharacter");
static_assert(offsetof(AValeriaVillagerCharacter, OnHiddenChanged) == 0x0004C8, "Member 'AValeriaVillagerCharacter::OnHiddenChanged' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, OnEngagedChanged) == 0x0004D8, "Member 'AValeriaVillagerCharacter::OnEngagedChanged' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, OnVillagerActionChangedDel) == 0x0004E8, "Member 'AValeriaVillagerCharacter::OnVillagerActionChangedDel' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, OnVillagerConfigIdChangedDel) == 0x0004F8, "Member 'AValeriaVillagerCharacter::OnVillagerConfigIdChangedDel' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, OnVillagerAbsentStateChanged) == 0x000508, "Member 'AValeriaVillagerCharacter::OnVillagerAbsentStateChanged' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, bFadingCharacter) == 0x000528, "Member 'AValeriaVillagerCharacter::bFadingCharacter' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, CurrentActionInfo) == 0x000540, "Member 'AValeriaVillagerCharacter::CurrentActionInfo' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, bQueuedForDespawn) == 0x0005C0, "Member 'AValeriaVillagerCharacter::bQueuedForDespawn' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, CurrentState) == 0x0005C1, "Member 'AValeriaVillagerCharacter::CurrentState' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, VillagerGuid) == 0x0005C4, "Member 'AValeriaVillagerCharacter::VillagerGuid' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, bIsEngaged) == 0x0005D4, "Member 'AValeriaVillagerCharacter::bIsEngaged' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, bAbsent) == 0x0005D5, "Member 'AValeriaVillagerCharacter::bAbsent' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, OriginalSpawnPoint) == 0x0005D8, "Member 'AValeriaVillagerCharacter::OriginalSpawnPoint' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, bAllowChangeOfFocusDuringDialogue) == 0x0005E0, "Member 'AValeriaVillagerCharacter::bAllowChangeOfFocusDuringDialogue' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, VillagerConfigId) == 0x0005E4, "Member 'AValeriaVillagerCharacter::VillagerConfigId' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, Costume) == 0x0005E8, "Member 'AValeriaVillagerCharacter::Costume' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, bCinematicsOnly) == 0x0005F0, "Member 'AValeriaVillagerCharacter::bCinematicsOnly' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, bDialogueOnly) == 0x0005F1, "Member 'AValeriaVillagerCharacter::bDialogueOnly' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, SpawnContext) == 0x0005F2, "Member 'AValeriaVillagerCharacter::SpawnContext' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, SpawnContextEvent) == 0x0005F8, "Member 'AValeriaVillagerCharacter::SpawnContextEvent' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, WalkOutDuration) == 0x000600, "Member 'AValeriaVillagerCharacter::WalkOutDuration' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, AnimMappings) == 0x000608, "Member 'AValeriaVillagerCharacter::AnimMappings' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, ExtraAnimMappings) == 0x000610, "Member 'AValeriaVillagerCharacter::ExtraAnimMappings' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, LastUsedAnimMappingName) == 0x000660, "Member 'AValeriaVillagerCharacter::LastUsedAnimMappingName' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, bLastUsedAnimWasBlendSpace) == 0x000668, "Member 'AValeriaVillagerCharacter::bLastUsedAnimWasBlendSpace' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, Persist) == 0x000670, "Member 'AValeriaVillagerCharacter::Persist' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, Dialogue) == 0x000678, "Member 'AValeriaVillagerCharacter::Dialogue' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, VillagerStore) == 0x000680, "Member 'AValeriaVillagerCharacter::VillagerStore' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, EquipmentComponent) == 0x000688, "Member 'AValeriaVillagerCharacter::EquipmentComponent' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, GiftReceiver) == 0x000690, "Member 'AValeriaVillagerCharacter::GiftReceiver' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, CombatState) == 0x000698, "Member 'AValeriaVillagerCharacter::CombatState' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, TagComponent) == 0x0006A0, "Member 'AValeriaVillagerCharacter::TagComponent' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerCharacter, CachedDialogueMontages) == 0x0006A8, "Member 'AValeriaVillagerCharacter::CachedDialogueMontages' has a wrong offset!");

// Class Palia.VAL_PlayerGuildStatics
// 0x0000 (0x0028 - 0x0028)
class UVAL_PlayerGuildStatics final : public UBlueprintFunctionLibrary
{
public:
	static void GetDateDifferenceInTimespan(struct FDateTime& StartDate, struct FDateTime& EndDate, struct FTimespan* OutTimespan);
	static TArray<struct FVAL_PlayerGuildQuest> SortPlayerGuildActivities(TArray<struct FVAL_PlayerGuildQuest>& GuildQuests, struct FVAL_PlayerGuildStatics_SortSettings& SortSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildStatics">();
	}
	static class UVAL_PlayerGuildStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildStatics>();
	}
};
static_assert(alignof(UVAL_PlayerGuildStatics) == 0x000008, "Wrong alignment on UVAL_PlayerGuildStatics");
static_assert(sizeof(UVAL_PlayerGuildStatics) == 0x000028, "Wrong size on UVAL_PlayerGuildStatics");

// Class Palia.ValeriaVillagerController
// 0x01F8 (0x05C8 - 0x03D0)
class AValeriaVillagerController : public AAIController
{
public:
	class UBlackboardData*                        BlackboardData;                                    // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnCurrentActivityChanged;                          // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVillagerActivityStatusChanged;                   // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 CachedLevelName;                                   // 0x03F8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FEngagedPlayer>                 EngagedPlayers;                                    // 0x0408(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           UpdateActivityTickTimerHandle;                     // 0x0418(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AValeriaVillagerCharacter*              CachedVillagerCharacter;                           // 0x0420(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          DefaultBehaviorTree;                               // 0x0428(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVillagerMasterScheduleConfig*          MasterScheduleConfig;                              // 0x0430(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVillagerScheduleConfig*                OverrideScheduleConfig;                            // 0x0438(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVillagerActiveActivity                ActiveActivity;                                    // 0x0440(0x0168)(Transient, NativeAccessSpecifierPrivate)
	EVillagerActivityStatus                       CurrentActivityStatus;                             // 0x05A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasMadeActivityChange;                            // 0x05A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AFA[0x6];                                     // 0x05AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PreFocusRotation;                                  // 0x05B0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void AssignDefaultBehaviorTree(class UBehaviorTree* InBehaviorTree);
	void AssignOverrideScheduleConfig(class UVillagerScheduleConfig* InOverrideScheduleConfig);
	void AssignVillagerMasterScheduleConfig(class UVillagerMasterScheduleConfig* InVillagerMasterScheduleConfig);
	bool GetBestScheduleActivity(struct FVillagerScheduleActivity* OutScheduleActivity);
	void OnUpdateActivityTimerTicked();
	void SetCurrentActivityStatus(EVillagerActivityStatus NewActivityStatus);
	bool StartNewActivity(struct FVillagerScheduleActivity& InScheduleActivity);
	bool UpdateActivity();

	bool DoesNeedToChangeActivity() const;
	const struct FVillagerActiveActivity GetActiveActivity() const;
	bool GetCurrentActionAnimationMappingConfig(struct FAnimationMappingConfig* OutAnimationMappingConfig) const;
	struct FVillagerActionInfo GetCurrentActionInfo() const;
	EVillagerActivityStatus GetCurrentActivityStatus() const;
	struct FVillagerScheduleActivity GetCurrentScheduleActivity() const;
	class AValeriaVillagerCharacter* GetVillagerCharacter() const;
	bool HasValidScheduleActivity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValeriaVillagerController">();
	}
	static class AValeriaVillagerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AValeriaVillagerController>();
	}
};
static_assert(alignof(AValeriaVillagerController) == 0x000008, "Wrong alignment on AValeriaVillagerController");
static_assert(sizeof(AValeriaVillagerController) == 0x0005C8, "Wrong size on AValeriaVillagerController");
static_assert(offsetof(AValeriaVillagerController, BlackboardData) == 0x0003D0, "Member 'AValeriaVillagerController::BlackboardData' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, OnCurrentActivityChanged) == 0x0003D8, "Member 'AValeriaVillagerController::OnCurrentActivityChanged' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, OnVillagerActivityStatusChanged) == 0x0003E8, "Member 'AValeriaVillagerController::OnVillagerActivityStatusChanged' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, CachedLevelName) == 0x0003F8, "Member 'AValeriaVillagerController::CachedLevelName' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, EngagedPlayers) == 0x000408, "Member 'AValeriaVillagerController::EngagedPlayers' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, UpdateActivityTickTimerHandle) == 0x000418, "Member 'AValeriaVillagerController::UpdateActivityTickTimerHandle' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, CachedVillagerCharacter) == 0x000420, "Member 'AValeriaVillagerController::CachedVillagerCharacter' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, DefaultBehaviorTree) == 0x000428, "Member 'AValeriaVillagerController::DefaultBehaviorTree' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, MasterScheduleConfig) == 0x000430, "Member 'AValeriaVillagerController::MasterScheduleConfig' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, OverrideScheduleConfig) == 0x000438, "Member 'AValeriaVillagerController::OverrideScheduleConfig' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, ActiveActivity) == 0x000440, "Member 'AValeriaVillagerController::ActiveActivity' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, CurrentActivityStatus) == 0x0005A8, "Member 'AValeriaVillagerController::CurrentActivityStatus' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, bHasMadeActivityChange) == 0x0005A9, "Member 'AValeriaVillagerController::bHasMadeActivityChange' has a wrong offset!");
static_assert(offsetof(AValeriaVillagerController, PreFocusRotation) == 0x0005B0, "Member 'AValeriaVillagerController::PreFocusRotation' has a wrong offset!");

// Class Palia.WeatherConfigsManager
// 0x0028 (0x0060 - 0x0038)
class UWeatherConfigsManager final : public UDeveloperSettings
{
public:
	struct FSoftObjectPath                        WeatherDataTable;                                  // 0x0038(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWeatherDisabled;                                // 0x0058(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFE[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherConfigsManager">();
	}
	static class UWeatherConfigsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherConfigsManager>();
	}
};
static_assert(alignof(UWeatherConfigsManager) == 0x000008, "Wrong alignment on UWeatherConfigsManager");
static_assert(sizeof(UWeatherConfigsManager) == 0x000060, "Wrong size on UWeatherConfigsManager");
static_assert(offsetof(UWeatherConfigsManager, WeatherDataTable) == 0x000038, "Member 'UWeatherConfigsManager::WeatherDataTable' has a wrong offset!");
static_assert(offsetof(UWeatherConfigsManager, bIsWeatherDisabled) == 0x000058, "Member 'UWeatherConfigsManager::bIsWeatherDisabled' has a wrong offset!");

// Class Palia.VAL_DeveloperSettings_PlayerGuild
// 0x0138 (0x0170 - 0x0038)
class UVAL_DeveloperSettings_PlayerGuild final : public UDeveloperSettings
{
public:
	class FText                                   CharacterKickedText;                               // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalKickedText;                                // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PlayerGuildDeletedText;                            // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterLeftText;                                 // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalLeftText;                                  // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterJoinedText;                               // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalJoinedText;                                // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterInvitedText;                              // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalInvitedText;                               // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterInvitationRescindedText;                  // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalInvitationDeclinedText;                    // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalInvitationRescindedText;                   // 0x0140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   PersonalApplicationRejectedText;                   // 0x0158(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DeveloperSettings_PlayerGuild">();
	}
	static class UVAL_DeveloperSettings_PlayerGuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DeveloperSettings_PlayerGuild>();
	}
};
static_assert(alignof(UVAL_DeveloperSettings_PlayerGuild) == 0x000008, "Wrong alignment on UVAL_DeveloperSettings_PlayerGuild");
static_assert(sizeof(UVAL_DeveloperSettings_PlayerGuild) == 0x000170, "Wrong size on UVAL_DeveloperSettings_PlayerGuild");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, CharacterKickedText) == 0x000038, "Member 'UVAL_DeveloperSettings_PlayerGuild::CharacterKickedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, PersonalKickedText) == 0x000050, "Member 'UVAL_DeveloperSettings_PlayerGuild::PersonalKickedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, PlayerGuildDeletedText) == 0x000068, "Member 'UVAL_DeveloperSettings_PlayerGuild::PlayerGuildDeletedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, CharacterLeftText) == 0x000080, "Member 'UVAL_DeveloperSettings_PlayerGuild::CharacterLeftText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, PersonalLeftText) == 0x000098, "Member 'UVAL_DeveloperSettings_PlayerGuild::PersonalLeftText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, CharacterJoinedText) == 0x0000B0, "Member 'UVAL_DeveloperSettings_PlayerGuild::CharacterJoinedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, PersonalJoinedText) == 0x0000C8, "Member 'UVAL_DeveloperSettings_PlayerGuild::PersonalJoinedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, CharacterInvitedText) == 0x0000E0, "Member 'UVAL_DeveloperSettings_PlayerGuild::CharacterInvitedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, PersonalInvitedText) == 0x0000F8, "Member 'UVAL_DeveloperSettings_PlayerGuild::PersonalInvitedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, CharacterInvitationRescindedText) == 0x000110, "Member 'UVAL_DeveloperSettings_PlayerGuild::CharacterInvitationRescindedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, PersonalInvitationDeclinedText) == 0x000128, "Member 'UVAL_DeveloperSettings_PlayerGuild::PersonalInvitationDeclinedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, PersonalInvitationRescindedText) == 0x000140, "Member 'UVAL_DeveloperSettings_PlayerGuild::PersonalInvitationRescindedText' has a wrong offset!");
static_assert(offsetof(UVAL_DeveloperSettings_PlayerGuild, PersonalApplicationRejectedText) == 0x000158, "Member 'UVAL_DeveloperSettings_PlayerGuild::PersonalApplicationRejectedText' has a wrong offset!");

// Class Palia.VAL_ActivitySubsystem
// 0x0030 (0x0060 - 0x0030)
class UVAL_ActivitySubsystem final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnActivityGameIntentReceivedIngame;                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActivityGameIntentReceivedPregame;               // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bReceivedGameIntent;                               // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AFF[0xF];                                     // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ActivitySubsystem">();
	}
	static class UVAL_ActivitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ActivitySubsystem>();
	}
};
static_assert(alignof(UVAL_ActivitySubsystem) == 0x000008, "Wrong alignment on UVAL_ActivitySubsystem");
static_assert(sizeof(UVAL_ActivitySubsystem) == 0x000060, "Wrong size on UVAL_ActivitySubsystem");
static_assert(offsetof(UVAL_ActivitySubsystem, OnActivityGameIntentReceivedIngame) == 0x000030, "Member 'UVAL_ActivitySubsystem::OnActivityGameIntentReceivedIngame' has a wrong offset!");
static_assert(offsetof(UVAL_ActivitySubsystem, OnActivityGameIntentReceivedPregame) == 0x000040, "Member 'UVAL_ActivitySubsystem::OnActivityGameIntentReceivedPregame' has a wrong offset!");
static_assert(offsetof(UVAL_ActivitySubsystem, bReceivedGameIntent) == 0x000050, "Member 'UVAL_ActivitySubsystem::bReceivedGameIntent' has a wrong offset!");

// Class Palia.VAL_AssetManager
// 0x0190 (0x0660 - 0x04D0)
class UVAL_AssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_2B00[0x190];                                   // 0x04D0(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AssetManager">();
	}
	static class UVAL_AssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AssetManager>();
	}
};
static_assert(alignof(UVAL_AssetManager) == 0x000008, "Wrong alignment on UVAL_AssetManager");
static_assert(sizeof(UVAL_AssetManager) == 0x000660, "Wrong size on UVAL_AssetManager");

// Class Palia.VAL_EnvironmentProfile
// 0x08D0 (0x0900 - 0x0030)
class UVAL_EnvironmentProfile final : public UDataAsset
{
public:
	class UVAL_EnvironmentProfile*                StartingProfile;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVAL_DirectionalLighting               DirectionalLightingSettings;                       // 0x0038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVAL_Skylight                          SkylightSettings;                                  // 0x0070(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVAL_FogProfile                        FogSettings;                                       // 0x00A4(0x004C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x00F0(0x06E0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVAL_MPCProfile                        MPCSettings;                                       // 0x07D0(0x0120)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FString>                         EnvProfBlends;                                     // 0x08F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EnvironmentProfile">();
	}
	static class UVAL_EnvironmentProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_EnvironmentProfile>();
	}
};
static_assert(alignof(UVAL_EnvironmentProfile) == 0x000010, "Wrong alignment on UVAL_EnvironmentProfile");
static_assert(sizeof(UVAL_EnvironmentProfile) == 0x000900, "Wrong size on UVAL_EnvironmentProfile");
static_assert(offsetof(UVAL_EnvironmentProfile, StartingProfile) == 0x000030, "Member 'UVAL_EnvironmentProfile::StartingProfile' has a wrong offset!");
static_assert(offsetof(UVAL_EnvironmentProfile, DirectionalLightingSettings) == 0x000038, "Member 'UVAL_EnvironmentProfile::DirectionalLightingSettings' has a wrong offset!");
static_assert(offsetof(UVAL_EnvironmentProfile, SkylightSettings) == 0x000070, "Member 'UVAL_EnvironmentProfile::SkylightSettings' has a wrong offset!");
static_assert(offsetof(UVAL_EnvironmentProfile, FogSettings) == 0x0000A4, "Member 'UVAL_EnvironmentProfile::FogSettings' has a wrong offset!");
static_assert(offsetof(UVAL_EnvironmentProfile, PostProcessSettings) == 0x0000F0, "Member 'UVAL_EnvironmentProfile::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(UVAL_EnvironmentProfile, MPCSettings) == 0x0007D0, "Member 'UVAL_EnvironmentProfile::MPCSettings' has a wrong offset!");
static_assert(offsetof(UVAL_EnvironmentProfile, EnvProfBlends) == 0x0008F0, "Member 'UVAL_EnvironmentProfile::EnvProfBlends' has a wrong offset!");

// Class Palia.VAL_AsyncAction_LoadCharacterCustomizationItems
// 0x0070 (0x00A0 - 0x0030)
class UVAL_AsyncAction_LoadCharacterCustomizationItems final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B01[0x60];                                    // 0x0040(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_AsyncAction_LoadCharacterCustomizationItems* LoadCharacterCustomizationItems(TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>>& Items);

	void OnLoadCharacterCustomizationItems__DelegateSignature(const TSet<class UVAL_CharacterCustomizationItemBase*>& LoadedItems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AsyncAction_LoadCharacterCustomizationItems">();
	}
	static class UVAL_AsyncAction_LoadCharacterCustomizationItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AsyncAction_LoadCharacterCustomizationItems>();
	}
};
static_assert(alignof(UVAL_AsyncAction_LoadCharacterCustomizationItems) == 0x000008, "Wrong alignment on UVAL_AsyncAction_LoadCharacterCustomizationItems");
static_assert(sizeof(UVAL_AsyncAction_LoadCharacterCustomizationItems) == 0x0000A0, "Wrong size on UVAL_AsyncAction_LoadCharacterCustomizationItems");
static_assert(offsetof(UVAL_AsyncAction_LoadCharacterCustomizationItems, Completed) == 0x000030, "Member 'UVAL_AsyncAction_LoadCharacterCustomizationItems::Completed' has a wrong offset!");

// Class Palia.VAL_AsyncActionRequestEntitlements
// 0x0028 (0x0058 - 0x0030)
class UVAL_AsyncActionRequestEntitlements final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Success;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Failure;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B02[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_AsyncActionRequestEntitlements* RequestEntitlements(class ULocalPlayer* LP);

	void OnRequestEntitlementFailure__DelegateSignature();
	void OnRequestEntitlementSuccess__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AsyncActionRequestEntitlements">();
	}
	static class UVAL_AsyncActionRequestEntitlements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AsyncActionRequestEntitlements>();
	}
};
static_assert(alignof(UVAL_AsyncActionRequestEntitlements) == 0x000008, "Wrong alignment on UVAL_AsyncActionRequestEntitlements");
static_assert(sizeof(UVAL_AsyncActionRequestEntitlements) == 0x000058, "Wrong size on UVAL_AsyncActionRequestEntitlements");
static_assert(offsetof(UVAL_AsyncActionRequestEntitlements, Success) == 0x000030, "Member 'UVAL_AsyncActionRequestEntitlements::Success' has a wrong offset!");
static_assert(offsetof(UVAL_AsyncActionRequestEntitlements, Failure) == 0x000040, "Member 'UVAL_AsyncActionRequestEntitlements::Failure' has a wrong offset!");

// Class Palia.VAL_AsyncAction_ExperienceMapLoaded
// 0x0038 (0x0068 - 0x0030)
class UVAL_AsyncAction_ExperienceMapLoaded final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnExperienceLoaded;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B03[0x18];                                    // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_AsyncAction_ExperienceMapLoaded* WaitForExperienceToLoad(const class FString& ExperienceName);

	void OnExperienceLoaded__DelegateSignature();
	void OnFailed__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AsyncAction_ExperienceMapLoaded">();
	}
	static class UVAL_AsyncAction_ExperienceMapLoaded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AsyncAction_ExperienceMapLoaded>();
	}
};
static_assert(alignof(UVAL_AsyncAction_ExperienceMapLoaded) == 0x000008, "Wrong alignment on UVAL_AsyncAction_ExperienceMapLoaded");
static_assert(sizeof(UVAL_AsyncAction_ExperienceMapLoaded) == 0x000068, "Wrong size on UVAL_AsyncAction_ExperienceMapLoaded");
static_assert(offsetof(UVAL_AsyncAction_ExperienceMapLoaded, OnExperienceLoaded) == 0x000030, "Member 'UVAL_AsyncAction_ExperienceMapLoaded::OnExperienceLoaded' has a wrong offset!");
static_assert(offsetof(UVAL_AsyncAction_ExperienceMapLoaded, OnFailed) == 0x000040, "Member 'UVAL_AsyncAction_ExperienceMapLoaded::OnFailed' has a wrong offset!");

// Class Palia.VAL_BpAsyncAction_Login
// 0x0060 (0x0090 - 0x0030)
class UVAL_BpAsyncAction_Login final : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_2B04[0x38];                                    // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UVAL_BpAsyncAction_Login* Login(class UObject* InWorldContextObject, int32 InLocalUserNum, const class FString& InUsername, const class FString& InPassword);

	void OnLoginCompleted__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_BpAsyncAction_Login">();
	}
	static class UVAL_BpAsyncAction_Login* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_BpAsyncAction_Login>();
	}
};
static_assert(alignof(UVAL_BpAsyncAction_Login) == 0x000008, "Wrong alignment on UVAL_BpAsyncAction_Login");
static_assert(sizeof(UVAL_BpAsyncAction_Login) == 0x000090, "Wrong size on UVAL_BpAsyncAction_Login");
static_assert(offsetof(UVAL_BpAsyncAction_Login, WorldContextObject) == 0x000068, "Member 'UVAL_BpAsyncAction_Login::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UVAL_BpAsyncAction_Login, OnSuccess) == 0x000070, "Member 'UVAL_BpAsyncAction_Login::OnSuccess' has a wrong offset!");
static_assert(offsetof(UVAL_BpAsyncAction_Login, OnFailed) == 0x000080, "Member 'UVAL_BpAsyncAction_Login::OnFailed' has a wrong offset!");

// Class Palia.VAL_BpAsyncAction_PlayLevelSequenceWithLoop
// 0x0090 (0x00C0 - 0x0030)
class UVAL_BpAsyncAction_PlayLevelSequenceWithLoop final : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_2B06[0x60];                                    // 0x0030(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlay;                                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnLoop;                                            // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnStop;                                            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UVAL_BpAsyncAction_PlayLevelSequenceWithLoop* PlayLevelSequenceWithLoop(class ALevelSequenceActor* LevelSequenceActor, struct FMovieSceneSequencePlaybackParams& LoopStartParam, struct FMovieSceneSequencePlaybackParams& LoopEndParam, float PlayRate);

	void HandleFinish();
	void HandlePause();
	void HandlePlay();
	void HandleStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_BpAsyncAction_PlayLevelSequenceWithLoop">();
	}
	static class UVAL_BpAsyncAction_PlayLevelSequenceWithLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_BpAsyncAction_PlayLevelSequenceWithLoop>();
	}
};
static_assert(alignof(UVAL_BpAsyncAction_PlayLevelSequenceWithLoop) == 0x000008, "Wrong alignment on UVAL_BpAsyncAction_PlayLevelSequenceWithLoop");
static_assert(sizeof(UVAL_BpAsyncAction_PlayLevelSequenceWithLoop) == 0x0000C0, "Wrong size on UVAL_BpAsyncAction_PlayLevelSequenceWithLoop");
static_assert(offsetof(UVAL_BpAsyncAction_PlayLevelSequenceWithLoop, OnPlay) == 0x000090, "Member 'UVAL_BpAsyncAction_PlayLevelSequenceWithLoop::OnPlay' has a wrong offset!");
static_assert(offsetof(UVAL_BpAsyncAction_PlayLevelSequenceWithLoop, OnLoop) == 0x0000A0, "Member 'UVAL_BpAsyncAction_PlayLevelSequenceWithLoop::OnLoop' has a wrong offset!");
static_assert(offsetof(UVAL_BpAsyncAction_PlayLevelSequenceWithLoop, OnStop) == 0x0000B0, "Member 'UVAL_BpAsyncAction_PlayLevelSequenceWithLoop::OnStop' has a wrong offset!");

// Class Palia.VAL_GameDataTableConfiguration
// 0x0010 (0x0048 - 0x0038)
class UVAL_GameDataTableConfiguration final : public UDeveloperSettings
{
public:
	TArray<TSoftObjectPtr<class UDataTable>>      TablesToExport;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameDataTableConfiguration">();
	}
	static class UVAL_GameDataTableConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameDataTableConfiguration>();
	}
};
static_assert(alignof(UVAL_GameDataTableConfiguration) == 0x000008, "Wrong alignment on UVAL_GameDataTableConfiguration");
static_assert(sizeof(UVAL_GameDataTableConfiguration) == 0x000048, "Wrong size on UVAL_GameDataTableConfiguration");
static_assert(offsetof(UVAL_GameDataTableConfiguration, TablesToExport) == 0x000038, "Member 'UVAL_GameDataTableConfiguration::TablesToExport' has a wrong offset!");

// Class Palia.VAL_ChallengeProgressComponent
// 0x00E0 (0x0180 - 0x00A0)
class UVAL_ChallengeProgressComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2B08[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      OwningCharacter;                                   // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChallengeState                        ChallengeState;                                    // 0x00B0(0x0068)(Net, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChallengeCompleted;                              // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FChallengeProgressPersistBlock         ChallengeProgressPersistBlock;                     // 0x0128(0x0058)(Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_ChallengeState();
	void RpcClient_ChallengeCompleted(const struct FGuid& Guid);
	void WasChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChallengeProgressComponent">();
	}
	static class UVAL_ChallengeProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChallengeProgressComponent>();
	}
};
static_assert(alignof(UVAL_ChallengeProgressComponent) == 0x000008, "Wrong alignment on UVAL_ChallengeProgressComponent");
static_assert(sizeof(UVAL_ChallengeProgressComponent) == 0x000180, "Wrong size on UVAL_ChallengeProgressComponent");
static_assert(offsetof(UVAL_ChallengeProgressComponent, OwningCharacter) == 0x0000A8, "Member 'UVAL_ChallengeProgressComponent::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_ChallengeProgressComponent, ChallengeState) == 0x0000B0, "Member 'UVAL_ChallengeProgressComponent::ChallengeState' has a wrong offset!");
static_assert(offsetof(UVAL_ChallengeProgressComponent, OnChallengeCompleted) == 0x000118, "Member 'UVAL_ChallengeProgressComponent::OnChallengeCompleted' has a wrong offset!");
static_assert(offsetof(UVAL_ChallengeProgressComponent, ChallengeProgressPersistBlock) == 0x000128, "Member 'UVAL_ChallengeProgressComponent::ChallengeProgressPersistBlock' has a wrong offset!");

// Class Palia.VAL_GliderBase
// 0x0018 (0x02C0 - 0x02A8)
class AVAL_GliderBase : public AEquipViewActor
{
public:
	bool                                          bShouldShowParticles;                              // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B09[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponentBudgeted*         SkeletalMeshComp;                                  // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      TrailParticles;                                    // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DestroySpawnedParticles();
	void SpawnParticles(TArray<class FName>& SocketNames, class UNiagaraSystem* ParticleSystem);

	class USkeletalMeshComponentBudgeted* GetSkeletalMeshComp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GliderBase">();
	}
	static class AVAL_GliderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_GliderBase>();
	}
};
static_assert(alignof(AVAL_GliderBase) == 0x000008, "Wrong alignment on AVAL_GliderBase");
static_assert(sizeof(AVAL_GliderBase) == 0x0002C0, "Wrong size on AVAL_GliderBase");
static_assert(offsetof(AVAL_GliderBase, bShouldShowParticles) == 0x0002A8, "Member 'AVAL_GliderBase::bShouldShowParticles' has a wrong offset!");
static_assert(offsetof(AVAL_GliderBase, SkeletalMeshComp) == 0x0002B0, "Member 'AVAL_GliderBase::SkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(AVAL_GliderBase, TrailParticles) == 0x0002B8, "Member 'AVAL_GliderBase::TrailParticles' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItem_AnimSet
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_AnimSet final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_AnimSet(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_AnimSet_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_AnimSet">();
	}
	static class UVAL_CharacterCustomizationItem_AnimSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_AnimSet>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_AnimSet) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_AnimSet");
static_assert(sizeof(UVAL_CharacterCustomizationItem_AnimSet) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_AnimSet");

// Class Palia.VAL_CharacterCustomizationItem_FaceMask
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_FaceMask final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_FaceMask(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_FaceMask_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_FaceMask">();
	}
	static class UVAL_CharacterCustomizationItem_FaceMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_FaceMask>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_FaceMask) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_FaceMask");
static_assert(sizeof(UVAL_CharacterCustomizationItem_FaceMask) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_FaceMask");

// Class Palia.VAL_ServerMaintenanceCancelledAsyncStream
// 0x0010 (0x0058 - 0x0048)
class UVAL_ServerMaintenanceCancelledAsyncStream final : public UVAL_MQTTAsyncStreamBase
{
public:
	uint8                                         Pad_2B0E[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ServerMaintenanceCancelledAsyncStream">();
	}
	static class UVAL_ServerMaintenanceCancelledAsyncStream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ServerMaintenanceCancelledAsyncStream>();
	}
};
static_assert(alignof(UVAL_ServerMaintenanceCancelledAsyncStream) == 0x000008, "Wrong alignment on UVAL_ServerMaintenanceCancelledAsyncStream");
static_assert(sizeof(UVAL_ServerMaintenanceCancelledAsyncStream) == 0x000058, "Wrong size on UVAL_ServerMaintenanceCancelledAsyncStream");

// Class Palia.VAL_CharacterCustomizationItem_FacialHairStyle
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_FacialHairStyle final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_FacialHairStyle(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_FacialHairStyle_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_FacialHairStyle">();
	}
	static class UVAL_CharacterCustomizationItem_FacialHairStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_FacialHairStyle>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_FacialHairStyle) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_FacialHairStyle");
static_assert(sizeof(UVAL_CharacterCustomizationItem_FacialHairStyle) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_FacialHairStyle");

// Class Palia.VAL_CharacterCustomizationItem_GliderTrail
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_GliderTrail final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_GliderTrail(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_GliderTrail_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_GliderTrail">();
	}
	static class UVAL_CharacterCustomizationItem_GliderTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_GliderTrail>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_GliderTrail) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_GliderTrail");
static_assert(sizeof(UVAL_CharacterCustomizationItem_GliderTrail) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_GliderTrail");

// Class Palia.VAL_SortObjectArray_BPFuncLib
// 0x0000 (0x0028 - 0x0028)
class UVAL_SortObjectArray_BPFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UObject*> SortObjectArray(TArray<class UObject*>& ArrayToSort, TDelegate<void(class UObject* A, class UObject* B)>& Predicate);

	bool ComparatorPredicate__DelegateSignature(class UObject* A, class UObject* B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_SortObjectArray_BPFuncLib">();
	}
	static class UVAL_SortObjectArray_BPFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_SortObjectArray_BPFuncLib>();
	}
};
static_assert(alignof(UVAL_SortObjectArray_BPFuncLib) == 0x000008, "Wrong alignment on UVAL_SortObjectArray_BPFuncLib");
static_assert(sizeof(UVAL_SortObjectArray_BPFuncLib) == 0x000028, "Wrong size on UVAL_SortObjectArray_BPFuncLib");

// Class Palia.VAL_CharacterCustomization_HatTypePreset
// 0x0030 (0x0068 - 0x0038)
class UVAL_CharacterCustomization_HatTypePreset final : public UVAL_CharacterCustomization_PerSlotPreset_Base
{
public:
	class FName                                   AttachmentSocketName;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HatAttachSocketName;                               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HairSquishMorphTargets;                            // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomization_HatTypePreset">();
	}
	static class UVAL_CharacterCustomization_HatTypePreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomization_HatTypePreset>();
	}
};
static_assert(alignof(UVAL_CharacterCustomization_HatTypePreset) == 0x000008, "Wrong alignment on UVAL_CharacterCustomization_HatTypePreset");
static_assert(sizeof(UVAL_CharacterCustomization_HatTypePreset) == 0x000068, "Wrong size on UVAL_CharacterCustomization_HatTypePreset");
static_assert(offsetof(UVAL_CharacterCustomization_HatTypePreset, AttachmentSocketName) == 0x000038, "Member 'UVAL_CharacterCustomization_HatTypePreset::AttachmentSocketName' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomization_HatTypePreset, HatAttachSocketName) == 0x000040, "Member 'UVAL_CharacterCustomization_HatTypePreset::HatAttachSocketName' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomization_HatTypePreset, HairSquishMorphTargets) == 0x000048, "Member 'UVAL_CharacterCustomization_HatTypePreset::HairSquishMorphTargets' has a wrong offset!");

// Class Palia.VAL_CharacterCustomization_HeadTypePreset
// 0x0000 (0x0038 - 0x0038)
class UVAL_CharacterCustomization_HeadTypePreset final : public UVAL_CharacterCustomization_PerSlotPreset_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomization_HeadTypePreset">();
	}
	static class UVAL_CharacterCustomization_HeadTypePreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomization_HeadTypePreset>();
	}
};
static_assert(alignof(UVAL_CharacterCustomization_HeadTypePreset) == 0x000008, "Wrong alignment on UVAL_CharacterCustomization_HeadTypePreset");
static_assert(sizeof(UVAL_CharacterCustomization_HeadTypePreset) == 0x000038, "Wrong size on UVAL_CharacterCustomization_HeadTypePreset");

// Class Palia.VAL_SprayStatics
// 0x0000 (0x0028 - 0x0028)
class UVAL_SprayStatics final : public UBlueprintFunctionLibrary
{
public:
	static void TrySpawnSpray(class AActor* ActorSource, TSoftObjectPtr<class UVAL_SprayDataAsset>& SprayDataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_SprayStatics">();
	}
	static class UVAL_SprayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_SprayStatics>();
	}
};
static_assert(alignof(UVAL_SprayStatics) == 0x000008, "Wrong alignment on UVAL_SprayStatics");
static_assert(sizeof(UVAL_SprayStatics) == 0x000028, "Wrong size on UVAL_SprayStatics");

// Class Palia.VAL_CharacterCustomizationItem_Legs
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_Legs final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_Legs(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_Legs_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_Legs">();
	}
	static class UVAL_CharacterCustomizationItem_Legs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_Legs>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_Legs) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_Legs");
static_assert(sizeof(UVAL_CharacterCustomizationItem_Legs) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_Legs");

// Class Palia.VAL_CharacterCustomizationItem_Pet
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_Pet final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_Pet(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_Pet_PerBodyTypeConfig* OutBodyTypeSpecificConfig);
	TSoftObjectPtr<class UTexture2D> TryGetPetUIDisplayIcon(EVAL_CharacterBodyType& BodyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_Pet">();
	}
	static class UVAL_CharacterCustomizationItem_Pet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_Pet>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_Pet) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_Pet");
static_assert(sizeof(UVAL_CharacterCustomizationItem_Pet) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_Pet");

// Class Palia.VAL_CharacterCustomizationItem_FaceComplexion
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_FaceComplexion final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_FaceComplexion(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_FaceComplexion_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_FaceComplexion">();
	}
	static class UVAL_CharacterCustomizationItem_FaceComplexion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_FaceComplexion>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_FaceComplexion) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_FaceComplexion");
static_assert(sizeof(UVAL_CharacterCustomizationItem_FaceComplexion) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_FaceComplexion");

// Class Palia.VAL_TimerManager
// 0x0080 (0x00B0 - 0x0030)
class UVAL_TimerManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2B1B[0x80];                                    // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearTimer(struct FVAL_TimerHandle* InHandle);
	void Server_OnGameStateChanged(class AGameStateBase* GameStateBase);
	void Server_OnTimeChanged();
	void SetTimer(struct FVAL_TimerHandle* InOutHandle, struct FTimerParams& TimerParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TimerManager">();
	}
	static class UVAL_TimerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TimerManager>();
	}
};
static_assert(alignof(UVAL_TimerManager) == 0x000008, "Wrong alignment on UVAL_TimerManager");
static_assert(sizeof(UVAL_TimerManager) == 0x0000B0, "Wrong size on UVAL_TimerManager");

// Class Palia.VAL_CharacterCustomizationItem_BodyComplexion
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_BodyComplexion final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_BodyComplexion(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_BodyComplexion_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_BodyComplexion">();
	}
	static class UVAL_CharacterCustomizationItem_BodyComplexion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_BodyComplexion>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_BodyComplexion) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_BodyComplexion");
static_assert(sizeof(UVAL_CharacterCustomizationItem_BodyComplexion) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_BodyComplexion");

// Class Palia.VAL_CharacterCustomizationItem_SkinTone
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_SkinTone final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_SkinTone(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_SkinTone_PerBodyTypeConfig* OutBodyTypeSpecificConfig);
	bool TrySetBodyTypeSpecificConfig_SkinTone(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_SkinTone_PerBodyTypeConfig& InBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_SkinTone">();
	}
	static class UVAL_CharacterCustomizationItem_SkinTone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_SkinTone>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_SkinTone) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_SkinTone");
static_assert(sizeof(UVAL_CharacterCustomizationItem_SkinTone) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_SkinTone");

// Class Palia.VAL_CharacterCustomizationItem_FaceTattoo
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_FaceTattoo final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_FaceTattoo(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_FaceTattoo_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_FaceTattoo">();
	}
	static class UVAL_CharacterCustomizationItem_FaceTattoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_FaceTattoo>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_FaceTattoo) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_FaceTattoo");
static_assert(sizeof(UVAL_CharacterCustomizationItem_FaceTattoo) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_FaceTattoo");

// Class Palia.VAL_CharacterCustomizationItem_BodyTattoo
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_BodyTattoo final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_BodyTattoo(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_BodyTattoo_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_BodyTattoo">();
	}
	static class UVAL_CharacterCustomizationItem_BodyTattoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_BodyTattoo>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_BodyTattoo) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_BodyTattoo");
static_assert(sizeof(UVAL_CharacterCustomizationItem_BodyTattoo) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_BodyTattoo");

// Class Palia.VAL_CharacterCustomization_TorsoTypePreset
// 0x0020 (0x0058 - 0x0038)
class UVAL_CharacterCustomization_TorsoTypePreset final : public UVAL_CharacterCustomization_PerSlotPreset_Base
{
public:
	struct FGameplayTagContainer                  HairMorphTargets;                                  // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomization_TorsoTypePreset">();
	}
	static class UVAL_CharacterCustomization_TorsoTypePreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomization_TorsoTypePreset>();
	}
};
static_assert(alignof(UVAL_CharacterCustomization_TorsoTypePreset) == 0x000008, "Wrong alignment on UVAL_CharacterCustomization_TorsoTypePreset");
static_assert(sizeof(UVAL_CharacterCustomization_TorsoTypePreset) == 0x000058, "Wrong size on UVAL_CharacterCustomization_TorsoTypePreset");
static_assert(offsetof(UVAL_CharacterCustomization_TorsoTypePreset, HairMorphTargets) == 0x000038, "Member 'UVAL_CharacterCustomization_TorsoTypePreset::HairMorphTargets' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItem_Torso
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_Torso final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_Torso(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_Torso_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_Torso">();
	}
	static class UVAL_CharacterCustomizationItem_Torso* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_Torso>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_Torso) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_Torso");
static_assert(sizeof(UVAL_CharacterCustomizationItem_Torso) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_Torso");

// Class Palia.VAL_CharacterCustomizationItem_Voice
// 0x0000 (0x0168 - 0x0168)
class UVAL_CharacterCustomizationItem_Voice final : public UVAL_CharacterCustomizationItemBase
{
public:
	bool TryGetBodyTypeSpecificConfig_Voice(EVAL_CharacterBodyType BodyType, struct FVAL_CharacterCustomizationItem_Voice_PerBodyTypeConfig* OutBodyTypeSpecificConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_Voice">();
	}
	static class UVAL_CharacterCustomizationItem_Voice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_Voice>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_Voice) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_Voice");
static_assert(sizeof(UVAL_CharacterCustomizationItem_Voice) == 0x000168, "Wrong size on UVAL_CharacterCustomizationItem_Voice");

// Class Palia.VAL_CharacterCreationCollectionDataAsset
// 0x00A0 (0x00D0 - 0x0030)
class UVAL_CharacterCreationCollectionDataAsset final : public UDataAsset
{
public:
	TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>> Assets;                                            // 0x0030(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EVAL_CharacterBodyType, TSoftObjectPtr<class USkeletalMesh>> BodyTypeToSkeletonMap;                             // 0x0080(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCreationCollectionDataAsset">();
	}
	static class UVAL_CharacterCreationCollectionDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCreationCollectionDataAsset>();
	}
};
static_assert(alignof(UVAL_CharacterCreationCollectionDataAsset) == 0x000008, "Wrong alignment on UVAL_CharacterCreationCollectionDataAsset");
static_assert(sizeof(UVAL_CharacterCreationCollectionDataAsset) == 0x0000D0, "Wrong size on UVAL_CharacterCreationCollectionDataAsset");
static_assert(offsetof(UVAL_CharacterCreationCollectionDataAsset, Assets) == 0x000030, "Member 'UVAL_CharacterCreationCollectionDataAsset::Assets' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCreationCollectionDataAsset, BodyTypeToSkeletonMap) == 0x000080, "Member 'UVAL_CharacterCreationCollectionDataAsset::BodyTypeToSkeletonMap' has a wrong offset!");

// Class Palia.VAL_CharacterCustomization_ColorsDataAsset
// 0x0060 (0x0090 - 0x0030)
class UVAL_CharacterCustomization_ColorsDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FVAL_CharacterCustomization_ColorList> Palettes;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FVAL_CharacterCustomization_Color> HairColors;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomization_ColorsDataAsset">();
	}
	static class UVAL_CharacterCustomization_ColorsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomization_ColorsDataAsset>();
	}
};
static_assert(alignof(UVAL_CharacterCustomization_ColorsDataAsset) == 0x000008, "Wrong alignment on UVAL_CharacterCustomization_ColorsDataAsset");
static_assert(sizeof(UVAL_CharacterCustomization_ColorsDataAsset) == 0x000090, "Wrong size on UVAL_CharacterCustomization_ColorsDataAsset");
static_assert(offsetof(UVAL_CharacterCustomization_ColorsDataAsset, Palettes) == 0x000030, "Member 'UVAL_CharacterCustomization_ColorsDataAsset::Palettes' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomization_ColorsDataAsset, HairColors) == 0x000080, "Member 'UVAL_CharacterCustomization_ColorsDataAsset::HairColors' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationItem_TooltipData
// 0x0018 (0x0048 - 0x0030)
class UVAL_CharacterCustomizationItem_TooltipData final : public UDataAsset
{
public:
	class FText                                   ToolTipText;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationItem_TooltipData">();
	}
	static class UVAL_CharacterCustomizationItem_TooltipData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationItem_TooltipData>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationItem_TooltipData) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationItem_TooltipData");
static_assert(sizeof(UVAL_CharacterCustomizationItem_TooltipData) == 0x000048, "Wrong size on UVAL_CharacterCustomizationItem_TooltipData");
static_assert(offsetof(UVAL_CharacterCustomizationItem_TooltipData, ToolTipText) == 0x000030, "Member 'UVAL_CharacterCustomizationItem_TooltipData::ToolTipText' has a wrong offset!");

// Class Palia.VAL_CharacterCreationSettings
// 0x00A0 (0x00D8 - 0x0038)
class UVAL_CharacterCreationSettings final : public UDeveloperSettings
{
public:
	class FText                                   CharacterRegisterDefaultErrorText;                 // 0x0038(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterRegisterNameValidation_NameTakenErrorText; // 0x0050(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterRegisterNameValidation_ProfanityErrorText; // 0x0068(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterRegisterNameValidation_S6ErrorText;       // 0x0080(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterRegisterInFlightText;                     // 0x0098(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterProfanityFilterFailedText;                // 0x00B0(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UVAL_CharacterCustomizationLoadoutPreset>> DefaultCharacterCreationPresets;                   // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCreationSettings">();
	}
	static class UVAL_CharacterCreationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCreationSettings>();
	}
};
static_assert(alignof(UVAL_CharacterCreationSettings) == 0x000008, "Wrong alignment on UVAL_CharacterCreationSettings");
static_assert(sizeof(UVAL_CharacterCreationSettings) == 0x0000D8, "Wrong size on UVAL_CharacterCreationSettings");
static_assert(offsetof(UVAL_CharacterCreationSettings, CharacterRegisterDefaultErrorText) == 0x000038, "Member 'UVAL_CharacterCreationSettings::CharacterRegisterDefaultErrorText' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCreationSettings, CharacterRegisterNameValidation_NameTakenErrorText) == 0x000050, "Member 'UVAL_CharacterCreationSettings::CharacterRegisterNameValidation_NameTakenErrorText' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCreationSettings, CharacterRegisterNameValidation_ProfanityErrorText) == 0x000068, "Member 'UVAL_CharacterCreationSettings::CharacterRegisterNameValidation_ProfanityErrorText' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCreationSettings, CharacterRegisterNameValidation_S6ErrorText) == 0x000080, "Member 'UVAL_CharacterCreationSettings::CharacterRegisterNameValidation_S6ErrorText' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCreationSettings, CharacterRegisterInFlightText) == 0x000098, "Member 'UVAL_CharacterCreationSettings::CharacterRegisterInFlightText' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCreationSettings, CharacterProfanityFilterFailedText) == 0x0000B0, "Member 'UVAL_CharacterCreationSettings::CharacterProfanityFilterFailedText' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCreationSettings, DefaultCharacterCreationPresets) == 0x0000C8, "Member 'UVAL_CharacterCreationSettings::DefaultCharacterCreationPresets' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationSettings
// 0x03D8 (0x0410 - 0x0038)
class UVAL_CharacterCustomizationSettings final : public UDeveloperSettings
{
public:
	TMap<class FName, struct FVAL_CharacterCustomization_LoadoutSlotSettings> LoadoutSlotSettingsTable;                          // 0x0038(0x0050)(Edit, BlueprintVisible, EditFixedSize, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVAL_CharacterCreationCollectionDataAsset> CharacterCreationCollectionDataAsset;              // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EVAL_CharacterBodyType, TSoftObjectPtr<class UVAL_CharacterCustomizationLoadoutPreset>> DefaultLoadoutPresets;                             // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVAL_CharacterCustomization_ColorsDataAsset> ColorsDataAsset;                                   // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVAL_VariantChannelSettings> VariantChannelSettingsTable;                       // 0x0128(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         DefaultCustomizationAnimation;                     // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<EVAL_CharacterCustomization_CosmeticTagType> AllowedFilterPanelTags;                            // 0x01A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              DefaultCosmeticTagsDataTable;                      // 0x01F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EVAL_CharacterCustomizationHideSlotFlags, struct FVAL_CharacterCustomization_SkeletalMeshComponentConfig> HideSlotToSkeletalMeshConfig;                      // 0x0218(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ExtraTooltipDataTable;                             // 0x0268(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SprayActorClass;                                   // 0x0290(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprayDistance;                                     // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2A[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveLinearColorAtlas>  CosmeticColorCurveAtlas;                           // 0x02C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVAL_VariantOptions_ColorCurveNameBackups DynamicVariantUINameBackups;                       // 0x02E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TSet<class FName>                             MandatoryItemSlotNames;                            // 0x0308(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     GliderTrailThumbnailActorClass;                    // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVAL_CharacterCustomizationItemEnableConfigWithId> EnabledOutfitsConfig;                              // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSet<class FName>                             FootprintEffectsLoadoutSlotPriorityOrder;          // 0x0370(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FVAL_CharacterCustomizationItemEnableConfig> EnabledOutfitsCache;                               // 0x03C0(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationSettings">();
	}
	static class UVAL_CharacterCustomizationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationSettings>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationSettings) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationSettings");
static_assert(sizeof(UVAL_CharacterCustomizationSettings) == 0x000410, "Wrong size on UVAL_CharacterCustomizationSettings");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, LoadoutSlotSettingsTable) == 0x000038, "Member 'UVAL_CharacterCustomizationSettings::LoadoutSlotSettingsTable' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, CharacterCreationCollectionDataAsset) == 0x000088, "Member 'UVAL_CharacterCustomizationSettings::CharacterCreationCollectionDataAsset' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, DefaultLoadoutPresets) == 0x0000B0, "Member 'UVAL_CharacterCustomizationSettings::DefaultLoadoutPresets' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, ColorsDataAsset) == 0x000100, "Member 'UVAL_CharacterCustomizationSettings::ColorsDataAsset' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, VariantChannelSettingsTable) == 0x000128, "Member 'UVAL_CharacterCustomizationSettings::VariantChannelSettingsTable' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, DefaultCustomizationAnimation) == 0x000178, "Member 'UVAL_CharacterCustomizationSettings::DefaultCustomizationAnimation' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, AllowedFilterPanelTags) == 0x0001A0, "Member 'UVAL_CharacterCustomizationSettings::AllowedFilterPanelTags' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, DefaultCosmeticTagsDataTable) == 0x0001F0, "Member 'UVAL_CharacterCustomizationSettings::DefaultCosmeticTagsDataTable' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, HideSlotToSkeletalMeshConfig) == 0x000218, "Member 'UVAL_CharacterCustomizationSettings::HideSlotToSkeletalMeshConfig' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, ExtraTooltipDataTable) == 0x000268, "Member 'UVAL_CharacterCustomizationSettings::ExtraTooltipDataTable' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, SprayActorClass) == 0x000290, "Member 'UVAL_CharacterCustomizationSettings::SprayActorClass' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, SprayDistance) == 0x0002B8, "Member 'UVAL_CharacterCustomizationSettings::SprayDistance' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, CosmeticColorCurveAtlas) == 0x0002C0, "Member 'UVAL_CharacterCustomizationSettings::CosmeticColorCurveAtlas' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, DynamicVariantUINameBackups) == 0x0002E8, "Member 'UVAL_CharacterCustomizationSettings::DynamicVariantUINameBackups' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, MandatoryItemSlotNames) == 0x000308, "Member 'UVAL_CharacterCustomizationSettings::MandatoryItemSlotNames' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, GliderTrailThumbnailActorClass) == 0x000358, "Member 'UVAL_CharacterCustomizationSettings::GliderTrailThumbnailActorClass' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, EnabledOutfitsConfig) == 0x000360, "Member 'UVAL_CharacterCustomizationSettings::EnabledOutfitsConfig' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, FootprintEffectsLoadoutSlotPriorityOrder) == 0x000370, "Member 'UVAL_CharacterCustomizationSettings::FootprintEffectsLoadoutSlotPriorityOrder' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomizationSettings, EnabledOutfitsCache) == 0x0003C0, "Member 'UVAL_CharacterCustomizationSettings::EnabledOutfitsCache' has a wrong offset!");

// Class Palia.VAL_CharacterCustomizationLoadoutPreset
// 0x0900 (0x0930 - 0x0030)
class UVAL_CharacterCustomizationLoadoutPreset final : public UDataAsset
{
public:
	struct FVAL_CharacterCustomizationLoadout     Loadout;                                           // 0x0030(0x0900)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationLoadoutPreset">();
	}
	static class UVAL_CharacterCustomizationLoadoutPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationLoadoutPreset>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationLoadoutPreset) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationLoadoutPreset");
static_assert(sizeof(UVAL_CharacterCustomizationLoadoutPreset) == 0x000930, "Wrong size on UVAL_CharacterCustomizationLoadoutPreset");
static_assert(offsetof(UVAL_CharacterCustomizationLoadoutPreset, Loadout) == 0x000030, "Member 'UVAL_CharacterCustomizationLoadoutPreset::Loadout' has a wrong offset!");

// Class Palia.VAL_CharacterCustomzationFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_CharacterCustomzationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyLoadoutGenderExpression(struct FVAL_CharacterCustomizationLoadout& Loadout, float Value);
	static void ApplyLoadoutHeight(struct FVAL_CharacterCustomizationLoadout& Loadout, float Value);
	static void ApplyLoadoutMuscularExpression(struct FVAL_CharacterCustomizationLoadout& Loadout, float Value);
	static void ApplyLoadoutThickness(struct FVAL_CharacterCustomizationLoadout& Loadout, float Value);
	static void ApplyMorphTargetsToMeshUsingNameAndWeight(class USkeletalMeshComponent* InMeshComponent, class FName& MorphTargetName, float MorphTargetWeight);
	static void ApplyMorphTargetsToMeshUsingTags(class USkeletalMeshComponent* InMeshComponent, struct FGameplayTagContainer& ItemTags, struct FVAL_CharacterCustomization_SkeletalMeshComponentConfig& InMeshConfig);
	static void ApplySkeletalMeshConfigToComponents(class USkeletalMeshComponent* SkeletalComp, class UAbilityAnimationComponent* AbilityAnimationComponent, struct FVAL_CharacterCustomization_SkeletalMeshComponentConfig& Config);
	static bool AreItemsValidClassForLoadoutSlot(class FName& LoadoutSlotName, TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>>& TargetAssets);
	static void ClearSkeletalMeshConfigFromComponents(class USkeletalMeshComponent* SkeletalComp, class UAbilityAnimationComponent* AbilityAnimationComponent);
	static struct FVAL_CharacterCustomizationLoadout CreateRandomLoadout();
	static void ForceMipLevelsToBeResidentOnMeshComponents(TArray<class UMeshComponent*>& MeshComponents);
	static struct FVAL_CharCustomization_AssetData GenerateTileAssetData(struct FAssetData& AssetData);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_AnimSet>> GetAllAnimSetCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_BodyComplexion>> GetAllBodyComplexionCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_BodyTattoo>> GetAllBodyTattooCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TArray<struct FAssetData> GetAllCharacterCustomizationItems(EVAL_CharacterBodyType BodyType, TSubclassOf<class UVAL_CharacterCustomizationItemBase>& ItemClass);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Eyes>> GetAllEyesCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_FaceComplexion>> GetAllFaceComplexionCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_FaceMask>> GetAllFaceMaskCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_FaceTattoo>> GetAllFaceTattooCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_FacialHairStyle>> GetAllFacialHairStyleCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Glider>> GetAllGliderCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_GliderTrail>> GetAllGliderTrailCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_HairStyle>> GetAllHairStyleCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Hat>> GetAllHatCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Head>> GetAllHeadCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TArray<struct FGuid> GetAllItemIdsFromLoadout(struct FVAL_CharacterCustomizationLoadout& Loadout);
	static TArray<TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>> GetAllItemsFromLoadout(struct FVAL_CharacterCustomizationLoadout& Loadout);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Legs>> GetAllLegsCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<class FName> GetAllLoadoutSlotsForItem(class UVAL_CharacterCustomizationItemBase* Item);
	static TSet<class FName> GetAllLoadoutSlotsForItemSoftObjectPtr(TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>& Item);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Makeup>> GetAllMakeupCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<class USkeletalMeshComponent*> GetAllMeshComponents(class AActor* Actor);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Pet>> GetAllPetCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_SkinTone>> GetAllSkinToneCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Torso>> GetAllTorsoCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItem_Voice>> GetAllVoiceCharacterCustomizationItems(EVAL_CharacterBodyType BodyType);
	static bool GetAssetDataFromItem(TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>& SoftItem, struct FAssetData* OutAssetData);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>> GetCharacterCustomizationItemsFromIds(TSet<struct FGuid>& Ids, EVAL_CharacterBodyType& BodyType);
	static struct FLinearColor GetColorFromColorCurveAtlas(class UCurveLinearColorAtlas* ColorCurveAtlas, float CurveIndex, float ColorCurvePoint);
	static bool GetCosmeticTagDataFromTagSelector(struct FVAL_CharacterCustomization_CosmeticTagSelector& TagSelector, struct FVAL_CharCustomization_CosmeticTagData* OutTagData);
	static struct FVAL_CharacterCustomizationLoadout GetDefaultLoadout(EVAL_CharacterBodyType BodyType);
	static TArray<class FName> GetDifferencesBetweenLoadouts(struct FVAL_CharacterCustomizationLoadout& LoadoutA, struct FVAL_CharacterCustomizationLoadout& LoadoutB);
	static TSet<TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>> GetFilteredCharacterCustomizationItems(struct FVAL_CharCustomization_FilteringSettings& FilteringSettings);
	static bool GetItemEnabledInCharacterCustomizationItemsConfig(struct FGuid& ItemId);
	static bool GetItemIdFromItem(TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>& SoftItem, struct FGuid* OutId);
	static bool GetItemValidToEquipInCharacterCustomizationItemsConfig(struct FGuid& ItemId);
	static class FName GetLoadoutSlotNameForItemClass(TSubclassOf<class UVAL_CharacterCustomizationItemBase>& ItemClass);
	static void GetLoadoutSlotSettings(class FName& LoadoutSlotName, struct FVAL_CharacterCustomization_LoadoutSlotSettings* Settings, bool* bSuccess);
	static class USkeletalMeshComponent* GetMeshComponentFromType(EVAL_CharacterCustomization_MeshType MeshType, class AActor* Actor);
	static TMap<class FName, TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>> GetNameToLoadoutSlotItemMap(struct FVAL_CharacterCustomizationLoadout& Loadout);
	static struct FVAL_CharacterCustomizationLoadout GetRandomLoadoutFromCustomizationItems(EVAL_CharacterBodyType& BodyType, TArray<TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>>& Items);
	static bool IsItemValidClassForLoadoutSlot(class FName& LoadoutSlotName, TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>& TargetAsset);
	static bool IsLoadoutEmpty(struct FVAL_CharacterCustomizationLoadout& Loadout);
	static bool IsMandatoryLoadoutSlot(class FName& SlotName);
	static struct FVALDTOS_CharacterCustomizationLoadout_PersistDTO_Stable LoadoutToPersistenceDTO_Stable(struct FVAL_CharacterCustomizationLoadout& Loadout);
	static struct FVALDTOS_CharacterCustomizationLoadout_PersistDTO_Volatile LoadoutToPersistenceDTO_Volatile(struct FVAL_CharacterCustomizationLoadout& Loadout);
	static void MatchLoadoutVariantIndicesForItem(struct FVAL_CharacterCustomizationLoadout& Loadout, class UVAL_CharacterCustomizationItemBase* SourceItem, TArray<class UVAL_CharacterCustomizationItemBase*>& TargetItems);
	static struct FVAL_CharacterCustomizationLoadout PersistenceDTOsToLoadout(struct FVALDTOS_CharacterCustomizationLoadout_PersistDTO_Stable& PersistDTO_Stable, struct FVALDTOS_CharacterCustomizationLoadout_PersistDTO_Volatile& PersistDTO_Volatile);
	static void PopulateEnabledCharacterCustomizationItemsConfig();
	static void SetItemInLoadout(struct FVAL_CharacterCustomizationLoadout& InLoadout, class FName& LoadoutSlotName, TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>& TargetAsset);
	static void SetItemsInLoadout(struct FVAL_CharacterCustomizationLoadout& InLoadout, TMap<class FName, TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>>& LoadoutSlotToAssetMap);
	static void SetVariantSelectionInLoadout(struct FVAL_CharacterCustomizationLoadout& InLoadout, class FName& LoadoutSlotName, class FName& VariantChannelName, struct FGuid& VariantOptionId);
	static TArray<class FName> SortCosmeticTagRowNamesByDisplayName(TArray<class FName>& CosmeticTagRowNames);
	static void SortItemsByPremium(TSet<struct FGuid>& CurrentEntitlements, bool bDescending, TArray<struct FAssetData>& OutItems);
	static bool TryGetItemByGuid(struct FGuid& ItemGuid, class UVAL_CharacterCustomizationItemBase** OutItem);
	static bool TryGetItemInLoadout(struct FVAL_CharacterCustomizationLoadout& Loadout, class FName& LoadoutSlotName, class UVAL_CharacterCustomizationItemBase** OutItem, bool bLoadSync);
	static bool TryGetSoftItemByGuid(struct FGuid& ItemGuid, TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase>* OutItem);
	static bool TryGetVariantSelectionInLoadout(struct FVAL_CharacterCustomizationLoadout& Loadout, class FName& LoadoutSlotName, class FName& VariantChannelName, struct FGuid* OutVariantOptionId);
	static struct FVAL_CharacterCustomizationLoadout TrySynchronizeVariantIndexSelectionsInLoadout(struct FVAL_CharacterCustomizationLoadout& OldLoadout, struct FVAL_CharacterCustomizationLoadout& NewLoadout);
	static struct FVAL_CharacterCustomizationLoadout ValidateLoadout(struct FVAL_CharacterCustomizationLoadout& Loadout, struct FVAL_ValidateLoadoutErrorPayload* OutErrorPayload, bool bCheckEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomzationFunctionLibrary">();
	}
	static class UVAL_CharacterCustomzationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomzationFunctionLibrary>();
	}
};
static_assert(alignof(UVAL_CharacterCustomzationFunctionLibrary) == 0x000008, "Wrong alignment on UVAL_CharacterCustomzationFunctionLibrary");
static_assert(sizeof(UVAL_CharacterCustomzationFunctionLibrary) == 0x000028, "Wrong size on UVAL_CharacterCustomzationFunctionLibrary");

// Class Palia.VAL_CharacterCustomizationVariantFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_CharacterCustomizationVariantFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetAssetDataFromId(struct FAssetData* OutData, const class FString& ItemId);
	static TArray<struct FLinearColor> GetDynamicUIColorsFromMaterial(class UMaterialInterface* Material, struct FVAL_VariantOption_UISettings& UISettings);
	static TSoftObjectPtr<class UMaterialInterface> GetMaterialInstanceFromVariantForDynamicUIColor(class UVAL_CharacterCustomizationItemBase* Item, class FName& VariantChannelName, struct FGuid& VariantOptionId, EVAL_CharacterBodyType& BodyType);
	static TSoftObjectPtr<class UTexture2D> GetPrerenderedThumbnailFromId(const class FString& ItemId, EVAL_CharacterBodyType BodyType);
	static bool TryGetTypedVariantOptionById(class UVAL_CharacterCustomizationItemBase* Item, EVAL_CharacterBodyType BodyType, class FName& VariantChannelName, struct FGuid& VariantOptionId, struct FVAL_CharacterCustomizationVariantOptionBase* OutVariantOption);
	static bool TryGetVariantOptionSelectedForItem(class FName& VariantChannelName, struct FVAL_CharacterCustomizationLoadout& Loadout, class UVAL_CharacterCustomizationItemBase* Item, struct FVAL_CharacterCustomizationVariantOptionBase* OptionChosen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomizationVariantFunctionLibrary">();
	}
	static class UVAL_CharacterCustomizationVariantFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomizationVariantFunctionLibrary>();
	}
};
static_assert(alignof(UVAL_CharacterCustomizationVariantFunctionLibrary) == 0x000008, "Wrong alignment on UVAL_CharacterCustomizationVariantFunctionLibrary");
static_assert(sizeof(UVAL_CharacterCustomizationVariantFunctionLibrary) == 0x000028, "Wrong size on UVAL_CharacterCustomizationVariantFunctionLibrary");

// Class Palia.VAL_CharacterCustomization_ScriptObject
// 0x00A8 (0x00D0 - 0x0028)
class UVAL_CharacterCustomization_ScriptObject : public UObject
{
public:
	struct FVAL_CharacterCustomization_EffectToMatchingCharactersMap CurrCooperativeEffectCharacters;                   // 0x0028(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVAL_CooperativeEffectData> CooperativeEffectMap;                              // 0x0078(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsPreviewCharacter;                               // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVAL_FootprintEffectType                      FootprintEffectType;                               // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B5E[0x6];                                     // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApply(class UVAL_CharacterCustomizationComponent* Component, class UVAL_CharacterCustomizationItemBase* Item, TMap<class FName, struct FGuid>& VariantSelections);
	void OnCooperativeEffectBegin(class FName& EffectName, TArray<class AValeriaCharacter*>& MatchingCharacters);
	void OnCooperativeEffectContinue(class FName& EffectName, TArray<class AValeriaCharacter*>& MatchingCharacters);
	void OnCooperativeEffectEnd(class FName& EffectName, TArray<class AValeriaCharacter*>& MatchingCharacters);
	void OnRemove(class UVAL_CharacterCustomizationComponent* Component);
	void OnUninitialize(class UVAL_CharacterCustomizationComponent* Component);
	void SpawnCustomFootprintEffects(struct FVector& SpawnLocation, struct FRotator& SpawnRotation);

	const TMap<class FName, struct FVAL_CooperativeEffectData> GetCooperativeEffectMap() const;
	TSet<class FName> GetCooperativeEffectNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterCustomization_ScriptObject">();
	}
	static class UVAL_CharacterCustomization_ScriptObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterCustomization_ScriptObject>();
	}
};
static_assert(alignof(UVAL_CharacterCustomization_ScriptObject) == 0x000008, "Wrong alignment on UVAL_CharacterCustomization_ScriptObject");
static_assert(sizeof(UVAL_CharacterCustomization_ScriptObject) == 0x0000D0, "Wrong size on UVAL_CharacterCustomization_ScriptObject");
static_assert(offsetof(UVAL_CharacterCustomization_ScriptObject, CurrCooperativeEffectCharacters) == 0x000028, "Member 'UVAL_CharacterCustomization_ScriptObject::CurrCooperativeEffectCharacters' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomization_ScriptObject, CooperativeEffectMap) == 0x000078, "Member 'UVAL_CharacterCustomization_ScriptObject::CooperativeEffectMap' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomization_ScriptObject, bIsPreviewCharacter) == 0x0000C8, "Member 'UVAL_CharacterCustomization_ScriptObject::bIsPreviewCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_CharacterCustomization_ScriptObject, FootprintEffectType) == 0x0000C9, "Member 'UVAL_CharacterCustomization_ScriptObject::FootprintEffectType' has a wrong offset!");

// Class Palia.VAL_CharacterPreviewer
// 0x01C8 (0x0470 - 0x02A8)
class AVAL_CharacterPreviewer : public AActor
{
public:
	struct FRotator                               BaseRotation;                                      // 0x02A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdlePose;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentRotationOffset;                             // 0x02C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EVAL_CharacterBodyType, struct FVAL_RenderPreviewCameraSettings> FullBodyRenderPreviewCameraSettingsMap;            // 0x02E0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EVAL_CharacterBodyType, struct FVAL_RenderPreviewCameraSettings> TorsoRenderPreviewCameraSettingsMap;               // 0x0330(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EVAL_CharacterBodyType, struct FVAL_RenderPreviewCameraSettings> HeadRenderPreviewCameraSettingsMap;                // 0x0380(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EVAL_CharacterBodyType, struct FVAL_RenderPreviewCameraSettings> LegsRenderPreviewCameraSettingsMap;                // 0x03D0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               FullBodyCaptureComponent;                          // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               HeadCaptureComponent;                              // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               LegsCaptureComponent;                              // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               TorsoCaptureComponent;                             // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   ChildActorComponent;                               // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        CaptureRootComponent;                              // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USceneCaptureComponent2D*>       AllCaptureComponents;                              // 0x0450(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B5F[0x10];                                    // 0x0460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelRequest(struct FGuid& RequestID);
	class UTextureRenderTarget2D* CaptureFullBodyScene(struct FVAL_RenderHeadPreviewParameters& PreviewParameters);
	class UTextureRenderTarget2D* CaptureHeadScene(struct FVAL_RenderHeadPreviewParameters& PreviewParameters);
	class UTextureRenderTarget2D* CaptureLegsScene(struct FVAL_RenderLegsPreviewParameters& PreviewParameters);
	class UTextureRenderTarget2D* CaptureTorsoScene(struct FVAL_RenderTorsoPreviewParameters& PreviewParameters);
	void ClearPendingPreviewRequests();
	void PrepareSceneForFullBodyRender(struct FVAL_RenderHeadPreviewParameters& PreviewParameters);
	void PrepareSceneForHeadRender(struct FVAL_RenderHeadPreviewParameters& PreviewParameters);
	void PrepareSceneForLegsRender(struct FVAL_RenderLegsPreviewParameters& PreviewParameters);
	void PrepareSceneForTorsoRender(struct FVAL_RenderTorsoPreviewParameters& PreviewParameters);
	void RequestRenderFullBodyPreview(struct FVAL_RenderFullBodyPreviewParameters& PreviewParameters, struct FGuid& InRequestId, TDelegate<void(class AVAL_CharacterPreviewer* CharacterPreviewer, const struct FGuid& RequestID, class UTextureRenderTarget2D* PreviewTexture)> OnRenderPreviewComplete);
	void RequestRenderHeadPreview(struct FVAL_RenderHeadPreviewParameters& PreviewParameters, struct FGuid& InRequestId, TDelegate<void(class AVAL_CharacterPreviewer* CharacterPreviewer, const struct FGuid& RequestID, class UTextureRenderTarget2D* PreviewTexture)> OnRenderPreviewComplete);
	void RequestRenderLegsPreview(struct FVAL_RenderLegsPreviewParameters& PreviewParameters, struct FGuid& InRequestId, TDelegate<void(class AVAL_CharacterPreviewer* CharacterPreviewer, const struct FGuid& RequestID, class UTextureRenderTarget2D* PreviewTexture)> OnRenderPreviewComplete);
	void RequestRenderTorsoPreview(struct FVAL_RenderTorsoPreviewParameters& PreviewParameters, struct FGuid& InRequestId, TDelegate<void(class AVAL_CharacterPreviewer* CharacterPreviewer, const struct FGuid& RequestID, class UTextureRenderTarget2D* PreviewTexture)> OnRenderPreviewComplete);
	void SetForceMipLevelsToBeResidentOnMeshComponents();

	class AActor* GetPreviewCharacter() const;
	struct FVAL_RenderPreviewCameraSettings GetRenderFullBodyCameraPreviewSettings(EVAL_CharacterBodyType BodyType) const;
	struct FVAL_RenderPreviewCameraSettings GetRenderHeadCameraPreviewSettings(EVAL_CharacterBodyType BodyType) const;
	struct FVAL_RenderPreviewCameraSettings GetRenderLegsCameraPreviewSettings(EVAL_CharacterBodyType BodyType) const;
	struct FVAL_RenderPreviewCameraSettings GetRenderTorsoCameraPreviewSettings(EVAL_CharacterBodyType BodyType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterPreviewer">();
	}
	static class AVAL_CharacterPreviewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_CharacterPreviewer>();
	}
};
static_assert(alignof(AVAL_CharacterPreviewer) == 0x000008, "Wrong alignment on AVAL_CharacterPreviewer");
static_assert(sizeof(AVAL_CharacterPreviewer) == 0x000470, "Wrong size on AVAL_CharacterPreviewer");
static_assert(offsetof(AVAL_CharacterPreviewer, BaseRotation) == 0x0002A8, "Member 'AVAL_CharacterPreviewer::BaseRotation' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, IdlePose) == 0x0002C0, "Member 'AVAL_CharacterPreviewer::IdlePose' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, CurrentRotationOffset) == 0x0002C8, "Member 'AVAL_CharacterPreviewer::CurrentRotationOffset' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, FullBodyRenderPreviewCameraSettingsMap) == 0x0002E0, "Member 'AVAL_CharacterPreviewer::FullBodyRenderPreviewCameraSettingsMap' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, TorsoRenderPreviewCameraSettingsMap) == 0x000330, "Member 'AVAL_CharacterPreviewer::TorsoRenderPreviewCameraSettingsMap' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, HeadRenderPreviewCameraSettingsMap) == 0x000380, "Member 'AVAL_CharacterPreviewer::HeadRenderPreviewCameraSettingsMap' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, LegsRenderPreviewCameraSettingsMap) == 0x0003D0, "Member 'AVAL_CharacterPreviewer::LegsRenderPreviewCameraSettingsMap' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, FullBodyCaptureComponent) == 0x000420, "Member 'AVAL_CharacterPreviewer::FullBodyCaptureComponent' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, HeadCaptureComponent) == 0x000428, "Member 'AVAL_CharacterPreviewer::HeadCaptureComponent' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, LegsCaptureComponent) == 0x000430, "Member 'AVAL_CharacterPreviewer::LegsCaptureComponent' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, TorsoCaptureComponent) == 0x000438, "Member 'AVAL_CharacterPreviewer::TorsoCaptureComponent' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, ChildActorComponent) == 0x000440, "Member 'AVAL_CharacterPreviewer::ChildActorComponent' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, CaptureRootComponent) == 0x000448, "Member 'AVAL_CharacterPreviewer::CaptureRootComponent' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterPreviewer, AllCaptureComponents) == 0x000450, "Member 'AVAL_CharacterPreviewer::AllCaptureComponents' has a wrong offset!");

// Class Palia.VAL_CharacterPreviewLevelInterface
// 0x0000 (0x0028 - 0x0028)
class IVAL_CharacterPreviewLevelInterface final : public IInterface
{
public:
	class AVAL_CharacterPreviewer* GetCharacterInventoryPreviewer();
	class AVAL_CharacterPreviewer* GetCharacterPreviewer();
	class AVAL_CharacterRenderStudio* GetCharacterRenderStudio();
	struct FVector GetItemPreviewerSpawnLocation();
	class AValeriaCharacter* GetLobbyCharacter();
	struct FVector GetRenderStudioSpawnLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterPreviewLevelInterface">();
	}
	static class IVAL_CharacterPreviewLevelInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVAL_CharacterPreviewLevelInterface>();
	}
};
static_assert(alignof(IVAL_CharacterPreviewLevelInterface) == 0x000008, "Wrong alignment on IVAL_CharacterPreviewLevelInterface");
static_assert(sizeof(IVAL_CharacterPreviewLevelInterface) == 0x000028, "Wrong size on IVAL_CharacterPreviewLevelInterface");

// Class Palia.VAL_CharacterPreviewLevelFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_CharacterPreviewLevelFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class AVAL_CharacterPreviewer* GetCharacterInventoryPreviewer(class UObject* WorldContextObject);
	static class AVAL_CharacterPreviewer* GetCharacterPreviewer(class UObject* WorldContextObject);
	static class AVAL_CharacterRenderStudio* GetCharacterRenderStudio(class UObject* WorldContextObject);
	static struct FVector GetItemPreviewerSpawnLocation(class UObject* WorldContextObject);
	static struct FVector GetRenderStudioSpawnLocation(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterPreviewLevelFunctionLibrary">();
	}
	static class UVAL_CharacterPreviewLevelFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CharacterPreviewLevelFunctionLibrary>();
	}
};
static_assert(alignof(UVAL_CharacterPreviewLevelFunctionLibrary) == 0x000008, "Wrong alignment on UVAL_CharacterPreviewLevelFunctionLibrary");
static_assert(sizeof(UVAL_CharacterPreviewLevelFunctionLibrary) == 0x000028, "Wrong size on UVAL_CharacterPreviewLevelFunctionLibrary");

// Class Palia.VAL_CharacterRenderLevelInterface
// 0x0000 (0x0028 - 0x0028)
class IVAL_CharacterRenderLevelInterface final : public IInterface
{
public:
	TSet<class AActor*> GetAllCameraActors() const;
	TSet<class AActor*> GetAllTaggedActors() const;
	class AActor* GetCameraActorForCosmeticAsset(class UVAL_CharacterCustomizationItemBase* Item, EVAL_CharacterBodyType BodyType) const;
	class AValeriaCharacter* GetCharacter() const;
	class AActor* GetDefaultCameraActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterRenderLevelInterface">();
	}
	static class IVAL_CharacterRenderLevelInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVAL_CharacterRenderLevelInterface>();
	}
};
static_assert(alignof(IVAL_CharacterRenderLevelInterface) == 0x000008, "Wrong alignment on IVAL_CharacterRenderLevelInterface");
static_assert(sizeof(IVAL_CharacterRenderLevelInterface) == 0x000028, "Wrong size on IVAL_CharacterRenderLevelInterface");

// Class Palia.VillagerCostumeDataAsset
// 0x0010 (0x0040 - 0x0030)
class UVillagerCostumeDataAsset final : public UDataAsset
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          HeadMesh;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerCostumeDataAsset">();
	}
	static class UVillagerCostumeDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerCostumeDataAsset>();
	}
};
static_assert(alignof(UVillagerCostumeDataAsset) == 0x000008, "Wrong alignment on UVillagerCostumeDataAsset");
static_assert(sizeof(UVillagerCostumeDataAsset) == 0x000040, "Wrong size on UVillagerCostumeDataAsset");
static_assert(offsetof(UVillagerCostumeDataAsset, Mesh) == 0x000030, "Member 'UVillagerCostumeDataAsset::Mesh' has a wrong offset!");
static_assert(offsetof(UVillagerCostumeDataAsset, HeadMesh) == 0x000038, "Member 'UVillagerCostumeDataAsset::HeadMesh' has a wrong offset!");

// Class Palia.VAL_CharacterRenderStudio
// 0x0290 (0x0538 - 0x02A8)
class AVAL_CharacterRenderStudio : public AActor
{
public:
	uint8                                         Pad_2B65[0x68];                                    // 0x02A8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStudioStateChanged;                              // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<class UObject*>                          CloseBlockers;                                     // 0x0320(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FVAL_RenderStudioLevelData             CurrentLevelData;                                  // 0x0370(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVAL_RenderStudioLevelData>     PreloadedLevelData;                                // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FVAL_RenderStudioLevelData> LevelTable;                                        // 0x0450(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   WorldPartitionStreamerClass;                       // 0x04A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AS6WorldPartitionStreamer*              WorldPartitionStreamer;                            // 0x04C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B66[0x10];                                    // 0x04D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class AActor*>              CinematicActors;                                   // 0x04E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B67[0x8];                                     // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CenterSubSceneOnTransform(struct FTransform& NewTransform, class FName& SubsceneName);
	void ExitStudio();
	void HandleOnCharacterRenderStateChanged(EVAL_CharacterRenderStudioState State);
	void InitializeValeriaCharacterForRenderStudio(class AValeriaCharacter* RenderStudioCharacter);
	void OnStateChanged__DelegateSignature(class AVAL_CharacterRenderStudio* Studio, EVAL_CharacterRenderStudioState State);
	bool PreloadScenes(TSet<class FName>& LevelNames);
	void RegisterCinematicActor(class FName& Key, class AActor* Actor);
	void RegisterCloseBlocker(class UObject* Blocker);
	bool RequestCharacterCreationScene();
	bool RequestCharacterStoreScene();
	bool RequestCharacterWardrobeScene();
	bool RequestInventoryScene();
	bool RequestPaliaPassScene();
	bool RequestScene(class FName& LevelName);
	class AActor* SpawnActorAtActorWithTag(TSubclassOf<class AActor>& ActorClass, class FName& TagName);
	void UnregisterCinematicActor(class FName& Key);
	void UnregisterCloseBlocker(class UObject* Blocker);

	class AActor* GetActorWithTag(class FName& Tag) const;
	class AActor* GetCameraActorForCosmeticAsset(class UVAL_CharacterCustomizationItemBase* Item, EVAL_CharacterBodyType BodyType) const;
	class AActor* GetCameraActorWithTag(class FName& Tag) const;
	class AValeriaCharacter* GetCharacter() const;
	class AActor* GetCinematicActor(class FName& Key) const;
	class AActor* GetDefaultCameraActor() const;
	EVAL_CharacterRenderStudioState GetRenderStudioState() const;
	bool TryFindLevelDataByName(class FName& LevelName, struct FVAL_RenderStudioLevelData* LevelData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CharacterRenderStudio">();
	}
	static class AVAL_CharacterRenderStudio* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_CharacterRenderStudio>();
	}
};
static_assert(alignof(AVAL_CharacterRenderStudio) == 0x000008, "Wrong alignment on AVAL_CharacterRenderStudio");
static_assert(sizeof(AVAL_CharacterRenderStudio) == 0x000538, "Wrong size on AVAL_CharacterRenderStudio");
static_assert(offsetof(AVAL_CharacterRenderStudio, OnStudioStateChanged) == 0x000310, "Member 'AVAL_CharacterRenderStudio::OnStudioStateChanged' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterRenderStudio, CloseBlockers) == 0x000320, "Member 'AVAL_CharacterRenderStudio::CloseBlockers' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterRenderStudio, CurrentLevelData) == 0x000370, "Member 'AVAL_CharacterRenderStudio::CurrentLevelData' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterRenderStudio, PreloadedLevelData) == 0x000440, "Member 'AVAL_CharacterRenderStudio::PreloadedLevelData' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterRenderStudio, LevelTable) == 0x000450, "Member 'AVAL_CharacterRenderStudio::LevelTable' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterRenderStudio, WorldPartitionStreamerClass) == 0x0004A0, "Member 'AVAL_CharacterRenderStudio::WorldPartitionStreamerClass' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterRenderStudio, WorldPartitionStreamer) == 0x0004C8, "Member 'AVAL_CharacterRenderStudio::WorldPartitionStreamer' has a wrong offset!");
static_assert(offsetof(AVAL_CharacterRenderStudio, CinematicActors) == 0x0004E0, "Member 'AVAL_CharacterRenderStudio::CinematicActors' has a wrong offset!");

// Class Palia.VAL_ChatCommand_Base
// 0x00F0 (0x0118 - 0x0028)
class UVAL_ChatCommand_Base : public UObject
{
public:
	uint8                                         Pad_2B6E[0x20];                                    // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVAL_ChatCommandInfo                   Info;                                              // 0x0048(0x0088)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B6F[0x48];                                    // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Base">();
	}
	static class UVAL_ChatCommand_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Base>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Base) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Base");
static_assert(sizeof(UVAL_ChatCommand_Base) == 0x000118, "Wrong size on UVAL_ChatCommand_Base");
static_assert(offsetof(UVAL_ChatCommand_Base, Info) == 0x000048, "Member 'UVAL_ChatCommand_Base::Info' has a wrong offset!");

// Class Palia.VAL_ChatCommand_CharacterNameParser
// 0x0038 (0x0150 - 0x0118)
class UVAL_ChatCommand_CharacterNameParser : public UVAL_ChatCommand_Base
{
public:
	uint8                                         Pad_2B70[0x8];                                     // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CharacterNameEmptyError;                           // 0x0120(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bExecuteCommandImmediatelyOnValidName;             // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B71[0x3];                                     // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCharacterNameSuggestionsNum;                    // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B72[0x10];                                    // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_CharacterNameParser">();
	}
	static class UVAL_ChatCommand_CharacterNameParser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_CharacterNameParser>();
	}
};
static_assert(alignof(UVAL_ChatCommand_CharacterNameParser) == 0x000008, "Wrong alignment on UVAL_ChatCommand_CharacterNameParser");
static_assert(sizeof(UVAL_ChatCommand_CharacterNameParser) == 0x000150, "Wrong size on UVAL_ChatCommand_CharacterNameParser");
static_assert(offsetof(UVAL_ChatCommand_CharacterNameParser, CharacterNameEmptyError) == 0x000120, "Member 'UVAL_ChatCommand_CharacterNameParser::CharacterNameEmptyError' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_CharacterNameParser, bExecuteCommandImmediatelyOnValidName) == 0x000138, "Member 'UVAL_ChatCommand_CharacterNameParser::bExecuteCommandImmediatelyOnValidName' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_CharacterNameParser, MaxCharacterNameSuggestionsNum) == 0x00013C, "Member 'UVAL_ChatCommand_CharacterNameParser::MaxCharacterNameSuggestionsNum' has a wrong offset!");

// Class Palia.VAL_ChatCommand_Whisper
// 0x0000 (0x0150 - 0x0150)
class UVAL_ChatCommand_Whisper : public UVAL_ChatCommand_CharacterNameParser
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Whisper">();
	}
	static class UVAL_ChatCommand_Whisper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Whisper>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Whisper) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Whisper");
static_assert(sizeof(UVAL_ChatCommand_Whisper) == 0x000150, "Wrong size on UVAL_ChatCommand_Whisper");

// Class Palia.VillagerGiftReceiverComponent
// 0x0010 (0x00B0 - 0x00A0)
class UVillagerGiftReceiverComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2B73[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanRecieveGiftsOverride;                          // 0x00A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B74[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanGiftVillager(class AValeriaCharacter* Character);
	EGiftPredictedResponse GetPredictedResponseFor(class AValeriaCharacter* Character, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, bool* bAlreadyReceived);

	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;
	bool IsVillagerInGiftableSpace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerGiftReceiverComponent">();
	}
	static class UVillagerGiftReceiverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerGiftReceiverComponent>();
	}
};
static_assert(alignof(UVillagerGiftReceiverComponent) == 0x000008, "Wrong alignment on UVillagerGiftReceiverComponent");
static_assert(sizeof(UVillagerGiftReceiverComponent) == 0x0000B0, "Wrong size on UVillagerGiftReceiverComponent");
static_assert(offsetof(UVillagerGiftReceiverComponent, bCanRecieveGiftsOverride) == 0x0000A8, "Member 'UVillagerGiftReceiverComponent::bCanRecieveGiftsOverride' has a wrong offset!");

// Class Palia.VAL_ChatCommand_Reply
// 0x0018 (0x0130 - 0x0118)
class UVAL_ChatCommand_Reply : public UVAL_ChatCommand_Base
{
public:
	class FText                                   NoReplyTargetFoundErrorText;                       // 0x0118(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Reply">();
	}
	static class UVAL_ChatCommand_Reply* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Reply>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Reply) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Reply");
static_assert(sizeof(UVAL_ChatCommand_Reply) == 0x000130, "Wrong size on UVAL_ChatCommand_Reply");
static_assert(offsetof(UVAL_ChatCommand_Reply, NoReplyTargetFoundErrorText) == 0x000118, "Member 'UVAL_ChatCommand_Reply::NoReplyTargetFoundErrorText' has a wrong offset!");

// Class Palia.VAL_ChatCommand_Emote
// 0x0058 (0x0170 - 0x0118)
class UVAL_ChatCommand_Emote final : public UVAL_ChatCommand_Base
{
public:
	TSoftObjectPtr<class UEmoteDataAsset>         EmoteAsset;                                        // 0x0118(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EmoteAssetNotFoundErrorText;                       // 0x0140(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   EmoteFailedToPlayErrorText;                        // 0x0158(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Emote">();
	}
	static class UVAL_ChatCommand_Emote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Emote>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Emote) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Emote");
static_assert(sizeof(UVAL_ChatCommand_Emote) == 0x000170, "Wrong size on UVAL_ChatCommand_Emote");
static_assert(offsetof(UVAL_ChatCommand_Emote, EmoteAsset) == 0x000118, "Member 'UVAL_ChatCommand_Emote::EmoteAsset' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_Emote, EmoteAssetNotFoundErrorText) == 0x000140, "Member 'UVAL_ChatCommand_Emote::EmoteAssetNotFoundErrorText' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_Emote, EmoteFailedToPlayErrorText) == 0x000158, "Member 'UVAL_ChatCommand_Emote::EmoteFailedToPlayErrorText' has a wrong offset!");

// Class Palia.VAL_ChatCommand_Mute
// 0x0018 (0x0168 - 0x0150)
class UVAL_ChatCommand_Mute : public UVAL_ChatCommand_CharacterNameParser
{
public:
	class FText                                   FailedCharacterSearchText;                         // 0x0150(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Mute">();
	}
	static class UVAL_ChatCommand_Mute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Mute>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Mute) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Mute");
static_assert(sizeof(UVAL_ChatCommand_Mute) == 0x000168, "Wrong size on UVAL_ChatCommand_Mute");
static_assert(offsetof(UVAL_ChatCommand_Mute, FailedCharacterSearchText) == 0x000150, "Member 'UVAL_ChatCommand_Mute::FailedCharacterSearchText' has a wrong offset!");

// Class Palia.VAL_ChatCommand_Unmute
// 0x0018 (0x0168 - 0x0150)
class UVAL_ChatCommand_Unmute : public UVAL_ChatCommand_CharacterNameParser
{
public:
	class FText                                   FailedCharacterSearchText;                         // 0x0150(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Unmute">();
	}
	static class UVAL_ChatCommand_Unmute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Unmute>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Unmute) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Unmute");
static_assert(sizeof(UVAL_ChatCommand_Unmute) == 0x000168, "Wrong size on UVAL_ChatCommand_Unmute");
static_assert(offsetof(UVAL_ChatCommand_Unmute, FailedCharacterSearchText) == 0x000150, "Member 'UVAL_ChatCommand_Unmute::FailedCharacterSearchText' has a wrong offset!");

// Class Palia.VillagerMovementComponent
// 0x0020 (0x0BE0 - 0x0BC0)
class UVillagerMovementComponent final : public UValeriaNpcMovementComponent
{
public:
	struct FVector                                LastKnownSafeLocation;                             // 0x0BB8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasSafeLocation;                                  // 0x0BD0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B7B[0xF];                                     // 0x0BD1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSafeLocation(struct FVector& NewLocation);
	bool ReturnToSafeLocation();

	const struct FVector GetLastKnownSafeLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerMovementComponent">();
	}
	static class UVillagerMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerMovementComponent>();
	}
};
static_assert(alignof(UVillagerMovementComponent) == 0x000010, "Wrong alignment on UVillagerMovementComponent");
static_assert(sizeof(UVillagerMovementComponent) == 0x000BE0, "Wrong size on UVillagerMovementComponent");
static_assert(offsetof(UVillagerMovementComponent, LastKnownSafeLocation) == 0x000BB8, "Member 'UVillagerMovementComponent::LastKnownSafeLocation' has a wrong offset!");
static_assert(offsetof(UVillagerMovementComponent, bHasSafeLocation) == 0x000BD0, "Member 'UVillagerMovementComponent::bHasSafeLocation' has a wrong offset!");

// Class Palia.VAL_ChatCommand_SubmitFeedback
// 0x0048 (0x0160 - 0x0118)
class UVAL_ChatCommand_SubmitFeedback final : public UVAL_ChatCommand_Base
{
public:
	uint8                                         Pad_2B7C[0x18];                                    // 0x0118(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FeedbackSubmitText;                                // 0x0130(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   EmptyFeedbackErrorText;                            // 0x0148(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_SubmitFeedback">();
	}
	static class UVAL_ChatCommand_SubmitFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_SubmitFeedback>();
	}
};
static_assert(alignof(UVAL_ChatCommand_SubmitFeedback) == 0x000008, "Wrong alignment on UVAL_ChatCommand_SubmitFeedback");
static_assert(sizeof(UVAL_ChatCommand_SubmitFeedback) == 0x000160, "Wrong size on UVAL_ChatCommand_SubmitFeedback");
static_assert(offsetof(UVAL_ChatCommand_SubmitFeedback, FeedbackSubmitText) == 0x000130, "Member 'UVAL_ChatCommand_SubmitFeedback::FeedbackSubmitText' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_SubmitFeedback, EmptyFeedbackErrorText) == 0x000148, "Member 'UVAL_ChatCommand_SubmitFeedback::EmptyFeedbackErrorText' has a wrong offset!");

// Class Palia.VAL_ChatCommand_Unstuck
// 0x0000 (0x0118 - 0x0118)
class UVAL_ChatCommand_Unstuck : public UVAL_ChatCommand_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Unstuck">();
	}
	static class UVAL_ChatCommand_Unstuck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Unstuck>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Unstuck) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Unstuck");
static_assert(sizeof(UVAL_ChatCommand_Unstuck) == 0x000118, "Wrong size on UVAL_ChatCommand_Unstuck");

// Class Palia.VAL_ChatCommand_Block
// 0x00B0 (0x0200 - 0x0150)
class UVAL_ChatCommand_Block : public UVAL_ChatCommand_CharacterNameParser
{
public:
	class FText                                   FailedCharacterSearchText;                         // 0x0150(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   AlreadyBlockedText;                                // 0x0168(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   NotBlockedText;                                    // 0x0180(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   BlockYourselfText;                                 // 0x0198(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   GenericFailText;                                   // 0x01B0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bBlock;                                            // 0x01C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B7D[0x37];                                    // 0x01C9(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBlockErrorSent(struct FUniqueNetIdRepl& UserId, EVAL_SocialBlockError BlockError);

	void OpenCommandModalDialogue(class UUserWidget* CommandModalDialogue, struct FUniqueNetIdRepl& UserId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Block">();
	}
	static class UVAL_ChatCommand_Block* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Block>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Block) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Block");
static_assert(sizeof(UVAL_ChatCommand_Block) == 0x000200, "Wrong size on UVAL_ChatCommand_Block");
static_assert(offsetof(UVAL_ChatCommand_Block, FailedCharacterSearchText) == 0x000150, "Member 'UVAL_ChatCommand_Block::FailedCharacterSearchText' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_Block, AlreadyBlockedText) == 0x000168, "Member 'UVAL_ChatCommand_Block::AlreadyBlockedText' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_Block, NotBlockedText) == 0x000180, "Member 'UVAL_ChatCommand_Block::NotBlockedText' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_Block, BlockYourselfText) == 0x000198, "Member 'UVAL_ChatCommand_Block::BlockYourselfText' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_Block, GenericFailText) == 0x0001B0, "Member 'UVAL_ChatCommand_Block::GenericFailText' has a wrong offset!");
static_assert(offsetof(UVAL_ChatCommand_Block, bBlock) == 0x0001C8, "Member 'UVAL_ChatCommand_Block::bBlock' has a wrong offset!");

// Class Palia.VAL_ChatCommand_Report
// 0x0048 (0x0198 - 0x0150)
class UVAL_ChatCommand_Report : public UVAL_ChatCommand_CharacterNameParser
{
public:
	class FText                                   ReportYourselfText;                                // 0x0150(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B7F[0x30];                                    // 0x0168(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenCommandModalDialogue(class UUserWidget* CommandModalDialogue, struct FUniqueNetIdRepl& UserId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Report">();
	}
	static class UVAL_ChatCommand_Report* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Report>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Report) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Report");
static_assert(sizeof(UVAL_ChatCommand_Report) == 0x000198, "Wrong size on UVAL_ChatCommand_Report");
static_assert(offsetof(UVAL_ChatCommand_Report, ReportYourselfText) == 0x000150, "Member 'UVAL_ChatCommand_Report::ReportYourselfText' has a wrong offset!");

// Class Palia.VillagerStoreComponent
// 0x0040 (0x00E0 - 0x00A0)
class UVillagerStoreComponent final : public UActorComponent
{
public:
	TArray<struct FStoreItem>                     ActiveItemsForSale;                                // 0x00A0(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B80[0x8];                                     // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVillagerStoreConfig*                   StoreConfig;                                       // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnStoreInventoryChanged;                           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnStoreActionComplete;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void Client_BuyItem(int32 StoreItemIndex, int32 NumToBuy);
	void Client_OpenStore();
	void Client_SellItem(const struct FBagSlotLocation& Location);
	void Client_SellItem_Custom(const struct FBagSlotLocation& SlotLocation, int32 NumToSell);
	void Client_SetStoreByConfig(class UVillagerStoreConfig* Config);
	void Client_SetVillagerStore(int32 VillagerConfigId);
	void OnRep_SellItems();
	void RpcClient_SellItemsReady();
	void RpcClient_StoreActionComplete(bool bBuy, bool bSuccess);
	void RpcServer_BuyItem(class UVAL_ItemTypeDefinitionAsset* ItemType, int32 NumToBuy, bool bIsRecipe);
	void RpcServer_OpenStore(int32 VillagerConfigId, class UVillagerStoreConfig* Config);
	void RpcServer_SellItem(const struct FBagSlotLocation& Location, int32 NumToSell);

	TArray<struct FStoreItem> GetStoreItemsForConfig(int32 VillagerConfigId, class UVillagerStoreConfig* Config) const;
	bool HasStore(int32 VillagerConfigId, struct FClientStoreInfo* ClientStoreInfo) const;
	bool StoreCanBuyItem(const struct FBagSlotLocation& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerStoreComponent">();
	}
	static class UVillagerStoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerStoreComponent>();
	}
};
static_assert(alignof(UVillagerStoreComponent) == 0x000008, "Wrong alignment on UVillagerStoreComponent");
static_assert(sizeof(UVillagerStoreComponent) == 0x0000E0, "Wrong size on UVillagerStoreComponent");
static_assert(offsetof(UVillagerStoreComponent, ActiveItemsForSale) == 0x0000A0, "Member 'UVillagerStoreComponent::ActiveItemsForSale' has a wrong offset!");
static_assert(offsetof(UVillagerStoreComponent, StoreConfig) == 0x0000B8, "Member 'UVillagerStoreComponent::StoreConfig' has a wrong offset!");
static_assert(offsetof(UVillagerStoreComponent, OnStoreInventoryChanged) == 0x0000C0, "Member 'UVillagerStoreComponent::OnStoreInventoryChanged' has a wrong offset!");
static_assert(offsetof(UVillagerStoreComponent, OnStoreActionComplete) == 0x0000D0, "Member 'UVillagerStoreComponent::OnStoreActionComplete' has a wrong offset!");

// Class Palia.VAL_ChatCommand_Nearby
// 0x0018 (0x0130 - 0x0118)
class UVAL_ChatCommand_Nearby : public UVAL_ChatCommand_Base
{
public:
	class FText                                   NoNearbyTargetFoundErrorText;                      // 0x0118(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatCommand_Nearby">();
	}
	static class UVAL_ChatCommand_Nearby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatCommand_Nearby>();
	}
};
static_assert(alignof(UVAL_ChatCommand_Nearby) == 0x000008, "Wrong alignment on UVAL_ChatCommand_Nearby");
static_assert(sizeof(UVAL_ChatCommand_Nearby) == 0x000130, "Wrong size on UVAL_ChatCommand_Nearby");
static_assert(offsetof(UVAL_ChatCommand_Nearby, NoNearbyTargetFoundErrorText) == 0x000118, "Member 'UVAL_ChatCommand_Nearby::NoNearbyTargetFoundErrorText' has a wrong offset!");

// Class Palia.VAl_ChatSettings
// 0x0270 (0x02A8 - 0x0038)
class UVAl_ChatSettings final : public UDeveloperSettings
{
public:
	float                                         RetryLoginIntervalSeconds;                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetryLoginVarianceSeconds;                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetryChannelsIntervalSeconds;                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetryChannelsVarianceSeconds;                      // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SendingWhisperToMutedText;                         // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterMutedText;                                // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterUnmutedText;                              // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterAlreadyUnmutedText;                       // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterAlreadyMutedText;                         // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   MutingSelfText;                                    // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   UnmutingSelfText;                                  // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CharacterNotFoundText;                             // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatRetryingLoginText;                             // 0x0108(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatSendMessagesNotPermittedText;                  // 0x0120(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatCensorFailureText;                             // 0x0138(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatCensorFailureText_PF;                          // 0x0150(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatProfanityFailureText;                          // 0x0168(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ServerTravelDelimiterText;                         // 0x0180(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   ServerTravelWelcomeText;                           // 0x0198(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	int32                                         NumberOfSurroundingMessagesInReport;               // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B87[0x4];                                     // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ChatBubbleWidgetComponentClass;                    // 0x01B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProximityChatDistance;                             // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProximityChatTextUpdateIntervalSeconds;            // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ChatProximityDisallowedText;                       // 0x01E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatProximitySingleCountText;                      // 0x0200(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatProximityPluralCountText;                      // 0x0218(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatProximitySingleCountPayloadText;               // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatProximityPluralCountPayloadText;               // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ServerMaintenanceCountdownText;                    // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ServerMaintenanceUnavailableDateTimeText;          // 0x0278(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	float                                         ServerMaintenanceUpdateTimerIntervalInSeconds;     // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B88[0x4];                                     // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ServerMaintenanceMessageTimespanThreshold;         // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientPlatformChatRestrictionPollIntervalInSeconds; // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B89[0x4];                                     // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAl_ChatSettings">();
	}
	static class UVAl_ChatSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAl_ChatSettings>();
	}
};
static_assert(alignof(UVAl_ChatSettings) == 0x000008, "Wrong alignment on UVAl_ChatSettings");
static_assert(sizeof(UVAl_ChatSettings) == 0x0002A8, "Wrong size on UVAl_ChatSettings");
static_assert(offsetof(UVAl_ChatSettings, RetryLoginIntervalSeconds) == 0x000038, "Member 'UVAl_ChatSettings::RetryLoginIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, RetryLoginVarianceSeconds) == 0x00003C, "Member 'UVAl_ChatSettings::RetryLoginVarianceSeconds' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, RetryChannelsIntervalSeconds) == 0x000040, "Member 'UVAl_ChatSettings::RetryChannelsIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, RetryChannelsVarianceSeconds) == 0x000044, "Member 'UVAl_ChatSettings::RetryChannelsVarianceSeconds' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, SendingWhisperToMutedText) == 0x000048, "Member 'UVAl_ChatSettings::SendingWhisperToMutedText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, CharacterMutedText) == 0x000060, "Member 'UVAl_ChatSettings::CharacterMutedText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, CharacterUnmutedText) == 0x000078, "Member 'UVAl_ChatSettings::CharacterUnmutedText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, CharacterAlreadyUnmutedText) == 0x000090, "Member 'UVAl_ChatSettings::CharacterAlreadyUnmutedText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, CharacterAlreadyMutedText) == 0x0000A8, "Member 'UVAl_ChatSettings::CharacterAlreadyMutedText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, MutingSelfText) == 0x0000C0, "Member 'UVAl_ChatSettings::MutingSelfText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, UnmutingSelfText) == 0x0000D8, "Member 'UVAl_ChatSettings::UnmutingSelfText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, CharacterNotFoundText) == 0x0000F0, "Member 'UVAl_ChatSettings::CharacterNotFoundText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatRetryingLoginText) == 0x000108, "Member 'UVAl_ChatSettings::ChatRetryingLoginText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatSendMessagesNotPermittedText) == 0x000120, "Member 'UVAl_ChatSettings::ChatSendMessagesNotPermittedText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatCensorFailureText) == 0x000138, "Member 'UVAl_ChatSettings::ChatCensorFailureText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatCensorFailureText_PF) == 0x000150, "Member 'UVAl_ChatSettings::ChatCensorFailureText_PF' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatProfanityFailureText) == 0x000168, "Member 'UVAl_ChatSettings::ChatProfanityFailureText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ServerTravelDelimiterText) == 0x000180, "Member 'UVAl_ChatSettings::ServerTravelDelimiterText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ServerTravelWelcomeText) == 0x000198, "Member 'UVAl_ChatSettings::ServerTravelWelcomeText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, NumberOfSurroundingMessagesInReport) == 0x0001B0, "Member 'UVAl_ChatSettings::NumberOfSurroundingMessagesInReport' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatBubbleWidgetComponentClass) == 0x0001B8, "Member 'UVAl_ChatSettings::ChatBubbleWidgetComponentClass' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ProximityChatDistance) == 0x0001E0, "Member 'UVAl_ChatSettings::ProximityChatDistance' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ProximityChatTextUpdateIntervalSeconds) == 0x0001E4, "Member 'UVAl_ChatSettings::ProximityChatTextUpdateIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatProximityDisallowedText) == 0x0001E8, "Member 'UVAl_ChatSettings::ChatProximityDisallowedText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatProximitySingleCountText) == 0x000200, "Member 'UVAl_ChatSettings::ChatProximitySingleCountText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatProximityPluralCountText) == 0x000218, "Member 'UVAl_ChatSettings::ChatProximityPluralCountText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatProximitySingleCountPayloadText) == 0x000230, "Member 'UVAl_ChatSettings::ChatProximitySingleCountPayloadText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ChatProximityPluralCountPayloadText) == 0x000248, "Member 'UVAl_ChatSettings::ChatProximityPluralCountPayloadText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ServerMaintenanceCountdownText) == 0x000260, "Member 'UVAl_ChatSettings::ServerMaintenanceCountdownText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ServerMaintenanceUnavailableDateTimeText) == 0x000278, "Member 'UVAl_ChatSettings::ServerMaintenanceUnavailableDateTimeText' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ServerMaintenanceUpdateTimerIntervalInSeconds) == 0x000290, "Member 'UVAl_ChatSettings::ServerMaintenanceUpdateTimerIntervalInSeconds' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ServerMaintenanceMessageTimespanThreshold) == 0x000298, "Member 'UVAl_ChatSettings::ServerMaintenanceMessageTimespanThreshold' has a wrong offset!");
static_assert(offsetof(UVAl_ChatSettings, ClientPlatformChatRestrictionPollIntervalInSeconds) == 0x0002A0, "Member 'UVAl_ChatSettings::ClientPlatformChatRestrictionPollIntervalInSeconds' has a wrong offset!");

// Class Palia.VAL_ChatLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_ChatLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ChatLibrary">();
	}
	static class UVAL_ChatLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ChatLibrary>();
	}
};
static_assert(alignof(UVAL_ChatLibrary) == 0x000008, "Wrong alignment on UVAL_ChatLibrary");
static_assert(sizeof(UVAL_ChatLibrary) == 0x000028, "Wrong size on UVAL_ChatLibrary");

// Class Palia.VAL_CheatManager
// 0x0000 (0x0088 - 0x0088)
class UVAL_CheatManager final : public UCheatManager
{
public:
	void Crafting_EndAllComplexRecipes();
	void Crafting_EndAllRecipes();
	void Valeria_Character_Export(const class FString& PlayerId);
	void Valeria_Character_Import(const class FString& PlayerId);
	void Valeria_CompleteAllQuests();
	void Valeria_EventsChapaaChaseEnable(bool bEnable);
	void Valeria_EventStart(const class FString& InEventId);
	void Valeria_EventStop(const class FString& InEventId);
	void Valeria_ForceHasSeenAllDialogue();
	void Valeria_HotPotEndGame();
	void Valeria_HotPotStartGame();
	void Valeria_Housing_ChangeHousingPermission(const class FString& Player, const class FString& Permission);
	void Valeria_Housing_ExportHOA(const class FString& HoaID, bool ExportAsNewOwner);
	void Valeria_Housing_ForceLoadHOAToOpenPlot(const class FString& HoaID);
	void Valeria_Housing_LoadCharHomeToOpenPlot(const class FString& PlayerId);
	void Valeria_Housing_LoadTestingSpawnOnHousingPlot(class FName ItemTypeName, int32 Amount);
	void Valeria_Housing_RemoveAllOnHousingPlot(const class FString& IncludeFilter);
	void Valeria_Housing_RespawnInitialPlotFences();
	void Valeria_Housing_TeleportToHousingPlot(const class FString& Dest);
	void Valeria_Housing_TransferHOAToNewHousingPlot(const class FString& PlotName);
	void Valeria_Housing_UnlockAllHousingWrits();
	void Valeria_ReloadAllCustomizationAssets();
	void Valeria_ResetAllShops();
	void Valeria_StartAllQuests();
	void Valeria_VillagerMail_Spoof(const class FString& MailId);

	bool AreCheatsEnabled() const;
	void Valeria_EventStatus(const class FString& InEventId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CheatManager">();
	}
	static class UVAL_CheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CheatManager>();
	}
};
static_assert(alignof(UVAL_CheatManager) == 0x000008, "Wrong alignment on UVAL_CheatManager");
static_assert(sizeof(UVAL_CheatManager) == 0x000088, "Wrong size on UVAL_CheatManager");

// Class Palia.VAL_PremiumStoreRequestGDK
// 0x0068 (0x0090 - 0x0028)
class UVAL_PremiumStoreRequestGDK final : public UObject
{
public:
	uint8                                         Pad_2B8B[0x68];                                    // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PremiumStoreRequestGDK">();
	}
	static class UVAL_PremiumStoreRequestGDK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PremiumStoreRequestGDK>();
	}
};
static_assert(alignof(UVAL_PremiumStoreRequestGDK) == 0x000008, "Wrong alignment on UVAL_PremiumStoreRequestGDK");
static_assert(sizeof(UVAL_PremiumStoreRequestGDK) == 0x000090, "Wrong size on UVAL_PremiumStoreRequestGDK");

// Class Palia.VAL_ContentBatchAsset
// 0x0008 (0x0060 - 0x0058)
class UVAL_ContentBatchAsset final : public UVAL_DataAsset
{
public:
	EBatchAvailability                            Availability;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8C[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TSoftObjectPtr<class UVAL_ContentBatchAsset> GetAssetByName_Cast(class FName& AssetName);
	static TSoftObjectPtr<class UVAL_ContentBatchAsset> GetAssetByPersistId_Cast(int32 PersistIdToGet);
	static TArray<TSoftObjectPtr<class UVAL_ContentBatchAsset>> GetAssetsOfType_Cast();

	bool IsContentBatchEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ContentBatchAsset">();
	}
	static class UVAL_ContentBatchAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ContentBatchAsset>();
	}
};
static_assert(alignof(UVAL_ContentBatchAsset) == 0x000008, "Wrong alignment on UVAL_ContentBatchAsset");
static_assert(sizeof(UVAL_ContentBatchAsset) == 0x000060, "Wrong size on UVAL_ContentBatchAsset");
static_assert(offsetof(UVAL_ContentBatchAsset, Availability) == 0x000058, "Member 'UVAL_ContentBatchAsset::Availability' has a wrong offset!");

// Class Palia.VAL_CorrectionDef
// 0x0040 (0x0098 - 0x0058)
class UVAL_CorrectionDef final : public UVAL_DataAsset
{
public:
	class UVAL_GameplayConditionDef*              ApplicationCondition;                              // 0x0058(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxApplicationCount;                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8E[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestRewardConfig>             Correction;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UVAL_DialogueAsset>> DialoguesToRemove;                                 // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FVAL_VisitCorrection>           VisitsToRemove;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CorrectionDef">();
	}
	static class UVAL_CorrectionDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CorrectionDef>();
	}
};
static_assert(alignof(UVAL_CorrectionDef) == 0x000008, "Wrong alignment on UVAL_CorrectionDef");
static_assert(sizeof(UVAL_CorrectionDef) == 0x000098, "Wrong size on UVAL_CorrectionDef");
static_assert(offsetof(UVAL_CorrectionDef, ApplicationCondition) == 0x000058, "Member 'UVAL_CorrectionDef::ApplicationCondition' has a wrong offset!");
static_assert(offsetof(UVAL_CorrectionDef, MaxApplicationCount) == 0x000060, "Member 'UVAL_CorrectionDef::MaxApplicationCount' has a wrong offset!");
static_assert(offsetof(UVAL_CorrectionDef, Correction) == 0x000068, "Member 'UVAL_CorrectionDef::Correction' has a wrong offset!");
static_assert(offsetof(UVAL_CorrectionDef, DialoguesToRemove) == 0x000078, "Member 'UVAL_CorrectionDef::DialoguesToRemove' has a wrong offset!");
static_assert(offsetof(UVAL_CorrectionDef, VisitsToRemove) == 0x000088, "Member 'UVAL_CorrectionDef::VisitsToRemove' has a wrong offset!");

// Class Palia.VAL_CrafterStatics
// 0x0000 (0x0028 - 0x0028)
class UVAL_CrafterStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool EqualEqual(struct FCrafterConfig& A, struct FCrafterConfig& B);
	static TArray<struct FRecipeConfig> FindAllRecipesProducingItem(class UObject* WorldContextObject, class UVAL_ItemTypeDefinitionAsset* Item, bool bOnlySubRecipes);
	static TSet<struct FCrafterConfig> GetAllowedCrafterConfigsFromRecipe(struct FRecipeConfig& Recipe);
	static TSet<ESkillType> GetAllowedCrafterSkillTypesFromRecipe(struct FRecipeConfig& Recipe);
	static int32 GetComplexIngredientAmount(class AValeriaCharacter* VC, struct FRecipe_RequireItem& Ingredient, bool UseStarQualityIngredient, bool bAllowIntermixingRegularAndStarQualityIngredients);
	static bool GetCrafterRowName(class UDataTable* CrafterConfigsDataTable, struct FCrafterConfig& CrafterConfig, class FName* RowName);
	static int32 GetIngredientAmount(class AValeriaCharacter* VC, struct FRecipe_RequireItem& Ingredient, struct FStarQualityConstraint& StarQualityConstraint);
	static TSet<TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>> GetItemTypesPlayerHasForItemTag(class AValeriaCharacter* VC, struct FGameplayTag& ItemTag, bool UseStarQualityIngredient);
	static bool IsRecipeRequireItemAMatch(struct FRecipe_RequireItem& Lhs, struct FRecipe_RequireItem& Rhs);
	static bool IsRecipeRequireItemItemTypeAMatch(struct FRecipe_RequireItem& RequireItem, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& OtherItemType);
	static bool IsRecipeUnlocked(class UObject* WorldContextObject, int32 RecipePersistId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CrafterStatics">();
	}
	static class UVAL_CrafterStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CrafterStatics>();
	}
};
static_assert(alignof(UVAL_CrafterStatics) == 0x000008, "Wrong alignment on UVAL_CrafterStatics");
static_assert(sizeof(UVAL_CrafterStatics) == 0x000028, "Wrong size on UVAL_CrafterStatics");

// Class Palia.VAL_CustomizableCharacterInterface
// 0x0000 (0x0028 - 0x0028)
class IVAL_CustomizableCharacterInterface final : public IInterface
{
public:
	class UAbilityAnimationComponent* GetAbilityAnimationComponent() const;
	class USkeletalMeshComponent* GetFaceMaskMeshComponent() const;
	class USkeletalMeshComponent* GetFacialHairMeshComponent() const;
	class USkeletalMeshComponent* GetHairMeshComponent() const;
	class USkeletalMeshComponent* GetHatMeshComponent() const;
	class USkeletalMeshComponent* GetHeadMeshComponent() const;
	class USkeletalMeshComponent* GetLegsMeshComponent() const;
	class USkeletalMeshComponent* GetRootSkeletonMeshComponent() const;
	class USkeletalMeshComponent* GetTorsoMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CustomizableCharacterInterface">();
	}
	static class IVAL_CustomizableCharacterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVAL_CustomizableCharacterInterface>();
	}
};
static_assert(alignof(IVAL_CustomizableCharacterInterface) == 0x000008, "Wrong alignment on IVAL_CustomizableCharacterInterface");
static_assert(sizeof(IVAL_CustomizableCharacterInterface) == 0x000028, "Wrong size on IVAL_CustomizableCharacterInterface");

// Class Palia.VAL_PremiumStoreRequestPC
// 0x0068 (0x0090 - 0x0028)
class UVAL_PremiumStoreRequestPC : public UObject
{
public:
	uint8                                         Pad_2B98[0x68];                                    // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PremiumStoreRequestPC">();
	}
	static class UVAL_PremiumStoreRequestPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PremiumStoreRequestPC>();
	}
};
static_assert(alignof(UVAL_PremiumStoreRequestPC) == 0x000008, "Wrong alignment on UVAL_PremiumStoreRequestPC");
static_assert(sizeof(UVAL_PremiumStoreRequestPC) == 0x000090, "Wrong size on UVAL_PremiumStoreRequestPC");

// Class Palia.VAL_PremiumStoreRequestSteam
// 0x0010 (0x00A0 - 0x0090)
class UVAL_PremiumStoreRequestSteam final : public UVAL_PremiumStoreRequestPC
{
public:
	uint8                                         Pad_2B99[0x8];                                     // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_PremiumStoreSubsystem*             CachedPremiumStoreSubsystem;                       // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleOnMicrotransactionComplete(uint32 AppID, uint64 OrderId, bool bAuthorized);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PremiumStoreRequestSteam">();
	}
	static class UVAL_PremiumStoreRequestSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PremiumStoreRequestSteam>();
	}
};
static_assert(alignof(UVAL_PremiumStoreRequestSteam) == 0x000008, "Wrong alignment on UVAL_PremiumStoreRequestSteam");
static_assert(sizeof(UVAL_PremiumStoreRequestSteam) == 0x0000A0, "Wrong size on UVAL_PremiumStoreRequestSteam");
static_assert(offsetof(UVAL_PremiumStoreRequestSteam, CachedPremiumStoreSubsystem) == 0x000098, "Member 'UVAL_PremiumStoreRequestSteam::CachedPremiumStoreSubsystem' has a wrong offset!");

// Class Palia.VAL_CustomizationItemAnimInstance
// 0x0000 (0x0350 - 0x0350)
class UVAL_CustomizationItemAnimInstance final : public UAnimInstance
{
public:
	class UVAL_ValeriaBaseAnimInstance*           ValeriaBaseAnimInstance;                           // 0x0348(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_CustomizationItemAnimInstance">();
	}
	static class UVAL_CustomizationItemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_CustomizationItemAnimInstance>();
	}
};
static_assert(alignof(UVAL_CustomizationItemAnimInstance) == 0x000010, "Wrong alignment on UVAL_CustomizationItemAnimInstance");
static_assert(sizeof(UVAL_CustomizationItemAnimInstance) == 0x000350, "Wrong size on UVAL_CustomizationItemAnimInstance");
static_assert(offsetof(UVAL_CustomizationItemAnimInstance, ValeriaBaseAnimInstance) == 0x000348, "Member 'UVAL_CustomizationItemAnimInstance::ValeriaBaseAnimInstance' has a wrong offset!");

// Class Palia.VAL_DataTableDirectoryByRowType
// 0x0058 (0x0088 - 0x0030)
class UVAL_DataTableDirectoryByRowType final : public UDataAsset
{
public:
	class FName                                   PrimaryDirectoryUsage;                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UScriptStruct*, struct FSoftTableList> Mappings;                                          // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DataTableDirectoryByRowType">();
	}
	static class UVAL_DataTableDirectoryByRowType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DataTableDirectoryByRowType>();
	}
};
static_assert(alignof(UVAL_DataTableDirectoryByRowType) == 0x000008, "Wrong alignment on UVAL_DataTableDirectoryByRowType");
static_assert(sizeof(UVAL_DataTableDirectoryByRowType) == 0x000088, "Wrong size on UVAL_DataTableDirectoryByRowType");
static_assert(offsetof(UVAL_DataTableDirectoryByRowType, PrimaryDirectoryUsage) == 0x000030, "Member 'UVAL_DataTableDirectoryByRowType::PrimaryDirectoryUsage' has a wrong offset!");
static_assert(offsetof(UVAL_DataTableDirectoryByRowType, Mappings) == 0x000038, "Member 'UVAL_DataTableDirectoryByRowType::Mappings' has a wrong offset!");

// Class Palia.VAL_DialogueAsset
// 0x0238 (0x02B8 - 0x0080)
class UVAL_DialogueAsset final : public UVAL_BatchedDataAsset
{
public:
	bool                                          bDisabled;                                         // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDialogueType                                 DialogueType;                                      // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlavorDialogue;                                   // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9C[0x5];                                     // 0x0083(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogueRequirements                  Requirements;                                      // 0x0088(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UVAL_DialogueSpeakerAsset*              DialogueSpeaker;                                   // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDialogueSpeakerOwnership>      AdditionalDialogueSpeakers;                        // 0x01B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    VillagerConfig;                                    // 0x01C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   VillagerName;                                      // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Grouping;                                          // 0x01E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipOncePerDayGroupingRestriction;                // 0x01E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9D[0x7];                                     // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDialogueLine>                  Scripts;                                           // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FConditionalDialogueScriptConfig> ConditionalScripts;                                // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   OptionButtonText;                                  // 0x0210(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FQuestRewardConfig>             Rewards;                                           // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsStartupDialogue;                                // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyShowOnce;                                     // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCancelDialogue;                                // 0x023A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEndConversation;                             // 0x023B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenStore;                                        // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9E[0x3];                                     // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeleportTravelConfigAsset*             TeleportTravelConfigAsset;                         // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          LevelSequenceAsset;                                // 0x0248(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCinematicSequenceConfig*               CinematicConfigAsset;                              // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackOnCompass;                                   // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9F[0x7];                                     // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UVAL_DialogueAsset>> DialogueOptions;                                   // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FPersistentTagWriteback>        PlayerTagWriteback;                                // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVillagerQuestItemReqSubConfig> ItemRemovalOnCompletion;                           // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EVillagerDialogueIcon                         DialogueIcon;                                      // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA0[0x7];                                     // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TSoftObjectPtr<class UVAL_DialogueAsset> GetAssetByName_Cast(class FName& AssetName);
	static TSoftObjectPtr<class UVAL_DialogueAsset> GetAssetByPersistId_Cast(int32 PersistIdToGet);
	static TArray<TSoftObjectPtr<class UVAL_DialogueAsset>> GetAssetsOfType_Cast();

	bool CanContinueConversation() const;
	TArray<class UVAL_DialogueSpeakerAsset*> GetAllDialogueOwners(bool bIncludePrimaryOwner) const;
	TArray<class UVAL_DialogueSpeakerAsset*> GetCharacters(bool bOnlyCheckVillagers) const;
	void GetDialogueOptionButtonTooltipSettings(bool* bOutShouldShowTooltip, class FText* OutTooltipText) const;
	class FName GetSpeakerName() const;
	int32 GetSpeakerPersistId() const;
	TArray<TSoftClassPtr<class UClass>> GetVillagersToLoad() const;
	bool HasAssociatedDialogueOptions() const;
	bool HasMultipleCharacters(bool bOnlyCheckVillagers) const;
	bool HasMultipleDialogueOwners() const;
	bool IsDisabled() const;
	bool IsEligibleForTrackableCache() const;
	bool IsEnabledForCharacter(class AValeriaCharacter* VC) const;
	bool IsLowStakes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DialogueAsset">();
	}
	static class UVAL_DialogueAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DialogueAsset>();
	}
};
static_assert(alignof(UVAL_DialogueAsset) == 0x000008, "Wrong alignment on UVAL_DialogueAsset");
static_assert(sizeof(UVAL_DialogueAsset) == 0x0002B8, "Wrong size on UVAL_DialogueAsset");
static_assert(offsetof(UVAL_DialogueAsset, bDisabled) == 0x000080, "Member 'UVAL_DialogueAsset::bDisabled' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, DialogueType) == 0x000081, "Member 'UVAL_DialogueAsset::DialogueType' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, bFlavorDialogue) == 0x000082, "Member 'UVAL_DialogueAsset::bFlavorDialogue' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, Requirements) == 0x000088, "Member 'UVAL_DialogueAsset::Requirements' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, DialogueSpeaker) == 0x0001B0, "Member 'UVAL_DialogueAsset::DialogueSpeaker' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, AdditionalDialogueSpeakers) == 0x0001B8, "Member 'UVAL_DialogueAsset::AdditionalDialogueSpeakers' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, VillagerConfig) == 0x0001C8, "Member 'UVAL_DialogueAsset::VillagerConfig' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, VillagerName) == 0x0001D8, "Member 'UVAL_DialogueAsset::VillagerName' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, Grouping) == 0x0001E0, "Member 'UVAL_DialogueAsset::Grouping' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, bSkipOncePerDayGroupingRestriction) == 0x0001E8, "Member 'UVAL_DialogueAsset::bSkipOncePerDayGroupingRestriction' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, Scripts) == 0x0001F0, "Member 'UVAL_DialogueAsset::Scripts' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, ConditionalScripts) == 0x000200, "Member 'UVAL_DialogueAsset::ConditionalScripts' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, OptionButtonText) == 0x000210, "Member 'UVAL_DialogueAsset::OptionButtonText' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, Rewards) == 0x000228, "Member 'UVAL_DialogueAsset::Rewards' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, bIsStartupDialogue) == 0x000238, "Member 'UVAL_DialogueAsset::bIsStartupDialogue' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, bOnlyShowOnce) == 0x000239, "Member 'UVAL_DialogueAsset::bOnlyShowOnce' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, bCanCancelDialogue) == 0x00023A, "Member 'UVAL_DialogueAsset::bCanCancelDialogue' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, bForceEndConversation) == 0x00023B, "Member 'UVAL_DialogueAsset::bForceEndConversation' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, bOpenStore) == 0x00023C, "Member 'UVAL_DialogueAsset::bOpenStore' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, TeleportTravelConfigAsset) == 0x000240, "Member 'UVAL_DialogueAsset::TeleportTravelConfigAsset' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, LevelSequenceAsset) == 0x000248, "Member 'UVAL_DialogueAsset::LevelSequenceAsset' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, CinematicConfigAsset) == 0x000270, "Member 'UVAL_DialogueAsset::CinematicConfigAsset' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, bTrackOnCompass) == 0x000278, "Member 'UVAL_DialogueAsset::bTrackOnCompass' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, DialogueOptions) == 0x000280, "Member 'UVAL_DialogueAsset::DialogueOptions' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, PlayerTagWriteback) == 0x000290, "Member 'UVAL_DialogueAsset::PlayerTagWriteback' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, ItemRemovalOnCompletion) == 0x0002A0, "Member 'UVAL_DialogueAsset::ItemRemovalOnCompletion' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueAsset, DialogueIcon) == 0x0002B0, "Member 'UVAL_DialogueAsset::DialogueIcon' has a wrong offset!");

// Class Palia.VAL_DialogueRoom
// 0x0070 (0x0318 - 0x02A8)
class AVAL_DialogueRoom : public AActor
{
public:
	class USceneComponent*                        DialogueRoomSceneRootComponent;                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   FloorMesh;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BackgroundWallMesh;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   TP_SpawnPoint1;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   TP_SpawnPoint2;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   TP_PlayerPoint;                                    // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDialogueRoomParameters                DialogueRoomParameters;                            // 0x02D8(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class AValeriaTargetPoint*>            TargetPoints;                                      // 0x0308(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_DialogueRoomParameters();

	class AValeriaTargetPoint* GetTargetPoint(class FName& InTargetPointName) const;
	TArray<class AValeriaTargetPoint*> GetTargetPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DialogueRoom">();
	}
	static class AVAL_DialogueRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_DialogueRoom>();
	}
};
static_assert(alignof(AVAL_DialogueRoom) == 0x000008, "Wrong alignment on AVAL_DialogueRoom");
static_assert(sizeof(AVAL_DialogueRoom) == 0x000318, "Wrong size on AVAL_DialogueRoom");
static_assert(offsetof(AVAL_DialogueRoom, DialogueRoomSceneRootComponent) == 0x0002A8, "Member 'AVAL_DialogueRoom::DialogueRoomSceneRootComponent' has a wrong offset!");
static_assert(offsetof(AVAL_DialogueRoom, FloorMesh) == 0x0002B0, "Member 'AVAL_DialogueRoom::FloorMesh' has a wrong offset!");
static_assert(offsetof(AVAL_DialogueRoom, BackgroundWallMesh) == 0x0002B8, "Member 'AVAL_DialogueRoom::BackgroundWallMesh' has a wrong offset!");
static_assert(offsetof(AVAL_DialogueRoom, TP_SpawnPoint1) == 0x0002C0, "Member 'AVAL_DialogueRoom::TP_SpawnPoint1' has a wrong offset!");
static_assert(offsetof(AVAL_DialogueRoom, TP_SpawnPoint2) == 0x0002C8, "Member 'AVAL_DialogueRoom::TP_SpawnPoint2' has a wrong offset!");
static_assert(offsetof(AVAL_DialogueRoom, TP_PlayerPoint) == 0x0002D0, "Member 'AVAL_DialogueRoom::TP_PlayerPoint' has a wrong offset!");
static_assert(offsetof(AVAL_DialogueRoom, DialogueRoomParameters) == 0x0002D8, "Member 'AVAL_DialogueRoom::DialogueRoomParameters' has a wrong offset!");
static_assert(offsetof(AVAL_DialogueRoom, TargetPoints) == 0x000308, "Member 'AVAL_DialogueRoom::TargetPoints' has a wrong offset!");

// Class Palia.VAL_QuestFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_QuestFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesQuestGoalRequireStarQuality(struct FVAL_QuestGoalState& GoalState);
	static bool DoesQuestStepHaveVisibleBranchingGoals(struct FVAL_QuestStepDef& QuestStepDef);
	static void GetCurrentQuestStep(struct FVAL_QuestState& QuestState, struct FVAL_QuestStepState* QuestStepState, bool* bFoundQuestStep);
	static void GetCurrentQuestStepDefinition(struct FVAL_QuestState& QuestState, struct FVAL_QuestStepDef* QuestStepDef, bool* bFoundQuestStep);
	static class FText GetQuestDescription(struct FVAL_QuestState& QuestState);
	static const struct FVAL_QuestGoalDef GetQuestGoalDefinition(struct FVAL_QuestGoalState& QuestGoalState);
	static class FText GetQuestGoalDescription(struct FVAL_QuestGoalState& GoalState, class AValeriaCharacter* ValeriaCharacter);
	static TSoftObjectPtr<class UTexture2D> GetQuestGoalIcon(struct FVAL_QuestGoalState& GoalState);
	static class FText GetQuestTitle(struct FVAL_QuestState& QuestState);
	static bool IsQuestCompleted(struct FVAL_QuestState& QuestState);
	static TArray<struct FVAL_QuestState> SortMainQuestsToBeginning(TArray<struct FVAL_QuestState>& QuestArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_QuestFunctionLibrary">();
	}
	static class UVAL_QuestFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_QuestFunctionLibrary>();
	}
};
static_assert(alignof(UVAL_QuestFunctionLibrary) == 0x000008, "Wrong alignment on UVAL_QuestFunctionLibrary");
static_assert(sizeof(UVAL_QuestFunctionLibrary) == 0x000028, "Wrong size on UVAL_QuestFunctionLibrary");

// Class Palia.VAL_DialogueRoomManagerComponent
// 0x0038 (0x00D8 - 0x00A0)
class UVAL_DialogueRoomManagerComponent final : public UActorComponent
{
public:
	TSubclassOf<class AVAL_DialogueRoom>          DialogueRoomClass;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AS6WorldPartitionStreamer>  WorldPartitionStreamerClass;                       // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AValeriaPlayerController*               OwningPlayerController;                            // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AS6WorldPartitionStreamer*              ActiveWorldPartitionStreamer;                      // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVAL_DialogueRoom*                      ActiveDialogueRoom;                                // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AValeriaVillagerCharacter>> ActiveDialogueRoomVillagers;                       // 0x00C8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void DialogueExited(class UDialogueComponent* DialogueComponent, class AValeriaCharacter* Player);
	void DialogueRoomVillagerSpawned(class AValeriaVillagerCharacter* SpawnedVillager, const struct FGuid& InstigatorGuid);
	void PostDialogueRoomVillagerSpawned(class AValeriaVillagerCharacter* SpawnedVillager);
	void RpcClient_CreateWorldPartitionStreamer(class AValeriaCharacter* InOwningCharacter);
	void RpcClient_DestroyWorldPartitionStreamer();
	void RpcServer_TryCreateDialogueRoom(class UPrivateSpaceConfig* InPrivateSpaceConfig, TArray<struct FPrivateSpaceScheduledVillagerDialogueRoomSpawnInfo>& InDialogueRoomSpawnInfos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DialogueRoomManagerComponent">();
	}
	static class UVAL_DialogueRoomManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DialogueRoomManagerComponent>();
	}
};
static_assert(alignof(UVAL_DialogueRoomManagerComponent) == 0x000008, "Wrong alignment on UVAL_DialogueRoomManagerComponent");
static_assert(sizeof(UVAL_DialogueRoomManagerComponent) == 0x0000D8, "Wrong size on UVAL_DialogueRoomManagerComponent");
static_assert(offsetof(UVAL_DialogueRoomManagerComponent, DialogueRoomClass) == 0x0000A0, "Member 'UVAL_DialogueRoomManagerComponent::DialogueRoomClass' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueRoomManagerComponent, WorldPartitionStreamerClass) == 0x0000A8, "Member 'UVAL_DialogueRoomManagerComponent::WorldPartitionStreamerClass' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueRoomManagerComponent, OwningPlayerController) == 0x0000B0, "Member 'UVAL_DialogueRoomManagerComponent::OwningPlayerController' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueRoomManagerComponent, ActiveWorldPartitionStreamer) == 0x0000B8, "Member 'UVAL_DialogueRoomManagerComponent::ActiveWorldPartitionStreamer' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueRoomManagerComponent, ActiveDialogueRoom) == 0x0000C0, "Member 'UVAL_DialogueRoomManagerComponent::ActiveDialogueRoom' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueRoomManagerComponent, ActiveDialogueRoomVillagers) == 0x0000C8, "Member 'UVAL_DialogueRoomManagerComponent::ActiveDialogueRoomVillagers' has a wrong offset!");

// Class Palia.VAL_DialogueRoomSettings
// 0x0038 (0x0070 - 0x0038)
class UVAL_DialogueRoomSettings final : public UDeveloperSettings
{
public:
	struct FVector                                BaseSpawnOffset;                                   // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnSeparation;                                   // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractionTeleporterCheckQuestValidityForDialogueRoomInteraction; // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BAB[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DialogueRoomSettings">();
	}
	static class UVAL_DialogueRoomSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DialogueRoomSettings>();
	}
};
static_assert(alignof(UVAL_DialogueRoomSettings) == 0x000008, "Wrong alignment on UVAL_DialogueRoomSettings");
static_assert(sizeof(UVAL_DialogueRoomSettings) == 0x000070, "Wrong size on UVAL_DialogueRoomSettings");
static_assert(offsetof(UVAL_DialogueRoomSettings, BaseSpawnOffset) == 0x000038, "Member 'UVAL_DialogueRoomSettings::BaseSpawnOffset' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueRoomSettings, SpawnSeparation) == 0x000050, "Member 'UVAL_DialogueRoomSettings::SpawnSeparation' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueRoomSettings, bInteractionTeleporterCheckQuestValidityForDialogueRoomInteraction) == 0x000068, "Member 'UVAL_DialogueRoomSettings::bInteractionTeleporterCheckQuestValidityForDialogueRoomInteraction' has a wrong offset!");

// Class Palia.VAL_DialogueSpeakerAsset
// 0x0068 (0x00C0 - 0x0058)
class UVAL_DialogueSpeakerAsset final : public UVAL_DataAsset
{
public:
	bool                                          bVillager;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BAC[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    VillagerConfig;                                    // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   SpeakerName;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   SpeakerDisplayName;                                // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ETextGender                                   SpeakerGender;                                     // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BAD[0x7];                                     // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              SpeakerIcon;                                       // 0x0098(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static TSoftObjectPtr<class UVAL_DialogueSpeakerAsset> GetAssetByName_Cast(class FName& AssetName);
	static TSoftObjectPtr<class UVAL_DialogueSpeakerAsset> GetAssetByPersistId_Cast(int32 PersistIdToGet);
	static TArray<TSoftObjectPtr<class UVAL_DialogueSpeakerAsset>> GetAssetsOfType_Cast();

	ETextGender GetGender() const;
	TSoftObjectPtr<class UTexture2D> GetSpeakerIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_DialogueSpeakerAsset">();
	}
	static class UVAL_DialogueSpeakerAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_DialogueSpeakerAsset>();
	}
};
static_assert(alignof(UVAL_DialogueSpeakerAsset) == 0x000008, "Wrong alignment on UVAL_DialogueSpeakerAsset");
static_assert(sizeof(UVAL_DialogueSpeakerAsset) == 0x0000C0, "Wrong size on UVAL_DialogueSpeakerAsset");
static_assert(offsetof(UVAL_DialogueSpeakerAsset, bVillager) == 0x000058, "Member 'UVAL_DialogueSpeakerAsset::bVillager' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueSpeakerAsset, VillagerConfig) == 0x000060, "Member 'UVAL_DialogueSpeakerAsset::VillagerConfig' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueSpeakerAsset, SpeakerName) == 0x000070, "Member 'UVAL_DialogueSpeakerAsset::SpeakerName' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueSpeakerAsset, SpeakerDisplayName) == 0x000078, "Member 'UVAL_DialogueSpeakerAsset::SpeakerDisplayName' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueSpeakerAsset, SpeakerGender) == 0x000090, "Member 'UVAL_DialogueSpeakerAsset::SpeakerGender' has a wrong offset!");
static_assert(offsetof(UVAL_DialogueSpeakerAsset, SpeakerIcon) == 0x000098, "Member 'UVAL_DialogueSpeakerAsset::SpeakerIcon' has a wrong offset!");

// Class Palia.VAL_EmergencyContentKillSwitchSettings
// 0x0190 (0x01C8 - 0x0038)
class UVAL_EmergencyContentKillSwitchSettings final : public UDeveloperSettings
{
public:
	TSet<int32>                                   DialoguesToDisable;                                // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TSet<int32>                                   MailMessagesToDisable;                             // 0x0088(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TSet<int32>                                   QuestsToDisable;                                   // 0x00D8(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TSet<struct FGuid>                            VisitsToDisable;                                   // 0x0128(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TSet<int32>                                   ContentBatchesToDisable;                           // 0x0178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EmergencyContentKillSwitchSettings">();
	}
	static class UVAL_EmergencyContentKillSwitchSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_EmergencyContentKillSwitchSettings>();
	}
};
static_assert(alignof(UVAL_EmergencyContentKillSwitchSettings) == 0x000008, "Wrong alignment on UVAL_EmergencyContentKillSwitchSettings");
static_assert(sizeof(UVAL_EmergencyContentKillSwitchSettings) == 0x0001C8, "Wrong size on UVAL_EmergencyContentKillSwitchSettings");
static_assert(offsetof(UVAL_EmergencyContentKillSwitchSettings, DialoguesToDisable) == 0x000038, "Member 'UVAL_EmergencyContentKillSwitchSettings::DialoguesToDisable' has a wrong offset!");
static_assert(offsetof(UVAL_EmergencyContentKillSwitchSettings, MailMessagesToDisable) == 0x000088, "Member 'UVAL_EmergencyContentKillSwitchSettings::MailMessagesToDisable' has a wrong offset!");
static_assert(offsetof(UVAL_EmergencyContentKillSwitchSettings, QuestsToDisable) == 0x0000D8, "Member 'UVAL_EmergencyContentKillSwitchSettings::QuestsToDisable' has a wrong offset!");
static_assert(offsetof(UVAL_EmergencyContentKillSwitchSettings, VisitsToDisable) == 0x000128, "Member 'UVAL_EmergencyContentKillSwitchSettings::VisitsToDisable' has a wrong offset!");
static_assert(offsetof(UVAL_EmergencyContentKillSwitchSettings, ContentBatchesToDisable) == 0x000178, "Member 'UVAL_EmergencyContentKillSwitchSettings::ContentBatchesToDisable' has a wrong offset!");

// Class Palia.VAL_SequencerFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_SequencerFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BindPlayerToSequence(class UObject* Context, class ALevelSequenceActor* Sequence, class AValeriaCharacter* Character);
	static void UnBindPlayerToSequence(class UObject* Context, class ALevelSequenceActor* Sequence, class AValeriaCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_SequencerFunctionLibrary">();
	}
	static class UVAL_SequencerFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_SequencerFunctionLibrary>();
	}
};
static_assert(alignof(UVAL_SequencerFunctionLibrary) == 0x000008, "Wrong alignment on UVAL_SequencerFunctionLibrary");
static_assert(sizeof(UVAL_SequencerFunctionLibrary) == 0x000028, "Wrong size on UVAL_SequencerFunctionLibrary");

// Class Palia.VAL_EmoteLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_EmoteLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetAllEmotes(TArray<TSoftObjectPtr<class UEmoteDataAsset>>* AllEmotes);
	static void GetAllEmotesMapped(TMap<struct FGuid, TSoftObjectPtr<class UEmoteDataAsset>>* AllEmotes);
	static class UEmoteDataAsset* GetEmoteById(struct FGuid& EmoteId);
	static void GetEmoteCollection(TArray<TSoftObjectPtr<class UEmoteDataAsset>>* EmoteCollection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EmoteLibrary">();
	}
	static class UVAL_EmoteLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_EmoteLibrary>();
	}
};
static_assert(alignof(UVAL_EmoteLibrary) == 0x000008, "Wrong alignment on UVAL_EmoteLibrary");
static_assert(sizeof(UVAL_EmoteLibrary) == 0x000028, "Wrong size on UVAL_EmoteLibrary");

// Class Palia.VAL_EncyclopediaManagerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UVAL_EncyclopediaManagerComponent final : public UActorComponent
{
public:
	void MarkCreatureAsSeen(struct FCreatureConfig& Creature);
	void MarkFishAsSeen(struct FFishConfig& Fish, bool bStarQuality);
	void MarkInsectAsSeen(class UVAL_ItemTypeDefinitionAsset* ItemType, bool bStarQuality);
	void MarkItemAsConsumed(class UVAL_ItemTypeDefinitionAsset* ItemType, bool bStarQuality);
	void MarkItemAsPurchased(class UVAL_ItemTypeDefinitionAsset* ItemType, bool bStarQuality);
	void MarkItemAsSeen(class UVAL_ItemTypeDefinitionAsset* ItemType, bool bStarQuality);
	void MarkRecipeItemsAsSeen(struct FRecipeConfig& Recipe);

	bool HasConsumedItem(class UVAL_ItemTypeDefinitionAsset* ItemType, bool bStarQuality) const;
	bool HasPurchasedItem(class UVAL_ItemTypeDefinitionAsset* ItemType, bool bStarQuality) const;
	bool HasSeenCreature(struct FCreatureConfig& Creature) const;
	bool HasSeenFish(struct FFishConfig& Fish, bool bStarQuality) const;
	bool HasSeenInsect(class UVAL_ItemTypeDefinitionAsset* ItemType, bool bStarQuality) const;
	bool HasSeenItem(class UVAL_ItemTypeDefinitionAsset* ItemType, bool bStarQuality) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EncyclopediaManagerComponent">();
	}
	static class UVAL_EncyclopediaManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_EncyclopediaManagerComponent>();
	}
};
static_assert(alignof(UVAL_EncyclopediaManagerComponent) == 0x000008, "Wrong alignment on UVAL_EncyclopediaManagerComponent");
static_assert(sizeof(UVAL_EncyclopediaManagerComponent) == 0x0000A0, "Wrong size on UVAL_EncyclopediaManagerComponent");

// Class Palia.VAL_EntitlementComponent
// 0x0198 (0x0238 - 0x00A0)
class UVAL_EntitlementComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnEntitlementsUpdated;                             // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEntitlementsSeenUpdated;                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MinSecondsBetweenSyncs;                            // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BBA[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVAL_EntitlementCollection             EntitlementCollection;                             // 0x00C8(0x0118)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FVALDATA_PremiumStoreEntitlements      EntitlementBlock;                                  // 0x01E0(0x0050)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BBB[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_EntitlementBlock();
	void OnRep_EntitlementCollection();
	void RpcServer_MarkEntitlementSeen(bool bSeen, struct FGuid& Entitlement);
	void RpcServer_ResyncEntitlements();

	const TArray<struct FVAL_EntitlementItemEntry> GetEntitlements() const;
	bool HasEntitlement(struct FGuid& Entitlement) const;
	bool WasEntitlementSeen(struct FGuid& Entitlement) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EntitlementComponent">();
	}
	static class UVAL_EntitlementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_EntitlementComponent>();
	}
};
static_assert(alignof(UVAL_EntitlementComponent) == 0x000008, "Wrong alignment on UVAL_EntitlementComponent");
static_assert(sizeof(UVAL_EntitlementComponent) == 0x000238, "Wrong size on UVAL_EntitlementComponent");
static_assert(offsetof(UVAL_EntitlementComponent, OnEntitlementsUpdated) == 0x0000A0, "Member 'UVAL_EntitlementComponent::OnEntitlementsUpdated' has a wrong offset!");
static_assert(offsetof(UVAL_EntitlementComponent, OnEntitlementsSeenUpdated) == 0x0000B0, "Member 'UVAL_EntitlementComponent::OnEntitlementsSeenUpdated' has a wrong offset!");
static_assert(offsetof(UVAL_EntitlementComponent, MinSecondsBetweenSyncs) == 0x0000C0, "Member 'UVAL_EntitlementComponent::MinSecondsBetweenSyncs' has a wrong offset!");
static_assert(offsetof(UVAL_EntitlementComponent, EntitlementCollection) == 0x0000C8, "Member 'UVAL_EntitlementComponent::EntitlementCollection' has a wrong offset!");
static_assert(offsetof(UVAL_EntitlementComponent, EntitlementBlock) == 0x0001E0, "Member 'UVAL_EntitlementComponent::EntitlementBlock' has a wrong offset!");

// Class Palia.VAL_EntitlementSubsystem
// 0x0068 (0x0098 - 0x0030)
class UVAL_EntitlementSubsystem final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnEntitlementsUpdated;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BBF[0x58];                                    // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEntitlementsUpdated__DelegateSignature(TSet<struct FGuid>& Entitlements);
	void SyncEntitlements();

	const TSet<struct FGuid> GetEntitlements() const;
	bool HasEntitlement(struct FGuid& Entitlement) const;
	bool IsEntitlementsLoaded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EntitlementSubsystem">();
	}
	static class UVAL_EntitlementSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_EntitlementSubsystem>();
	}
};
static_assert(alignof(UVAL_EntitlementSubsystem) == 0x000008, "Wrong alignment on UVAL_EntitlementSubsystem");
static_assert(sizeof(UVAL_EntitlementSubsystem) == 0x000098, "Wrong size on UVAL_EntitlementSubsystem");
static_assert(offsetof(UVAL_EntitlementSubsystem, OnEntitlementsUpdated) == 0x000030, "Member 'UVAL_EntitlementSubsystem::OnEntitlementsUpdated' has a wrong offset!");

// Class Palia.VAL_EnvironmentBoundary
// 0x0078 (0x0358 - 0x02E0)
class AVAL_EnvironmentBoundary final : public AVolume
{
public:
	float                                         TransitionBlendDuration;                           // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride_StaticEnvironmentProfile;                // 0x02E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC1[0x3];                                     // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVAL_EnvironmentProfile> StaticEnvironmentProfile;                          // 0x02E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC2[0x4];                                     // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_EnvironmentProfileSet*             EnvironmentProfileSet;                             // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC3[0x38];                                    // 0x0320(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	bool IsStaticBoundary();
	void VAL_EnterEnvBoundary__DelegateSignature(class AVAL_EnvironmentBoundary* EnvBoundary);
	void VAL_ExitEnvBoundary__DelegateSignature(class AVAL_EnvironmentBoundary* EnvBoundary);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EnvironmentBoundary">();
	}
	static class AVAL_EnvironmentBoundary* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_EnvironmentBoundary>();
	}
};
static_assert(alignof(AVAL_EnvironmentBoundary) == 0x000008, "Wrong alignment on AVAL_EnvironmentBoundary");
static_assert(sizeof(AVAL_EnvironmentBoundary) == 0x000358, "Wrong size on AVAL_EnvironmentBoundary");
static_assert(offsetof(AVAL_EnvironmentBoundary, TransitionBlendDuration) == 0x0002E0, "Member 'AVAL_EnvironmentBoundary::TransitionBlendDuration' has a wrong offset!");
static_assert(offsetof(AVAL_EnvironmentBoundary, bOverride_StaticEnvironmentProfile) == 0x0002E4, "Member 'AVAL_EnvironmentBoundary::bOverride_StaticEnvironmentProfile' has a wrong offset!");
static_assert(offsetof(AVAL_EnvironmentBoundary, StaticEnvironmentProfile) == 0x0002E8, "Member 'AVAL_EnvironmentBoundary::StaticEnvironmentProfile' has a wrong offset!");
static_assert(offsetof(AVAL_EnvironmentBoundary, Priority) == 0x000310, "Member 'AVAL_EnvironmentBoundary::Priority' has a wrong offset!");
static_assert(offsetof(AVAL_EnvironmentBoundary, EnvironmentProfileSet) == 0x000318, "Member 'AVAL_EnvironmentBoundary::EnvironmentProfileSet' has a wrong offset!");

// Class Palia.VAL_EnvironmentProfileSet
// 0x0020 (0x0050 - 0x0030)
class UVAL_EnvironmentProfileSet final : public UDataAsset
{
public:
	bool                                          bDefaultProfile;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC6[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_SunSettings*                       DefaultProfileSunSettings;                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVAL_ProfKey>                   EnvProfKeys;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	TArray<TSoftObjectPtr<class UVAL_EnvironmentProfile>> GetSoftEnvProfs();
	void RepopulateEnvironmentProfileSet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EnvironmentProfileSet">();
	}
	static class UVAL_EnvironmentProfileSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_EnvironmentProfileSet>();
	}
};
static_assert(alignof(UVAL_EnvironmentProfileSet) == 0x000008, "Wrong alignment on UVAL_EnvironmentProfileSet");
static_assert(sizeof(UVAL_EnvironmentProfileSet) == 0x000050, "Wrong size on UVAL_EnvironmentProfileSet");
static_assert(offsetof(UVAL_EnvironmentProfileSet, bDefaultProfile) == 0x000030, "Member 'UVAL_EnvironmentProfileSet::bDefaultProfile' has a wrong offset!");
static_assert(offsetof(UVAL_EnvironmentProfileSet, DefaultProfileSunSettings) == 0x000038, "Member 'UVAL_EnvironmentProfileSet::DefaultProfileSunSettings' has a wrong offset!");
static_assert(offsetof(UVAL_EnvironmentProfileSet, EnvProfKeys) == 0x000040, "Member 'UVAL_EnvironmentProfileSet::EnvProfKeys' has a wrong offset!");

// Class Palia.VAL_EventBusViaChatSubsystem
// 0x0068 (0x0098 - 0x0030)
class UVAL_EventBusViaChatSubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_2BC7[0x68];                                    // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleReceivedControlMessage(struct FControlMessage& ControlMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_EventBusViaChatSubsystem">();
	}
	static class UVAL_EventBusViaChatSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_EventBusViaChatSubsystem>();
	}
};
static_assert(alignof(UVAL_EventBusViaChatSubsystem) == 0x000008, "Wrong alignment on UVAL_EventBusViaChatSubsystem");
static_assert(sizeof(UVAL_EventBusViaChatSubsystem) == 0x000098, "Wrong size on UVAL_EventBusViaChatSubsystem");

// Class Palia.VAL_FriendsManager
// 0x00A0 (0x00D0 - 0x0030)
class UVAL_FriendsManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnRelationshipsChanged;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFriendRequestReceived;                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFriendRequestAccepted;                           // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFriendRequestFailed;                             // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterBlocked;                                // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterBlockListChanged;                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC8[0x40];                                    // 0x0090(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterBlocked__DelegateSignature(struct FUniqueNetIdRepl& BlockedNetId, bool bBlocked);
	void OnCharacterBlockListChanged__DelegateSignature(TSet<struct FUniqueNetIdRepl>& BlockedUsers);
	void OnFriendRequestAccepted__DelegateSignature(const struct FUniqueNetIdRepl& OtherUserId);
	void OnFriendRequestFailed__DelegateSignature(const struct FUniqueNetIdRepl& OtherUserId, const class FString& ErrorMsg);
	void OnFriendRequestReceived__DelegateSignature(const struct FUniqueNetIdRepl& OtherUserId);
	void OnRelationshipsChanged__DelegateSignature(const TSet<struct FUniqueNetIdRepl>& PlayerCharacterIds);
	void OnRequestFriendshipWithPlayerFailed__DelegateSignature(const struct FUniqueNetIdRepl& AddedPlayerCharacterId);
	void OnRequestFriendshipWithPlayerSucceeded__DelegateSignature(const struct FUniqueNetIdRepl& AddedPlayerCharacterId);
	void OnRescindFriendshipWithPlayerFailed__DelegateSignature(const struct FUniqueNetIdRepl& RemovedPlayerCharacterId);
	void OnRescindFriendshipWithPlayerSucceeded__DelegateSignature(const struct FUniqueNetIdRepl& RemovedPlayerCharacterId);
	bool RejectInvitation(struct FUniqueNetIdRepl& PlayerCharacterId);
	EVAL_SocialBlockError RequestBlockUser(bool bBlock, struct FUniqueNetIdRepl& UserId);
	bool RequestFriendshipWithPlayer(struct FUniqueNetIdRepl& PlayerCharacterId, TDelegate<void(const struct FUniqueNetIdRepl& AddedPlayerCharacterId)>& OnSucceeded, TDelegate<void(const struct FUniqueNetIdRepl& AddedPlayerCharacterId)>& OnFailed);
	bool RescindFriendshipWithPlayer(struct FUniqueNetIdRepl& PlayerCharacterId, TDelegate<void(const struct FUniqueNetIdRepl& RemovedPlayerCharacterId)>& OnSucceeded, TDelegate<void(const struct FUniqueNetIdRepl& RemovedPlayerCharacterId)>& OnFailed);

	TSet<struct FUniqueNetIdRepl> GetBlockedPlayers() const;
	bool HasFriendWithCharacterName(const class FString& PlayerCharacterName) const;
	bool IsFriend(struct FUniqueNetIdRepl& PlayerCharacterId) const;
	bool IsUserBlocked(struct FUniqueNetIdRepl& UserId) const;
	bool IsUserBlockedWithNetIdAsString(const class FString& UserId) const;
	bool TryGetIncomingFriendRequests(TSet<struct FUniqueNetIdRepl>* OutFriendRequests, bool bOnlyNewRequests) const;
	bool TryGetOutgoingFriendRequests(TSet<struct FUniqueNetIdRepl>* OutFriendRequests) const;
	bool TryGetReciprocalFriendRequests(TSet<struct FUniqueNetIdRepl>* OutFriendRequests) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_FriendsManager">();
	}
	static class UVAL_FriendsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_FriendsManager>();
	}
};
static_assert(alignof(UVAL_FriendsManager) == 0x000008, "Wrong alignment on UVAL_FriendsManager");
static_assert(sizeof(UVAL_FriendsManager) == 0x0000D0, "Wrong size on UVAL_FriendsManager");
static_assert(offsetof(UVAL_FriendsManager, OnRelationshipsChanged) == 0x000030, "Member 'UVAL_FriendsManager::OnRelationshipsChanged' has a wrong offset!");
static_assert(offsetof(UVAL_FriendsManager, OnFriendRequestReceived) == 0x000040, "Member 'UVAL_FriendsManager::OnFriendRequestReceived' has a wrong offset!");
static_assert(offsetof(UVAL_FriendsManager, OnFriendRequestAccepted) == 0x000050, "Member 'UVAL_FriendsManager::OnFriendRequestAccepted' has a wrong offset!");
static_assert(offsetof(UVAL_FriendsManager, OnFriendRequestFailed) == 0x000060, "Member 'UVAL_FriendsManager::OnFriendRequestFailed' has a wrong offset!");
static_assert(offsetof(UVAL_FriendsManager, OnCharacterBlocked) == 0x000070, "Member 'UVAL_FriendsManager::OnCharacterBlocked' has a wrong offset!");
static_assert(offsetof(UVAL_FriendsManager, OnCharacterBlockListChanged) == 0x000080, "Member 'UVAL_FriendsManager::OnCharacterBlockListChanged' has a wrong offset!");

// Class Palia.VAL_FTUESettings
// 0x0018 (0x0050 - 0x0038)
class UVAL_FTUESettings final : public UDeveloperSettings
{
public:
	struct FGameplayTag                           FTUEFinalStep;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         FTUEMapAndExperienceNames;                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_FTUESettings">();
	}
	static class UVAL_FTUESettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_FTUESettings>();
	}
};
static_assert(alignof(UVAL_FTUESettings) == 0x000008, "Wrong alignment on UVAL_FTUESettings");
static_assert(sizeof(UVAL_FTUESettings) == 0x000050, "Wrong size on UVAL_FTUESettings");
static_assert(offsetof(UVAL_FTUESettings, FTUEFinalStep) == 0x000038, "Member 'UVAL_FTUESettings::FTUEFinalStep' has a wrong offset!");
static_assert(offsetof(UVAL_FTUESettings, FTUEMapAndExperienceNames) == 0x000040, "Member 'UVAL_FTUESettings::FTUEMapAndExperienceNames' has a wrong offset!");

// Class Palia.VAL_Subsystem_GameplayUIBridge
// 0x0010 (0x0040 - 0x0030)
class UVAL_Subsystem_GameplayUIBridge final : public ULocalPlayerSubsystem
{
public:
	TScriptInterface<class IVAL_GameplayUIBridgeInterface> UIImplementation;                                  // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetUIImplementation(TScriptInterface<class IVAL_GameplayUIBridgeInterface>& Param_UIImplementation);

	TScriptInterface<class IVAL_GameplayUIBridgeInterface> GetUIInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_Subsystem_GameplayUIBridge">();
	}
	static class UVAL_Subsystem_GameplayUIBridge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_Subsystem_GameplayUIBridge>();
	}
};
static_assert(alignof(UVAL_Subsystem_GameplayUIBridge) == 0x000008, "Wrong alignment on UVAL_Subsystem_GameplayUIBridge");
static_assert(sizeof(UVAL_Subsystem_GameplayUIBridge) == 0x000040, "Wrong size on UVAL_Subsystem_GameplayUIBridge");
static_assert(offsetof(UVAL_Subsystem_GameplayUIBridge, UIImplementation) == 0x000030, "Member 'UVAL_Subsystem_GameplayUIBridge::UIImplementation' has a wrong offset!");

// Class Palia.VAL_GameUISubsystem
// 0x0050 (0x0080 - 0x0030)
class UVAL_GameUISubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_2BD6[0x50];                                    // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearDraggedItem(const class FString& HoldWidgetName);
	void SetDraggedItem(const class FString& HoldWidgetName, class UDragDropOperation* DraggedItem);

	class UDragDropOperation* GetDraggedItem(const class FString& HoldWidgetName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GameUISubsystem">();
	}
	static class UVAL_GameUISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GameUISubsystem>();
	}
};
static_assert(alignof(UVAL_GameUISubsystem) == 0x000008, "Wrong alignment on UVAL_GameUISubsystem");
static_assert(sizeof(UVAL_GameUISubsystem) == 0x000080, "Wrong size on UVAL_GameUISubsystem");

// Class Palia.VAL_GraphicsFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_GraphicsFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EVAL_DirectXVersion GetDirectXVersion();
	static void SetDirectXVersion(EVAL_DirectXVersion DxVersion);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_GraphicsFunctionLibrary">();
	}
	static class UVAL_GraphicsFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_GraphicsFunctionLibrary>();
	}
};
static_assert(alignof(UVAL_GraphicsFunctionLibrary) == 0x000008, "Wrong alignment on UVAL_GraphicsFunctionLibrary");
static_assert(sizeof(UVAL_GraphicsFunctionLibrary) == 0x000028, "Wrong size on UVAL_GraphicsFunctionLibrary");

// Class Palia.VAL_KismetTextLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_KismetTextLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 CompareText(class FText& A, class FText& B, EVAL_TextComparisonLevel TextComparisonLevel);
	static class FText JoinTextArray(TArray<class FText>& SourceArray, class FText& Separator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_KismetTextLibrary">();
	}
	static class UVAL_KismetTextLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_KismetTextLibrary>();
	}
};
static_assert(alignof(UVAL_KismetTextLibrary) == 0x000008, "Wrong alignment on UVAL_KismetTextLibrary");
static_assert(sizeof(UVAL_KismetTextLibrary) == 0x000028, "Wrong size on UVAL_KismetTextLibrary");

// Class Palia.VAL_LevelScriptFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_LevelScriptFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ALevelScriptActor* GetLevelScriptActor(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_LevelScriptFunctionLibrary">();
	}
	static class UVAL_LevelScriptFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_LevelScriptFunctionLibrary>();
	}
};
static_assert(alignof(UVAL_LevelScriptFunctionLibrary) == 0x000008, "Wrong alignment on UVAL_LevelScriptFunctionLibrary");
static_assert(sizeof(UVAL_LevelScriptFunctionLibrary) == 0x000028, "Wrong size on UVAL_LevelScriptFunctionLibrary");

// Class Palia.VAL_LevelSequencePlayer
// 0x0000 (0x0610 - 0x0610)
class UVAL_LevelSequencePlayer final : public ULevelSequencePlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_LevelSequencePlayer">();
	}
	static class UVAL_LevelSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_LevelSequencePlayer>();
	}
};
static_assert(alignof(UVAL_LevelSequencePlayer) == 0x000008, "Wrong alignment on UVAL_LevelSequencePlayer");
static_assert(sizeof(UVAL_LevelSequencePlayer) == 0x000610, "Wrong size on UVAL_LevelSequencePlayer");

// Class Palia.VAL_LevelSequenceSublevelLink
// 0x0010 (0x02B8 - 0x02A8)
class AVAL_LevelSequenceSublevelLink final : public AActor
{
public:
	struct FTopLevelAssetPath                     OriginalLevelAssetPath;                            // 0x02A8(0x0010)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_LevelSequenceSublevelLink">();
	}
	static class AVAL_LevelSequenceSublevelLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_LevelSequenceSublevelLink>();
	}
};
static_assert(alignof(AVAL_LevelSequenceSublevelLink) == 0x000008, "Wrong alignment on AVAL_LevelSequenceSublevelLink");
static_assert(sizeof(AVAL_LevelSequenceSublevelLink) == 0x0002B8, "Wrong size on AVAL_LevelSequenceSublevelLink");
static_assert(offsetof(AVAL_LevelSequenceSublevelLink, OriginalLevelAssetPath) == 0x0002A8, "Member 'AVAL_LevelSequenceSublevelLink::OriginalLevelAssetPath' has a wrong offset!");

// Class Palia.VAL_AsyncAction_JoinServer
// 0x00C0 (0x00F0 - 0x0030)
class UVAL_AsyncAction_JoinServer final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnResultObtained;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD8[0xB0];                                    // 0x0040(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_AsyncAction_JoinServer* JoinServer(class ULocalPlayer* LocalPlayer, struct FOSSVAL_MatchmakingTicketContext& MatchmakingTicketContext, struct FOSSVAL_MatchmakingTicket& MatchmakingTicket);

	void OnResultObtained__DelegateSignature(struct FOSSVAL_MatchmakingTicket& Ticket, struct FOSSVAL_MatchmakingResult& Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AsyncAction_JoinServer">();
	}
	static class UVAL_AsyncAction_JoinServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AsyncAction_JoinServer>();
	}
};
static_assert(alignof(UVAL_AsyncAction_JoinServer) == 0x000008, "Wrong alignment on UVAL_AsyncAction_JoinServer");
static_assert(sizeof(UVAL_AsyncAction_JoinServer) == 0x0000F0, "Wrong size on UVAL_AsyncAction_JoinServer");
static_assert(offsetof(UVAL_AsyncAction_JoinServer, OnResultObtained) == 0x000030, "Member 'UVAL_AsyncAction_JoinServer::OnResultObtained' has a wrong offset!");

// Class Palia.VAL_AsyncAction_MatchmakingDeleteRequest
// 0x00C0 (0x00F0 - 0x0030)
class UVAL_AsyncAction_MatchmakingDeleteRequest final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnResultObtained;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD9[0xB0];                                    // 0x0040(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVAL_AsyncAction_MatchmakingDeleteRequest* DeleteMatchmakingRequest(class ULocalPlayer* LocalPlayer, bool bInternal);

	void OnResultObtained__DelegateSignature(struct FOSSVAL_MatchmakingResult& Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_AsyncAction_MatchmakingDeleteRequest">();
	}
	static class UVAL_AsyncAction_MatchmakingDeleteRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_AsyncAction_MatchmakingDeleteRequest>();
	}
};
static_assert(alignof(UVAL_AsyncAction_MatchmakingDeleteRequest) == 0x000008, "Wrong alignment on UVAL_AsyncAction_MatchmakingDeleteRequest");
static_assert(sizeof(UVAL_AsyncAction_MatchmakingDeleteRequest) == 0x0000F0, "Wrong size on UVAL_AsyncAction_MatchmakingDeleteRequest");
static_assert(offsetof(UVAL_AsyncAction_MatchmakingDeleteRequest, OnResultObtained) == 0x000030, "Member 'UVAL_AsyncAction_MatchmakingDeleteRequest::OnResultObtained' has a wrong offset!");

// Class Palia.VAL_MQTTMatchmakerServerAsyncStreamBase
// 0x0000 (0x0048 - 0x0048)
class UVAL_MQTTMatchmakerServerAsyncStreamBase : public UVAL_MQTTAsyncStreamBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_MQTTMatchmakerServerAsyncStreamBase">();
	}
	static class UVAL_MQTTMatchmakerServerAsyncStreamBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_MQTTMatchmakerServerAsyncStreamBase>();
	}
};
static_assert(alignof(UVAL_MQTTMatchmakerServerAsyncStreamBase) == 0x000008, "Wrong alignment on UVAL_MQTTMatchmakerServerAsyncStreamBase");
static_assert(sizeof(UVAL_MQTTMatchmakerServerAsyncStreamBase) == 0x000048, "Wrong size on UVAL_MQTTMatchmakerServerAsyncStreamBase");

// Class Palia.VAL_NewsInboxLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_NewsInboxLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_NewsInboxLibrary">();
	}
	static class UVAL_NewsInboxLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_NewsInboxLibrary>();
	}
};
static_assert(alignof(UVAL_NewsInboxLibrary) == 0x000008, "Wrong alignment on UVAL_NewsInboxLibrary");
static_assert(sizeof(UVAL_NewsInboxLibrary) == 0x000028, "Wrong size on UVAL_NewsInboxLibrary");

// Class Palia.VAL_PaliaPassRewardObject_Cosmetic
// 0x0028 (0x0058 - 0x0030)
class UVAL_PaliaPassRewardObject_Cosmetic final : public UVAL_PaliaPassRewardObject_Base
{
public:
	TSoftObjectPtr<class UVAL_CharacterCustomizationItemBase> Item;                                              // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PaliaPassRewardObject_Cosmetic">();
	}
	static class UVAL_PaliaPassRewardObject_Cosmetic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PaliaPassRewardObject_Cosmetic>();
	}
};
static_assert(alignof(UVAL_PaliaPassRewardObject_Cosmetic) == 0x000008, "Wrong alignment on UVAL_PaliaPassRewardObject_Cosmetic");
static_assert(sizeof(UVAL_PaliaPassRewardObject_Cosmetic) == 0x000058, "Wrong size on UVAL_PaliaPassRewardObject_Cosmetic");
static_assert(offsetof(UVAL_PaliaPassRewardObject_Cosmetic, Item) == 0x000030, "Member 'UVAL_PaliaPassRewardObject_Cosmetic::Item' has a wrong offset!");

// Class Palia.VAL_PaliaPassRewardObject_Emote
// 0x0028 (0x0058 - 0x0030)
class UVAL_PaliaPassRewardObject_Emote final : public UVAL_PaliaPassRewardObject_Base
{
public:
	TSoftObjectPtr<class UEmoteDataAsset>         Emote;                                             // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PaliaPassRewardObject_Emote">();
	}
	static class UVAL_PaliaPassRewardObject_Emote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PaliaPassRewardObject_Emote>();
	}
};
static_assert(alignof(UVAL_PaliaPassRewardObject_Emote) == 0x000008, "Wrong alignment on UVAL_PaliaPassRewardObject_Emote");
static_assert(sizeof(UVAL_PaliaPassRewardObject_Emote) == 0x000058, "Wrong size on UVAL_PaliaPassRewardObject_Emote");
static_assert(offsetof(UVAL_PaliaPassRewardObject_Emote, Emote) == 0x000030, "Member 'UVAL_PaliaPassRewardObject_Emote::Emote' has a wrong offset!");

// Class Palia.VAL_ParentalControlsSettings
// 0x0048 (0x0080 - 0x0038)
class UVAL_ParentalControlsSettings final : public UDeveloperSettings
{
public:
	class FText                                   CommunityMottoText;                                // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   CommunityDescriptionText;                          // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   ChatText;                                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ParentalControlsSettings">();
	}
	static class UVAL_ParentalControlsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ParentalControlsSettings>();
	}
};
static_assert(alignof(UVAL_ParentalControlsSettings) == 0x000008, "Wrong alignment on UVAL_ParentalControlsSettings");
static_assert(sizeof(UVAL_ParentalControlsSettings) == 0x000080, "Wrong size on UVAL_ParentalControlsSettings");
static_assert(offsetof(UVAL_ParentalControlsSettings, CommunityMottoText) == 0x000038, "Member 'UVAL_ParentalControlsSettings::CommunityMottoText' has a wrong offset!");
static_assert(offsetof(UVAL_ParentalControlsSettings, CommunityDescriptionText) == 0x000050, "Member 'UVAL_ParentalControlsSettings::CommunityDescriptionText' has a wrong offset!");
static_assert(offsetof(UVAL_ParentalControlsSettings, ChatText) == 0x000068, "Member 'UVAL_ParentalControlsSettings::ChatText' has a wrong offset!");

// Class Palia.VAL_PartyManager
// 0x0338 (0x0368 - 0x0030)
class UVAL_PartyManager final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_2BDB[0x70];                                    // 0x0030(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPartyStateChanged;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInviteReceived;                                  // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInviteSent;                                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInviteRescinded;                                 // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInviteRejected;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInviteTimedOut;                                  // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMemberAdded;                                     // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMemberRemoved;                                   // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMemberKicked;                                    // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMemberDisconnected;                              // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLeaderDisconnected;                              // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMemberPromoted;                                  // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDC[0x10];                                    // 0x0160(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVAL_PartyMember                       LocalPartyMember;                                  // 0x0170(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVAL_Party                             CurrentParty;                                      // 0x01C0(0x0108)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TSet<struct FVAL_PartyInvite>                 PendingSentInvites;                                // 0x02C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TSet<struct FVAL_PartyInvite>                 PendingReceivedInvites;                            // 0x0318(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void AcceptInvite(struct FVAL_PartyInvite& Invite);
	void ExitParty();
	void HandleNewControlMessage(struct FControlMessage& ControlMessage);
	void HandleOnPresenceChanged(const struct FPresence& OldPresence, const struct FPresence& NewPresence);
	void HandleOnSelectedCharacterChanged(struct FOSSVAL_SelectedCharacter& SelectedCharacter);
	void KickMember(struct FVAL_PartyMember& Member);
	void OnPartyInviteReceived__DelegateSignature(struct FVAL_PartyInvite& Invite);
	void OnPartyInviteRejected__DelegateSignature(struct FVAL_PartyInvite& Invite);
	void OnPartyInviteRescinded__DelegateSignature(struct FVAL_PartyInvite& Invite);
	void OnPartyInviteSent__DelegateSignature(struct FVAL_PartyInvite& Invite);
	void OnPartyInviteTimedOut__DelegateSignature(struct FVAL_PartyInvite& Invite);
	void OnPartyLeaderDisconnected__DelegateSignature(struct FVAL_PartyMember& Leader);
	void OnPartyMemberAdded__DelegateSignature(struct FVAL_PartyMember& Member);
	void OnPartyMemberDisconnected__DelegateSignature(struct FVAL_PartyMember& Member);
	void OnPartyMemberKicked__DelegateSignature(struct FVAL_PartyMember& Member);
	void OnPartyMemberPromoted__DelegateSignature(struct FVAL_PartyMember& Member);
	void OnPartyMemberRemoved__DelegateSignature(struct FVAL_PartyMember& Member);
	void OnPartyStateChanged__DelegateSignature(EVAL_PartyManagerState State);
	void PromoteMember(struct FVAL_PartyMember& Member);
	void RejectInvite(struct FVAL_PartyInvite& Invite);
	void RescindInvite(struct FVAL_PartyInvite& Invite);
	void SendInvite(struct FVAL_PartyMember& Recipient);

	EVAL_PartyManagerState GetCurrentPartyState() const;
	int32 GetMaximumPartySize() const;
	bool HasReceivedInviteFrom(struct FVAL_PartyMember& Member, struct FVAL_PartyInvite* OutInvite) const;
	bool HasSentInviteTo(struct FVAL_PartyMember& Member, struct FVAL_PartyInvite* OutInvite) const;
	bool IsCurrentPartyValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PartyManager">();
	}
	static class UVAL_PartyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PartyManager>();
	}
};
static_assert(alignof(UVAL_PartyManager) == 0x000008, "Wrong alignment on UVAL_PartyManager");
static_assert(sizeof(UVAL_PartyManager) == 0x000368, "Wrong size on UVAL_PartyManager");
static_assert(offsetof(UVAL_PartyManager, OnPartyStateChanged) == 0x0000A0, "Member 'UVAL_PartyManager::OnPartyStateChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnInviteReceived) == 0x0000B0, "Member 'UVAL_PartyManager::OnInviteReceived' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnInviteSent) == 0x0000C0, "Member 'UVAL_PartyManager::OnInviteSent' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnInviteRescinded) == 0x0000D0, "Member 'UVAL_PartyManager::OnInviteRescinded' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnInviteRejected) == 0x0000E0, "Member 'UVAL_PartyManager::OnInviteRejected' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnInviteTimedOut) == 0x0000F0, "Member 'UVAL_PartyManager::OnInviteTimedOut' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnMemberAdded) == 0x000100, "Member 'UVAL_PartyManager::OnMemberAdded' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnMemberRemoved) == 0x000110, "Member 'UVAL_PartyManager::OnMemberRemoved' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnMemberKicked) == 0x000120, "Member 'UVAL_PartyManager::OnMemberKicked' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnMemberDisconnected) == 0x000130, "Member 'UVAL_PartyManager::OnMemberDisconnected' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnLeaderDisconnected) == 0x000140, "Member 'UVAL_PartyManager::OnLeaderDisconnected' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, OnMemberPromoted) == 0x000150, "Member 'UVAL_PartyManager::OnMemberPromoted' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, LocalPartyMember) == 0x000170, "Member 'UVAL_PartyManager::LocalPartyMember' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, CurrentParty) == 0x0001C0, "Member 'UVAL_PartyManager::CurrentParty' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, PendingSentInvites) == 0x0002C8, "Member 'UVAL_PartyManager::PendingSentInvites' has a wrong offset!");
static_assert(offsetof(UVAL_PartyManager, PendingReceivedInvites) == 0x000318, "Member 'UVAL_PartyManager::PendingReceivedInvites' has a wrong offset!");

// Class Palia.VAL_PartySubsystem_Client
// 0x0020 (0x0050 - 0x0030)
class UVAL_PartySubsystem_Client final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_2BDF[0x20];                                    // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleNewControlMessage(struct FControlMessage& ControlMessage);
	void HandleOnSelectedCharacterChanged(struct FOSSVAL_SelectedCharacter& SelectedCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PartySubsystem_Client">();
	}
	static class UVAL_PartySubsystem_Client* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PartySubsystem_Client>();
	}
};
static_assert(alignof(UVAL_PartySubsystem_Client) == 0x000008, "Wrong alignment on UVAL_PartySubsystem_Client");
static_assert(sizeof(UVAL_PartySubsystem_Client) == 0x000050, "Wrong size on UVAL_PartySubsystem_Client");

// Class Palia.VAL_PartyLibrary
// 0x0000 (0x0028 - 0x0028)
class UVAL_PartyLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVAL_PartyMember CreatePartyMember(struct FGuid& AccountId, struct FGuid& CharacterId);
	static bool DoesPartyContainMember(struct FVAL_Party& Party, struct FVAL_PartyMember& PartyMember);
	static bool DoesPartyContainMemberByNetId(struct FVAL_Party& Party, struct FUniqueNetIdRepl& NetId);
	static bool EqualEqual(struct FVAL_PartyMember& A, struct FVAL_PartyMember& B);
	static TArray<struct FUniqueNetIdRepl> GetAllPartyMemberIds(struct FVAL_Party& Party);
	static TSet<struct FVAL_PartyMember> GetAllPartyMembers(struct FVAL_Party& Party);
	static class FString GetPartyInviteDurationLeftFormatted(struct FVAL_PartyInvite& Invite);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PartyLibrary">();
	}
	static class UVAL_PartyLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PartyLibrary>();
	}
};
static_assert(alignof(UVAL_PartyLibrary) == 0x000008, "Wrong alignment on UVAL_PartyLibrary");
static_assert(sizeof(UVAL_PartyLibrary) == 0x000028, "Wrong size on UVAL_PartyLibrary");

// Class Palia.VAL_PlateWidgetComponent
// 0x0220 (0x0990 - 0x0770)
class UVAL_PlateWidgetComponent : public UWidgetComponent
{
public:
	uint8                                         Pad_2BE3[0x10];                                    // 0x0770(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShouldScaleWithCamera;                             // 0x0780(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CameraScaleAlpha;                                  // 0x0781(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleDistanceRange;                                // 0x0782(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE4[0x5];                                     // 0x0783(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MinScale;                                          // 0x0788(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxScale;                                          // 0x0790(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinCameraDistance;                                 // 0x0798(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxCameraDistance;                                 // 0x07A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CameraDistanceForScaleOne;                         // 0x07A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        LastCameraDistance;                                // 0x07B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        VisibilityTimerInterval;                           // 0x07B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInteractivePlateWidget;                          // 0x07C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldIgnoreLineTrace;                             // 0x07C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldVisibilityTimerBeActive;                     // 0x07C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasExtraTickLogic;                                 // 0x07C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WidgetCreated;                                     // 0x07C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisibleOnSpawn;                                  // 0x07C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldPlateBeVisibleVar;                           // 0x07C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsTimerActive;                                     // 0x07C7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseOptimizedLineTrace;                            // 0x07C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsVisibleToPlayer;                                 // 0x07C9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BE5[0x3E];                                    // 0x07CA(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_PlateWidgetComponent*              CachedFirstPlateWidgetComponent;                   // 0x0808(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UVAL_PlateWidgetComponent*>      ListeningComps;                                    // 0x0810(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BE6[0x170];                                   // 0x0820(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	double CalcNextVisCheckTime();
	void CheckAndSetVisibility();
	void DoCheckAndSetVisibility();
	void DoVisibilityCheck();
	void GetIsVisibleToPlayer(bool* Param_IsVisible);
	void GetLastDistance(double* Distance);
	class AValeriaCharacter* GetLocalPlayerCharacter();
	bool IsCameraManagerFading();
	bool IsLocalPlayerInCinematicMode();
	void ScaleBasedOnViewport();
	void ScheduleCheckAndSetVisibility();
	void SetPlateVisibility(bool bActive);
	void SetVisibilityTimerActive(bool bActive);
	bool ShouldPlateBeVisible();
	void WasWidgetCreated(bool* WasCreated);

	double CalcDistToCamera() const;
	double CalcXYDistToCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlateWidgetComponent">();
	}
	static class UVAL_PlateWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlateWidgetComponent>();
	}
};
static_assert(alignof(UVAL_PlateWidgetComponent) == 0x000010, "Wrong alignment on UVAL_PlateWidgetComponent");
static_assert(sizeof(UVAL_PlateWidgetComponent) == 0x000990, "Wrong size on UVAL_PlateWidgetComponent");
static_assert(offsetof(UVAL_PlateWidgetComponent, ShouldScaleWithCamera) == 0x000780, "Member 'UVAL_PlateWidgetComponent::ShouldScaleWithCamera' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, CameraScaleAlpha) == 0x000781, "Member 'UVAL_PlateWidgetComponent::CameraScaleAlpha' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, ScaleDistanceRange) == 0x000782, "Member 'UVAL_PlateWidgetComponent::ScaleDistanceRange' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, MinScale) == 0x000788, "Member 'UVAL_PlateWidgetComponent::MinScale' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, MaxScale) == 0x000790, "Member 'UVAL_PlateWidgetComponent::MaxScale' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, MinCameraDistance) == 0x000798, "Member 'UVAL_PlateWidgetComponent::MinCameraDistance' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, MaxCameraDistance) == 0x0007A0, "Member 'UVAL_PlateWidgetComponent::MaxCameraDistance' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, CameraDistanceForScaleOne) == 0x0007A8, "Member 'UVAL_PlateWidgetComponent::CameraDistanceForScaleOne' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, LastCameraDistance) == 0x0007B0, "Member 'UVAL_PlateWidgetComponent::LastCameraDistance' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, VisibilityTimerInterval) == 0x0007B8, "Member 'UVAL_PlateWidgetComponent::VisibilityTimerInterval' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, IsInteractivePlateWidget) == 0x0007C0, "Member 'UVAL_PlateWidgetComponent::IsInteractivePlateWidget' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, ShouldIgnoreLineTrace) == 0x0007C1, "Member 'UVAL_PlateWidgetComponent::ShouldIgnoreLineTrace' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, ShouldVisibilityTimerBeActive) == 0x0007C2, "Member 'UVAL_PlateWidgetComponent::ShouldVisibilityTimerBeActive' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, HasExtraTickLogic) == 0x0007C3, "Member 'UVAL_PlateWidgetComponent::HasExtraTickLogic' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, WidgetCreated) == 0x0007C4, "Member 'UVAL_PlateWidgetComponent::WidgetCreated' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, IsVisibleOnSpawn) == 0x0007C5, "Member 'UVAL_PlateWidgetComponent::IsVisibleOnSpawn' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, ShouldPlateBeVisibleVar) == 0x0007C6, "Member 'UVAL_PlateWidgetComponent::ShouldPlateBeVisibleVar' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, IsTimerActive) == 0x0007C7, "Member 'UVAL_PlateWidgetComponent::IsTimerActive' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, bUseOptimizedLineTrace) == 0x0007C8, "Member 'UVAL_PlateWidgetComponent::bUseOptimizedLineTrace' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, IsVisibleToPlayer) == 0x0007C9, "Member 'UVAL_PlateWidgetComponent::IsVisibleToPlayer' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, CachedFirstPlateWidgetComponent) == 0x000808, "Member 'UVAL_PlateWidgetComponent::CachedFirstPlateWidgetComponent' has a wrong offset!");
static_assert(offsetof(UVAL_PlateWidgetComponent, ListeningComps) == 0x000810, "Member 'UVAL_PlateWidgetComponent::ListeningComps' has a wrong offset!");

// Class Palia.VAL_PlayerCameraManager
// 0x0020 (0x23F0 - 0x23D0)
class AVAL_PlayerCameraManager final : public APlayerCameraManager
{
public:
	FMulticastInlineDelegateProperty_             OnCameraFadeFinished;                              // 0x23D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsInPhotoCameraMode;                              // 0x23E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsSelfieMode;                                  // 0x23E1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE7[0x6];                                     // 0x23E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HidePlateWidgetFadeAmountThreshold;                // 0x23E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldAttemptToAttachListener;                    // 0x23EC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BE8[0x3];                                     // 0x23ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCameraGenericNotify__DelegateSignature(class AVAL_PlayerCameraManager* CameraManager);

	class USceneCaptureComponent2D* GetPhotoCameraModeSceneCaptureComponent() const;
	bool ShouldHidePlateWidgets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerCameraManager">();
	}
	static class AVAL_PlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_PlayerCameraManager>();
	}
};
static_assert(alignof(AVAL_PlayerCameraManager) == 0x000010, "Wrong alignment on AVAL_PlayerCameraManager");
static_assert(sizeof(AVAL_PlayerCameraManager) == 0x0023F0, "Wrong size on AVAL_PlayerCameraManager");
static_assert(offsetof(AVAL_PlayerCameraManager, OnCameraFadeFinished) == 0x0023D0, "Member 'AVAL_PlayerCameraManager::OnCameraFadeFinished' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerCameraManager, bIsInPhotoCameraMode) == 0x0023E0, "Member 'AVAL_PlayerCameraManager::bIsInPhotoCameraMode' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerCameraManager, bWantsSelfieMode) == 0x0023E1, "Member 'AVAL_PlayerCameraManager::bWantsSelfieMode' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerCameraManager, HidePlateWidgetFadeAmountThreshold) == 0x0023E8, "Member 'AVAL_PlayerCameraManager::HidePlateWidgetFadeAmountThreshold' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerCameraManager, bShouldAttemptToAttachListener) == 0x0023EC, "Member 'AVAL_PlayerCameraManager::bShouldAttemptToAttachListener' has a wrong offset!");

// Class Palia.VAL_PlayerGuildComponent
// 0x0178 (0x0218 - 0x00A0)
class UVAL_PlayerGuildComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2BE9[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPinStateChanged;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPinnedQuestsChanged;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVAL_PlayerGuildQuestTracker           QuestTracker;                                      // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPlayerGuildLevelInfo                  GuildLevelInfo;                                    // 0x00E0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FVAL_PlayerGuildQuestCollection        GuildQuests;                                       // 0x0100(0x0040)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FVAL_PlayerGuildQuestGeneratedInfo     PotentialGuildQuests;                              // 0x0140(0x0048)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGuildXpChanged;                                  // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGuildQuestsChanged;                              // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGuildPotentialQuestsChanged;                     // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGuildSeedExpirationChanged;                      // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEA[0x50];                                    // 0x01C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCharacterSpawned(class AValeriaPlayerController* PlayerController, class AValeriaCharacter* Character);
	void HandlePlayerGuildChanged(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem, const struct FGuid& NewGuildId);
	void OnRep_PotentialQuests(struct FVAL_PlayerGuildQuestGeneratedInfo& PotentialGuildQuests_Old);
	void OnRep_Quests();
	void OnRep_Xp();
	void Server_ClearPinnedPlayerGuildQuests();
	void Server_ClearPlayerGuildQuests();
	void Server_MarkPlayerGuildQuestAsPinned(struct FGuid& QuestId, bool bIsPinned);
	void Server_UpdatePlayerGuildQuests();
	void ServerCheat_ContributeToGuildQuest(struct FGuid& QuestInstanceId, const class FString& CounterName, int32 AmountToContribute);
	void ServerCheat_CreateGuildQuest(const class FString& CounterId, int32 AmountRequired, int32 XpReward, const class FString& QuestSize, const class FString& Rarity);
	void ServerCheat_DeleteGuildQuest(struct FGuid& QuestId);
	void ServerCheat_ModifyPlayerGuildXp(int64 Amount);
	void ServerCheat_RefreshGuildQuests();
	void ServerCreateGuildQuest(struct FGuid& QuestId);
	void ServerDeleteGuildQuest(struct FGuid& QuestId);
	void ServerNotifyGuildIdChanged(const struct FGuid& NewGuildId);
	void ServerRequestFetchGuildXp();
	void VAL_PlayerGuildQuestTracker_PinnedQuestsChanged__DelegateSignature(class UVAL_PlayerGuildComponent* PlayerGuildComponent);
	void VAL_PlayerGuildQuestTracker_PinStateChanged__DelegateSignature(class UVAL_PlayerGuildComponent* PlayerGuildComponent, struct FGuid& QuestId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildComponent">();
	}
	static class UVAL_PlayerGuildComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildComponent>();
	}
};
static_assert(alignof(UVAL_PlayerGuildComponent) == 0x000008, "Wrong alignment on UVAL_PlayerGuildComponent");
static_assert(sizeof(UVAL_PlayerGuildComponent) == 0x000218, "Wrong size on UVAL_PlayerGuildComponent");
static_assert(offsetof(UVAL_PlayerGuildComponent, OnPinStateChanged) == 0x0000A8, "Member 'UVAL_PlayerGuildComponent::OnPinStateChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildComponent, OnPinnedQuestsChanged) == 0x0000B8, "Member 'UVAL_PlayerGuildComponent::OnPinnedQuestsChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildComponent, QuestTracker) == 0x0000C8, "Member 'UVAL_PlayerGuildComponent::QuestTracker' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildComponent, GuildLevelInfo) == 0x0000E0, "Member 'UVAL_PlayerGuildComponent::GuildLevelInfo' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildComponent, GuildQuests) == 0x000100, "Member 'UVAL_PlayerGuildComponent::GuildQuests' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildComponent, PotentialGuildQuests) == 0x000140, "Member 'UVAL_PlayerGuildComponent::PotentialGuildQuests' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildComponent, OnGuildXpChanged) == 0x000188, "Member 'UVAL_PlayerGuildComponent::OnGuildXpChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildComponent, OnGuildQuestsChanged) == 0x000198, "Member 'UVAL_PlayerGuildComponent::OnGuildQuestsChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildComponent, OnGuildPotentialQuestsChanged) == 0x0001A8, "Member 'UVAL_PlayerGuildComponent::OnGuildPotentialQuestsChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildComponent, OnGuildSeedExpirationChanged) == 0x0001B8, "Member 'UVAL_PlayerGuildComponent::OnGuildSeedExpirationChanged' has a wrong offset!");

// Class Palia.VAL_PlayerGuildProgressionSettings
// 0x0078 (0x00B0 - 0x0038)
class UVAL_PlayerGuildProgressionSettings final : public UDeveloperSettings
{
public:
	TMap<ESkillType, int64>                       PlayerGuildXpPerSkillXpEvent;                      // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVAL_PlayerGuildQuestGeneratorConfig> ActiveQuestGenerationConfig;                       // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildProgressionSettings">();
	}
	static class UVAL_PlayerGuildProgressionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildProgressionSettings>();
	}
};
static_assert(alignof(UVAL_PlayerGuildProgressionSettings) == 0x000008, "Wrong alignment on UVAL_PlayerGuildProgressionSettings");
static_assert(sizeof(UVAL_PlayerGuildProgressionSettings) == 0x0000B0, "Wrong size on UVAL_PlayerGuildProgressionSettings");
static_assert(offsetof(UVAL_PlayerGuildProgressionSettings, PlayerGuildXpPerSkillXpEvent) == 0x000038, "Member 'UVAL_PlayerGuildProgressionSettings::PlayerGuildXpPerSkillXpEvent' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildProgressionSettings, ActiveQuestGenerationConfig) == 0x000088, "Member 'UVAL_PlayerGuildProgressionSettings::ActiveQuestGenerationConfig' has a wrong offset!");

// Class Palia.PlayerGuildProgressionSubsystem
// 0x01D0 (0x0200 - 0x0030)
class UPlayerGuildProgressionSubsystem final : public UGameInstanceSubsystem
{
public:
	int32                                         NumSmallQuests;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BED[0x1A4];                                   // 0x0034(0x01A4)(Fixing Size After Last Property [ Dumper-7 ])
	class UVAL_PlayerGuildLevels*                 Levels;                                            // 0x01D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVAL_PlayerGuild_GameplayEventListener* GameplayEventListener;                             // 0x01E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BEE[0x18];                                    // 0x01E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsFeatureEnabled();

	void InitializePostAuth();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerGuildProgressionSubsystem">();
	}
	static class UPlayerGuildProgressionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerGuildProgressionSubsystem>();
	}
};
static_assert(alignof(UPlayerGuildProgressionSubsystem) == 0x000008, "Wrong alignment on UPlayerGuildProgressionSubsystem");
static_assert(sizeof(UPlayerGuildProgressionSubsystem) == 0x000200, "Wrong size on UPlayerGuildProgressionSubsystem");
static_assert(offsetof(UPlayerGuildProgressionSubsystem, NumSmallQuests) == 0x000030, "Member 'UPlayerGuildProgressionSubsystem::NumSmallQuests' has a wrong offset!");
static_assert(offsetof(UPlayerGuildProgressionSubsystem, Levels) == 0x0001D8, "Member 'UPlayerGuildProgressionSubsystem::Levels' has a wrong offset!");
static_assert(offsetof(UPlayerGuildProgressionSubsystem, GameplayEventListener) == 0x0001E0, "Member 'UPlayerGuildProgressionSubsystem::GameplayEventListener' has a wrong offset!");

// Class Palia.VAL_PlayerGuild_GameplayEventListener
// 0x0028 (0x0050 - 0x0028)
class UVAL_PlayerGuild_GameplayEventListener final : public UObject
{
public:
	uint8                                         Pad_2BEF[0x28];                                    // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuild_GameplayEventListener">();
	}
	static class UVAL_PlayerGuild_GameplayEventListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuild_GameplayEventListener>();
	}
};
static_assert(alignof(UVAL_PlayerGuild_GameplayEventListener) == 0x000008, "Wrong alignment on UVAL_PlayerGuild_GameplayEventListener");
static_assert(sizeof(UVAL_PlayerGuild_GameplayEventListener) == 0x000050, "Wrong size on UVAL_PlayerGuild_GameplayEventListener");

// Class Palia.VAL_PlayerGuildQuestGeneratorStatics
// 0x0000 (0x0028 - 0x0028)
class UVAL_PlayerGuildQuestGeneratorStatics final : public UBlueprintFunctionLibrary
{
public:
	static struct FVAL_PlayerGuildQuestCollection GenerateQuests(int32 Seed, class UVAL_PlayerGuildQuestGeneratorConfig* GeneratorConfigData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildQuestGeneratorStatics">();
	}
	static class UVAL_PlayerGuildQuestGeneratorStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildQuestGeneratorStatics>();
	}
};
static_assert(alignof(UVAL_PlayerGuildQuestGeneratorStatics) == 0x000008, "Wrong alignment on UVAL_PlayerGuildQuestGeneratorStatics");
static_assert(sizeof(UVAL_PlayerGuildQuestGeneratorStatics) == 0x000028, "Wrong size on UVAL_PlayerGuildQuestGeneratorStatics");

// Class Palia.VAL_PlayerGuildQuestWrapperObject
// 0x0040 (0x0068 - 0x0028)
class UVAL_PlayerGuildQuestWrapperObject final : public UObject
{
public:
	struct FVAL_PlayerGuildQuestCollection        Quests;                                            // 0x0028(0x0040)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildQuestWrapperObject">();
	}
	static class UVAL_PlayerGuildQuestWrapperObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildQuestWrapperObject>();
	}
};
static_assert(alignof(UVAL_PlayerGuildQuestWrapperObject) == 0x000008, "Wrong alignment on UVAL_PlayerGuildQuestWrapperObject");
static_assert(sizeof(UVAL_PlayerGuildQuestWrapperObject) == 0x000068, "Wrong size on UVAL_PlayerGuildQuestWrapperObject");
static_assert(offsetof(UVAL_PlayerGuildQuestWrapperObject, Quests) == 0x000028, "Member 'UVAL_PlayerGuildQuestWrapperObject::Quests' has a wrong offset!");

// Class Palia.VAL_PlayerGuildQuestGeneratorGoal
// 0x0078 (0x00A8 - 0x0030)
class UVAL_PlayerGuildQuestGeneratorGoal final : public UDataAsset
{
public:
	class FText                                   ActivityName;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ActivityDescription;                               // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	EVAL_PlayerGuildQuestRarity                   ActivityRarity;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF1[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset> ActivityItemRequired;                              // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuantityRequired;                                  // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVAL_PlayerGuildQuestAction                   ActivityAction;                                    // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF2[0x3];                                     // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerGuildExpReward;                              // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerGuildActivityLevelReward;                    // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerCoinReward;                                  // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF3[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildQuestGeneratorGoal">();
	}
	static class UVAL_PlayerGuildQuestGeneratorGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildQuestGeneratorGoal>();
	}
};
static_assert(alignof(UVAL_PlayerGuildQuestGeneratorGoal) == 0x000008, "Wrong alignment on UVAL_PlayerGuildQuestGeneratorGoal");
static_assert(sizeof(UVAL_PlayerGuildQuestGeneratorGoal) == 0x0000A8, "Wrong size on UVAL_PlayerGuildQuestGeneratorGoal");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorGoal, ActivityName) == 0x000030, "Member 'UVAL_PlayerGuildQuestGeneratorGoal::ActivityName' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorGoal, ActivityDescription) == 0x000048, "Member 'UVAL_PlayerGuildQuestGeneratorGoal::ActivityDescription' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorGoal, ActivityRarity) == 0x000060, "Member 'UVAL_PlayerGuildQuestGeneratorGoal::ActivityRarity' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorGoal, ActivityItemRequired) == 0x000068, "Member 'UVAL_PlayerGuildQuestGeneratorGoal::ActivityItemRequired' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorGoal, QuantityRequired) == 0x000090, "Member 'UVAL_PlayerGuildQuestGeneratorGoal::QuantityRequired' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorGoal, ActivityAction) == 0x000094, "Member 'UVAL_PlayerGuildQuestGeneratorGoal::ActivityAction' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorGoal, PlayerGuildExpReward) == 0x000098, "Member 'UVAL_PlayerGuildQuestGeneratorGoal::PlayerGuildExpReward' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorGoal, PlayerGuildActivityLevelReward) == 0x00009C, "Member 'UVAL_PlayerGuildQuestGeneratorGoal::PlayerGuildActivityLevelReward' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorGoal, PlayerCoinReward) == 0x0000A0, "Member 'UVAL_PlayerGuildQuestGeneratorGoal::PlayerCoinReward' has a wrong offset!");

// Class Palia.VAL_PlayerGuildQuestGeneratorBucket
// 0x0010 (0x0040 - 0x0030)
class UVAL_PlayerGuildQuestGeneratorBucket final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UVAL_PlayerGuildQuestGeneratorGoal>> PlayerGuildActivity;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildQuestGeneratorBucket">();
	}
	static class UVAL_PlayerGuildQuestGeneratorBucket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildQuestGeneratorBucket>();
	}
};
static_assert(alignof(UVAL_PlayerGuildQuestGeneratorBucket) == 0x000008, "Wrong alignment on UVAL_PlayerGuildQuestGeneratorBucket");
static_assert(sizeof(UVAL_PlayerGuildQuestGeneratorBucket) == 0x000040, "Wrong size on UVAL_PlayerGuildQuestGeneratorBucket");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorBucket, PlayerGuildActivity) == 0x000030, "Member 'UVAL_PlayerGuildQuestGeneratorBucket::PlayerGuildActivity' has a wrong offset!");

// Class Palia.VAL_PlayerGuildQuestGeneratorConfig
// 0x0090 (0x00C0 - 0x0030)
class UVAL_PlayerGuildQuestGeneratorConfig final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UVAL_PlayerGuildQuestGeneratorBucket>> SmallBuckets;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UVAL_PlayerGuildQuestGeneratorBucket>> MediumBuckets;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UVAL_PlayerGuildQuestGeneratorBucket>> LargeBuckets;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         NumSmallToGenerate;                                // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumMediumToGenerate;                               // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumLargeToGenerate;                                // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF4[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EVAL_PlayerGuildQuestRarity, uint32>     RarityWeights;                                     // 0x0070(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildQuestGeneratorConfig">();
	}
	static class UVAL_PlayerGuildQuestGeneratorConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildQuestGeneratorConfig>();
	}
};
static_assert(alignof(UVAL_PlayerGuildQuestGeneratorConfig) == 0x000008, "Wrong alignment on UVAL_PlayerGuildQuestGeneratorConfig");
static_assert(sizeof(UVAL_PlayerGuildQuestGeneratorConfig) == 0x0000C0, "Wrong size on UVAL_PlayerGuildQuestGeneratorConfig");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorConfig, SmallBuckets) == 0x000030, "Member 'UVAL_PlayerGuildQuestGeneratorConfig::SmallBuckets' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorConfig, MediumBuckets) == 0x000040, "Member 'UVAL_PlayerGuildQuestGeneratorConfig::MediumBuckets' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorConfig, LargeBuckets) == 0x000050, "Member 'UVAL_PlayerGuildQuestGeneratorConfig::LargeBuckets' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorConfig, NumSmallToGenerate) == 0x000060, "Member 'UVAL_PlayerGuildQuestGeneratorConfig::NumSmallToGenerate' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorConfig, NumMediumToGenerate) == 0x000064, "Member 'UVAL_PlayerGuildQuestGeneratorConfig::NumMediumToGenerate' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorConfig, NumLargeToGenerate) == 0x000068, "Member 'UVAL_PlayerGuildQuestGeneratorConfig::NumLargeToGenerate' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildQuestGeneratorConfig, RarityWeights) == 0x000070, "Member 'UVAL_PlayerGuildQuestGeneratorConfig::RarityWeights' has a wrong offset!");

// Class Palia.VAL_PlayerGuildSubsystem
// 0x0180 (0x01B0 - 0x0030)
class UVAL_PlayerGuildSubsystem final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnUserMembershipChanged;                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerGuildChanged;                              // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInboundInvitationsChanged;                       // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewInboundInvitationReceived;                    // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOutboundInvitationsChanged;                      // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInboundApplicationsChanged;                      // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewInboundApplicationReceived;                   // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOutboundApplicationsChanged;                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF5[0x100];                                   // 0x00B0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 FindIndexOfUserInPlayerGuildRoster(TArray<struct FVAL_PlayerGuildRosterEntry>& Roster, struct FUniqueNetIdRepl& UserNetId);
	static bool TryGetRoleForUserId(struct FVAL_PlayerGuild& PlayerGuild, struct FUniqueNetIdRepl& UserId, EVAL_PlayerGuildMemberRole* OutRole);

	void AcceptApplication(struct FGuid& PlayerGuildId, struct FUniqueNetIdRepl& ApplicantUserId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void OnGenericOperation_Failed__DelegateSignature(const class FString& ErrorMessage);
	void OnGenericOperation_Succeeded__DelegateSignature();
	void AcceptInvite(struct FGuid& PlayerGuildId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void CancelApplication(struct FGuid& PlayerGuildId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void CancelInvite(struct FGuid& PlayerGuildId, struct FUniqueNetIdRepl& UserId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	bool CanTransferGuildOwnership(struct FUniqueNetIdRepl& CurrentOwnerId, struct FUniqueNetIdRepl& NewOwnerId);
	void CreatePlayerGuild(struct FVAL_PlayerGuild& PlayerGuild, TDelegate<void(const struct FGuid& PlayerGuildId)> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void OnCreatePlayerGuild_Succeeded__DelegateSignature(const struct FGuid& PlayerGuildId);
	void DeclineApplication(struct FGuid& PlayerGuildId, struct FUniqueNetIdRepl& ApplicantUserId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void DeclineInvite(struct FGuid& PlayerGuildId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void DeletePlayerGuild(struct FGuid& PlayerGuildId, TDelegate<void(const struct FGuid& PlayerGuildId)> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void OnDeletePlayerGuild_Succeeded__DelegateSignature(const struct FGuid& PlayerGuildId);
	void DemoteFromAdmin(struct FGuid& PlayerGuildId, struct FUniqueNetIdRepl& UserId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void HandleNewControlMessage(struct FControlMessage& ControlMessage);
	void KickFromPlayerGuild(struct FGuid& PlayerGuildId, struct FUniqueNetIdRepl& UserId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void LeavePlayerGuild(struct FGuid& PlayerGuildId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void ModifyPlayerGuild(struct FVAL_PlayerGuild& ModifiedPlayerGuild, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void OnGetApplications_Succeeded__DelegateSignature(const struct FVAL_PlayerGuildApplicationList& ApplicationList);
	void OnGetInvitations_Succeeded__DelegateSignature(const struct FVAL_PlayerGuildInvitationList& InvitationList);
	void OnGetPlayerGuild_Succeeded__DelegateSignature(const struct FVAL_PlayerGuild& PlayerGuild);
	void OnGetUsersPlayerGuild_Succeeded__DelegateSignature(bool bHasMembership, const struct FVAL_PlayerGuild& PlayerGuild);
	void OnInboundApplicationsChanged__DelegateSignature(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem);
	void OnInboundInvitationsChanged__DelegateSignature(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem);
	void OnNewInboundApplicationReceived__DelegateSignature(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem, const struct FGuid& PlayerGuildId, const struct FUniqueNetIdRepl& ApplicantId);
	void OnNewInboundInvitationReceived__DelegateSignature(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem, const struct FGuid& PlayerGuildId, const struct FUniqueNetIdRepl& InviterId);
	void OnOutboundApplicationsChanged__DelegateSignature(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem);
	void OnOutboundInvitationsChanged__DelegateSignature(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem);
	void OnPlayerGuildChanged__DelegateSignature(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem, const struct FGuid& PlayerGuildId);
	void OnUserMembershipChanged__DelegateSignature(class UVAL_PlayerGuildSubsystem* PlayerGuildSubsystem, struct FUniqueNetIdRepl& AffectedUserNetId);
	void PromoteToAdmin(struct FGuid& PlayerGuildId, struct FUniqueNetIdRepl& UserId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void QueryInboundApplications(TDelegate<void(const struct FVAL_PlayerGuildApplicationList& ApplicationList)> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void QueryInboundInvitations(TDelegate<void(const struct FVAL_PlayerGuildInvitationList& InvitationList)> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void QueryOutboundApplications(TDelegate<void(const struct FVAL_PlayerGuildApplicationList& ApplicationList)> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void QueryOutboundInvitations(TDelegate<void(const struct FVAL_PlayerGuildInvitationList& InvitationList)> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void QueryPlayerGuild(struct FGuid& PlayerGuildId, TDelegate<void(const struct FVAL_PlayerGuild& PlayerGuild)> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void QueryUserMembership(struct FUniqueNetIdRepl& UserId, TDelegate<void(bool bHasMembership, const struct FVAL_PlayerGuild& PlayerGuild)>& OnSuccess, TDelegate<void(const class FString& ErrorMessage)>& OnFailure);
	void RefreshPlayerGuild(struct FGuid& PlayerGuildId);
	void RefreshUserMembership(struct FUniqueNetIdRepl& UserId);
	void SendApplication(struct FGuid& PlayerGuildId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);
	void SendInvite(struct FGuid& PlayerGuildId, struct FUniqueNetIdRepl& UserId, TDelegate<void()> OnSuccess, TDelegate<void(const class FString& ErrorMessage)> OnFailure);

	bool CanRoleDemoteFromAdmin(EVAL_PlayerGuildMemberRole ActingRole, EVAL_PlayerGuildMemberRole TargetRole) const;
	bool CanRoleKickFromPlayerGuild(EVAL_PlayerGuildMemberRole ActingRole, EVAL_PlayerGuildMemberRole TargetRole) const;
	bool CanRoleManageApplicants(struct FVAL_PlayerGuild& PlayerGuild, EVAL_PlayerGuildMemberRole ActingRole) const;
	bool CanRolePromoteToAdmin(EVAL_PlayerGuildMemberRole ActingRole, EVAL_PlayerGuildMemberRole TargetRole) const;
	bool CanRoleSendInvites(struct FVAL_PlayerGuild& PlayerGuild, EVAL_PlayerGuildMemberRole ActingRole) const;
	TArray<struct FVAL_PlayerGuildRosterEntry> GetGuildRoster(struct FGuid& PlayerGuildId) const;
	bool IsLocalPlayerInPlayerGuildWith(const class FString& PlayerCharacterName) const;
	TArray<struct FVAL_PlayerGuildRosterEntry> SortPlayerGuildMembersArray(TArray<struct FVAL_PlayerGuildRosterEntry>& Array) const;
	bool TryGetInboundApplications(struct FVAL_PlayerGuildApplicationList* OutApplications) const;
	bool TryGetInboundInvitations(struct FVAL_PlayerGuildInvitationList* OutInvitations) const;
	bool TryGetOutboundApplications(struct FVAL_PlayerGuildApplicationList* OutApplications) const;
	bool TryGetOutboundInvitations(struct FVAL_PlayerGuildInvitationList* OutInvitations) const;
	bool TryGetPlayerGuild(struct FGuid& PlayerGuildId, struct FVAL_PlayerGuild* OutPlayerGuildInfo) const;
	bool TryGetUserMembership(struct FUniqueNetIdRepl& UserId, bool* bOutHasMembership, struct FVAL_PlayerGuild* PlayerGuild) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildSubsystem">();
	}
	static class UVAL_PlayerGuildSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildSubsystem>();
	}
};
static_assert(alignof(UVAL_PlayerGuildSubsystem) == 0x000008, "Wrong alignment on UVAL_PlayerGuildSubsystem");
static_assert(sizeof(UVAL_PlayerGuildSubsystem) == 0x0001B0, "Wrong size on UVAL_PlayerGuildSubsystem");
static_assert(offsetof(UVAL_PlayerGuildSubsystem, OnUserMembershipChanged) == 0x000030, "Member 'UVAL_PlayerGuildSubsystem::OnUserMembershipChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSubsystem, OnPlayerGuildChanged) == 0x000040, "Member 'UVAL_PlayerGuildSubsystem::OnPlayerGuildChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSubsystem, OnInboundInvitationsChanged) == 0x000050, "Member 'UVAL_PlayerGuildSubsystem::OnInboundInvitationsChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSubsystem, OnNewInboundInvitationReceived) == 0x000060, "Member 'UVAL_PlayerGuildSubsystem::OnNewInboundInvitationReceived' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSubsystem, OnOutboundInvitationsChanged) == 0x000070, "Member 'UVAL_PlayerGuildSubsystem::OnOutboundInvitationsChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSubsystem, OnInboundApplicationsChanged) == 0x000080, "Member 'UVAL_PlayerGuildSubsystem::OnInboundApplicationsChanged' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSubsystem, OnNewInboundApplicationReceived) == 0x000090, "Member 'UVAL_PlayerGuildSubsystem::OnNewInboundApplicationReceived' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSubsystem, OnOutboundApplicationsChanged) == 0x0000A0, "Member 'UVAL_PlayerGuildSubsystem::OnOutboundApplicationsChanged' has a wrong offset!");

// Class Palia.VAL_PlayerGuildGameInstanceSubsystem
// 0x00A0 (0x00D0 - 0x0030)
class UVAL_PlayerGuildGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2C04[0xA0];                                    // 0x0030(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildGameInstanceSubsystem">();
	}
	static class UVAL_PlayerGuildGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildGameInstanceSubsystem>();
	}
};
static_assert(alignof(UVAL_PlayerGuildGameInstanceSubsystem) == 0x000008, "Wrong alignment on UVAL_PlayerGuildGameInstanceSubsystem");
static_assert(sizeof(UVAL_PlayerGuildGameInstanceSubsystem) == 0x0000D0, "Wrong size on UVAL_PlayerGuildGameInstanceSubsystem");

// Class Palia.VAL_Functor_OnGetPlayerGuildDelegates
// 0x0088 (0x00B0 - 0x0028)
class UVAL_Functor_OnGetPlayerGuildDelegates final : public UObject
{
public:
	uint8                                         Pad_2C05[0x88];                                    // 0x0028(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FailureCallback(const class FString& ErrorMessage);
	void SuccessCallback(const struct FVAL_PlayerGuild& PlayerGuildInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_Functor_OnGetPlayerGuildDelegates">();
	}
	static class UVAL_Functor_OnGetPlayerGuildDelegates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_Functor_OnGetPlayerGuildDelegates>();
	}
};
static_assert(alignof(UVAL_Functor_OnGetPlayerGuildDelegates) == 0x000008, "Wrong alignment on UVAL_Functor_OnGetPlayerGuildDelegates");
static_assert(sizeof(UVAL_Functor_OnGetPlayerGuildDelegates) == 0x0000B0, "Wrong size on UVAL_Functor_OnGetPlayerGuildDelegates");

// Class Palia.VAL_PlayerGuildSettings
// 0x0078 (0x00B0 - 0x0038)
class UVAL_PlayerGuildSettings final : public UDeveloperSettings
{
public:
	class FText                                   PlayerGuildCreationDefaultErrorText;               // 0x0038(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   PlayerGuildCreationNameValidation_InvalidErrorText; // 0x0050(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   PlayerGuildCreationNameValidation_ProfanityErrorText; // 0x0068(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   PlayerGuildCreationMottoValidation_ProfanityErrorText; // 0x0080(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   PlayerGuildCreationDescriptionValidation_ProfanityErrorText; // 0x0098(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerGuildSettings">();
	}
	static class UVAL_PlayerGuildSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PlayerGuildSettings>();
	}
};
static_assert(alignof(UVAL_PlayerGuildSettings) == 0x000008, "Wrong alignment on UVAL_PlayerGuildSettings");
static_assert(sizeof(UVAL_PlayerGuildSettings) == 0x0000B0, "Wrong size on UVAL_PlayerGuildSettings");
static_assert(offsetof(UVAL_PlayerGuildSettings, PlayerGuildCreationDefaultErrorText) == 0x000038, "Member 'UVAL_PlayerGuildSettings::PlayerGuildCreationDefaultErrorText' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSettings, PlayerGuildCreationNameValidation_InvalidErrorText) == 0x000050, "Member 'UVAL_PlayerGuildSettings::PlayerGuildCreationNameValidation_InvalidErrorText' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSettings, PlayerGuildCreationNameValidation_ProfanityErrorText) == 0x000068, "Member 'UVAL_PlayerGuildSettings::PlayerGuildCreationNameValidation_ProfanityErrorText' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSettings, PlayerGuildCreationMottoValidation_ProfanityErrorText) == 0x000080, "Member 'UVAL_PlayerGuildSettings::PlayerGuildCreationMottoValidation_ProfanityErrorText' has a wrong offset!");
static_assert(offsetof(UVAL_PlayerGuildSettings, PlayerGuildCreationDescriptionValidation_ProfanityErrorText) == 0x000098, "Member 'UVAL_PlayerGuildSettings::PlayerGuildCreationDescriptionValidation_ProfanityErrorText' has a wrong offset!");

// Class Palia.VAL_PlayerState
// 0x0020 (0x0380 - 0x0360)
class AVAL_PlayerState final : public APlayerState
{
public:
	bool                                          bHasInitializedIdentity;                           // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C06[0x7];                                     // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnIdentityInitialized;                             // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHidePlayerOnRemoteClients;                        // 0x0378(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C07[0x7];                                     // 0x0379(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIdentityInitialized__DelegateSignature(class AVAL_PlayerState* PlayerState);
	void OnRep_HidePlayerOnRemoteClient();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PlayerState">();
	}
	static class AVAL_PlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_PlayerState>();
	}
};
static_assert(alignof(AVAL_PlayerState) == 0x000008, "Wrong alignment on AVAL_PlayerState");
static_assert(sizeof(AVAL_PlayerState) == 0x000380, "Wrong size on AVAL_PlayerState");
static_assert(offsetof(AVAL_PlayerState, bHasInitializedIdentity) == 0x000360, "Member 'AVAL_PlayerState::bHasInitializedIdentity' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerState, OnIdentityInitialized) == 0x000368, "Member 'AVAL_PlayerState::OnIdentityInitialized' has a wrong offset!");
static_assert(offsetof(AVAL_PlayerState, bHidePlayerOnRemoteClients) == 0x000378, "Member 'AVAL_PlayerState::bHidePlayerOnRemoteClients' has a wrong offset!");

// Class Palia.VAL_PremiumStoreRequestInterface
// 0x0000 (0x0028 - 0x0028)
class IVAL_PremiumStoreRequestInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PremiumStoreRequestInterface">();
	}
	static class IVAL_PremiumStoreRequestInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVAL_PremiumStoreRequestInterface>();
	}
};
static_assert(alignof(IVAL_PremiumStoreRequestInterface) == 0x000008, "Wrong alignment on IVAL_PremiumStoreRequestInterface");
static_assert(sizeof(IVAL_PremiumStoreRequestInterface) == 0x000028, "Wrong size on IVAL_PremiumStoreRequestInterface");

// Class Palia.VAL_PremiumStoreSubsystem
// 0x0048 (0x0078 - 0x0030)
class UVAL_PremiumStoreSubsystem final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPremiumItemsAcquired;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPremiumCurrencyBalanceUpdated;                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C08[0x8];                                     // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IVAL_PremiumStoreRequestInterface> OnlineFeatureRequester;                            // 0x0058(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C09[0x10];                                    // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPremiumCurrencyBalanceUpdated__DelegateSignature(int32 PremiumCurrencyAmount, int32 TotalPurchasedCoinsAmount);
	void OnPremiumItemsAcquired__DelegateSignature(TSet<struct FGuid>& Ids);
	void OnPurchaseMultipleItemsRequestCompleted__DelegateSignature(TArray<struct FGuid>& VariantId, bool bWasSuccessful);
	void OnPurchaseRequestCompleted__DelegateSignature(struct FGuid& VariantId, bool bWasSuccessful);
	bool PurchaseBundle(struct FGuid& BundleId, TSet<struct FGuid>& ItemIds, int32 Price, TDelegate<void(struct FGuid& VariantId, bool bWasSuccessful)>& HandlePurchaseRequestCompleted);
	bool PurchaseMultipleVariants(TArray<struct FGuid>& VariantIds, TSet<struct FGuid>& ItemIds, int32 Price, TDelegate<void(TArray<struct FGuid>& VariantId, bool bWasSuccessful)>& HandlePurchaseRequestCompleted);
	bool PurchaseSet(struct FGuid& SetId, TSet<struct FGuid>& ItemIds, int32 Price, TDelegate<void(struct FGuid& VariantId, bool bWasSuccessful)>& HandlePurchaseRequestCompleted);
	bool PurchaseVariant(struct FGuid& VariantId, TSet<struct FGuid>& ItemIds, int32 Price, TDelegate<void(struct FGuid& VariantId, bool bWasSuccessful)>& HandlePurchaseRequestCompleted);
	bool RequestSyncWallet();

	int32 GetPremiumCurrencyAmount() const;
	int32 GetTotalPurchasedCoinAmount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_PremiumStoreSubsystem">();
	}
	static class UVAL_PremiumStoreSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_PremiumStoreSubsystem>();
	}
};
static_assert(alignof(UVAL_PremiumStoreSubsystem) == 0x000008, "Wrong alignment on UVAL_PremiumStoreSubsystem");
static_assert(sizeof(UVAL_PremiumStoreSubsystem) == 0x000078, "Wrong size on UVAL_PremiumStoreSubsystem");
static_assert(offsetof(UVAL_PremiumStoreSubsystem, OnPremiumItemsAcquired) == 0x000030, "Member 'UVAL_PremiumStoreSubsystem::OnPremiumItemsAcquired' has a wrong offset!");
static_assert(offsetof(UVAL_PremiumStoreSubsystem, OnPremiumCurrencyBalanceUpdated) == 0x000040, "Member 'UVAL_PremiumStoreSubsystem::OnPremiumCurrencyBalanceUpdated' has a wrong offset!");
static_assert(offsetof(UVAL_PremiumStoreSubsystem, OnlineFeatureRequester) == 0x000058, "Member 'UVAL_PremiumStoreSubsystem::OnlineFeatureRequester' has a wrong offset!");

// Class Palia.VAL_ProximityTeleporter
// 0x0010 (0x0330 - 0x0320)
class AVAL_ProximityTeleporter : public AVAL_TeleporterBase
{
public:
	class UBoxComponent*                          EffectOverlap;                                     // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          TeleportTriggerOverlap;                            // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Implementation_OnEffectOverlapBegin_Client(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void Implementation_OnEffectOverlapBegin_Server(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void Implementation_OnEffectOverlapEnd_Client(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Implementation_OnEffectOverlapEnd_Server(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Implementation_OnTeleportOverlapBegin_Client(class AValeriaCharacter* TeleportedCharacter);
	void Implementation_OnTeleportOverlapBegin_Server(class AValeriaCharacter* TeleportedCharacter);
	void OnEffectOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnEffectOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnTeleportTriggerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ProximityTeleporter">();
	}
	static class AVAL_ProximityTeleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVAL_ProximityTeleporter>();
	}
};
static_assert(alignof(AVAL_ProximityTeleporter) == 0x000008, "Wrong alignment on AVAL_ProximityTeleporter");
static_assert(sizeof(AVAL_ProximityTeleporter) == 0x000330, "Wrong size on AVAL_ProximityTeleporter");
static_assert(offsetof(AVAL_ProximityTeleporter, EffectOverlap) == 0x000320, "Member 'AVAL_ProximityTeleporter::EffectOverlap' has a wrong offset!");
static_assert(offsetof(AVAL_ProximityTeleporter, TeleportTriggerOverlap) == 0x000328, "Member 'AVAL_ProximityTeleporter::TeleportTriggerOverlap' has a wrong offset!");

// Class Palia.VAL_RewardsPlayerComponent
// 0x0068 (0x0108 - 0x00A0)
class UVAL_RewardsPlayerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C17[0x18];                                    // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FVAL_OnClaimPlayerRewardDelegates> ClaimPlayerRewardsRequestIdToResponseDelegatesMap; // 0x00B8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void ClaimPlayerRewards(TArray<struct FGuid>& OriginIds, TDelegate<void(class UVAL_RewardsPlayerComponent* Component)>& OnSuccess, TDelegate<void(class UVAL_RewardsPlayerComponent* Component, class FText& Error)>& OnFailure);
	void ClientReceiveResponse_ClaimPlayerRewards_Failure(struct FGuid& RequestID, class FText& ErrorMessage);
	void ClientReceiveResponse_ClaimPlayerRewards_Success(struct FGuid& RequestID, TArray<struct FGuid>& ClaimedOriginIds);
	bool QueryPlayerRewards(TDelegate<void(class UVAL_RewardsPlayerComponent* Component)>& OnSuccess, TDelegate<void(class UVAL_RewardsPlayerComponent* Component, class FText& Error)>& OnFailure);
	void VAL_OnQueryPlayerRewards_Failure__DelegateSignature(class UVAL_RewardsPlayerComponent* Component, class FText& Error);
	void VAL_OnQueryPlayerRewards_Success__DelegateSignature(class UVAL_RewardsPlayerComponent* Component);
	void ServerMakeRequest_ClaimPlayerRewards(struct FGuid& RequestID, TArray<struct FGuid>& OriginIds);

	bool TryGetCachedPlayerRewards(TArray<struct FConsumableReward>* OutRewards) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_RewardsPlayerComponent">();
	}
	static class UVAL_RewardsPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_RewardsPlayerComponent>();
	}
};
static_assert(alignof(UVAL_RewardsPlayerComponent) == 0x000008, "Wrong alignment on UVAL_RewardsPlayerComponent");
static_assert(sizeof(UVAL_RewardsPlayerComponent) == 0x000108, "Wrong size on UVAL_RewardsPlayerComponent");
static_assert(offsetof(UVAL_RewardsPlayerComponent, ClaimPlayerRewardsRequestIdToResponseDelegatesMap) == 0x0000B8, "Member 'UVAL_RewardsPlayerComponent::ClaimPlayerRewardsRequestIdToResponseDelegatesMap' has a wrong offset!");

// Class Palia.VAL_ScoreComponent
// 0x00E8 (0x0188 - 0x00A0)
class UVAL_ScoreComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C1A[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnScoreChanged;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisplayedScoreChanged;                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FScorePersistBlock                     ScorePersistBlock;                                 // 0x00C8(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FScoreStruct>                   BestScores;                                        // 0x0158(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UVAL_ScoreDefinition*>           ScoresToDisplay;                                   // 0x0168(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UVAL_ScoreDefinition*>           EnabledScores;                                     // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void DisableScore(class UVAL_ScoreDefinition* ScoreDefinition);
	void EnableScore(class UVAL_ScoreDefinition* ScoreDefinition);
	void RpcClient_InitScores(TArray<int32>& ScoreIds, TArray<int32>& ScoreValues);
	void RpcClient_SetScore(class UVAL_ScoreDefinition* ScoreDefinition, int32 Value);
	void RpcClient_SetScoreToDisplay(class UVAL_ScoreDefinition* ScoreDefinition, int32 DisplayedIndex);
	void Server_AddScore(class UVAL_ScoreDefinition* ScoreDefinition, int32 Value);
	void Server_SetScore(class UVAL_ScoreDefinition* ScoreDefinition, int32 Value);
	void Server_SetScoreToDisplay(class UVAL_ScoreDefinition* ScoreDefinition, int32 DisplayedIndex);
	void Server_SubtractScore(class UVAL_ScoreDefinition* ScoreDefinition, int32 Value);

	int32 GetScore(class UVAL_ScoreDefinition* ScoreDefinition) const;
	const class UVAL_ScoreDefinition* GetScoreToDisplay(int32 DisplayedIndex) const;
	bool HasScore(class UVAL_ScoreDefinition* ScoreDefinition) const;
	bool IsScoreEnabled(class UVAL_ScoreDefinition* ScoreDefinition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ScoreComponent">();
	}
	static class UVAL_ScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ScoreComponent>();
	}
};
static_assert(alignof(UVAL_ScoreComponent) == 0x000008, "Wrong alignment on UVAL_ScoreComponent");
static_assert(sizeof(UVAL_ScoreComponent) == 0x000188, "Wrong size on UVAL_ScoreComponent");
static_assert(offsetof(UVAL_ScoreComponent, OnScoreChanged) == 0x0000A8, "Member 'UVAL_ScoreComponent::OnScoreChanged' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreComponent, OnDisplayedScoreChanged) == 0x0000B8, "Member 'UVAL_ScoreComponent::OnDisplayedScoreChanged' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreComponent, ScorePersistBlock) == 0x0000C8, "Member 'UVAL_ScoreComponent::ScorePersistBlock' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreComponent, BestScores) == 0x000158, "Member 'UVAL_ScoreComponent::BestScores' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreComponent, ScoresToDisplay) == 0x000168, "Member 'UVAL_ScoreComponent::ScoresToDisplay' has a wrong offset!");
static_assert(offsetof(UVAL_ScoreComponent, EnabledScores) == 0x000178, "Member 'UVAL_ScoreComponent::EnabledScores' has a wrong offset!");

// Class Palia.VAL_ServerReserveRequestAsyncStream
// 0x0010 (0x0058 - 0x0048)
class UVAL_ServerReserveRequestAsyncStream final : public UVAL_MQTTMatchmakerServerAsyncStreamBase
{
public:
	uint8                                         Pad_2C25[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ServerReserveRequestAsyncStream">();
	}
	static class UVAL_ServerReserveRequestAsyncStream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ServerReserveRequestAsyncStream>();
	}
};
static_assert(alignof(UVAL_ServerReserveRequestAsyncStream) == 0x000008, "Wrong alignment on UVAL_ServerReserveRequestAsyncStream");
static_assert(sizeof(UVAL_ServerReserveRequestAsyncStream) == 0x000058, "Wrong size on UVAL_ServerReserveRequestAsyncStream");

// Class Palia.VAL_ServerMaintenanceScheduledAsyncStream
// 0x0010 (0x0058 - 0x0048)
class UVAL_ServerMaintenanceScheduledAsyncStream final : public UVAL_MQTTAsyncStreamBase
{
public:
	uint8                                         Pad_2C26[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ServerMaintenanceScheduledAsyncStream">();
	}
	static class UVAL_ServerMaintenanceScheduledAsyncStream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ServerMaintenanceScheduledAsyncStream>();
	}
};
static_assert(alignof(UVAL_ServerMaintenanceScheduledAsyncStream) == 0x000008, "Wrong alignment on UVAL_ServerMaintenanceScheduledAsyncStream");
static_assert(sizeof(UVAL_ServerMaintenanceScheduledAsyncStream) == 0x000058, "Wrong size on UVAL_ServerMaintenanceScheduledAsyncStream");

// Class Palia.VAL_ServerRegistrationRequestAsyncStream
// 0x0010 (0x0058 - 0x0048)
class UVAL_ServerRegistrationRequestAsyncStream final : public UVAL_MQTTMatchmakerServerAsyncStreamBase
{
public:
	uint8                                         Pad_2C27[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ServerRegistrationRequestAsyncStream">();
	}
	static class UVAL_ServerRegistrationRequestAsyncStream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ServerRegistrationRequestAsyncStream>();
	}
};
static_assert(alignof(UVAL_ServerRegistrationRequestAsyncStream) == 0x000008, "Wrong alignment on UVAL_ServerRegistrationRequestAsyncStream");
static_assert(sizeof(UVAL_ServerRegistrationRequestAsyncStream) == 0x000058, "Wrong size on UVAL_ServerRegistrationRequestAsyncStream");

// Class Palia.SpawnValidator
// 0x0010 (0x02B8 - 0x02A8)
class ASpawnValidator final : public AActor
{
public:
	TSubclassOf<class USpawnOnFoliageManager>     SpawnOnFoliageManager;                             // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           MapOpenedTimer;                                    // 0x02B0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleDestroyed(class AActor* DestroyedActor);
	void HandleMapOpened(const class FString& Filename, bool bLoadAsTemplate);
	void HandleTimerComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnValidator">();
	}
	static class ASpawnValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnValidator>();
	}
};
static_assert(alignof(ASpawnValidator) == 0x000008, "Wrong alignment on ASpawnValidator");
static_assert(sizeof(ASpawnValidator) == 0x0002B8, "Wrong size on ASpawnValidator");
static_assert(offsetof(ASpawnValidator, SpawnOnFoliageManager) == 0x0002A8, "Member 'ASpawnValidator::SpawnOnFoliageManager' has a wrong offset!");
static_assert(offsetof(ASpawnValidator, MapOpenedTimer) == 0x0002B0, "Member 'ASpawnValidator::MapOpenedTimer' has a wrong offset!");

// Class Palia.VAL_SprayDataAsset
// 0x0048 (0x0078 - 0x0030)
class UVAL_SprayDataAsset final : public UPrimaryDataAsset
{
public:
	struct FGuid                                  SprayId;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVAL_SprayData                         SprayData;                                         // 0x0040(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_SprayDataAsset">();
	}
	static class UVAL_SprayDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_SprayDataAsset>();
	}
};
static_assert(alignof(UVAL_SprayDataAsset) == 0x000008, "Wrong alignment on UVAL_SprayDataAsset");
static_assert(sizeof(UVAL_SprayDataAsset) == 0x000078, "Wrong size on UVAL_SprayDataAsset");
static_assert(offsetof(UVAL_SprayDataAsset, SprayId) == 0x000030, "Member 'UVAL_SprayDataAsset::SprayId' has a wrong offset!");
static_assert(offsetof(UVAL_SprayDataAsset, SprayData) == 0x000040, "Member 'UVAL_SprayDataAsset::SprayData' has a wrong offset!");

// Class Palia.VAL_TimerComponent
// 0x0060 (0x0100 - 0x00A0)
class UVAL_TimerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnTimerChanged;                                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimerStarted;                                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimerStopped;                                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisplayedTimerChanged;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UVAL_TimerInstance*>             TimerInstances;                                    // 0x00E0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UVAL_TimerDefinition*>           TimersToDisplay;                                   // 0x00F0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void HandleCharacterUnstuck();
	void RpcClient_SetTimerToDisplay(class UVAL_TimerDefinition* TimerDefinition, int32 DisplayedIndex);
	void RpcClient_TimerStarted(struct FVAL_TimerStateStruct& TimerState);
	void RpcClient_TimerStopped(struct FVAL_TimerStateStruct& TimerState);
	void RpcClient_UpdateTimer(struct FVAL_TimerStateStruct& TimerState);
	void Server_PauseTimer(class UVAL_TimerDefinition* TimerDefinition);
	void Server_SetTimerToDisplay(class UVAL_TimerDefinition* TimerDefinition, int32 DisplayedIndex);
	void Server_StartTimer(class UVAL_TimerDefinition* TimerDefinition);
	void Server_StopTimer(class UVAL_TimerDefinition* TimerDefinition);
	void Server_UnpauseTimer(class UVAL_TimerDefinition* TimerDefinition);

	int64 GetSecondsElapsed(class UVAL_TimerDefinition* TimerDefinition) const;
	int64 GetSecondsOnTimer(class UVAL_TimerDefinition* TimerDefinition) const;
	int64 GetSecondsOnTimerToDisplay(int32 DisplayedIndex) const;
	int64 GetSecondsRemaining(class UVAL_TimerDefinition* TimerDefinition) const;
	const class UVAL_TimerDefinition* GetTimerToDisplay(int32 DisplayedIndex) const;
	bool HasTimerStarted(class UVAL_TimerDefinition* TimerDefinition) const;
	bool IsTimerPaused(class UVAL_TimerDefinition* TimerDefinition) const;
	bool IsTimerStopped(class UVAL_TimerDefinition* TimerDefinition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TimerComponent">();
	}
	static class UVAL_TimerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TimerComponent>();
	}
};
static_assert(alignof(UVAL_TimerComponent) == 0x000008, "Wrong alignment on UVAL_TimerComponent");
static_assert(sizeof(UVAL_TimerComponent) == 0x000100, "Wrong size on UVAL_TimerComponent");
static_assert(offsetof(UVAL_TimerComponent, OnTimerChanged) == 0x0000A0, "Member 'UVAL_TimerComponent::OnTimerChanged' has a wrong offset!");
static_assert(offsetof(UVAL_TimerComponent, OnTimerStarted) == 0x0000B0, "Member 'UVAL_TimerComponent::OnTimerStarted' has a wrong offset!");
static_assert(offsetof(UVAL_TimerComponent, OnTimerStopped) == 0x0000C0, "Member 'UVAL_TimerComponent::OnTimerStopped' has a wrong offset!");
static_assert(offsetof(UVAL_TimerComponent, OnDisplayedTimerChanged) == 0x0000D0, "Member 'UVAL_TimerComponent::OnDisplayedTimerChanged' has a wrong offset!");
static_assert(offsetof(UVAL_TimerComponent, TimerInstances) == 0x0000E0, "Member 'UVAL_TimerComponent::TimerInstances' has a wrong offset!");
static_assert(offsetof(UVAL_TimerComponent, TimersToDisplay) == 0x0000F0, "Member 'UVAL_TimerComponent::TimersToDisplay' has a wrong offset!");

// Class Palia.VAL_TimerDefinition
// 0x0028 (0x0080 - 0x0058)
class UVAL_TimerDefinition final : public UVAL_DataAsset
{
public:
	ETimerDirection                               TimerDirection;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C30[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         CountdownSeconds;                                  // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldResetOnStart;                               // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldResetOnUnstuck;                             // 0x0069(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C31[0x6];                                     // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVAL_TimerGameplayEventSpecification> GameplayEventSpecs;                                // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TimerDefinition">();
	}
	static class UVAL_TimerDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TimerDefinition>();
	}
};
static_assert(alignof(UVAL_TimerDefinition) == 0x000008, "Wrong alignment on UVAL_TimerDefinition");
static_assert(sizeof(UVAL_TimerDefinition) == 0x000080, "Wrong size on UVAL_TimerDefinition");
static_assert(offsetof(UVAL_TimerDefinition, TimerDirection) == 0x000058, "Member 'UVAL_TimerDefinition::TimerDirection' has a wrong offset!");
static_assert(offsetof(UVAL_TimerDefinition, CountdownSeconds) == 0x000060, "Member 'UVAL_TimerDefinition::CountdownSeconds' has a wrong offset!");
static_assert(offsetof(UVAL_TimerDefinition, bShouldResetOnStart) == 0x000068, "Member 'UVAL_TimerDefinition::bShouldResetOnStart' has a wrong offset!");
static_assert(offsetof(UVAL_TimerDefinition, bShouldResetOnUnstuck) == 0x000069, "Member 'UVAL_TimerDefinition::bShouldResetOnUnstuck' has a wrong offset!");
static_assert(offsetof(UVAL_TimerDefinition, GameplayEventSpecs) == 0x000070, "Member 'UVAL_TimerDefinition::GameplayEventSpecs' has a wrong offset!");

// Class Palia.VAL_TintAsset
// 0x0058 (0x00B0 - 0x0058)
class UVAL_TintAsset final : public UVAL_DataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	struct FGuid                                  ItemId;                                            // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultUnlocked;                                  // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C32[0x7];                                     // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              IconOverlay;                                       // 0x0088(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static TArray<TSoftObjectPtr<class UVAL_TintAsset>> GetAllTintAssets();
	static TSoftObjectPtr<class UVAL_TintAsset> GetTintFromPersistID(int32 PersistIdToGet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TintAsset">();
	}
	static class UVAL_TintAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TintAsset>();
	}
};
static_assert(alignof(UVAL_TintAsset) == 0x000008, "Wrong alignment on UVAL_TintAsset");
static_assert(sizeof(UVAL_TintAsset) == 0x0000B0, "Wrong size on UVAL_TintAsset");
static_assert(offsetof(UVAL_TintAsset, DisplayName) == 0x000058, "Member 'UVAL_TintAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UVAL_TintAsset, ItemId) == 0x000070, "Member 'UVAL_TintAsset::ItemId' has a wrong offset!");
static_assert(offsetof(UVAL_TintAsset, bDefaultUnlocked) == 0x000080, "Member 'UVAL_TintAsset::bDefaultUnlocked' has a wrong offset!");
static_assert(offsetof(UVAL_TintAsset, IconOverlay) == 0x000088, "Member 'UVAL_TintAsset::IconOverlay' has a wrong offset!");

// Class Palia.VAL_TravelLoadingScreenStateRequester
// 0x0080 (0x00C8 - 0x0048)
class UVAL_TravelLoadingScreenStateRequester final : public UPaliaScreenStateRequester
{
public:
	uint8                                         Pad_2C34[0x80];                                    // 0x0048(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnPawnChanged(class APawn* Pawn);
	void HandleOnTeleportFlagsChanged(EVAL_TeleportCompFlags Param_Flags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TravelLoadingScreenStateRequester">();
	}
	static class UVAL_TravelLoadingScreenStateRequester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TravelLoadingScreenStateRequester>();
	}
};
static_assert(alignof(UVAL_TravelLoadingScreenStateRequester) == 0x000008, "Wrong alignment on UVAL_TravelLoadingScreenStateRequester");
static_assert(sizeof(UVAL_TravelLoadingScreenStateRequester) == 0x0000C8, "Wrong size on UVAL_TravelLoadingScreenStateRequester");

// Class Palia.VAL_TutorialFlagDefinition
// 0x0088 (0x00B8 - 0x0030)
class UVAL_TutorialFlagDefinition final : public UDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSet<TSoftObjectPtr<class UVAL_TutorialFlagDefinition>> PrerequisiteFlags;                                 // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAllowOverOtherModals;                             // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C35[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TutorialFlagDefinition">();
	}
	static class UVAL_TutorialFlagDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TutorialFlagDefinition>();
	}
};
static_assert(alignof(UVAL_TutorialFlagDefinition) == 0x000008, "Wrong alignment on UVAL_TutorialFlagDefinition");
static_assert(sizeof(UVAL_TutorialFlagDefinition) == 0x0000B8, "Wrong size on UVAL_TutorialFlagDefinition");
static_assert(offsetof(UVAL_TutorialFlagDefinition, DisplayName) == 0x000030, "Member 'UVAL_TutorialFlagDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(UVAL_TutorialFlagDefinition, Description) == 0x000048, "Member 'UVAL_TutorialFlagDefinition::Description' has a wrong offset!");
static_assert(offsetof(UVAL_TutorialFlagDefinition, PrerequisiteFlags) == 0x000060, "Member 'UVAL_TutorialFlagDefinition::PrerequisiteFlags' has a wrong offset!");
static_assert(offsetof(UVAL_TutorialFlagDefinition, bAllowOverOtherModals) == 0x0000B0, "Member 'UVAL_TutorialFlagDefinition::bAllowOverOtherModals' has a wrong offset!");

// Class Palia.VAL_TutorialFlagsManager
// 0x0080 (0x00B0 - 0x0030)
class UVAL_TutorialFlagsManager final : public ULocalPlayerSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnTutorialFlagTriggered;                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsTutorialEnabled;                                // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C36[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSoftObjectPtr<class UVAL_TutorialFlagDefinition>> SetFlagsSet;                                       // 0x0048(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	class FString                                 PersistentJsonFilePathPrefix;                      // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C37[0x8];                                     // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllFlags();
	void ClearFlag(TSoftObjectPtr<class UVAL_TutorialFlagDefinition> Flag);
	void OnTutorialFlagTriggered__DelegateSignature(class UVAL_TutorialFlagsManager* TutorialFlagsManager, TSoftObjectPtr<class UVAL_TutorialFlagDefinition> TriggeredFlag);
	void SetAllFlags();
	void SetFlag(TSoftObjectPtr<class UVAL_TutorialFlagDefinition> Flag);
	void SetIsTutorialEnabled(bool bValue);
	void TryToTriggerTutorialForFlag(TSoftObjectPtr<class UVAL_TutorialFlagDefinition> Flag);

	bool CanStartTutorialForFlag(TSoftObjectPtr<class UVAL_TutorialFlagDefinition> Flag) const;
	TSet<TSoftObjectPtr<class UVAL_TutorialFlagDefinition>> GetAllPossibleFlags() const;
	TSet<TSoftObjectPtr<class UVAL_TutorialFlagDefinition>> GetAllSetFlags() const;
	bool IsFlagSet(TSoftObjectPtr<class UVAL_TutorialFlagDefinition> Flag) const;
	bool IsTutorialEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_TutorialFlagsManager">();
	}
	static class UVAL_TutorialFlagsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_TutorialFlagsManager>();
	}
};
static_assert(alignof(UVAL_TutorialFlagsManager) == 0x000008, "Wrong alignment on UVAL_TutorialFlagsManager");
static_assert(sizeof(UVAL_TutorialFlagsManager) == 0x0000B0, "Wrong size on UVAL_TutorialFlagsManager");
static_assert(offsetof(UVAL_TutorialFlagsManager, OnTutorialFlagTriggered) == 0x000030, "Member 'UVAL_TutorialFlagsManager::OnTutorialFlagTriggered' has a wrong offset!");
static_assert(offsetof(UVAL_TutorialFlagsManager, bIsTutorialEnabled) == 0x000040, "Member 'UVAL_TutorialFlagsManager::bIsTutorialEnabled' has a wrong offset!");
static_assert(offsetof(UVAL_TutorialFlagsManager, SetFlagsSet) == 0x000048, "Member 'UVAL_TutorialFlagsManager::SetFlagsSet' has a wrong offset!");
static_assert(offsetof(UVAL_TutorialFlagsManager, PersistentJsonFilePathPrefix) == 0x000098, "Member 'UVAL_TutorialFlagsManager::PersistentJsonFilePathPrefix' has a wrong offset!");

// Class Palia.VAL_ValeriaBaseAnimInstance
// 0x0000 (0x0350 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) UVAL_ValeriaBaseAnimInstance : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ValeriaBaseAnimInstance">();
	}
	static class UVAL_ValeriaBaseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ValeriaBaseAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVAL_ValeriaBaseAnimInstance) == 0x000010, "Wrong alignment on UVAL_ValeriaBaseAnimInstance");
static_assert(sizeof(UVAL_ValeriaBaseAnimInstance) == 0x000350, "Wrong size on UVAL_ValeriaBaseAnimInstance");

// Class Palia.VAL_ValeriaPCAnimInstance
// 0x07B0 (0x0B00 - 0x0350)
class UVAL_ValeriaPCAnimInstance : public UVAL_ValeriaBaseAnimInstance
{
public:
	struct FGameplayTag                           CurrentLocomotionTag;                              // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerVelocity;                                    // 0x0350(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerRotation;                                    // 0x0368(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PlayerRightVector;                                 // 0x0380(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3A[0x8];                                     // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerTransform;                                   // 0x03A0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerLocation;                                    // 0x0400(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerUsedClimbingSpeed;                           // 0x0418(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3B[0x4];                                     // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFishingMiniGameViewState              CurrentFishingMiniGameViewState;                   // 0x0420(0x0120)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsLeftHandHigher;                                 // 0x0540(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIkEnabledThreaded;                              // 0x0541(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootIKEnabled;                                    // 0x0542(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3C[0x5];                                     // 0x0543(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FootIKOffsetL;                                     // 0x0548(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIkTargetL;                                     // 0x0560(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FootIKRotationOffsetL;                             // 0x0578(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                FootIKOffsetR;                                     // 0x0590(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIkTargetR;                                     // 0x05A8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FootIKRotationOffsetR;                             // 0x05C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FootIKOffsetPelvisAlpha;                           // 0x05D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3D[0x4];                                     // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FootIKOffsetPelvis;                                // 0x05E0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3E[0x68];                                    // 0x05F8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class AValeriaCharacter*                      ValeriaCharacter;                                  // 0x0660(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UValeriaCharacterMoveComponent*         ValeriaCharacterMoveComponent;                     // 0x0668(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocomotionMapping;                                 // 0x0670(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocomotionMappingSecond;                           // 0x0678(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayingSecondLocomotion;                          // 0x0680(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInAir;                                          // 0x0681(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGliding;                                        // 0x0682(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClimbing;                                       // 0x0683(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClimbMoving;                                    // 0x0684(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClimbingAroundEdge;                             // 0x0685(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightSideClimb;                                   // 0x0686(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x0687(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSprinting;                                      // 0x0688(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValeriaClimbDashDirection                    ClimbDashDirection;                                // 0x0689(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3F[0x6];                                     // 0x068A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        VelZ;                                              // 0x0690(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        PrevVelZ;                                          // 0x0698(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExpectSafeLanding;                                // 0x06A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedsLandingCheck;                                // 0x06A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C40[0x6];                                     // 0x06A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        SpeedThresholdFromApex;                            // 0x06A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SpeedThresholdToGuaranteeFall;                     // 0x06B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JumpStartMapping;                                  // 0x06B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JumpPedalMapping;                                  // 0x06C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JumpLoopMapping;                                   // 0x06C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JumpLandMapping;                                   // 0x06D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLooking;                                        // 0x06D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C41[0x7];                                     // 0x06D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PitchLookDirection;                                // 0x06E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Speed;                                             // 0x06E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SpeedDuringAirStateChange;                         // 0x06F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GlideSpeed;                                        // 0x06F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AngleBetweenVelocityandFacing;                     // 0x0700(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        YawDirection;                                      // 0x0708(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        UpperBodyBlend;                                    // 0x0710(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpperAsFull;                                      // 0x0718(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C42[0x7];                                     // 0x0719(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        FishingDirection;                                  // 0x0720(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBiting;                                         // 0x0728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReelHeld;                                         // 0x0729(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFishingMiniGameState                         FishingMinigameState;                              // 0x072A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C43[0x5];                                     // 0x072B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        StateLerp;                                         // 0x0730(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        FishWindExplicitTime;                              // 0x0738(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CatchCelebrateMapping;                             // 0x0740(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimState                             StateChangeRequest;                                // 0x0748(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   FailCancelMapping;                                 // 0x0760(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        FishCastStartTime;                                 // 0x0768(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ClimbUpDown;                                       // 0x0770(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ClimbRightLeft;                                    // 0x0778(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombatTagMapping;                                  // 0x0780(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AdditiveHurtAlpha;                                 // 0x0788(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimOffsetMappingName;                              // 0x0790(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinigameAnimationTime;                             // 0x0798(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CookingRollingAnimationLength;                     // 0x07A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CharacterCustomization_HeightAlpha_Tall;           // 0x07A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CharacterCustomization_HeightAlpha_Short;          // 0x07B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CharacterCustomization_ThicknessAlpha;             // 0x07B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CharacterCustomization_FitnessAlpha;               // 0x07C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CharacterCustomization_GenderAlpha;                // 0x07C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CosmeticsClimbingChangedNew;                       // 0x07D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CosmeticsGlidingChangedNew;                        // 0x07E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CosmeticsMovingChangedNew;                         // 0x07F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CosmeticsJumpingChangedNew;                        // 0x0800(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	float                                         CharacterCustomization_WideAlpha;                  // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNearJumpApex;                                     // 0x0814(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C44[0x3];                                     // 0x0815(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAimingAnimationAimOffset, class FName>  AimOffsetToMapping;                                // 0x0818(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   DefaultJumpStartMapping;                           // 0x0868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultJumpPedalMapping;                           // 0x0870(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultJumpLoopMapping;                            // 0x0878(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultJumpLandRollMapping;                        // 0x0880(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultJumpLandMapping;                            // 0x0888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultJumpEarlyLandMapping;                       // 0x0890(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultLocomotionMapping;                          // 0x0898(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultCombatMapping;                              // 0x08A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FName>        JumpStartMappings;                                 // 0x08A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FName>        JumpPedalMappings;                                 // 0x08F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FName>        JumpLoopMappings;                                  // 0x0948(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FName>        JumpLandMappings;                                  // 0x0998(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FName>        JumpEarlyLandMappings;                             // 0x09E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FName>        FishingSuccessStateChanges;                        // 0x0A38(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class FName>        FishingFailureStateChanges;                        // 0x0A88(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   UpperBodyBlendSlotName;                            // 0x0AD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RunSpeedLowerLimit;                                // 0x0AE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GlideSpeedLowerLimit;                              // 0x0AE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClimbingOverTopMontageName;                        // 0x0AF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClimbingJumpOverTopMontageName;                    // 0x0AF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CalcFishViewVars(struct FFishingMiniGameViewState& FishingMiniGameViewState);
	void CalcGlideVars();
	void CalcLandingExpectation();
	void CheckIsInAir(class AValeriaMoveablePawn* Pawn, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode);
	void CosmeticsClimbingChangedNew__DelegateSignature(bool IsClimbing);
	void CosmeticsGlidingChangedNew__DelegateSignature(bool IsGliding);
	void CosmeticsJumpingChangedNew__DelegateSignature(bool bIsJumping);
	void CosmeticsMovingChangedNew__DelegateSignature(bool Param_bIsMoving, bool Param_bIsSprinting);
	void OnChanged(class AActor* Actor, const struct FAnimState& Context);
	void OnClimbAroundEdgeChanged(const struct FVector& Location, bool MoveStart);
	void OnClimbingChanged(bool bInIsClimbing);
	void OnClimbingDashing(bool bInIsClimbing, EValeriaClimbDashDirection InDirection);
	void OnClimbMovingChanged(bool bInIsMoving);
	void OnClimbOutStarted(const struct FVector& Location);
	void OnCombatTagChange(const struct FGameplayTag& NewTag);
	void OnGliderChange(bool bInIsGliding);
	void OnLocomotionTagChange(const struct FGameplayTag& NewTag);
	void PredictJumpLandingMapping();
	void PrepJumpLandMapping();
	void PrepJumpLandMapping_Internal();
	void PrepJumpLoopMapping();
	void PrepJumpPedalMapping();
	void PrepJumpStartMapping();
	void ResetIKData(float DeltaTime);
	void ResetPhys();
	void SetFootIKData(class FName AnimCurveName, class FName FootIkBone, class FName RootBone, struct FVector* FootIKOffset, struct FVector* FootIKTarget, struct FRotator* FootIkRotation, float DeltaTime);
	void SetLongFalling(bool bFalling);
	void SetPelvisIKData(const struct FVector& Param_FootIkTargetL, const struct FVector& Param_FootIkTargetR, float DeltaTime);
	void TempDisableJump();
	void TempReenableJump();
	void UpdateIKData(float DeltaTime);

	void GetClimbDirectionAxisValues(EValeriaClimbDashDirection ClimbDirection, double* OutX, double* OutY) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_ValeriaPCAnimInstance">();
	}
	static class UVAL_ValeriaPCAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_ValeriaPCAnimInstance>();
	}
};
static_assert(alignof(UVAL_ValeriaPCAnimInstance) == 0x000010, "Wrong alignment on UVAL_ValeriaPCAnimInstance");
static_assert(sizeof(UVAL_ValeriaPCAnimInstance) == 0x000B00, "Wrong size on UVAL_ValeriaPCAnimInstance");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CurrentLocomotionTag) == 0x000348, "Member 'UVAL_ValeriaPCAnimInstance::CurrentLocomotionTag' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, PlayerVelocity) == 0x000350, "Member 'UVAL_ValeriaPCAnimInstance::PlayerVelocity' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, PlayerRotation) == 0x000368, "Member 'UVAL_ValeriaPCAnimInstance::PlayerRotation' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, PlayerRightVector) == 0x000380, "Member 'UVAL_ValeriaPCAnimInstance::PlayerRightVector' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, PlayerTransform) == 0x0003A0, "Member 'UVAL_ValeriaPCAnimInstance::PlayerTransform' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, PlayerLocation) == 0x000400, "Member 'UVAL_ValeriaPCAnimInstance::PlayerLocation' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, PlayerUsedClimbingSpeed) == 0x000418, "Member 'UVAL_ValeriaPCAnimInstance::PlayerUsedClimbingSpeed' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CurrentFishingMiniGameViewState) == 0x000420, "Member 'UVAL_ValeriaPCAnimInstance::CurrentFishingMiniGameViewState' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsLeftHandHigher) == 0x000540, "Member 'UVAL_ValeriaPCAnimInstance::bIsLeftHandHigher' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsIkEnabledThreaded) == 0x000541, "Member 'UVAL_ValeriaPCAnimInstance::bIsIkEnabledThreaded' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bFootIKEnabled) == 0x000542, "Member 'UVAL_ValeriaPCAnimInstance::bFootIKEnabled' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FootIKOffsetL) == 0x000548, "Member 'UVAL_ValeriaPCAnimInstance::FootIKOffsetL' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FootIkTargetL) == 0x000560, "Member 'UVAL_ValeriaPCAnimInstance::FootIkTargetL' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FootIKRotationOffsetL) == 0x000578, "Member 'UVAL_ValeriaPCAnimInstance::FootIKRotationOffsetL' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FootIKOffsetR) == 0x000590, "Member 'UVAL_ValeriaPCAnimInstance::FootIKOffsetR' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FootIkTargetR) == 0x0005A8, "Member 'UVAL_ValeriaPCAnimInstance::FootIkTargetR' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FootIKRotationOffsetR) == 0x0005C0, "Member 'UVAL_ValeriaPCAnimInstance::FootIKRotationOffsetR' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FootIKOffsetPelvisAlpha) == 0x0005D8, "Member 'UVAL_ValeriaPCAnimInstance::FootIKOffsetPelvisAlpha' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FootIKOffsetPelvis) == 0x0005E0, "Member 'UVAL_ValeriaPCAnimInstance::FootIKOffsetPelvis' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, ValeriaCharacter) == 0x000660, "Member 'UVAL_ValeriaPCAnimInstance::ValeriaCharacter' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, ValeriaCharacterMoveComponent) == 0x000668, "Member 'UVAL_ValeriaPCAnimInstance::ValeriaCharacterMoveComponent' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, LocomotionMapping) == 0x000670, "Member 'UVAL_ValeriaPCAnimInstance::LocomotionMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, LocomotionMappingSecond) == 0x000678, "Member 'UVAL_ValeriaPCAnimInstance::LocomotionMappingSecond' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bPlayingSecondLocomotion) == 0x000680, "Member 'UVAL_ValeriaPCAnimInstance::bPlayingSecondLocomotion' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsInAir) == 0x000681, "Member 'UVAL_ValeriaPCAnimInstance::bIsInAir' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsGliding) == 0x000682, "Member 'UVAL_ValeriaPCAnimInstance::bIsGliding' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsClimbing) == 0x000683, "Member 'UVAL_ValeriaPCAnimInstance::bIsClimbing' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsClimbMoving) == 0x000684, "Member 'UVAL_ValeriaPCAnimInstance::bIsClimbMoving' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsClimbingAroundEdge) == 0x000685, "Member 'UVAL_ValeriaPCAnimInstance::bIsClimbingAroundEdge' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bRightSideClimb) == 0x000686, "Member 'UVAL_ValeriaPCAnimInstance::bRightSideClimb' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsMoving) == 0x000687, "Member 'UVAL_ValeriaPCAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsSprinting) == 0x000688, "Member 'UVAL_ValeriaPCAnimInstance::bIsSprinting' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, ClimbDashDirection) == 0x000689, "Member 'UVAL_ValeriaPCAnimInstance::ClimbDashDirection' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, VelZ) == 0x000690, "Member 'UVAL_ValeriaPCAnimInstance::VelZ' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, PrevVelZ) == 0x000698, "Member 'UVAL_ValeriaPCAnimInstance::PrevVelZ' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bExpectSafeLanding) == 0x0006A0, "Member 'UVAL_ValeriaPCAnimInstance::bExpectSafeLanding' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bNeedsLandingCheck) == 0x0006A1, "Member 'UVAL_ValeriaPCAnimInstance::bNeedsLandingCheck' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, SpeedThresholdFromApex) == 0x0006A8, "Member 'UVAL_ValeriaPCAnimInstance::SpeedThresholdFromApex' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, SpeedThresholdToGuaranteeFall) == 0x0006B0, "Member 'UVAL_ValeriaPCAnimInstance::SpeedThresholdToGuaranteeFall' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, JumpStartMapping) == 0x0006B8, "Member 'UVAL_ValeriaPCAnimInstance::JumpStartMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, JumpPedalMapping) == 0x0006C0, "Member 'UVAL_ValeriaPCAnimInstance::JumpPedalMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, JumpLoopMapping) == 0x0006C8, "Member 'UVAL_ValeriaPCAnimInstance::JumpLoopMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, JumpLandMapping) == 0x0006D0, "Member 'UVAL_ValeriaPCAnimInstance::JumpLandMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsLooking) == 0x0006D8, "Member 'UVAL_ValeriaPCAnimInstance::bIsLooking' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, PitchLookDirection) == 0x0006E0, "Member 'UVAL_ValeriaPCAnimInstance::PitchLookDirection' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, Speed) == 0x0006E8, "Member 'UVAL_ValeriaPCAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, SpeedDuringAirStateChange) == 0x0006F0, "Member 'UVAL_ValeriaPCAnimInstance::SpeedDuringAirStateChange' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, GlideSpeed) == 0x0006F8, "Member 'UVAL_ValeriaPCAnimInstance::GlideSpeed' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, AngleBetweenVelocityandFacing) == 0x000700, "Member 'UVAL_ValeriaPCAnimInstance::AngleBetweenVelocityandFacing' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, YawDirection) == 0x000708, "Member 'UVAL_ValeriaPCAnimInstance::YawDirection' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, UpperBodyBlend) == 0x000710, "Member 'UVAL_ValeriaPCAnimInstance::UpperBodyBlend' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bUpperAsFull) == 0x000718, "Member 'UVAL_ValeriaPCAnimInstance::bUpperAsFull' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FishingDirection) == 0x000720, "Member 'UVAL_ValeriaPCAnimInstance::FishingDirection' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bIsBiting) == 0x000728, "Member 'UVAL_ValeriaPCAnimInstance::bIsBiting' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bReelHeld) == 0x000729, "Member 'UVAL_ValeriaPCAnimInstance::bReelHeld' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FishingMinigameState) == 0x00072A, "Member 'UVAL_ValeriaPCAnimInstance::FishingMinigameState' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, StateLerp) == 0x000730, "Member 'UVAL_ValeriaPCAnimInstance::StateLerp' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FishWindExplicitTime) == 0x000738, "Member 'UVAL_ValeriaPCAnimInstance::FishWindExplicitTime' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CatchCelebrateMapping) == 0x000740, "Member 'UVAL_ValeriaPCAnimInstance::CatchCelebrateMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, StateChangeRequest) == 0x000748, "Member 'UVAL_ValeriaPCAnimInstance::StateChangeRequest' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FailCancelMapping) == 0x000760, "Member 'UVAL_ValeriaPCAnimInstance::FailCancelMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FishCastStartTime) == 0x000768, "Member 'UVAL_ValeriaPCAnimInstance::FishCastStartTime' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, ClimbUpDown) == 0x000770, "Member 'UVAL_ValeriaPCAnimInstance::ClimbUpDown' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, ClimbRightLeft) == 0x000778, "Member 'UVAL_ValeriaPCAnimInstance::ClimbRightLeft' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CombatTagMapping) == 0x000780, "Member 'UVAL_ValeriaPCAnimInstance::CombatTagMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, AdditiveHurtAlpha) == 0x000788, "Member 'UVAL_ValeriaPCAnimInstance::AdditiveHurtAlpha' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, AimOffsetMappingName) == 0x000790, "Member 'UVAL_ValeriaPCAnimInstance::AimOffsetMappingName' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, MinigameAnimationTime) == 0x000798, "Member 'UVAL_ValeriaPCAnimInstance::MinigameAnimationTime' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CookingRollingAnimationLength) == 0x0007A0, "Member 'UVAL_ValeriaPCAnimInstance::CookingRollingAnimationLength' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CharacterCustomization_HeightAlpha_Tall) == 0x0007A8, "Member 'UVAL_ValeriaPCAnimInstance::CharacterCustomization_HeightAlpha_Tall' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CharacterCustomization_HeightAlpha_Short) == 0x0007B0, "Member 'UVAL_ValeriaPCAnimInstance::CharacterCustomization_HeightAlpha_Short' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CharacterCustomization_ThicknessAlpha) == 0x0007B8, "Member 'UVAL_ValeriaPCAnimInstance::CharacterCustomization_ThicknessAlpha' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CharacterCustomization_FitnessAlpha) == 0x0007C0, "Member 'UVAL_ValeriaPCAnimInstance::CharacterCustomization_FitnessAlpha' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CharacterCustomization_GenderAlpha) == 0x0007C8, "Member 'UVAL_ValeriaPCAnimInstance::CharacterCustomization_GenderAlpha' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CosmeticsClimbingChangedNew) == 0x0007D0, "Member 'UVAL_ValeriaPCAnimInstance::CosmeticsClimbingChangedNew' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CosmeticsGlidingChangedNew) == 0x0007E0, "Member 'UVAL_ValeriaPCAnimInstance::CosmeticsGlidingChangedNew' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CosmeticsMovingChangedNew) == 0x0007F0, "Member 'UVAL_ValeriaPCAnimInstance::CosmeticsMovingChangedNew' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CosmeticsJumpingChangedNew) == 0x000800, "Member 'UVAL_ValeriaPCAnimInstance::CosmeticsJumpingChangedNew' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, CharacterCustomization_WideAlpha) == 0x000810, "Member 'UVAL_ValeriaPCAnimInstance::CharacterCustomization_WideAlpha' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, bNearJumpApex) == 0x000814, "Member 'UVAL_ValeriaPCAnimInstance::bNearJumpApex' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, AimOffsetToMapping) == 0x000818, "Member 'UVAL_ValeriaPCAnimInstance::AimOffsetToMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, DefaultJumpStartMapping) == 0x000868, "Member 'UVAL_ValeriaPCAnimInstance::DefaultJumpStartMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, DefaultJumpPedalMapping) == 0x000870, "Member 'UVAL_ValeriaPCAnimInstance::DefaultJumpPedalMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, DefaultJumpLoopMapping) == 0x000878, "Member 'UVAL_ValeriaPCAnimInstance::DefaultJumpLoopMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, DefaultJumpLandRollMapping) == 0x000880, "Member 'UVAL_ValeriaPCAnimInstance::DefaultJumpLandRollMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, DefaultJumpLandMapping) == 0x000888, "Member 'UVAL_ValeriaPCAnimInstance::DefaultJumpLandMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, DefaultJumpEarlyLandMapping) == 0x000890, "Member 'UVAL_ValeriaPCAnimInstance::DefaultJumpEarlyLandMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, DefaultLocomotionMapping) == 0x000898, "Member 'UVAL_ValeriaPCAnimInstance::DefaultLocomotionMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, DefaultCombatMapping) == 0x0008A0, "Member 'UVAL_ValeriaPCAnimInstance::DefaultCombatMapping' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, JumpStartMappings) == 0x0008A8, "Member 'UVAL_ValeriaPCAnimInstance::JumpStartMappings' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, JumpPedalMappings) == 0x0008F8, "Member 'UVAL_ValeriaPCAnimInstance::JumpPedalMappings' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, JumpLoopMappings) == 0x000948, "Member 'UVAL_ValeriaPCAnimInstance::JumpLoopMappings' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, JumpLandMappings) == 0x000998, "Member 'UVAL_ValeriaPCAnimInstance::JumpLandMappings' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, JumpEarlyLandMappings) == 0x0009E8, "Member 'UVAL_ValeriaPCAnimInstance::JumpEarlyLandMappings' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FishingSuccessStateChanges) == 0x000A38, "Member 'UVAL_ValeriaPCAnimInstance::FishingSuccessStateChanges' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, FishingFailureStateChanges) == 0x000A88, "Member 'UVAL_ValeriaPCAnimInstance::FishingFailureStateChanges' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, UpperBodyBlendSlotName) == 0x000AD8, "Member 'UVAL_ValeriaPCAnimInstance::UpperBodyBlendSlotName' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, RunSpeedLowerLimit) == 0x000AE0, "Member 'UVAL_ValeriaPCAnimInstance::RunSpeedLowerLimit' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, GlideSpeedLowerLimit) == 0x000AE8, "Member 'UVAL_ValeriaPCAnimInstance::GlideSpeedLowerLimit' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, ClimbingOverTopMontageName) == 0x000AF0, "Member 'UVAL_ValeriaPCAnimInstance::ClimbingOverTopMontageName' has a wrong offset!");
static_assert(offsetof(UVAL_ValeriaPCAnimInstance, ClimbingJumpOverTopMontageName) == 0x000AF8, "Member 'UVAL_ValeriaPCAnimInstance::ClimbingJumpOverTopMontageName' has a wrong offset!");

// Class Palia.VAL_VoiceSet
// 0x0000 (0x0030 - 0x0030)
class UVAL_VoiceSet : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_VoiceSet">();
	}
	static class UVAL_VoiceSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_VoiceSet>();
	}
};
static_assert(alignof(UVAL_VoiceSet) == 0x000008, "Wrong alignment on UVAL_VoiceSet");
static_assert(sizeof(UVAL_VoiceSet) == 0x000030, "Wrong size on UVAL_VoiceSet");

// Class Palia.VAL_WwiseMotionLocalPlayerSubsystem
// 0x0008 (0x0038 - 0x0030)
class UVAL_WwiseMotionLocalPlayerSubsystem final : public ULocalPlayerSubsystem
{
public:
	class UVAL_WwiseMotionBase*                   WwiseMotion;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_WwiseMotionLocalPlayerSubsystem">();
	}
	static class UVAL_WwiseMotionLocalPlayerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_WwiseMotionLocalPlayerSubsystem>();
	}
};
static_assert(alignof(UVAL_WwiseMotionLocalPlayerSubsystem) == 0x000008, "Wrong alignment on UVAL_WwiseMotionLocalPlayerSubsystem");
static_assert(sizeof(UVAL_WwiseMotionLocalPlayerSubsystem) == 0x000038, "Wrong size on UVAL_WwiseMotionLocalPlayerSubsystem");
static_assert(offsetof(UVAL_WwiseMotionLocalPlayerSubsystem, WwiseMotion) == 0x000030, "Member 'UVAL_WwiseMotionLocalPlayerSubsystem::WwiseMotion' has a wrong offset!");

// Class Palia.VAL_WwiseMotionPC
// 0x0008 (0x0038 - 0x0030)
class UVAL_WwiseMotionPC final : public UVAL_WwiseMotionBase
{
public:
	uint8                                         Pad_2C4A[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_WwiseMotionPC">();
	}
	static class UVAL_WwiseMotionPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_WwiseMotionPC>();
	}
};
static_assert(alignof(UVAL_WwiseMotionPC) == 0x000008, "Wrong alignment on UVAL_WwiseMotionPC");
static_assert(sizeof(UVAL_WwiseMotionPC) == 0x000038, "Wrong size on UVAL_WwiseMotionPC");

// Class Palia.VAL_WwiseMotionSwitch
// 0x0000 (0x0030 - 0x0030)
class UVAL_WwiseMotionSwitch final : public UVAL_WwiseMotionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_WwiseMotionSwitch">();
	}
	static class UVAL_WwiseMotionSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_WwiseMotionSwitch>();
	}
};
static_assert(alignof(UVAL_WwiseMotionSwitch) == 0x000008, "Wrong alignment on UVAL_WwiseMotionSwitch");
static_assert(sizeof(UVAL_WwiseMotionSwitch) == 0x000030, "Wrong size on UVAL_WwiseMotionSwitch");

// Class Palia.VAL_WwiseMotionXbox
// 0x0000 (0x0030 - 0x0030)
class UVAL_WwiseMotionXbox final : public UVAL_WwiseMotionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VAL_WwiseMotionXbox">();
	}
	static class UVAL_WwiseMotionXbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVAL_WwiseMotionXbox>();
	}
};
static_assert(alignof(UVAL_WwiseMotionXbox) == 0x000008, "Wrong alignment on UVAL_WwiseMotionXbox");
static_assert(sizeof(UVAL_WwiseMotionXbox) == 0x000030, "Wrong size on UVAL_WwiseMotionXbox");

// Class Palia.VillagerGiftHistoryComponent
// 0x0080 (0x0120 - 0x00A0)
class UVillagerGiftHistoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C4B[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnVillagerGiftHistoryChangedDel;                   // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bGaveAcceptedGiftPreCommit;                        // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4C[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVillagerGiftHistory>           History;                                           // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	struct FGiftHistoryPersistBlock               GiftHistoryPersistBlock;                           // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void NotifyHistoryChanged();
	void OnRep_History();

	bool AlreadyGiftedItemThisReset(int32 VillagerCoreId, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType, class AValeriaCharacter* Character) const;
	bool CanGiftVillager(int32 VillagerCoreId, class AValeriaCharacter* Character) const;
	bool HasEverReceivedGift(int32 VillagerCoreId, TSoftObjectPtr<class UVAL_ItemTypeDefinitionAsset>& ItemType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerGiftHistoryComponent">();
	}
	static class UVillagerGiftHistoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerGiftHistoryComponent>();
	}
};
static_assert(alignof(UVillagerGiftHistoryComponent) == 0x000008, "Wrong alignment on UVillagerGiftHistoryComponent");
static_assert(sizeof(UVillagerGiftHistoryComponent) == 0x000120, "Wrong size on UVillagerGiftHistoryComponent");
static_assert(offsetof(UVillagerGiftHistoryComponent, OnVillagerGiftHistoryChangedDel) == 0x0000A8, "Member 'UVillagerGiftHistoryComponent::OnVillagerGiftHistoryChangedDel' has a wrong offset!");
static_assert(offsetof(UVillagerGiftHistoryComponent, bGaveAcceptedGiftPreCommit) == 0x0000B8, "Member 'UVillagerGiftHistoryComponent::bGaveAcceptedGiftPreCommit' has a wrong offset!");
static_assert(offsetof(UVillagerGiftHistoryComponent, History) == 0x0000C0, "Member 'UVillagerGiftHistoryComponent::History' has a wrong offset!");
static_assert(offsetof(UVillagerGiftHistoryComponent, GiftHistoryPersistBlock) == 0x0000D0, "Member 'UVillagerGiftHistoryComponent::GiftHistoryPersistBlock' has a wrong offset!");

// Class Palia.VillagerManager
// 0x0158 (0x01F8 - 0x00A0)
class UVillagerManager final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnVillagersOnMapChanged;                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueRoomVillagerSpawned;                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogueRoomVillagerDespawned;                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AValeriaVillagerCharacter*>      WorldVillagers;                                    // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AValeriaVillagerCharacter*>      EventVillagers;                                    // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C53[0xA0];                                    // 0x00F0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AValeriaVillagerCharacter*>      ActiveVillagers;                                   // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C54[0x28];                                    // 0x01A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVillagerMasterScheduleConfig*>  VillagerMasterScheduleCache;                       // 0x01C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UVillagerWeeklyScheduleConfig*>  VillagerWeeklyScheduleCache;                       // 0x01D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UVillagerScheduleConfig*>        VillagerScheduleCache;                             // 0x01E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void VillagerAbsentStateChanged(class AValeriaVillagerCharacter* InVillager, bool bInAbsent);

	bool DoesAnyCoreVisitVillagerExist(class AValeriaCharacter* InInstigatorCharacter, class UPrivateSpaceConfig* InPrivateSpaceConfig, const TArray<int32>& InVillagerCoreIds) const;
	bool DoesAnyVisitVillagerHaveSpawnPoint(class AValeriaCharacter* InInstigatorCharacter, class UPrivateSpaceConfig* InPrivateSpaceConfig, class AValeriaTargetPoint* InTargetPoint) const;
	bool DoesWorldVillagerExistOnCurrentMap(int32 InVillagerId) const;
	class AValeriaVillagerCharacter* FindClosestVillagerByType(struct FVector& Location, TSubclassOf<class AValeriaVillagerCharacter> ClassType) const;
	class AValeriaVillagerCharacter* FindNamedVillagerWithContext(class FName& VillagerName, EWorldLocationContext Context) const;
	TArray<class AValeriaVillagerCharacter*> GetAllSpawnedVillagers() const;
	TArray<class AValeriaVillagerCharacter*> GetEventVillagers() const;
	TArray<class AValeriaVillagerCharacter*> GetWorldVillagers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerManager">();
	}
	static class UVillagerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerManager>();
	}
};
static_assert(alignof(UVillagerManager) == 0x000008, "Wrong alignment on UVillagerManager");
static_assert(sizeof(UVillagerManager) == 0x0001F8, "Wrong size on UVillagerManager");
static_assert(offsetof(UVillagerManager, OnVillagersOnMapChanged) == 0x0000A0, "Member 'UVillagerManager::OnVillagersOnMapChanged' has a wrong offset!");
static_assert(offsetof(UVillagerManager, OnDialogueRoomVillagerSpawned) == 0x0000B0, "Member 'UVillagerManager::OnDialogueRoomVillagerSpawned' has a wrong offset!");
static_assert(offsetof(UVillagerManager, OnDialogueRoomVillagerDespawned) == 0x0000C0, "Member 'UVillagerManager::OnDialogueRoomVillagerDespawned' has a wrong offset!");
static_assert(offsetof(UVillagerManager, WorldVillagers) == 0x0000D0, "Member 'UVillagerManager::WorldVillagers' has a wrong offset!");
static_assert(offsetof(UVillagerManager, EventVillagers) == 0x0000E0, "Member 'UVillagerManager::EventVillagers' has a wrong offset!");
static_assert(offsetof(UVillagerManager, ActiveVillagers) == 0x000190, "Member 'UVillagerManager::ActiveVillagers' has a wrong offset!");
static_assert(offsetof(UVillagerManager, VillagerMasterScheduleCache) == 0x0001C8, "Member 'UVillagerManager::VillagerMasterScheduleCache' has a wrong offset!");
static_assert(offsetof(UVillagerManager, VillagerWeeklyScheduleCache) == 0x0001D8, "Member 'UVillagerManager::VillagerWeeklyScheduleCache' has a wrong offset!");
static_assert(offsetof(UVillagerManager, VillagerScheduleCache) == 0x0001E8, "Member 'UVillagerManager::VillagerScheduleCache' has a wrong offset!");

// Class Palia.VillagerRelationshipsComponent
// 0x0078 (0x0118 - 0x00A0)
class UVillagerRelationshipsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C5A[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeNotifAdded;                                // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVillagerRelationshipsPersistBlock     Relationships;                                     // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NativeAccessSpecifierPrivate)

public:
	void Client_BreakUpWithVillager(int32 VillagerCoreId);
	void OnReplicatedAndShouldBroadcast();
	void RpcClient_RelationshipChangeMade(const struct FVillagerRelationshipChange& Change);
	void RpcServer_BreakUpWithVillager(int32 VillagerCoreId);

	int32 GetMaxRelationshipLevel(int32 VillagerCoreId, ERelationshipType Type) const;
	int32 GetPointsNeededForRelationshipLevel(float InRelationshipLevel, int32 VillagerCoreId, ERelationshipType Type) const;
	struct FVillagerRelationship GetRelationship(int32 VillagerCoreId) const;
	int32 GetRelationshipLevel(int32 VillagerCoreId, ERelationshipType Type) const;
	class FText GetRelationshipLevelName(int32 VillagerCoreId, ERelationshipType Type) const;
	float GetRelationshipLevelProgress(int32 VillagerCoreId, ERelationshipType Type) const;
	int32 GetRelationshipValue(int32 VillagerCoreId, ERelationshipType Type) const;
	int32 GetRemainingPointsUntilRelationshipLevel(float InRelationshipLevel, int32 VillagerCoreId, ERelationshipType Type) const;
	int32 GetVillagerCoreIdFromVillagerId(int32 VillagerId) const;
	bool HasMetVillager(int32 VillagerCoreId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerRelationshipsComponent">();
	}
	static class UVillagerRelationshipsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerRelationshipsComponent>();
	}
};
static_assert(alignof(UVillagerRelationshipsComponent) == 0x000008, "Wrong alignment on UVillagerRelationshipsComponent");
static_assert(sizeof(UVillagerRelationshipsComponent) == 0x000118, "Wrong size on UVillagerRelationshipsComponent");
static_assert(offsetof(UVillagerRelationshipsComponent, OnChanged) == 0x0000A8, "Member 'UVillagerRelationshipsComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UVillagerRelationshipsComponent, OnChangeNotifAdded) == 0x0000B8, "Member 'UVillagerRelationshipsComponent::OnChangeNotifAdded' has a wrong offset!");
static_assert(offsetof(UVillagerRelationshipsComponent, Relationships) == 0x0000C8, "Member 'UVillagerRelationshipsComponent::Relationships' has a wrong offset!");

// Class Palia.VillagerStoreInteractableComponent
// 0x0010 (0x00B0 - 0x00A0)
class UVillagerStoreInteractableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C63[0x10];                                    // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Character, const struct FInteractEventParams& EventParams);

	bool GetText(class AValeriaCharacter* Player, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Player, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerStoreInteractableComponent">();
	}
	static class UVillagerStoreInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerStoreInteractableComponent>();
	}
};
static_assert(alignof(UVillagerStoreInteractableComponent) == 0x000008, "Wrong alignment on UVillagerStoreInteractableComponent");
static_assert(sizeof(UVillagerStoreInteractableComponent) == 0x0000B0, "Wrong size on UVillagerStoreInteractableComponent");

// Class Palia.VillagerVisitComponent
// 0x0230 (0x02D0 - 0x00A0)
class UVillagerVisitComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C68[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrivateSpaceVillagerDeterminantConfig* HousingVillagerDeterminantConfig;                  // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HousingVillagerVisitOffPlotCheckRate;              // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InPrivateSpaceVisitCheckRate;                      // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VillagerVisitPostActiveVisitEndCheckTime;          // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QueuedActiveVillagerVisitToEndCheckRate;           // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActiveVillagerVisitCompletionCheckRate;            // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C69[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHousingVillagerVisitReadyChanged;                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FActiveVillagerVisit>           ActiveVillagerVisits;                              // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	bool                                          bHousingVillagerVisitReady;                        // 0x00E8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6A[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedVillagerVisitArray               SavedHousingVillagerVisits;                        // 0x00F0(0x0010)(NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FSavedVillagerVisitArray> SavedPrivateSpaceVillagerVisits;                   // 0x0100(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FPrivateSpaceScheduledVillagerSpawnInfo> PrivateSpaceScheduledVillagerSpawnInfos;           // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TSet<struct FGuid>                            CompletedVisits;                                   // 0x0160(0x0050)(NativeAccessSpecifierPublic)
	class UPrivateSpaceManager*                   PrivateSpaceManager;                               // 0x01B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AValeriaCharacter*                      CachedCharOwner;                                   // 0x01B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnHousingPlot;                                    // 0x01C0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C6B[0x7];                                     // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrivateSpaceConfig*                    ActivePrivateSpaceConfig;                          // 0x01C8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FActiveVillagerVisit>           QueuedActiveVillagerVisitsToEnd;                   // 0x01D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActiveVillagerVisit>           QueuedActiveVillagerVisitsToEndOnLeave;            // 0x01E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckForHousingVillagerVisitOffPlotTimerHandle;    // 0x01F0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckForHousingVillagerVisitOnPlotTimerHandle;     // 0x01F8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckForPrivateSpaceVillagerVisitInPrivateSpaceTimerHandle; // 0x0200(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckForVillagerVisitPostActiveVisitEndTimerHandle; // 0x0208(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckForQueuedActiveVillagerVisitToEndTimerHandle; // 0x0210(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CheckForActiveVillagerVisitCompletionTimerHandle;  // 0x0218(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C6C[0xB0];                                    // 0x0220(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckForHousingVillagerVisitStart();
	void CheckForHousingVillagerVisitStartAndTryStartVisit();
	void CheckForPrivateSpaceScheduledVillagerVisitStart(class UPrivateSpaceConfig* InPrivateSpaceConfig);
	void CheckForPrivateSpaceVillagerVisitStart(class UPrivateSpaceConfig* InPrivateSpaceConfig);
	void CheckForPrivateSpaceVillagerVisitStartAndTryStartVisit();
	void Debug_CompleteActiveVillagerVisits();
	void Debug_CompleteVillagerVisit(class UPrivateSpaceVillagerVisitConfig* InVillagerVisitConfig);
	void Debug_ResetAllVillagerVisits();
	void Debug_StartVillagerVisit(class UPrivateSpaceConfig* InPrivateSpaceConfig, class UPrivateSpaceVillagerVisitConfig* InVillagerVisitConfig, bool bSkipTimeDelay);
	void HandleEnteredPrivateSpace(class AValeriaCharacter* VC, class UPrivateSpaceConfig* PrivateSpaceConfig);
	void HandleLeftPrivateSpace(class AValeriaCharacter* VC, class UPrivateSpaceConfig* PrivateSpaceConfig);
	void HandleVillagerInPrivateSpaceForScheduleChanged(class UPrivateSpaceConfig* PrivateSpaceConfig);
	void OnRep_ActiveVillagerVisits();
	void OnRep_bHousingVillagerVisitReady();
	void PostActiveVillagerVisitEnd(const struct FActiveVillagerVisit& InActiveVillagerVisit);
	void RpcClient_AddCompletedVisitGuid(struct FGuid& InGuid);
	void RpcClient_Debug_ResetAllCompletedVisits();
	void RpcClient_InitializeCompletedVisitGuids(TArray<struct FGuid>& InGuids);
	void RpcServer_Debug_CompleteActiveVillagerVisits();
	void RpcServer_Debug_CompleteVillagerVisit(class UPrivateSpaceVillagerVisitConfig* InVillagerVisitConfig);
	void RpcServer_Debug_ResetAllVillagerVisits();
	void RpcServer_Debug_StartVillagerVisit(class UPrivateSpaceConfig* InPrivateSpaceConfig, class UPrivateSpaceVillagerVisitConfig* InVillagerVisitConfig, bool bSkipTimeDelay);
	void TryCompleteActiveVillagerVisits();
	void TryEndQueuedActiveVillagerVisitsToEnd();

	bool HasCompletedVisit(class UPrivateSpaceVillagerVisitConfig* VisitConfig) const;
	bool IsPlayerInPrivateSpaceOrHousingPlot() const;
	bool IsScheduledVisitActive(int32 InVillagerId) const;
	bool IsVisitActive(class UPrivateSpaceVillagerVisitConfig* VisitConfig) const;
	bool IsVisitSavedAndReadyToStart(class UPrivateSpaceVillagerVisitConfig* VisitConfig) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerVisitComponent">();
	}
	static class UVillagerVisitComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerVisitComponent>();
	}
};
static_assert(alignof(UVillagerVisitComponent) == 0x000008, "Wrong alignment on UVillagerVisitComponent");
static_assert(sizeof(UVillagerVisitComponent) == 0x0002D0, "Wrong size on UVillagerVisitComponent");
static_assert(offsetof(UVillagerVisitComponent, HousingVillagerDeterminantConfig) == 0x0000A8, "Member 'UVillagerVisitComponent::HousingVillagerDeterminantConfig' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, HousingVillagerVisitOffPlotCheckRate) == 0x0000B0, "Member 'UVillagerVisitComponent::HousingVillagerVisitOffPlotCheckRate' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, InPrivateSpaceVisitCheckRate) == 0x0000B4, "Member 'UVillagerVisitComponent::InPrivateSpaceVisitCheckRate' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, VillagerVisitPostActiveVisitEndCheckTime) == 0x0000B8, "Member 'UVillagerVisitComponent::VillagerVisitPostActiveVisitEndCheckTime' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, QueuedActiveVillagerVisitToEndCheckRate) == 0x0000BC, "Member 'UVillagerVisitComponent::QueuedActiveVillagerVisitToEndCheckRate' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, ActiveVillagerVisitCompletionCheckRate) == 0x0000C0, "Member 'UVillagerVisitComponent::ActiveVillagerVisitCompletionCheckRate' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, OnHousingVillagerVisitReadyChanged) == 0x0000C8, "Member 'UVillagerVisitComponent::OnHousingVillagerVisitReadyChanged' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, ActiveVillagerVisits) == 0x0000D8, "Member 'UVillagerVisitComponent::ActiveVillagerVisits' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, bHousingVillagerVisitReady) == 0x0000E8, "Member 'UVillagerVisitComponent::bHousingVillagerVisitReady' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, SavedHousingVillagerVisits) == 0x0000F0, "Member 'UVillagerVisitComponent::SavedHousingVillagerVisits' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, SavedPrivateSpaceVillagerVisits) == 0x000100, "Member 'UVillagerVisitComponent::SavedPrivateSpaceVillagerVisits' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, PrivateSpaceScheduledVillagerSpawnInfos) == 0x000150, "Member 'UVillagerVisitComponent::PrivateSpaceScheduledVillagerSpawnInfos' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, CompletedVisits) == 0x000160, "Member 'UVillagerVisitComponent::CompletedVisits' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, PrivateSpaceManager) == 0x0001B0, "Member 'UVillagerVisitComponent::PrivateSpaceManager' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, CachedCharOwner) == 0x0001B8, "Member 'UVillagerVisitComponent::CachedCharOwner' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, bOnHousingPlot) == 0x0001C0, "Member 'UVillagerVisitComponent::bOnHousingPlot' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, ActivePrivateSpaceConfig) == 0x0001C8, "Member 'UVillagerVisitComponent::ActivePrivateSpaceConfig' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, QueuedActiveVillagerVisitsToEnd) == 0x0001D0, "Member 'UVillagerVisitComponent::QueuedActiveVillagerVisitsToEnd' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, QueuedActiveVillagerVisitsToEndOnLeave) == 0x0001E0, "Member 'UVillagerVisitComponent::QueuedActiveVillagerVisitsToEndOnLeave' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, CheckForHousingVillagerVisitOffPlotTimerHandle) == 0x0001F0, "Member 'UVillagerVisitComponent::CheckForHousingVillagerVisitOffPlotTimerHandle' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, CheckForHousingVillagerVisitOnPlotTimerHandle) == 0x0001F8, "Member 'UVillagerVisitComponent::CheckForHousingVillagerVisitOnPlotTimerHandle' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, CheckForPrivateSpaceVillagerVisitInPrivateSpaceTimerHandle) == 0x000200, "Member 'UVillagerVisitComponent::CheckForPrivateSpaceVillagerVisitInPrivateSpaceTimerHandle' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, CheckForVillagerVisitPostActiveVisitEndTimerHandle) == 0x000208, "Member 'UVillagerVisitComponent::CheckForVillagerVisitPostActiveVisitEndTimerHandle' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, CheckForQueuedActiveVillagerVisitToEndTimerHandle) == 0x000210, "Member 'UVillagerVisitComponent::CheckForQueuedActiveVillagerVisitToEndTimerHandle' has a wrong offset!");
static_assert(offsetof(UVillagerVisitComponent, CheckForActiveVillagerVisitCompletionTimerHandle) == 0x000218, "Member 'UVillagerVisitComponent::CheckForActiveVillagerVisitCompletionTimerHandle' has a wrong offset!");

// Class Palia.VillagerWeeklyScheduleConfig
// 0x0028 (0x0058 - 0x0030)
class UVillagerWeeklyScheduleConfig final : public UDataAsset
{
public:
	TSoftObjectPtr<class UVillagerScheduleConfig> FirstDaySchedule;                                  // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetBestScheduleActivity(class UObject* Context, struct FVillagerScheduleActivity* OutBestScheduleActivity) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerWeeklyScheduleConfig">();
	}
	static class UVillagerWeeklyScheduleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerWeeklyScheduleConfig>();
	}
};
static_assert(alignof(UVillagerWeeklyScheduleConfig) == 0x000008, "Wrong alignment on UVillagerWeeklyScheduleConfig");
static_assert(sizeof(UVillagerWeeklyScheduleConfig) == 0x000058, "Wrong size on UVillagerWeeklyScheduleConfig");
static_assert(offsetof(UVillagerWeeklyScheduleConfig, FirstDaySchedule) == 0x000030, "Member 'UVillagerWeeklyScheduleConfig::FirstDaySchedule' has a wrong offset!");

// Class Palia.VillagerWishDataAsset
// 0x0058 (0x0088 - 0x0030)
class UVillagerWishDataAsset final : public UDataAsset
{
public:
	class FText                                   Title;                                             // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   WishText;                                          // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    VillagerConfig;                                    // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VillagerWishDataAsset">();
	}
	static class UVillagerWishDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVillagerWishDataAsset>();
	}
};
static_assert(alignof(UVillagerWishDataAsset) == 0x000008, "Wrong alignment on UVillagerWishDataAsset");
static_assert(sizeof(UVillagerWishDataAsset) == 0x000088, "Wrong size on UVillagerWishDataAsset");
static_assert(offsetof(UVillagerWishDataAsset, Title) == 0x000030, "Member 'UVillagerWishDataAsset::Title' has a wrong offset!");
static_assert(offsetof(UVillagerWishDataAsset, Subtitle) == 0x000048, "Member 'UVillagerWishDataAsset::Subtitle' has a wrong offset!");
static_assert(offsetof(UVillagerWishDataAsset, WishText) == 0x000060, "Member 'UVillagerWishDataAsset::WishText' has a wrong offset!");
static_assert(offsetof(UVillagerWishDataAsset, VillagerConfig) == 0x000078, "Member 'UVillagerWishDataAsset::VillagerConfig' has a wrong offset!");

// Class Palia.VisibilityInterface
// 0x0000 (0x0028 - 0x0028)
class IVisibilityInterface final : public IInterface
{
public:
	void BPNE_HideVisibility();
	void BPNE_ShowVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibilityInterface">();
	}
	static class IVisibilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVisibilityInterface>();
	}
};
static_assert(alignof(IVisibilityInterface) == 0x000008, "Wrong alignment on IVisibilityInterface");
static_assert(sizeof(IVisibilityInterface) == 0x000028, "Wrong size on IVisibilityInterface");

// Class Palia.VisibilityManagerComponent
// 0x0008 (0x00A8 - 0x00A0)
class UVisibilityManagerComponent final : public UActorComponent
{
public:
	bool                                          bAllVillagersHidden;                               // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C74[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_HideAllVillagers(TArray<class AValeriaVillagerCharacter*>& ExcludedVillagers, const struct FVAL_VisibilityModifierSource& VisibilityModifierSource);
	void Client_UnhideAllVillagers(TArray<class AValeriaVillagerCharacter*>& ExcludedVillagers, const struct FVAL_VisibilityModifierSource& VisibilityModifierSource);

	bool AreAllVillagersHidden() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibilityManagerComponent">();
	}
	static class UVisibilityManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibilityManagerComponent>();
	}
};
static_assert(alignof(UVisibilityManagerComponent) == 0x000008, "Wrong alignment on UVisibilityManagerComponent");
static_assert(sizeof(UVisibilityManagerComponent) == 0x0000A8, "Wrong size on UVisibilityManagerComponent");
static_assert(offsetof(UVisibilityManagerComponent, bAllVillagersHidden) == 0x0000A0, "Member 'UVisibilityManagerComponent::bAllVillagersHidden' has a wrong offset!");

// Class Palia.PersistedVitalsComponent
// 0x0060 (0x0220 - 0x01C0)
class UPersistedVitalsComponent final : public UVitalsComponent
{
public:
	uint8                                         Pad_2C75[0x8];                                     // 0x01C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVitalsPersistBlock                    VitalsPersistBlock;                                // 0x01C8(0x0058)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistedVitalsComponent">();
	}
	static class UPersistedVitalsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersistedVitalsComponent>();
	}
};
static_assert(alignof(UPersistedVitalsComponent) == 0x000008, "Wrong alignment on UPersistedVitalsComponent");
static_assert(sizeof(UPersistedVitalsComponent) == 0x000220, "Wrong size on UPersistedVitalsComponent");
static_assert(offsetof(UPersistedVitalsComponent, VitalsPersistBlock) == 0x0001C8, "Member 'UPersistedVitalsComponent::VitalsPersistBlock' has a wrong offset!");

// Class Palia.WallpaperComponent
// 0x00D0 (0x0170 - 0x00A0)
class UWallpaperComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C76[0x10];                                    // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWallpaperItem>                 Wallpapers;                                        // 0x00B0(0x0010)(BlueprintVisible, Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	TMap<class FString, struct FPersistPlacementRegionMeshGroup> PersistAnchorToPlacementRegionAndMeshGroupset;     // 0x00C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FWallpaperItem>                 Client_Wallpapers;                                 // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, class UMeshComponent*>    ComponentNameToMeshComponentLookupCache;           // 0x0120(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Client_ReapplyMaterial(bool CheckBSide);
	struct FUseEventResult OnClientInteract(class UInteractableComponent* Interactable, class AValeriaPlayerController* Character, const struct FInteractEventParams& EventParams);
	void OnRep_WallpaperReplication();
	void UpdateVisuals();

	bool GetText(class AValeriaCharacter* Character, EInteractEventIndex EventIndex, struct FGetTextParams* Params_0) const;
	bool GetUseableIMC(class AValeriaCharacter* Character, EInteractEventIndex InteractIndex, struct FInputMappingPriorityData* OutMappingData, struct FModifyContextOptions* OutOptions) const;
	int32 InteractPriority(class AValeriaCharacter* Character) const;
	bool IsInteractable(class AValeriaCharacter* Character, const struct FInteractEventParams& EventParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallpaperComponent">();
	}
	static class UWallpaperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWallpaperComponent>();
	}
};
static_assert(alignof(UWallpaperComponent) == 0x000008, "Wrong alignment on UWallpaperComponent");
static_assert(sizeof(UWallpaperComponent) == 0x000170, "Wrong size on UWallpaperComponent");
static_assert(offsetof(UWallpaperComponent, Wallpapers) == 0x0000B0, "Member 'UWallpaperComponent::Wallpapers' has a wrong offset!");
static_assert(offsetof(UWallpaperComponent, PersistAnchorToPlacementRegionAndMeshGroupset) == 0x0000C0, "Member 'UWallpaperComponent::PersistAnchorToPlacementRegionAndMeshGroupset' has a wrong offset!");
static_assert(offsetof(UWallpaperComponent, Client_Wallpapers) == 0x000110, "Member 'UWallpaperComponent::Client_Wallpapers' has a wrong offset!");
static_assert(offsetof(UWallpaperComponent, ComponentNameToMeshComponentLookupCache) == 0x000120, "Member 'UWallpaperComponent::ComponentNameToMeshComponentLookupCache' has a wrong offset!");

// Class Palia.WarpStoneComponent
// 0x00A0 (0x0140 - 0x00A0)
class UWarpStoneComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C7D[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWarpStone>                     WarpStones;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         WarpStoneActors;                                   // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DoNotTick;                                         // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DoNotReplicate;                                    // 0x00D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C7E[0x2];                                     // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C7F[0x8];                                     // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWarpStonePersistBlock                 WarpStonePersistBlock;                             // 0x00E8(0x0058)(NativeAccessSpecifierPrivate)

public:
	bool AddFlowSprite(int32 FlowSpriteId, const struct FGuid& WarpStoneId);
	bool AddWarpStone(const struct FGuid& WarpStoneId);
	bool AreWarpStonesEnabled();
	bool AttemptToUseWarpStone(const struct FGuid& WarpStoneId);
	bool CanUseWarpStones();
	float GetTimeUntilNextUse();
	TArray<class AActor*> GetWarpStoneActors();
	void OnRep_WarpStones();
	void RegisterWarpStoneActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WarpStoneComponent">();
	}
	static class UWarpStoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWarpStoneComponent>();
	}
};
static_assert(alignof(UWarpStoneComponent) == 0x000008, "Wrong alignment on UWarpStoneComponent");
static_assert(sizeof(UWarpStoneComponent) == 0x000140, "Wrong size on UWarpStoneComponent");
static_assert(offsetof(UWarpStoneComponent, WarpStones) == 0x0000A8, "Member 'UWarpStoneComponent::WarpStones' has a wrong offset!");
static_assert(offsetof(UWarpStoneComponent, OnChanged) == 0x0000B8, "Member 'UWarpStoneComponent::OnChanged' has a wrong offset!");
static_assert(offsetof(UWarpStoneComponent, WarpStoneActors) == 0x0000C8, "Member 'UWarpStoneComponent::WarpStoneActors' has a wrong offset!");
static_assert(offsetof(UWarpStoneComponent, DoNotTick) == 0x0000D8, "Member 'UWarpStoneComponent::DoNotTick' has a wrong offset!");
static_assert(offsetof(UWarpStoneComponent, DoNotReplicate) == 0x0000D9, "Member 'UWarpStoneComponent::DoNotReplicate' has a wrong offset!");
static_assert(offsetof(UWarpStoneComponent, Cooldown) == 0x0000DC, "Member 'UWarpStoneComponent::Cooldown' has a wrong offset!");
static_assert(offsetof(UWarpStoneComponent, WarpStonePersistBlock) == 0x0000E8, "Member 'UWarpStoneComponent::WarpStonePersistBlock' has a wrong offset!");

// Class Palia.WarpStoneConfig
// 0x0040 (0x0070 - 0x0030)
class UWarpStoneConfig final : public UDataAsset
{
public:
	struct FGuid                                  WarpStoneId;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 FlowSpriteIds;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         CurrencyCost;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocationName;                                      // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocationNameLabel;                                 // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInHousingPlot;                                  // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C83[0x3];                                     // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      PreviewMaterial;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WarpStoneConfig">();
	}
	static class UWarpStoneConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWarpStoneConfig>();
	}
};
static_assert(alignof(UWarpStoneConfig) == 0x000008, "Wrong alignment on UWarpStoneConfig");
static_assert(sizeof(UWarpStoneConfig) == 0x000070, "Wrong size on UWarpStoneConfig");
static_assert(offsetof(UWarpStoneConfig, WarpStoneId) == 0x000030, "Member 'UWarpStoneConfig::WarpStoneId' has a wrong offset!");
static_assert(offsetof(UWarpStoneConfig, FlowSpriteIds) == 0x000040, "Member 'UWarpStoneConfig::FlowSpriteIds' has a wrong offset!");
static_assert(offsetof(UWarpStoneConfig, CurrencyCost) == 0x000050, "Member 'UWarpStoneConfig::CurrencyCost' has a wrong offset!");
static_assert(offsetof(UWarpStoneConfig, LocationName) == 0x000054, "Member 'UWarpStoneConfig::LocationName' has a wrong offset!");
static_assert(offsetof(UWarpStoneConfig, LocationNameLabel) == 0x00005C, "Member 'UWarpStoneConfig::LocationNameLabel' has a wrong offset!");
static_assert(offsetof(UWarpStoneConfig, bIsInHousingPlot) == 0x000064, "Member 'UWarpStoneConfig::bIsInHousingPlot' has a wrong offset!");
static_assert(offsetof(UWarpStoneConfig, PreviewMaterial) == 0x000068, "Member 'UWarpStoneConfig::PreviewMaterial' has a wrong offset!");

// Class Palia.WaterableObject
// 0x0068 (0x0310 - 0x02A8)
class AWaterableObject final : public AActor
{
public:
	uint8                                         Pad_2C84[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        WaterableObjectRootComponent;                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           WaterableObjectAkComponent;                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxWaterAmount;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterRemovalCountdownTime;                         // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WaterAmountRemovedPerSecond;                       // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideWaterProgressWidgetWhenEmpty;                 // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideWaterProgressWidgetWhenFull;                  // 0x02CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C85[0x2];                                     // 0x02CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWaterableObjectFilled;                           // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWaterableObjectUnfilled;                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentWaterAmount;                                // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousWaterAmount;                               // 0x02F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVAL_WaterFillType                            PreviousWaterFillType;                             // 0x02F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C86[0x7];                                     // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RemoveWaterCountdownTimerHandle;                   // 0x0300(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           RemoveWaterOnRepeatTimerHandle;                    // 0x0308(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginRemoveWaterOnRepeat();
	void BPIE_HideWaterProgressWidget();
	void BPIE_ShowWaterProgressWidget();
	void BPIE_UpdateWaterProgress(float WaterFillPercentage, bool bIncreasing);
	void OnRep_CurrentWaterAmount();
	void RemoveWaterOnRepeat();
	void SetWaterAmount(int32 NewWaterAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterableObject">();
	}
	static class AWaterableObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterableObject>();
	}
};
static_assert(alignof(AWaterableObject) == 0x000008, "Wrong alignment on AWaterableObject");
static_assert(sizeof(AWaterableObject) == 0x000310, "Wrong size on AWaterableObject");
static_assert(offsetof(AWaterableObject, WaterableObjectRootComponent) == 0x0002B0, "Member 'AWaterableObject::WaterableObjectRootComponent' has a wrong offset!");
static_assert(offsetof(AWaterableObject, WaterableObjectAkComponent) == 0x0002B8, "Member 'AWaterableObject::WaterableObjectAkComponent' has a wrong offset!");
static_assert(offsetof(AWaterableObject, MaxWaterAmount) == 0x0002C0, "Member 'AWaterableObject::MaxWaterAmount' has a wrong offset!");
static_assert(offsetof(AWaterableObject, WaterRemovalCountdownTime) == 0x0002C4, "Member 'AWaterableObject::WaterRemovalCountdownTime' has a wrong offset!");
static_assert(offsetof(AWaterableObject, WaterAmountRemovedPerSecond) == 0x0002C8, "Member 'AWaterableObject::WaterAmountRemovedPerSecond' has a wrong offset!");
static_assert(offsetof(AWaterableObject, bHideWaterProgressWidgetWhenEmpty) == 0x0002CC, "Member 'AWaterableObject::bHideWaterProgressWidgetWhenEmpty' has a wrong offset!");
static_assert(offsetof(AWaterableObject, bHideWaterProgressWidgetWhenFull) == 0x0002CD, "Member 'AWaterableObject::bHideWaterProgressWidgetWhenFull' has a wrong offset!");
static_assert(offsetof(AWaterableObject, OnWaterableObjectFilled) == 0x0002D0, "Member 'AWaterableObject::OnWaterableObjectFilled' has a wrong offset!");
static_assert(offsetof(AWaterableObject, OnWaterableObjectUnfilled) == 0x0002E0, "Member 'AWaterableObject::OnWaterableObjectUnfilled' has a wrong offset!");
static_assert(offsetof(AWaterableObject, CurrentWaterAmount) == 0x0002F0, "Member 'AWaterableObject::CurrentWaterAmount' has a wrong offset!");
static_assert(offsetof(AWaterableObject, PreviousWaterAmount) == 0x0002F4, "Member 'AWaterableObject::PreviousWaterAmount' has a wrong offset!");
static_assert(offsetof(AWaterableObject, PreviousWaterFillType) == 0x0002F8, "Member 'AWaterableObject::PreviousWaterFillType' has a wrong offset!");
static_assert(offsetof(AWaterableObject, RemoveWaterCountdownTimerHandle) == 0x000300, "Member 'AWaterableObject::RemoveWaterCountdownTimerHandle' has a wrong offset!");
static_assert(offsetof(AWaterableObject, RemoveWaterOnRepeatTimerHandle) == 0x000308, "Member 'AWaterableObject::RemoveWaterOnRepeatTimerHandle' has a wrong offset!");

// Class Palia.WaterForRewardsComponent
// 0x0030 (0x00D0 - 0x00A0)
class UWaterForRewardsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2C88[0x8];                                     // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CallDataLoadedTimerHandle;                         // 0x00A8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWaterForRewardsReplicatedData         ReplicatedData;                                    // 0x00B0(0x0020)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void DataWasLoaded();
	void DataWasReplicated();
	void DataWasTimeWarped();
	void OnRep_DataReplicated();
	void SetAsJustWatered();
	void SetTimesCollected(int32 Amount);
	void SetValeriaTimeRewardCollectedAt(int64 Timestamp);
	bool SpawnItemOnPlotAndDestroySelf(class UVAL_ItemTypeDefinitionAsset* ItemTypeToSpawn);
	void ValeriaTimeRewardCollectedAtLoaded();
	void ValeriaTimeRewardCollectedAtReplicated();

	int32 GetTimesCollected() const;
	int32 GetTimesWatered() const;
	int64 GetValeriaTimeRewardCollectedAt() const;
	int64 GetValeriaTimeWateredAt() const;
	bool HasPermissionToWater(class AValeriaCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterForRewardsComponent">();
	}
	static class UWaterForRewardsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterForRewardsComponent>();
	}
};
static_assert(alignof(UWaterForRewardsComponent) == 0x000008, "Wrong alignment on UWaterForRewardsComponent");
static_assert(sizeof(UWaterForRewardsComponent) == 0x0000D0, "Wrong size on UWaterForRewardsComponent");
static_assert(offsetof(UWaterForRewardsComponent, CallDataLoadedTimerHandle) == 0x0000A8, "Member 'UWaterForRewardsComponent::CallDataLoadedTimerHandle' has a wrong offset!");
static_assert(offsetof(UWaterForRewardsComponent, ReplicatedData) == 0x0000B0, "Member 'UWaterForRewardsComponent::ReplicatedData' has a wrong offset!");

// Class Palia.WishTree
// 0x0058 (0x0300 - 0x02A8)
class AWishTree final : public AActor
{
public:
	TArray<struct FWishTreeEntry>                 PlayerWishes;                                      // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         RefreshWishPeriodSeconds;                          // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WishTreeBagTag;                                    // 0x02BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WishTreeInternalItemTag;                           // 0x02C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WishTreeTimestampTag;                              // 0x02CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8B[0xC];                                     // 0x02D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWishMade;                                        // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWishGranted;                                     // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void HandleWishAction(bool bIsDeposit, class AValeriaCharacter* Character, struct FValeriaItem& WishItem);
	void OnWishGranted__DelegateSignature(class AWishTree* WishTree, class AValeriaCharacter* ValeriaCharacter, struct FValeriaItem& WishItem);
	void OnWishMade__DelegateSignature(class AWishTree* WishTree, class AValeriaCharacter* ValeriaCharacter, struct FValeriaItem& WishItem);
	void Server_RefreshWishes();

	const TArray<struct FWishTreeEntry> GetAllWishes() const;
	bool HasWishesToDisplayForPlayer(class AValeriaPlayerController* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WishTree">();
	}
	static class AWishTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWishTree>();
	}
};
static_assert(alignof(AWishTree) == 0x000008, "Wrong alignment on AWishTree");
static_assert(sizeof(AWishTree) == 0x000300, "Wrong size on AWishTree");
static_assert(offsetof(AWishTree, PlayerWishes) == 0x0002A8, "Member 'AWishTree::PlayerWishes' has a wrong offset!");
static_assert(offsetof(AWishTree, RefreshWishPeriodSeconds) == 0x0002B8, "Member 'AWishTree::RefreshWishPeriodSeconds' has a wrong offset!");
static_assert(offsetof(AWishTree, WishTreeBagTag) == 0x0002BC, "Member 'AWishTree::WishTreeBagTag' has a wrong offset!");
static_assert(offsetof(AWishTree, WishTreeInternalItemTag) == 0x0002C4, "Member 'AWishTree::WishTreeInternalItemTag' has a wrong offset!");
static_assert(offsetof(AWishTree, WishTreeTimestampTag) == 0x0002CC, "Member 'AWishTree::WishTreeTimestampTag' has a wrong offset!");
static_assert(offsetof(AWishTree, OnWishMade) == 0x0002E0, "Member 'AWishTree::OnWishMade' has a wrong offset!");
static_assert(offsetof(AWishTree, OnWishGranted) == 0x0002F0, "Member 'AWishTree::OnWishGranted' has a wrong offset!");

// Class Palia.WorldPersistGatherable
// 0x0008 (0x0310 - 0x0308)
class AWorldPersistGatherable : public AWorldGatherableBase
{
public:
	struct FGameplayTag                           SavableTag;                                        // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void WorldPersistGatherableAdded(const struct FGameplayTag& InTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldPersistGatherable">();
	}
	static class AWorldPersistGatherable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldPersistGatherable>();
	}
};
static_assert(alignof(AWorldPersistGatherable) == 0x000008, "Wrong alignment on AWorldPersistGatherable");
static_assert(sizeof(AWorldPersistGatherable) == 0x000310, "Wrong size on AWorldPersistGatherable");
static_assert(offsetof(AWorldPersistGatherable, SavableTag) == 0x000308, "Member 'AWorldPersistGatherable::SavableTag' has a wrong offset!");

// Class Palia.WorldTerrainPlacementManager
// 0x0050 (0x0080 - 0x0030)
class UWorldTerrainPlacementManager final : public UGameInstanceSubsystem
{
public:
	TMap<class UClass*, struct FWorldTerrainPlaceables> PlacedInWorld;                                     // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void TrackedActorWasDestroyed(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTerrainPlacementManager">();
	}
	static class UWorldTerrainPlacementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTerrainPlacementManager>();
	}
};
static_assert(alignof(UWorldTerrainPlacementManager) == 0x000008, "Wrong alignment on UWorldTerrainPlacementManager");
static_assert(sizeof(UWorldTerrainPlacementManager) == 0x000080, "Wrong size on UWorldTerrainPlacementManager");
static_assert(offsetof(UWorldTerrainPlacementManager, PlacedInWorld) == 0x000030, "Member 'UWorldTerrainPlacementManager::PlacedInWorld' has a wrong offset!");

}

